-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_desfazer_analise_lote ( nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

 
nr_seq_fatura_w			pls_conta.nr_seq_fatura%type;
nr_lote_contabil_w		pls_protocolo_conta.nr_lote_contabil%type;
nr_lote_contabil_prov_w		pls_protocolo_conta.nr_lote_contabil_prov%type;
nr_lote_contab_pag_w		pls_protocolo_conta.nr_lote_contab_pag%type;
nr_lote_prov_copartic_w		pls_protocolo_conta.nr_lote_prov_copartic%type;
ie_status_w			ptu_fatura.ie_status%type;
qt_conta_medica_resumo_w	integer;
cont_w				integer;
qt_coparticipacao_mens_w	integer;
qt_lote_liberacao_w		integer;
nr_seq_lote_fat_w		pls_conta_pos_estabelecido.nr_seq_lote_fat%type;
ie_status_prov_pagto_w		pls_parametro_contabil.ie_status_prov_pagto%type;
nr_lote_contabilizado_w		pls_conta_medica_resumo.nr_lote_contabil_prov%type;
ds_stack_w			varchar(4000);
ds_err_stack_w			varchar(4000);
ds_sqlerrm_w			varchar(4000);
ds_erro_w			varchar(4000);
qt_ora_deadlock_w	integer := 0;
qt_0060_w		integer := 0;


C01 CURSOR FOR
	SELECT	y.nr_sequencia nr_seq_conta, 
		x.nr_sequencia nr_seq_protocolo, 
		x.ie_status
	from	pls_conta y, 
		pls_protocolo_conta x 
	where	x.nr_sequencia = y.nr_seq_protocolo 
	and	x.nr_seq_lote_conta = nr_seq_lote_p 
	and	(x.nr_seq_lote_conta IS NOT NULL AND x.nr_seq_lote_conta::text <> '');

BEGIN
select	coalesce(ie_status_prov_pagto,'NC')
into STRICT	ie_status_prov_pagto_w
from	pls_parametro_contabil
where	cd_estabelecimento	= cd_estabelecimento_p;
	
for r_c01_w in C01 loop

	if (r_c01_w.ie_status in ('3','6')) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(277123);
	end if;

	if (ie_status_prov_pagto_w = 'F') then	
		select	max(coalesce(nr_lote_contabil_prov,0)) nr_lote_contabil
		into STRICT	nr_lote_contabilizado_w
		from	pls_conta_medica_resumo
		where	nr_seq_conta = r_c01_w.nr_seq_conta
		and	coalesce(nr_lote_contabil_prov,0) <> 0;
		
		if ( coalesce( nr_lote_contabilizado_w, 0 ) = 0 ) then	
			select	max( coalesce( nr_lote_contabil_prov,0 ) ) nr_lote_contabil
			into STRICT	nr_lote_contabilizado_w
			from	pls_conta_coparticipacao
			where	nr_seq_conta = r_c01_w.nr_seq_conta
			and	coalesce( nr_lote_contabil_prov,0 ) <> 0;		
		end if;
		
		if (coalesce(nr_lote_contabilizado_w, 0) > 0) then
			/* A conta ja foi contabilizada no lote #@NR_LOTE_CONTABILIZADO#@. */

			CALL wheb_mensagem_pck.exibir_mensagem_abort(324839, 'NR_LOTE_CONTABILIZADO=' || nr_lote_contabilizado_w);	
		end if;
	end if;

	select	nr_seq_fatura
	into STRICT	nr_seq_fatura_w 
	from	pls_conta 
	where	nr_sequencia = r_c01_w.nr_seq_conta;

	select	max(g.ie_status) 
	into STRICT	ie_status_w 
	from	ptu_fatura g 
	where	g.nr_sequencia = nr_seq_fatura_w 
	and	g.ie_status in ('CA','E');

	if (ie_status_w = 'CA') then
		--A fatura da conta #@NR_SEQ_CONTA#@ esta cancelada. Nao e possivel desfazer a finalizacao dos grupos. 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(236201,'NR_SEQ_CONTA='||r_c01_w.nr_seq_conta);	
	elsif (ie_status_w = 'E') then	 
		--A fatura da conta #@NR_SEQ_CONTA#@ est? encerrada. Nao e possivel desfazer a finalizacao dos grupos.	 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(236202, 'NR_SEQ_CONTA='||r_c01_w.nr_seq_conta);
	end if;

	select	count(1) 
	into STRICT	cont_w 
	from	pls_prot_conta_titulo a, 
		pls_protocolo_conta b, 
		pls_conta c 
	where	a.nr_seq_protocolo	= b.nr_sequencia 
	and	b.nr_sequencia		= c.nr_seq_protocolo 
	and	c.nr_sequencia		= r_c01_w.nr_seq_conta;
 
	select	count(1) 
	into STRICT	qt_coparticipacao_mens_w 
	from	pls_conta_coparticipacao 
	where	nr_seq_conta = r_c01_w.nr_seq_conta 
	and	(nr_seq_mensalidade_seg IS NOT NULL AND nr_seq_mensalidade_seg::text <> '');
	 
	/*Caso tiver pagamento de producao para a conta nao pode desfazer o fechamento*/
 
	select	sum(qt)
	into STRICT	qt_conta_medica_resumo_w
	from (
		SELECT	count(1) qt
		from	pls_conta_medica_resumo 
		where	nr_seq_conta = r_c01_w.nr_seq_conta 
		and	(nr_seq_lote_pgto IS NOT NULL AND nr_seq_lote_pgto::text <> '') 
		and	ie_situacao = 'A'
		
union all

		SELECT	count(1) qt
		from	pls_conta_medica_resumo 
		where	nr_seq_conta = r_c01_w.nr_seq_conta 
		and	(nr_seq_pp_lote IS NOT NULL AND nr_seq_pp_lote::text <> '') 
		and	ie_situacao = 'A'
	) alias5;

	select	max(nr_lote_contabil), 
		max(nr_lote_contabil_prov), 
		max(nr_lote_contab_pag), 
		max(nr_lote_prov_copartic) 
	into STRICT	nr_lote_contabil_w, 
		nr_lote_contabil_prov_w, 
		nr_lote_contab_pag_w, 
		nr_lote_prov_copartic_w 
	from	pls_protocolo_conta 
	where	nr_sequencia	= r_c01_w.nr_seq_protocolo;
		
	 select	max(a.nr_seq_lote_fat)	
		into STRICT	nr_seq_lote_fat_w
		from	pls_conta_pos_estabelecido a,
			pls_lote_faturamento b
		where	a.nr_seq_lote_fat = b.nr_sequencia
		and	a.nr_seq_conta	= r_c01_w.nr_seq_conta 
		and	(a.nr_seq_lote_fat IS NOT NULL AND a.nr_seq_lote_fat::text <> '')
		and	((a.ie_situacao	= 'A') or (coalesce(a.ie_situacao::text, '') = ''))
		and	b.ie_tipo_lote <> 'A';

	if (nr_seq_lote_fat_w IS NOT NULL AND nr_seq_lote_fat_w::text <> '') then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190837,'NR_LOTE='||nr_seq_lote_fat_w);
	end if;
	 
	if (qt_conta_medica_resumo_w <> 0) then 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190838);
	end if;
 
	if (qt_coparticipacao_mens_w <> 0) then 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190839);
	end if;
 
	if (cont_w <> 0) then 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190841);
	end if;
 
	-- caso a mesma ja esteja em lote de contabilizacao 
	if (coalesce(nr_lote_contabil_w,0) <> 0) then 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190842, 'NR_LOTE_CONTABIL_W=' || nr_lote_contabil_w);
	end if;

	if (coalesce(nr_lote_contab_pag_w,0) <> 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190845, 'NR_LOTE_CONTABIL_W=' || nr_lote_contab_pag_w);
	end if;

	if (coalesce(nr_lote_prov_copartic_w,0) <> 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190849, 'NR_LOTE_CONTABIL_W=' || nr_lote_prov_copartic_w);
	end if;
	
	select	count(1)
	into STRICT	qt_lote_liberacao_w
	from	pls_lib_coparticipacao a,
			pls_lote_coparticipacao b
	where	a.nr_seq_conta	= r_c01_w.nr_seq_conta
	and	a.nr_seq_lote = b.nr_sequencia
	and	b.ie_status = 'D'; --Definitivo
	
	if (qt_lote_liberacao_w > 0) then
	CALL wheb_mensagem_pck.exibir_mensagem_abort(328668); --Ja existe lote de liberacao para a coparticipacao. Favor verificar na funcao OPS - Controle de Coparticipacoes.
	end if;	

	qt_ora_deadlock_w := 0;
	while(qt_ora_deadlock_w < 3)
	loop
		begin
			CALL pls_desfazer_analise_conta( r_c01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p);
			qt_ora_deadlock_w := 3; --se chegar aqui, seta para 3 para sair da iteracao
		exception
		when others then
			ds_stack_w := dbms_utility.format_call_stack;
			ds_err_stack_w := dbms_utility.format_error_backtrace;
			ds_sqlerrm_w := sqlerrm;			
			
			ds_erro_w := substr(	'Erro: ' || ds_sqlerrm_w || pls_util_pck.enter_w || pls_util_pck.enter_w ||
						'Stack:' || pls_util_pck.enter_w ||
						ds_stack_w || pls_util_pck.enter_w ||
						'Error Back Trace: ' || pls_util_pck.enter_w ||
						ds_err_stack_w,1,4000);
			
			-- caso detectar deadlock na msg de erro,  jogar para processar novamente	
			select	position('ORA-00060' in ds_erro_w)
			into STRICT	qt_0060_w
			;
			
			if ( qt_0060_w > 0) and (coalesce( qt_ora_deadlock_w, 0) < 3) then
				
				qt_ora_deadlock_w := qt_ora_deadlock_w + 1;
				
			
			else --se nao for deadlock ou se ocorreu deadlock nas 3 tentativas, deve re-lancar a exception
				raise;
			end if;
			
		end;
	end loop;
	qt_ora_deadlock_w := 0;
	
end loop;

qt_ora_deadlock_w := 0;
while(qt_ora_deadlock_w < 3)
	loop
		begin

			update	pls_lote_protocolo_conta
			set	dt_geracao_analise  = NULL, 
				ie_status = 'U' 
			where	nr_sequencia = nr_seq_lote_p; 			
			
			delete	FROM pls_analise_glo_ocor_grupo	a 
			where	a.nr_seq_analise in (	SELECT	y.nr_sequencia 
							from	pls_analise_conta y
							where	y.nr_seq_lote_protocolo = nr_seq_lote_p);
			qt_ora_deadlock_w := 3;--chegando ate aqui, pode sair do controle
		exception
		when others then
			ds_stack_w := dbms_utility.format_call_stack;
			ds_err_stack_w := dbms_utility.format_error_backtrace;
			ds_sqlerrm_w := sqlerrm;			
			
			ds_erro_w := substr(	'Erro: ' || ds_sqlerrm_w || pls_util_pck.enter_w || pls_util_pck.enter_w ||
						'Stack:' || pls_util_pck.enter_w ||
						ds_stack_w || pls_util_pck.enter_w ||
						'Error Back Trace: ' || pls_util_pck.enter_w ||
						ds_err_stack_w,1,4000);
			
			-- caso detectar deadlock na msg de erro,  jogar para processar novamente	
			select	position('ORA-00060' in ds_erro_w)
			into STRICT	qt_0060_w
			;
			
			if ( qt_0060_w > 0) and (coalesce( qt_ora_deadlock_w, 0) < 3) then
				
				qt_ora_deadlock_w := qt_ora_deadlock_w + 1;
				
			
			else --se nao for deadlock ou se ocorreu deadlock nas 3 tentativas, deve re-lancar a exception				
				raise;
			end if;
			
		end;
end loop;
qt_ora_deadlock_w := 0;
				
commit;

for r_c01_w in c01 loop

	qt_ora_deadlock_w := 0;
	while(qt_ora_deadlock_w < 3)
	loop
		begin
			/* Alterar status da conta para pendente pois nao permite desconsistir com status em analise */
			update	pls_conta 
			set	ie_status	= 'P'
			where	nr_sequencia	= r_c01_w.nr_seq_conta
			and	ie_status 	<> 'C';
			
			update	pls_conta
			set	nr_seq_analise 	 = NULL
			where	nr_sequencia	= r_c01_w.nr_seq_conta;
			
			update	pls_conta_proc 
			set	ie_status 	= 'P' 
			where	nr_seq_conta	= r_c01_w.nr_seq_conta 
			and	ie_status 	<> 'D';
			
			update	pls_conta_mat 
			set	ie_status	= 'P' 
			where	nr_seq_conta	= r_c01_w.nr_seq_conta
			and	ie_status 	<> 'D';
			 
			CALL pls_desfazer_consistir_conta(r_c01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p);
			qt_ora_deadlock_w := 3;--chegando ate aqui, pdoe sair do controle
	exception
		when others then
			ds_stack_w := dbms_utility.format_call_stack;
			ds_err_stack_w := dbms_utility.format_error_backtrace;
			ds_sqlerrm_w := sqlerrm;			
			
			ds_erro_w := substr(	'Erro: ' || ds_sqlerrm_w || pls_util_pck.enter_w || pls_util_pck.enter_w ||
						'Stack:' || pls_util_pck.enter_w ||
						ds_stack_w || pls_util_pck.enter_w ||
						'Error Back Trace: ' || pls_util_pck.enter_w ||
						ds_err_stack_w,1,4000);
			
			-- caso detectar deadlock na msg de erro,  jogar para processar novamente	
			select	position('ORA-00060' in ds_erro_w)
			into STRICT	qt_0060_w
			;
			
			if ( qt_0060_w > 0) and (coalesce( qt_ora_deadlock_w, 0) < 3) then
				
				qt_ora_deadlock_w := qt_ora_deadlock_w + 1;
				
			
			else --se nao for deadlock ou se ocorreu deadlock nas 3 tentativas, deve re-lancar a exception
				raise;
				
			end if;
			
		end;
	end loop;
	qt_ora_deadlock_w := 0;
	
end loop;

commit;

if ( nr_seq_lote_p > 0) then

	qt_ora_deadlock_w := 0;
	while( qt_ora_deadlock_w < 3)
	loop
	begin

		delete	FROM pls_analise_observacao	a
		where	a.nr_seq_analise in (	SELECT	y.nr_sequencia 
						from	pls_analise_conta y, 
							pls_lote_protocolo_conta x 
						where	x.nr_sequencia = y.nr_seq_lote_protocolo 
						and	x.nr_sequencia = nr_seq_lote_p);
		commit;

		delete
		from	pls_analise_fluxo_ocor a 
		where	a.nr_seq_analise in (	SELECT	y.nr_sequencia 
						from	pls_analise_conta y, 
							pls_lote_protocolo_conta x 
						where	x.nr_sequencia = y.nr_seq_lote_protocolo 
						and	x.nr_sequencia = nr_seq_lote_p);
		commit;

		delete	FROM pls_analise_fluxo_item	a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;
	 
		delete	FROM pls_hist_analise_conta	a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;
	 
		delete	FROM pls_tempo_conta_grupo 	b 
		where	b.nr_seq_auditoria in (	SELECT	a.nr_sequencia 
						from	pls_auditoria_conta_grupo	a 
						where	a.nr_seq_analise in (	select	y.nr_sequencia 
										from	pls_analise_conta		y, 
											pls_lote_protocolo_conta	x 
										where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
										and	x.nr_sequencia	= nr_seq_lote_p));
		commit;

		delete	FROM pls_auditoria_conta_grupo	a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		delete	FROM pls_analise_conta_item_log	a 
		where	a.nr_seq_analise_item in (SELECT	w.nr_sequencia 
							from	pls_analise_conta		y, 
								pls_lote_protocolo_conta	x, 
								pls_analise_conta_item		w 
							where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
							and	x.nr_sequencia	= nr_seq_lote_p 
							and	y.nr_sequencia	= w.nr_seq_analise);
		commit;

		delete	FROM pls_analise_fluxo_item	a 
		where	a.nr_seq_glosa_item in (SELECT	w.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x, 
							pls_analise_conta_item		w 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p 
						and	y.nr_sequencia	= w.nr_seq_analise);
		commit;

		delete	FROM pls_analise_grupo_item	a 
		where	a.nr_seq_item_analise in (SELECT	w.nr_sequencia 
							from	pls_analise_conta		y, 
								pls_lote_protocolo_conta	x, 
								pls_analise_conta_item		w 
							where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
							and	x.nr_sequencia	= nr_seq_lote_p 
							and	y.nr_sequencia	= w.nr_seq_analise);
		commit;

		delete	FROM pls_analise_parecer_item	a 
		where	a.nr_seq_item	in (SELECT	w.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x, 
							pls_analise_conta_item		w 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p 
						and	y.nr_sequencia	= w.nr_seq_analise);
		commit;
	 
		delete	FROM pls_analise_conta_item	a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		delete	FROM pls_contestacao_discussao	a
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		delete	FROM w_pls_proc_participante	a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		delete	FROM w_pls_resumo_conta	a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		delete	FROM pls_analise_log_acesso a
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		update 	ptu_consulta_beneficiario 
		set 	nr_seq_inf_conta_interc	 = NULL 
		where 	nr_seq_inf_conta_interc in ( SELECT nr_sequencia 
							 from pls_analise_inf_conta_int a 
							 where	a.nr_seq_analise in (select	y.nr_sequencia 
											 from	pls_analise_conta y, 
												pls_lote_protocolo_conta x 
											 where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
											 and	x.nr_sequencia	= nr_seq_lote_p));
		commit;

		delete	FROM pls_analise_inf_conta_int a 
		where	a.nr_seq_analise in (SELECT	y.nr_sequencia 
						from	pls_analise_conta		y, 
							pls_lote_protocolo_conta	x 
						where	x.nr_sequencia	= y.nr_seq_lote_protocolo 
						and	x.nr_sequencia	= nr_seq_lote_p);
		commit;

		delete	FROM pls_analise_conta	a 
		where	a.nr_seq_lote_protocolo in (SELECT	x.nr_sequencia 
							from	pls_lote_protocolo_conta	x 
							where	x.nr_sequencia	= nr_seq_lote_p);
							
		qt_ora_deadlock_w := 3;
							
		commit;
	exception
		when others then
			ds_stack_w := dbms_utility.format_call_stack;
			ds_err_stack_w := dbms_utility.format_error_backtrace;
			ds_sqlerrm_w := sqlerrm;			
			
			ds_erro_w := substr(	'Erro: ' || ds_sqlerrm_w || pls_util_pck.enter_w || pls_util_pck.enter_w ||
						'Stack:' || pls_util_pck.enter_w ||
						ds_stack_w || pls_util_pck.enter_w ||
						'Error Back Trace: ' || pls_util_pck.enter_w ||
						ds_err_stack_w,1,4000);
			
			-- caso detectar deadlock na msg de erro,  jogar para processar novamente	
			select	position('ORA-00060' in ds_erro_w)
			into STRICT	qt_0060_w
			;
			
			if ( qt_0060_w > 0) and (coalesce( qt_ora_deadlock_w, 0) < 3) then
				
				qt_ora_deadlock_w := qt_ora_deadlock_w + 1;
				
			
			else --se nao for deadlock ou se ocorreu deadlock nas 3 tentativas, deve re-lancar a exception
				raise;
				
			end if;
			
		end;
	end loop;	
	
end if;

insert into pls_log_lote_prot_conta(
	nr_sequencia, dt_atualizacao, nm_usuario, 
	dt_atualizacao_nrec, nm_usuario_nrec, ds_log, 
	nr_seq_lote_protocolo
) values (
	nextval('pls_log_lote_prot_conta_seq'), clock_timestamp(), nm_usuario_p, 
	clock_timestamp(), nm_usuario_p,' Desfazer an?lise',
	nr_seq_lote_p
);
commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_desfazer_analise_lote ( nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

