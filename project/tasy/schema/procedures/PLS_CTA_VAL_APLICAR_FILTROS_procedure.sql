-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_cta_val_aplicar_filtros ( dados_consistencia_p pls_tipos_cta_val_pck.dados_consistencia, dados_regra_p pls_tipos_cta_val_pck.dados_regra, nr_id_transacao_p pls_rp_cta_selecao.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, qt_registro_p INOUT integer) AS $body$
DECLARE


qt_registro_w		integer;
dados_filtro_w		pls_tipos_cta_val_pck.dados_filtro;
ie_incidencia_regra_w	pls_oc_cta_tipo_validacao.ie_aplicacao_ocorrencia%type;

-- dados dos filtros
c_comb_filtro CURSOR(nr_seq_regra_pc	pls_rp_cta_combinada.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia,
		a.nm_filtro,
		a.ie_filtro_conta,
		a.ie_filtro_benef,
		a.ie_filtro_prest,
		a.ie_filtro_produto,
		a.ie_filtro_proc
	from	pls_rp_cta_filtro a
	where	a.nr_seq_rp_combinada	= nr_seq_regra_pc
	and	a.ie_situacao	= 'A';

BEGIN
-- Inicialização dos contadores
qt_registro_w	:= 0;
if (dados_regra_p.nr_seq_regra IS NOT NULL AND dados_regra_p.nr_seq_regra::text <> '') then

	-- Se não tiver nenhum filtro na regra e se ela não for de somente filtros, então inclui na seleção todas as contas ou todos os itens
	if (dados_regra_p.ie_utiliza_filtro = 'N' and (dados_regra_p.nr_seq_validacao IS NOT NULL AND dados_regra_p.nr_seq_validacao::text <> '')) then
		CALL pls_grava_log_execucao_temp('Início pls_cta_val_aplic_fil_pad', 'val_dif_filtro', nm_usuario_p);
		-- Inserir todas as contas na tabela de seleção com o campo ie_valido como 'S' para validar quando existe mais de um filtro na regra.
		CALL pls_cta_val_aplic_fil_pad(	dados_consistencia_p, nr_id_transacao_p, cd_estabelecimento_p,
						nm_usuario_p);
		CALL pls_grava_log_execucao_temp('Fim pls_cta_val_aplic_fil_pad', 'val_dif_filtro', nm_usuario_p);
		qt_registro_w := pls_tipos_ocor_pck.obter_qtde_reg_valido_filtro(nr_id_transacao_p, null);
	else

		for r_c_comb_filtro in c_comb_filtro(dados_regra_p.nr_seq_regra) loop
			-- Atualizar os dados do filtro na variável para passar todos os dados as outras rotinas
			dados_filtro_w.nr_sequencia		:= r_c_comb_filtro.nr_sequencia;
			dados_filtro_w.nm_filtro		:= r_c_comb_filtro.nm_filtro;
			dados_filtro_w.ie_filtro_conta		:= r_c_comb_filtro.ie_filtro_conta;
			dados_filtro_w.ie_filtro_benef		:= r_c_comb_filtro.ie_filtro_benef;
			dados_filtro_w.ie_filtro_prest		:= r_c_comb_filtro.ie_filtro_prest;
			dados_filtro_w.ie_filtro_produto	:= r_c_comb_filtro.ie_filtro_produto;
			dados_filtro_w.ie_filtro_proc		:= r_c_comb_filtro.ie_filtro_proc;

			-- feito esse tratamento de inicializar com -1 porque se retornar zero significa que
			-- não tem registros no filtro aplicado e portanto deverá parar de executar, pois tudo
			-- é do tipo E
			qt_registro_w := -1;

			-- Verificar cada checkbox da combinação de filtros, para filtrar cada tipo
			-- Para executar a verificação dos filtros deve ser respeitada a ordem de aplicação dos mesmos, passando do nível mais alto
			-- Para o nível mais baixo, começando do Protocolo para as contas, das contas para os itens, para que os filtros
			-- respeitem os outros filtros cadastrados.  Isto evita  casos em que a conta não atende aos filtros e a ocorrência é lançada para os itens.
			-- Além disto este conceito ajuda no quesito de performance da aplicação de filtros, por exemplo, o filtro por protocolo deve ser aplicado
			-- primeiro, pois se o protocolo não atender ao cadastro do filtro então nem busca as contas do mesmo, assim para as contas, os itens,
			-- pariticipantes e assim por diante.
			-- filtro de conta OK
			if (dados_filtro_w.ie_filtro_conta = 'S' and (qt_registro_w = -1 or qt_registro_w > 0)) then
				CALL pls_grava_log_execucao_temp('Início pls_cta_val_aplica_fil_conta', 'val_dif_filtro', nm_usuario_p);
				CALL pls_cta_val_aplica_fil_conta(
								dados_regra_p, dados_filtro_w, dados_consistencia_p,
								nr_id_transacao_p, cd_estabelecimento_p, nm_usuario_p);
				CALL pls_grava_log_execucao_temp('Fim pls_cta_val_aplica_fil_conta', 'val_dif_filtro', nm_usuario_p);
				qt_registro_w := pls_tipos_cta_val_pck.obter_qtde_reg_valido_filtro(nr_id_transacao_p, dados_filtro_w);
			end if;

			-- Prestador
			if (dados_filtro_w.ie_filtro_prest = 'S' and (qt_registro_w = -1 or qt_registro_w > 0)) then
				CALL pls_grava_log_execucao_temp('Início pls_cta_val_aplicar_fil_pres', 'val_dif_filtro', nm_usuario_p);
				CALL pls_cta_val_aplicar_fil_pres(
								dados_regra_p, dados_filtro_w, dados_consistencia_p,
								nr_id_transacao_p, cd_estabelecimento_p, nm_usuario_p);
				CALL pls_grava_log_execucao_temp('Fim pls_cta_val_aplicar_fil_pres', 'val_dif_filtro', nm_usuario_p);
				qt_registro_w := pls_tipos_cta_val_pck.obter_qtde_reg_valido_filtro(nr_id_transacao_p, dados_filtro_w);
			end if;

			-- produto
			if (dados_filtro_w.ie_filtro_produto = 'S' and (qt_registro_w = -1 or qt_registro_w > 0)) then
				CALL pls_grava_log_execucao_temp('Início pls_cta_val_aplicar_fil_prod', 'val_dif_filtro', nm_usuario_p);
				CALL pls_cta_val_aplicar_fil_prod(
								dados_regra_p, dados_filtro_w, dados_consistencia_p,
								nr_id_transacao_p, cd_estabelecimento_p, nm_usuario_p);
				CALL pls_grava_log_execucao_temp('Fim pls_cta_val_aplicar_fil_prod', 'val_dif_filtro', nm_usuario_p);
				qt_registro_w := pls_tipos_cta_val_pck.obter_qtde_reg_valido_filtro(nr_id_transacao_p, dados_filtro_w);
			end if;

			-- beneficiário
			if (dados_filtro_w.ie_filtro_benef = 'S' and (qt_registro_w = -1 or qt_registro_w > 0)) then
				CALL pls_grava_log_execucao_temp('Início pls_val_cta_aplicar_fil_ben', 'val_dif_filtro', nm_usuario_p);
				CALL pls_val_cta_aplicar_fil_ben(
								dados_regra_p, dados_filtro_w, dados_consistencia_p,
								nr_id_transacao_p, cd_estabelecimento_p, nm_usuario_p);
				CALL pls_grava_log_execucao_temp('Fim pls_val_cta_aplicar_fil_ben', 'val_dif_filtro', nm_usuario_p);
				qt_registro_w := pls_tipos_cta_val_pck.obter_qtde_reg_valido_filtro(nr_id_transacao_p, dados_filtro_w);
			end if;

			-- procedimento
			if (dados_filtro_w.ie_filtro_proc = 'S' and (qt_registro_w = -1 or qt_registro_w > 0))  then
			CALL pls_grava_log_execucao_temp('Inicio pls_val_cta_aplicar_fil_proc', 'val_dif_filtro', nm_usuario_p);
				CALL pls_val_cta_aplicar_fil_proc(
							dados_regra_p, dados_filtro_w, dados_consistencia_p,
							nr_id_transacao_p, cd_estabelecimento_p, nm_usuario_p);
			CALL pls_grava_log_execucao_temp('Fim pls_val_cta_aplicar_fil_proc', 'val_dif_filtro', nm_usuario_p);
				-- como é o último filtro, não é necessário verificar a quantidade de registros
			end if;

		end loop; -- loop combinações
	end if;
end if;

qt_registro_p	:= qt_registro_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_cta_val_aplicar_filtros ( dados_consistencia_p pls_tipos_cta_val_pck.dados_consistencia, dados_regra_p pls_tipos_cta_val_pck.dados_regra, nr_id_transacao_p pls_rp_cta_selecao.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, qt_registro_p INOUT integer) FROM PUBLIC;

