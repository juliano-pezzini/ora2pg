-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE gerar_terceiro_regra_esp ( NR_REPASSE_TERCEIRO_P bigint, CD_ESTABELECIMENTO_P bigint, IE_TIPO_VALOR_P text, IE_SOMENTE_FORA_P text, NM_USUARIO_P text) AS $body$
DECLARE

 
/* IE_SOMENTE_FORA_P 
 
S	Somente 
F	Fora 
 
*/
 
 
ie_tipo_valor_w		varchar(255);
nr_seq_tipo_valor_w	bigint;
nr_seq_compl_w		bigint;
nr_seq_regra_w		bigint;
nr_seq_terceiro_w	bigint;
dt_referencia_w		timestamp;
vl_item_w		double precision;
nr_adiantamento_w	bigint;
cd_material_w		bigint;
cd_centro_custo_w	bigint;
vl_repasse_w		double precision;
ie_condicao_valor_w	varchar(5);
vl_condicao_w		double precision;
ie_prosseguir_w		varchar(1)	:= 'N';
tx_item_w		double precision;
vl_item_final_w		double precision;
vl_base_w		double precision;
vl_diferenca_w		double precision;
nr_seq_regra_ant_w	bigint;
ie_forma_calculo_w	varchar(5);
nr_seq_terc_regra_ant_w	bigint;
tx_desconto_w		double precision;
nr_seq_regra_item_w	bigint;
cd_regra_repasse_w	integer;
count_w			bigint;
nr_seq_regra_ant_base_w	bigint;
vl_repasse_regra_base_w	double precision;
ie_gerar_desconto_w	varchar(10) := 'N';
cd_regra_repasse_desc_w	bigint;
nr_seq_regra_ant_desc_w	bigint;
count_regra_tributo_w	bigint := 0;
vl_repasse_item_w	double precision;
vl_repasse_normal_w	double precision;
ie_ajustar_valor_w		varchar(10);
ie_valor_final_w		varchar(10);
nr_seq_terceiro_venc_w		bigint;
vl_ajuste_proc_mat_w		double precision;
qt_regra_ajuste_w		bigint;
qt_regra_pag_fixo_w		bigint;
vl_ignorar_w			double precision;
nr_seq_apresentacao_w		bigint;
vl_repasse_normal_atual_w	double precision;
vl_repasse_regra_ant_w		double precision;
vl_repasse_total_w		double precision;
pr_repasse_w			double precision;
vl_repassar_total_w		double precision;
cd_regra_repasse_ant_w		bigint;
nr_repasse_terceiro_w		bigint;
cd_estab_regra_ant_w		bigint;
vl_repasse_ajuste_estab_w	double precision;
tx_regra_base_w			double precision;
qt_regra_comple_acordo_w	bigint;
vl_estab_atual_w		double precision;
pr_repasse_exedente_w		double precision;
vl_sobra_w			double precision;
qt_regra_perc_repasse_w		bigint;
ie_terceiro_deff_w		boolean;
vl_repasse_real_w		double precision;
vl_repasse_geral_w		double precision;
vl_repasse_ajuste_w		double precision;
vl_repasse_total_base_w		double precision;
vl_total_rateio_w		double precision;
ie_regra_base_valor_w		varchar(10);
nr_seq_tipo_w			bigint;
ie_item_repasse_w		varchar(1);
ds_tipo_repasse_w		varchar(255);

c01 CURSOR FOR 
SELECT	a.nr_sequencia, 
	a.ie_condicao_valor, 
	a.vl_condicao, 
	coalesce(a.nr_seq_regra_ant,0), 
	coalesce(a.cd_regra_repasse,0), 
	coalesce(a.ie_valor_final,'N'), 
	coalesce(a.nr_seq_apresentacao,0), 
	coalesce(a.ie_regra_base_valor,'N') 
from	terceiro_regra_esp a 
where	a.nr_seq_terceiro	= nr_seq_terceiro_w 
and (cd_estabelecimento	= cd_estabelecimento_p or coalesce(cd_estabelecimento::text, '') = '') 
and	dt_referencia_w		between a.dt_inicio_vigencia and fim_dia(dt_fim_vigencia) 
and	ie_situacao		= 'A' 
order by	7,4,2;

c02 CURSOR FOR 
SELECT	a.nr_seq_tipo_valor, 
	a.vl_item, 
	a.nr_adiant_pago, 
	a.cd_material, 
	a.cd_centro_custo, 
	a.tx_item, 
	a.ie_forma_calculo, 
	coalesce(a.nr_seq_terc_regra_ant,0), 
	b.ie_tipo_valor, 
	a.nr_sequencia 
FROM terceiro_regra_esp_item a
LEFT OUTER JOIN tipo_valor_repasse_esp b ON (a.nr_seq_tipo_valor = b.nr_sequencia)
WHERE not exists (SELECT	1 
	from	repasse_terceiro_item x 
	where	x.nr_seq_terc_regra_item	= a.nr_sequencia 
	and	x.nr_seq_terc_regra_esp		= a.nr_seq_terc_regra 
	and	x.nr_repasse_terceiro		= nr_repasse_terceiro_p) and ((coalesce(ie_tipo_valor_p::text, '') = '') or (ie_somente_fora_p = 'S' and b.ie_tipo_valor = ie_tipo_valor_p) or (ie_somente_fora_p = 'F' and b.ie_tipo_valor <> ie_tipo_valor_p))  and a.nr_seq_terc_regra	= nr_seq_regra_w;

c03 CURSOR FOR 
SELECT	nr_seq_regra_esp, 
	tx_regra_base 
from	terc_regra_esp_base 
where	nr_seq_regra_item	= nr_seq_regra_item_w 
and	exists (SELECT	1 
		from	terceiro_regra_esp x 
		where	x.nr_sequencia	= nr_seq_regra_esp 
		and	x.ie_situacao	= 'A');
		
c04 CURSOR FOR 
SELECT	distinct 
	coalesce(a.cd_regra_repasse,0)	 
from	terceiro_regra_esp a 
where	a.nr_seq_terceiro	= nr_seq_terceiro_w 
and (a.cd_estabelecimento	= cd_estabelecimento_p or coalesce(a.cd_estabelecimento::text, '') = '') 
and	dt_referencia_w		between a.dt_inicio_vigencia and fim_dia(dt_fim_vigencia) 
and	ie_situacao		= 'A' 
and	exists (SELECT	1 
		FROM terceiro_regra_esp_item y
LEFT OUTER JOIN tipo_valor_repasse_esp x ON (y.nr_seq_tipo_valor = x.nr_sequencia)
WHERE y.nr_seq_terc_regra	= a.nr_sequencia and (x.ie_tipo_valor	<> '1' or coalesce(y.nr_seq_tipo_valor::text, '') = '') )		 
and	exists (select	1 
		from	repasse_terceiro_item z 
		where	z.nr_seq_terc_regra_esp	= a.nr_sequencia 
		and	z.nr_repasse_terceiro	= nr_repasse_terceiro_p) 
and  ((select	count(*) 
	FROM repasse_terceiro_item z, terceiro_regra_esp q, terceiro_regra_esp_item e
LEFT OUTER JOIN tipo_valor_repasse_esp i ON (e.nr_seq_tipo_valor = i.nr_sequencia)
WHERE z.nr_seq_terc_regra_esp	= a.nr_sequencia and z.nr_seq_terc_regra_esp = q.nr_sequencia and q.nr_sequencia 		= e.nr_seq_terc_regra  and (i.ie_tipo_valor	= '8' or coalesce(e.nr_seq_tipo_valor::text, '') = '') and z.nr_repasse_terceiro	= nr_repasse_terceiro_p ) = 0)		 
and  ((select	count(*) /*Se só existe regra de desconto, não desconta o valor total do repasse normal.*/
 
	from	repasse_terceiro_item z, 
		terceiro_regra_esp q, 
		terceiro_regra_esp_item e 
	where	z.nr_seq_terc_regra_esp	= a.nr_sequencia 
	and	z.nr_seq_terc_regra_esp = q.nr_sequencia 
	and	q.nr_sequencia 		= e.nr_seq_terc_regra 
	and	e.ie_forma_calculo 	not in ('2','8') 
	and	z.nr_repasse_terceiro	= nr_repasse_terceiro_p) >= 1);
	
c05 CURSOR FOR 
SELECT	a.nr_seq_regra_esp, 
	a.tx_regra_base 
from	terc_regra_esp_base a 
where	a.nr_seq_regra_item	= nr_seq_regra_item_w 
and	exists (SELECT	1 
	from	terceiro_regra_esp x 
	where	x.nr_sequencia		= a.nr_seq_regra_esp 
	and	x.cd_estabelecimento	= cd_estabelecimento_p);		
	 
c06 CURSOR FOR 
SELECT	nr_seq_regra_esp 
from	terceiro_regra_esp b, 
	terc_regra_esp_base a 
where	a.nr_seq_regra_item	= nr_seq_regra_item_w 
and	b.nr_sequencia		= a.nr_seq_regra_esp 
and	b.cd_estabelecimento	= cd_estabelecimento_p;		
 

BEGIN 
 
select	max(nr_seq_terceiro), 
	max(dt_mesano_referencia), 
	obter_valor_repasse(max(nr_repasse_terceiro),'R'), 
	max(nr_seq_tipo) 
into STRICT	nr_seq_terceiro_w, 
	dt_referencia_w, 
	vl_repasse_w, 
	nr_seq_tipo_w 
from	repasse_terceiro 
where	nr_repasse_terceiro	= nr_repasse_terceiro_p;
 
select	coalesce(max(a.ie_item_repasse),'S'), 
	max(a.ds_tipo_repasse) 
into STRICT	ie_item_repasse_w, 
	ds_tipo_repasse_w 
from	tipo_repasse a 
where	a.nr_sequencia	= nr_seq_tipo_w;
 
if (coalesce(ie_item_repasse_w,'S') = 'N') then 
	CALL wheb_mensagem_pck.exibir_mensagem_abort(205337, 'DS_TIPO_REPASSE_W='||ds_tipo_repasse_w);	
end if;
 
delete	from repasse_terceiro_item 
where	((nr_seq_terc_regra_item IS NOT NULL AND nr_seq_terc_regra_item::text <> '') or (nr_seq_terc_regra_esp IS NOT NULL AND nr_seq_terc_regra_esp::text <> '')) 
and	nr_repasse_terceiro	= nr_repasse_terceiro_p;
 
if (nr_seq_terceiro_w in (41,7645)) then 
	ie_terceiro_deff_w	:= True;
else 
	ie_terceiro_deff_w	:= False;
end if;
 
open c01;
loop 
fetch c01 into 
	nr_seq_regra_w, 
	ie_condicao_valor_w, 
	vl_condicao_w, 
	nr_seq_regra_ant_w, 
	cd_regra_repasse_w, 
	ie_valor_final_w, 
	nr_seq_apresentacao_w, 
	ie_regra_base_valor_w;
EXIT WHEN NOT FOUND; /* apply on c01 */	
 
	if (nr_seq_regra_ant_w	<> 0) then 
	 
		vl_repasse_w := obter_valor_regra_rep_ant( nr_repasse_terceiro_p, nr_seq_regra_ant_w, vl_repasse_w);
 
		/* 
		select	nvl(sum(a.vl_repasse),0) 
		into	vl_repasse_w 
		from	repasse_terceiro_item a 
		where	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_w 
		and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p;*/
 
 
	elsif (cd_regra_repasse_w	<> 0) then 
 
		select	coalesce(sum(vl_repasse),0) 
		into STRICT	vl_repasse_w 
		from (SELECT	a.vl_repasse 
			from	procedimento_repasse a 
			where	a.cd_regra		= cd_regra_repasse_w 
			and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
			
union all
 
			SELECT	a.vl_repasse 
			from	material_repasse a 
			where	a.cd_regra		= cd_regra_repasse_w 
			and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias3;
 
	else 
 
		select	obter_valor_repasse(max(a.nr_repasse_terceiro),'R') 
		into STRICT	vl_repasse_w 
		from	repasse_terceiro a 
		where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p;
 
	end if;
	 
	ie_ajustar_valor_w	:= 'N';
	ie_prosseguir_w		:= 'N';
 
	if (coalesce(ie_condicao_valor_w::text, '') = '') then 
		ie_prosseguir_w	:= 'S';		
	elsif (ie_condicao_valor_w = '1') then /*Valor do repasse até*/
 
		ie_prosseguir_w	:= 'S';		
	elsif (ie_condicao_valor_w = '2') then/* Valor do Repasse menor que */
		 
		ie_prosseguir_w	:= 'S';	
	elsif (ie_condicao_valor_w = '3') then /*Valor do repasse maior que*/
		 
		ie_prosseguir_w	:= 'S';
	end if;
 
	if (ie_prosseguir_w = 'S') then 
		 
		open c02;
		loop 
		fetch c02 into 
			nr_seq_tipo_valor_w, 
			vl_item_w, 
			nr_adiantamento_w, 
			cd_material_w, 
			cd_centro_custo_w, 
			tx_item_w, 
			ie_forma_calculo_w, 
			nr_seq_terc_regra_ant_w, 
			ie_tipo_valor_w, 
			nr_seq_regra_item_w;
		EXIT WHEN NOT FOUND; /* apply on c02 */	
			 
			vl_ajuste_proc_mat_w := 0;
		 
			if (vl_item_w IS NOT NULL AND vl_item_w::text <> '') then 
				vl_item_final_w	:= coalesce(vl_item_w,0);
			else 
				vl_item_final_w	:= coalesce(vl_repasse_w,0);
			end if;	
 
			if (ie_tipo_valor_w = '2') and (coalesce(vl_item_w::text, '') = '') then --Desconto			 
				if (nr_seq_regra_ant_w <> 0) then 
					select	coalesce(sum(a.vl_repasse),0) 
					into STRICT	vl_item_final_w 
					from	repasse_terceiro_item a 
					where	nr_seq_terc_regra_esp		= nr_seq_regra_ant_w 
					and	a.nr_repasse_terceiro		= nr_repasse_terceiro_p;
				end if;						
			end if;			
 
			if (coalesce(tx_item_w,0) > 0) then 
				vl_item_final_w	:= (vl_item_final_w * tx_item_w) / 100;
			end if;			
 
			if (ie_forma_calculo_w = '1') then	/* valor do repasse menor ou igual a */
 
				 
				if (ie_tipo_valor_w = '8') then /* Tipo de valor 'Complemento para o mínimo acordado' */ 
				 
					/*Considera também a pasta 'Regra base valor'*/
 
					select	count(*) 
					into STRICT	count_w 
					from	terc_regra_esp_base 
					where	nr_seq_regra_item	= nr_seq_regra_item_w;				
				 
					if (count_w > 0) then 
						vl_item_final_w 	:= 0;
						vl_repasse_regra_base_w := 0;
						vl_repasse_w		:= 0;
						 
						open C03;
						loop 
						fetch C03 into	 
							nr_seq_regra_ant_base_w, 
							tx_regra_base_w;
						EXIT WHEN NOT FOUND; /* apply on C03 */
							 
							select	max(cd_regra_repasse) 
							into STRICT	cd_regra_repasse_ant_w 
							from	terceiro_regra_esp 
							where	nr_sequencia	= nr_seq_regra_ant_base_w;						
						 
							 
							select	max(a.nr_repasse_terceiro) 
							into STRICT	nr_repasse_terceiro_w 
							from	repasse_terceiro a, 
								terceiro_regra_esp b 
							where	a.nr_seq_terceiro			= b.nr_seq_terceiro 
							and	b.nr_sequencia				= nr_seq_regra_ant_base_w 
							and	PKG_DATE_UTILS.start_of(a.dt_mesano_referencia,'MONTH',0)	= PKG_DATE_UTILS.start_of(dt_referencia_w,'MONTH',0) 
							and	exists (SELECT	1 
									from	procedimento_repasse x 
									where	x.cd_regra		= b.cd_regra_repasse 
									and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro 
									
union all
 
									SELECT	1 
									from	material_repasse x 
									where	x.cd_regra		= b.cd_regra_repasse 
									and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro);
									 
							if (nr_repasse_terceiro_w IS NOT NULL AND nr_repasse_terceiro_w::text <> '') then 
							 
								 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_regra_base_w 
								from (SELECT	a.vl_repasse 
									from	procedimento_repasse a 
									where	a.cd_regra		= cd_regra_repasse_ant_w 
									and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w 
									
union all
 
									SELECT	a.vl_repasse 
									from	material_repasse a 
									where	a.cd_regra		= cd_regra_repasse_ant_w 
									and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w) alias3;
 
							else							 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_regra_base_w 
								from	repasse_terceiro b, 
									repasse_terceiro_item a 
								where	a.nr_repasse_terceiro	= b.nr_repasse_terceiro 
								and	b.dt_mesano_referencia	= dt_referencia_w 
								and	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;							
							end if;	
							 
							if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
								vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
							end if;
 
							vl_repasse_w	:= vl_repasse_w + vl_repasse_regra_base_w;							
							 
						end loop;
						close C03;
						 
						if (coalesce(vl_repasse_w,0) <= coalesce(vl_condicao_w,0)) then /* Se menor ou igual, é o valor da condição */
 
						 
							vl_estab_atual_w	:= 0;
							vl_repasse_total_w	:= 0;
							pr_repasse_w		:= 100;
							vl_repasse_regra_base_w	:= 0;
							 
							/*Buscar o valor do estabelecimento atual, para saber o % de cada estab*/
 
							open C05;
							loop 
							fetch C05 into	 
								nr_seq_regra_ant_base_w, 
								tx_regra_base_w;
							EXIT WHEN NOT FOUND; /* apply on C05 */
								 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_regra_base_w 
								from	repasse_terceiro_item 
								where	nr_repasse_terceiro	= nr_repasse_terceiro_p 
								and	nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;
 
								if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
									vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
								end if;								
 
								vl_estab_atual_w	:= vl_estab_atual_w + vl_repasse_regra_base_w;
								 
							end loop;
							close C05;						
							 
							vl_repasse_total_w	:= coalesce(vl_repasse_w,0);														
							pr_repasse_w		:= dividir_sem_round(vl_estab_atual_w,vl_repasse_total_w); /*percentual do repasse atual sobre o total do repasse das regras base valor*/
							 
							--vl_item_final_w		:= nvl(vl_condicao_w,0) * nvl(pr_repasse_w,0); /*O valor a ser repassado é rateado conforme o percentual do repasse atual sobre as regras base valor*/	 
							
							if (coalesce(vl_repasse_w,0) <= coalesce(vl_condicao_w,0)) then /* Se menor ou igual*/
 
								vl_item_final_w	:= coalesce(vl_condicao_w,0) - coalesce(vl_repasse_total_w,0);
							elsif (coalesce(vl_repasse_w,0) > coalesce(vl_condicao_w,0)) then /* Se maior */
 
								vl_item_final_w	:= 0;
							end if;
							 
							vl_item_final_w		:= coalesce(vl_item_final_w,0) * coalesce(pr_repasse_w,0);
						 
							if (coalesce(tx_item_w,0) > 0) then 
								vl_item_final_w	:= (vl_item_final_w * tx_item_w) * 100;
							end if;	
						else 
							vl_item_final_w	:= 0;
						end if;						
						 
					elsif (nr_seq_regra_ant_w <> 0) then	/*Se não existe, considera a regra anterior*/
				 
						--obter_valor_regra_rep_ant( nr_repasse_terceiro_p, nr_seq_regra_ant_w, vl_repasse_w);	 
						select	coalesce(sum(a.vl_repasse),0) 
						into STRICT	vl_repasse_w 
						from	repasse_terceiro_item a 
						where	a.nr_repasse_terceiro		= nr_repasse_terceiro_p 
						and	(a.nr_seq_terc_regra_esp IS NOT NULL AND a.nr_seq_terc_regra_esp::text <> '');						
						 
						if (coalesce(vl_repasse_w,0) <= coalesce(vl_condicao_w,0)) then /* Se menor ou igual*/
 
							vl_item_final_w	:= coalesce(vl_condicao_w,0) - coalesce(vl_repasse_w,0);
						elsif (coalesce(vl_repasse_w,0) > coalesce(vl_condicao_w,0)) then /* Se maior */
 
							vl_item_final_w	:= 0;
						end if;	
						 
						if (coalesce(tx_item_w,0) > 0) then 
							vl_item_final_w	:= (vl_item_final_w * tx_item_w) / 100;
						end if;	
						 
					elsif (cd_regra_repasse_w <> 0) then 
					 
						select	coalesce(sum(vl_repasse),0) 
						into STRICT	vl_repasse_w 
						from (SELECT	a.vl_repasse 
							from	procedimento_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
							
union all
 
							SELECT	a.vl_repasse 
							from	material_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias3;
						 
					end if;				
					 
				else				 
					select	count(*) 
					into STRICT	count_w 
					from	terc_regra_esp_base 
					where	nr_seq_regra_item	= nr_seq_regra_item_w;				
				 
					if (count_w > 0) then 
						vl_item_final_w 	:= 0;
						vl_repasse_regra_base_w := 0;
						vl_repasse_w		:= 0;
						 
						/*Buscar a regra base valor informada*/
 
						open C03;
						loop 
						fetch C03 into	 
							nr_seq_regra_ant_base_w, 
							tx_regra_base_w;
						EXIT WHEN NOT FOUND; /* apply on C03 */
							 
							/*regra de repasse informada na regra base valor*/
 
							select	max(cd_regra_repasse) 
							into STRICT	cd_regra_repasse_ant_w 
							from	terceiro_regra_esp 
							where	nr_sequencia	= nr_seq_regra_ant_base_w;						
						 
							/*Repasse gerado para o terceiro no mes referência */
 
							select	max(a.nr_repasse_terceiro) 
							into STRICT	nr_repasse_terceiro_w 
							from	repasse_terceiro a, 
								terceiro_regra_esp b 
							where	a.nr_seq_terceiro			= b.nr_seq_terceiro 
							and	b.nr_sequencia				= nr_seq_regra_ant_base_w 
							and	PKG_DATE_UTILS.start_of(a.dt_mesano_referencia,'MONTH',0)	= PKG_DATE_UTILS.start_of(dt_referencia_w,'MONTH',0) 
							and	exists (SELECT	1 
									from	procedimento_repasse x 
									where	x.cd_regra		= b.cd_regra_repasse 
									and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro 
									
union all
 
									SELECT	1 
									from	material_repasse x 
									where	x.cd_regra		= b.cd_regra_repasse 
									and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro);
									 
							if (nr_repasse_terceiro_w IS NOT NULL AND nr_repasse_terceiro_w::text <> '') then 
							 
								/*Valor do repasse gerado para a regra de repasse*/
 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_regra_base_w 
								from (SELECT	a.vl_repasse 
									from	procedimento_repasse a 
									where	a.cd_regra		= cd_regra_repasse_ant_w 
									and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w 
									
union all
 
									SELECT	a.vl_repasse 
									from	material_repasse a 
									where	a.cd_regra		= cd_regra_repasse_ant_w 
									and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w) alias3;
 
							else							 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_regra_base_w 
								from	repasse_terceiro b, 
									repasse_terceiro_item a 
								where	a.nr_repasse_terceiro	= b.nr_repasse_terceiro 
								and	b.dt_mesano_referencia	= dt_referencia_w 
								and	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;							
							end if;
							 
							if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
								vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
							end if;
 
							vl_repasse_w	:= vl_repasse_w + vl_repasse_regra_base_w;
							 
						end loop;
						close C03;							
 
						if (coalesce(vl_repasse_w,0) > coalesce(vl_condicao_w,0)) then /* Se maior, o valor do próprio repasse */
 
							 
							if (ie_regra_base_valor_w = 'N') then							 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_normal_atual_w 
								from (SELECT	a.vl_repasse 
									from	procedimento_repasse a 
									where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
									
union all
 
									SELECT	a.vl_repasse 
									from	material_repasse a 
									where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias6;
							else 
								vl_repasse_normal_atual_w := 0;
								open C06;
								loop 
								fetch C06 into	 
									nr_seq_regra_ant_base_w;								
								EXIT WHEN NOT FOUND; /* apply on C06 */
								 
									select	coalesce(sum(vl_repasse),0) 
									into STRICT	vl_repasse_regra_base_w 
									from	repasse_terceiro_item a 
									where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
									and	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;
									 
									vl_repasse_normal_atual_w	:= vl_repasse_normal_atual_w + vl_repasse_regra_base_w;
								 
								end loop;
								close C06;				
								 
							end if;
								 
							vl_repasse_total_w	:= coalesce(vl_repasse_w,0);							
							vl_repassar_total_w	:= (coalesce(vl_condicao_w,0) * tx_item_w) / 100; /*Valor total a ser repassado (% sobre o total do repasse)*/
							pr_repasse_w		:= dividir(vl_repasse_normal_atual_w,vl_repasse_total_w) * 100; /*percentual do repasse atual sobre o total do repasse das regras base valor*/
													 
							 
							/*(-20011,' vl_repassar_total_w: '||vl_repasse_normal_atual_w|| 
											' vl_repasse_total_w: '||vl_repasse_total_w|| 
											' pr_repasse_w: '||pr_repasse_w);*/
							 
							vl_item_final_w		:= (coalesce(vl_repassar_total_w,0) * coalesce(pr_repasse_w,0)) / 100; /*O valor a ser repassado é rateado conforme o percentual do repasse atual sobre as regras base valor*/
														
							 
						elsif (coalesce(vl_repasse_w,0) <= coalesce(vl_condicao_w,0)) then /* Se menor ou igual, é o valor da condição */
 
						 
							select	count(*) 
							into STRICT	qt_regra_perc_repasse_w 
							from	repasse_terceiro_item a 
							where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
							and	(a.nr_seq_terc_regra_esp IS NOT NULL AND a.nr_seq_terc_regra_esp::text <> '') 
							and	exists (SELECT	1 
									from	terceiro_regra_esp_item y, 
										terceiro_regra_esp x 
									where	x.nr_sequencia		= y.nr_seq_terc_regra 
									and	x.nr_sequencia		= a.nr_seq_terc_regra_esp 
									and	x.ie_condicao_valor	= '1' 
									and	y.ie_forma_calculo	= '1');
									 
							if (qt_regra_perc_repasse_w = 0) then						 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_normal_atual_w 
								from (SELECT	a.vl_repasse 
									from	procedimento_repasse a 
									where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
									
union all
 
									SELECT	a.vl_repasse 
									from	material_repasse a 
									where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias3;
							else	/*lhaoves - 18/10/2011 - OS 298210*/
 
 
								if (ie_regra_base_valor_w = 'N') then 
									select	coalesce(sum(a.vl_repasse),0) 
									into STRICT	vl_repasse_normal_atual_w 
									from	terceiro_regra_esp b, 
										repasse_terceiro_item a 
									where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
									and	a.nr_seq_terc_regra_esp	= b.nr_sequencia 
									and	b.nr_seq_apresentacao	< nr_seq_apresentacao_w								 
									and	(b.cd_regra_repasse IS NOT NULL AND b.cd_regra_repasse::text <> '');
								else 
									vl_repasse_normal_atual_w := 0;
									open C06;
									loop 
									fetch C06 into	 
										nr_seq_regra_ant_base_w;								
									EXIT WHEN NOT FOUND; /* apply on C06 */
									 
										select	coalesce(sum(vl_repasse),0) 
										into STRICT	vl_repasse_regra_base_w 
										from	repasse_terceiro_item a 
										where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
										and	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;
										 
										vl_repasse_normal_atual_w	:= vl_repasse_normal_atual_w + vl_repasse_regra_base_w;
									 
									end loop;
									close C06;								
								end if;
							end if;							
								 
							vl_repasse_total_w	:= coalesce(vl_repasse_w,0);							
							vl_repassar_total_w	:= (coalesce(vl_repasse_total_w,0) * tx_item_w) / 100; /*Valor total a ser repassado (% sobre o total do repasse)*/
							pr_repasse_w		:= dividir(vl_repasse_normal_atual_w,vl_repasse_total_w) * 100; /*percentual do repasse atual sobre o total do repasse das regras base valor*/
											 
							vl_item_final_w		:= (coalesce(vl_repassar_total_w,0) * coalesce(pr_repasse_w,0)) / 100; /*O valor a ser repassado é rateado conforme o percentual do repasse atual sobre as regras base valor*/
							
						end if;	
 
						if (vl_item_final_w <> 0) and /*Se o item possui valor e a condição do valor for 'Valor do repasse até', desconta o valor do repasse gerado*/
 
							(ie_condicao_valor_w = '1') and (not ie_terceiro_deff_w) 
							then 
							 
							select	coalesce(sum(vl_repasse),0) 
							into STRICT	vl_ajuste_proc_mat_w 
							from (SELECT	a.vl_repasse 
								from	procedimento_repasse a 
								where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
								
union all
 
								SELECT	a.vl_repasse 
								from	material_repasse a 
								where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias5;
								 
							CALL gerar_repasse_tre(	null, 
										null, 
										vl_ajuste_proc_mat_w * -1, 
										null, 
										null, 
										nr_repasse_terceiro_p, 
										null, 
										nm_usuario_p, 
										null, 
										nr_seq_regra_item_w);	
						end if;						
						 
					else					 
						if (coalesce(vl_repasse_w,0) <= coalesce(vl_condicao_w,0)) then /* Se menor ou igual, é o valor da condição */
 
							vl_item_final_w	:= coalesce(vl_repasse_w,0);
						elsif (coalesce(vl_repasse_w,0) > coalesce(vl_condicao_w,0)) then /* Se maior, o valor do próprio repasse */
 
							vl_item_final_w	:= coalesce(vl_condicao_w,0);
						end if;
						 
						if (coalesce(tx_item_w,0) > 0) then 
							vl_item_final_w	:= (vl_item_final_w * tx_item_w) / 100;
						end if;						
					end if;				
				end if;										
				 
			elsif (ie_forma_calculo_w = '2') then	/* desconto por inadimplência */
 
			 
				select	count(*) 
				into STRICT	count_w 
				from	terc_regra_esp_base 
				where	nr_seq_regra_item	= nr_seq_regra_item_w;				
				 
				if (count_w > 0) then 
					vl_item_final_w 	:= 0;
					vl_repasse_regra_base_w := 0;
					 
					open C03;
					loop 
					fetch C03 into	 
						nr_seq_regra_ant_base_w, 
						tx_regra_base_w;
					EXIT WHEN NOT FOUND; /* apply on C03 */
						 
						select	coalesce(sum(vl_repasse),0) 
						into STRICT	vl_repasse_regra_base_w 
						from	repasse_terceiro_item 
						where	nr_repasse_terceiro	= nr_repasse_terceiro_p 
						and	nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;
						 
						if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
							vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
						end if;
 
						vl_item_final_w	:= vl_item_final_w + vl_repasse_regra_base_w;
						 
					end loop;
					close C03;		
				else 
					if (nr_seq_regra_ant_w <> 0) then 
						vl_item_final_w := obter_valor_regra_rep_ant( nr_repasse_terceiro_p, nr_seq_regra_ant_w, vl_item_final_w);
					else		 
						select	coalesce(sum(vl_repasse),0) 
						into STRICT	vl_item_final_w 
						from (SELECT	a.vl_repasse 
							from	procedimento_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
							
union all
 
							SELECT	a.vl_repasse 
							from	material_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias2;
					end if;
				end if;								
			 
				select	coalesce(max(tx_desconto),0) * -1 
				into STRICT	tx_desconto_w 
				from	regra_desc_repasse a 
				where	PKG_DATE_UTILS.start_of(a.dt_mesano_ref,'MONTH',0) = PKG_DATE_UTILS.start_of(dt_referencia_w,'MONTH',0);
 
				vl_item_final_w	:= (coalesce(vl_item_final_w,0) * tx_desconto_w) / 100;
 
			elsif (ie_forma_calculo_w = '3') then	/* Valor do repasse excedente multiplicado por */
 
 
				select	count(*) 
				into STRICT	count_w 
				from	terc_regra_esp_base 
				where	nr_seq_regra_item	= nr_seq_regra_item_w;			
 
				if (count_w > 0) then 
					vl_item_final_w 	:= 0;
					vl_repasse_regra_base_w := 0;
					vl_repasse_w		:= 0;
					 
					open C03;
					loop 
					fetch C03 into	 
						nr_seq_regra_ant_base_w, 
						tx_regra_base_w;
					EXIT WHEN NOT FOUND; /* apply on C03 */
 
						select	max(cd_regra_repasse) 
						into STRICT	cd_regra_repasse_ant_w 
						from	terceiro_regra_esp 
						where	nr_sequencia	= nr_seq_regra_ant_base_w;						
					 
						select	max(a.nr_repasse_terceiro) 
						into STRICT	nr_repasse_terceiro_w 
						from	repasse_terceiro a, 
							terceiro_regra_esp b 
						where	a.nr_seq_terceiro			= b.nr_seq_terceiro 
						and	b.nr_sequencia				= nr_seq_regra_ant_base_w 
						and	PKG_DATE_UTILS.start_of(a.dt_mesano_referencia,'MONTH',0)	= PKG_DATE_UTILS.start_of(dt_referencia_w,'MONTH',0) 
						and	exists (SELECT	1 
								from	procedimento_repasse x 
								where	x.cd_regra		= b.cd_regra_repasse 
								and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro 
								
union all
 
								SELECT	1 
								from	material_repasse x 
								where	x.cd_regra		= b.cd_regra_repasse 
								and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro);
								 
						if (nr_repasse_terceiro_w IS NOT NULL AND nr_repasse_terceiro_w::text <> '') then 
						 
							select	coalesce(sum(vl_repasse),0) 
							into STRICT	vl_repasse_regra_base_w 
							from (SELECT	a.vl_repasse 
								from	procedimento_repasse a 
								where	a.cd_regra		= cd_regra_repasse_ant_w 
								and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w 
								
union all
 
								SELECT	a.vl_repasse 
								from	material_repasse a 
								where	a.cd_regra		= cd_regra_repasse_ant_w 
								and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w) alias3;
 
						else							 
							select	coalesce(sum(vl_repasse),0) 
							into STRICT	vl_repasse_regra_base_w 
							from	repasse_terceiro b, 
								repasse_terceiro_item a 
							where	a.nr_repasse_terceiro	= b.nr_repasse_terceiro 
							and	b.dt_mesano_referencia	= dt_referencia_w 
							and	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;							
						end if;						
						 
						if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
							vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
						end if;
 
						vl_repasse_w	:= vl_repasse_w + vl_repasse_regra_base_w;
						 
					end loop;
					close C03;		
 
					if (coalesce(vl_repasse_w,0) > coalesce(vl_condicao_w,0)) then /* Se menor ou igual, é o valor da condição */
	 
 
						if (ie_regra_base_valor_w = 'N') then					 
							select	coalesce(sum(vl_repasse),0) 
							into STRICT	vl_repasse_normal_atual_w 
							from (SELECT	a.vl_repasse 
								from	procedimento_repasse a 
								where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
								
union all
 
								SELECT	a.vl_repasse 
								from	material_repasse a 
								where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
								
union all
 
								select	a.vl_repasse 
								from	centro_custo c, 
									tipo_valor_repasse_esp b, 
									repasse_terceiro_item a 
								where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
								and	a.nr_seq_tipo_valor	= b.nr_sequencia 
								and	b.ie_tipo_valor		= '1' 
								and	a.cd_centro_custo	= c.cd_centro_custo 
								and	c.cd_estabelecimento	= cd_estabelecimento_p) alias6;	
						else						 
							vl_repasse_normal_atual_w := 0;
							open C06;
							loop 
							fetch C06 into	 
								nr_seq_regra_ant_base_w;								
							EXIT WHEN NOT FOUND; /* apply on C06 */
							 
								select	coalesce(sum(vl_repasse),0) 
								into STRICT	vl_repasse_regra_base_w 
								from	repasse_terceiro_item a 
								where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
								and	a.nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;
								 
								vl_repasse_normal_atual_w	:= vl_repasse_normal_atual_w + vl_repasse_regra_base_w;
							 
							end loop;
							close C06;						
						end if;
							 
						vl_repasse_total_w	:= coalesce(vl_repasse_w,0);	
						vl_repassar_total_w	:= ((coalesce(vl_repasse_total_w,0) - coalesce(vl_condicao_w,0)) * coalesce(tx_item_w,1)) / 100; /*Valor total a ser repassado (valor total dos repasses - condição * taxa )*/
						
						pr_repasse_exedente_w	:= trunc(dividir_sem_round(vl_repasse_normal_atual_w,vl_repasse_total_w),6); /*percentual do repasse atual sobre o total do repasse das regras base valo*/
 
						 
						/*Rotina para arredondar, se for por exemplo 0,02185, fica como 0,0218, se for 0,02186, fica 0,0219*/
						vl_sobra_w		:= pr_repasse_exedente_w - trunc(pr_repasse_exedente_w,5);						
						if (vl_sobra_w	<= 0.000005) then 
							pr_repasse_exedente_w	:= trunc(pr_repasse_exedente_w,4);
						else 
							pr_repasse_exedente_w	:= round((pr_repasse_exedente_w)::numeric,4);
						end if;
 
						vl_item_final_w		:= coalesce(vl_repassar_total_w,0) * coalesce(pr_repasse_exedente_w,0); /*O valor a ser repassado é rateado conforme o percentual do repasse atual sobre as regras base valor*/
				
						 
					elsif (coalesce(vl_repasse_w,0) <= coalesce(vl_condicao_w,0)) then /* Se maior, o valor do próprio repasse */
					 
						vl_item_final_w		:= 0;						
					end if;	
					 
				else	 
					if (tx_item_w IS NOT NULL AND tx_item_w::text <> '') then	 
						if (coalesce(vl_repasse_w,0) > coalesce(vl_condicao_w,0)) then				 
							vl_item_final_w	:= ((coalesce(vl_repasse_w,0) - coalesce(vl_condicao_w,0)) * coalesce(tx_item_w,1)) / 100;
						else 
							vl_item_final_w	:= 0;
						end if;	
					else 
						vl_item_final_w	:= coalesce(vl_repasse_w,0) - coalesce(vl_condicao_w,0);
					end if;	
				end if;
				 
			elsif (ie_forma_calculo_w = '4') then /*Procedimentos e Materiais de repasse multiplicado por*/
			 
				 
				if (cd_regra_repasse_w <> 0) then 
				 
					select	max(cd_estabelecimento) 
					into STRICT	cd_estab_regra_ant_w 
					from	regra_repasse_terceiro						 
					where	cd_regra	= cd_regra_repasse_w;
					 
					if (coalesce(cd_estab_regra_ant_w,cd_estabelecimento_p) <> cd_estabelecimento_p) then 
 
						select	max(nr_repasse_terceiro) 
						into STRICT	nr_repasse_terceiro_w 
						from	repasse_terceiro a 
						where	PKG_DATE_UTILS.start_of(a.dt_mesano_referencia,'MONTH',0)	= PKG_DATE_UTILS.start_of(dt_referencia_w,'MONTH',0) 
						and	a.cd_estabelecimento			= cd_estab_regra_ant_w 
						and	exists (SELECT	1 
								from	procedimento_repasse x 
								where	x.cd_regra		= cd_regra_repasse_w 
								and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro 
								
union all
 
								SELECT	1 
								from	material_repasse x 
								where	x.cd_regra		= cd_regra_repasse_w 
								and	x.nr_repasse_terceiro	= a.nr_repasse_terceiro);
								 
						select	coalesce(sum(vl_repasse),0) 
						into STRICT	vl_repasse_w 
						from (SELECT	a.vl_repasse 
							from	procedimento_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w 
							
union all
 
							SELECT	a.vl_repasse 
							from	material_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_w) alias2;							
					 
					else				 
						/*Se possui regra de repasse informada, busca o valor gerado por esta regra*/
 
						select	coalesce(sum(vl_repasse),0) 
						into STRICT	vl_repasse_w 
						from (SELECT	a.vl_repasse 
							from	procedimento_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
							
union all
 
							SELECT	a.vl_repasse 
							from	material_repasse a 
							where	a.cd_regra		= cd_regra_repasse_w 
							and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias2;
					end if;
				else	 
					/*Se não, busca o valor total do repasse até o momento*/
 
					select	obter_valor_repasse(max(a.nr_repasse_terceiro),'R') 
					into STRICT	vl_repasse_w 
					from	repasse_terceiro a 
					where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p;					
				end if;
				 
				if (tx_item_w IS NOT NULL AND tx_item_w::text <> '') then				 
					vl_item_final_w	:= vl_repasse_w * tx_item_w;
				else 
					vl_item_final_w	:= vl_repasse_w;
				end if;
				 
				/*Só desconta se não existe regra definida como 'Valor Final', porque desconta duas vezes a mesma regra*/
 
				select	count(*) 
				into STRICT	qt_regra_ajuste_w 
				from	terceiro_regra_esp a 
				where	a.nr_seq_terceiro	= nr_seq_terceiro_w 
				and (a.cd_estabelecimento	= cd_estabelecimento_p or coalesce(a.cd_estabelecimento::text, '') = '') 
				and	dt_referencia_w		between a.dt_inicio_vigencia and fim_dia(dt_fim_vigencia) 
				and	ie_valor_final		= 'S'				 
				and	ie_situacao		= 'A';
				/*Só desconta se não existe regra definida como tipo de valor 'Pagamento fixo'.*/
 
				select	count(*) 
				into STRICT	qt_regra_pag_fixo_w 
				from	tipo_valor_repasse_esp c, 
					terceiro_regra_esp_item b, 
					terceiro_regra_esp a 
				where	a.nr_seq_terceiro	= nr_seq_terceiro_w 
				and (a.cd_estabelecimento	= cd_estabelecimento_p or coalesce(a.cd_estabelecimento::text, '') = '') 
				and	a.nr_sequencia		= b.nr_seq_terc_regra 
				and	b.nr_seq_tipo_valor	= c.nr_sequencia 
				and	c.ie_tipo_valor		= '3' 
				and	dt_referencia_w		between a.dt_inicio_vigencia and fim_dia(dt_fim_vigencia)								 
				and	a.ie_situacao		= 'A';
				 
				/*O valor desta regra deve ser gerado nos itens do repasse, mas desconta do repasse normal*/
 
				if (coalesce(tx_item_w,0) > 0) and (not ie_terceiro_deff_w) then 
					vl_ajuste_proc_mat_w	:= vl_item_final_w * -1;
					 
					if	(qt_regra_ajuste_w = 0 AND qt_regra_pag_fixo_w = 0) or (vl_ajuste_proc_mat_w <> 0)then					 
						 
						CALL gerar_repasse_tre(	null, 
									null, 
									vl_ajuste_proc_mat_w, 
									null, 
									null, 
									nr_repasse_terceiro_p, 
									null, 
									nm_usuario_p, 
									null, 
									nr_seq_regra_item_w);
					end if;
				end if;
 
			elsif (ie_forma_calculo_w = '5') then	/*Tributos*/
		 
				null;
			elsif (ie_forma_calculo_w = '6') then /*Valor do repasse multiplicado por*/
 
			 
				select	count(*) 
				into STRICT	count_w 
				from	terc_regra_esp_base 
				where	nr_seq_regra_item	= nr_seq_regra_item_w;				
				 
				if (count_w > 0) then 
					vl_repasse_w		:= 0;
					vl_item_final_w 	:= 0;
					vl_repasse_regra_base_w := 0;
					 
					open C03;
					loop 
					fetch C03 into	 
						nr_seq_regra_ant_base_w, 
						tx_regra_base_w;
					EXIT WHEN NOT FOUND; /* apply on C03 */
						 
						select	coalesce(sum(vl_repasse),0) 
						into STRICT	vl_repasse_regra_base_w 
						from	repasse_terceiro_item 
						where	nr_repasse_terceiro	= nr_repasse_terceiro_p 
						and	nr_seq_terc_regra_esp	= nr_seq_regra_ant_base_w;
						 
						if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
							vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
						end if;
 
						vl_repasse_w	:= vl_repasse_w + vl_repasse_regra_base_w;
						 
					end loop;
					close C03;
				else			 
					if (nr_seq_regra_ant_w <> 0) then 
						/*Se possui regra anteriro, busca o valor gerado nos itens do repasse até o momento*/
 
						select	coalesce(sum(a.vl_repasse),0) 
						into STRICT	vl_repasse_w 
						from	repasse_terceiro_item a 
						where	(nr_seq_terc_regra_esp IS NOT NULL AND nr_seq_terc_regra_esp::text <> '') 
						and	a.nr_repasse_terceiro		= nr_repasse_terceiro_p;			
						 
					else	 
						/*Se não, busca o valor total do repasse até o momento*/
 
						select	obter_valor_repasse(max(a.nr_repasse_terceiro),'R') 
						into STRICT	vl_repasse_w 
						from	repasse_terceiro a 
						where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p;
					end if;	
				end if;
				 
				if (coalesce(tx_item_w,0) <> 0) then 
					vl_item_final_w	:= (vl_repasse_w * tx_item_w) / 100;
				else 
					vl_item_final_w	:= vl_repasse_w;
				end if;	
				 
			elsif (ie_forma_calculo_w = '7') then /*Esta condição de valor busca os valores da seguinte forma 
								1- Soma os valores das regras especiais ifnormadas na regra base valor 
								2- Busca o valor da regra anteiror 
								3- Calcula o percentual da regra anterios sobre as regras base valor*/
 
			 
				vl_repasse_total_base_w := 0;
				vl_repasse_regra_base_w	:= 0;
			 
				open C03;
				loop 
				fetch C03 into	 
					nr_seq_regra_ant_base_w, 
					tx_regra_base_w;
				EXIT WHEN NOT FOUND; /* apply on C03 */
				 
					select	max(a.nr_repasse_terceiro) 
					into STRICT	nr_repasse_terceiro_w 
					from	repasse_terceiro a, 
						terceiro_regra_esp b 
					where	a.nr_seq_terceiro			= b.nr_seq_terceiro 
					and	b.nr_sequencia				= nr_seq_regra_ant_base_w 
					and	PKG_DATE_UTILS.start_of(a.dt_mesano_referencia,'MONTH',0)	= PKG_DATE_UTILS.start_of(dt_referencia_w,'MONTH',0);
					 
					if (coalesce(nr_repasse_terceiro_w::text, '') = '') then 
						nr_repasse_terceiro_w	:= nr_repasse_terceiro_p;				
					end if;
					 
					select	coalesce(sum(a.vl_repasse),0) 
					into STRICT	vl_repasse_regra_base_w 
					from	repasse_terceiro_item a 
					where	nr_seq_terc_regra_esp		= nr_seq_regra_ant_base_w 
					and	a.nr_repasse_terceiro		= nr_repasse_terceiro_w;
				 
					if (tx_regra_base_w IS NOT NULL AND tx_regra_base_w::text <> '') then 
						vl_repasse_regra_base_w	:= (vl_repasse_regra_base_w * tx_regra_base_w) / 100;
					end if;
 
					vl_repasse_total_base_w	:= vl_repasse_total_base_w + vl_repasse_regra_base_w;					
				 
				end loop;
				close C03;
				 
				select	coalesce(sum(a.vl_repasse),0) 
				into STRICT	vl_repasse_w 
				from	repasse_terceiro_item a 
				where	nr_seq_terc_regra_esp		= nr_seq_regra_ant_w 
				and	a.nr_repasse_terceiro		= nr_repasse_terceiro_p;
				 
				vl_item_final_w		:= 0;
				pr_repasse_exedente_w	:= 0;
				vl_sobra_w		:= 0;
 
				if (ie_condicao_valor_w = '1') then 
					if (coalesce(vl_repasse_total_base_w,0) <= coalesce(vl_condicao_w,0)) then /* Se menor ou igual, é o valor da condição */
 
						vl_total_rateio_w	:= coalesce(vl_repasse_total_base_w,0);
					elsif (coalesce(vl_repasse_total_base_w,0) > coalesce(vl_condicao_w,0)) then /* Se maior, o valor do próprio repasse */
 
						vl_total_rateio_w	:= coalesce(vl_condicao_w,0);
					end if;
				elsif (ie_condicao_valor_w = '3') then 
					if (coalesce(vl_repasse_total_base_w,0) > coalesce(vl_condicao_w,0)) then 
						vl_total_rateio_w	:= coalesce(vl_repasse_total_base_w,0) - coalesce(vl_condicao_w,0);
					else 
						vl_total_rateio_w	:= 0;
					end if;					
				end if;	
				 
				if (vl_total_rateio_w <> 0) then	 
					/*única forma de fazer os calculos conforme o modelo 23.*/
 
					if (cd_estabelecimento_p = '1') then 
					 
						pr_repasse_exedente_w	:= trunc(dividir_sem_round(vl_repasse_w,vl_repasse_total_base_w),5); /*percentual do repasse atual sobre o total do repasse das regras base valo*/
							 
					 
						/*Rotina para arredondar, se for por exemplo 0,02185, fica como 0,0218, se for 0,02186, fica 0,0219*/
						vl_sobra_w		:= pr_repasse_exedente_w - trunc(pr_repasse_exedente_w,4);						
						if (vl_sobra_w	<= 0.00005) then 
							pr_repasse_exedente_w	:= trunc(pr_repasse_exedente_w,4);
						else 
							pr_repasse_exedente_w	:= round((pr_repasse_exedente_w)::numeric,4);
						end if;
 
						vl_item_final_w		:= coalesce(vl_total_rateio_w,0) * coalesce(pr_repasse_exedente_w,0); /*O valor a ser repassado é rateado conforme o percentual do repasse atual sobre as regras base valor*/
					else 
						pr_repasse_exedente_w	:= trunc(dividir_sem_round(vl_repasse_w,vl_repasse_total_base_w),5); /*percentual do repasse atual sobre o total do repasse das regras base valo*/
							 
						 
						/*Rotina para arredondar, se for por exemplo 0,02185, fica como 0,0218, se for 0,02186, fica 0,0219*/
						vl_sobra_w		:= pr_repasse_exedente_w - trunc(pr_repasse_exedente_w,4);																		
						 
						if (vl_sobra_w	< 0.00005) then 
							pr_repasse_exedente_w	:= trunc(pr_repasse_exedente_w,4);
						else 
							pr_repasse_exedente_w	:= round((pr_repasse_exedente_w)::numeric,4);
						end if;						
 
						vl_item_final_w		:= coalesce(vl_total_rateio_w,0) * coalesce(pr_repasse_exedente_w,0); /*O valor a ser repassado é rateado conforme o percentual do repasse atual sobre as regras base valor*/
					 
					end if;
				end if;					
				 
			end if;	
			 
			if (ie_condicao_valor_w in ('1')) and (not ie_terceiro_deff_w) then /*Se condição 'Valor do repasse até'*/
 
 
				if (vl_item_final_w <> 0) then /*Se o item ficou com valor para esta condição, desconta o gerado até o momento*/
			 
									/*Utilizado para 'Complemento para o mínimo acordado'*/
 
				 
					vl_ignorar_w	:= 0;
					 
					select	obter_valor_repasse(max(a.nr_repasse_terceiro),'R') 
					into STRICT	vl_ignorar_w 
					from	repasse_terceiro a 
					where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p;
					 
					vl_ignorar_w	:= vl_ignorar_w * -1;
					 
					CALL gerar_repasse_tre(	null, 
								null, 
								vl_ignorar_w, 
								null, 
								null, 
								nr_repasse_terceiro_p, 
								null, 
								nm_usuario_p, 
								null, 
								nr_seq_regra_item_w);
					ie_valor_final_w := 'N';
				end if;			
			end if;
			 
			if (ie_valor_final_w = 'S') and (vl_item_final_w <> 0) then /*Se definido como Valor Final do Repasse, gera um item de repasse negativo, 
								com o valor do repasse gerado antes desta regra, para considerar como valor final do repasse apenas o valor desta regra*/
 
			 
				select	coalesce(sum(vl_repasse),0) 
				into STRICT	vl_repasse_normal_w 
				from (SELECT	a.vl_repasse 
					from	procedimento_repasse a 
					where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
					
union all
 
					SELECT	a.vl_repasse 
					from	material_repasse a 
					where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias4;				
				 
				select	coalesce(sum(a.vl_repasse),0) 
				into STRICT	vl_repasse_item_w 
				from	repasse_terceiro_item a 
				where	((nr_seq_terc_regra_item IS NOT NULL AND nr_seq_terc_regra_item::text <> '') or (nr_seq_terc_regra_esp IS NOT NULL AND nr_seq_terc_regra_esp::text <> '')) 
				and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p;				
				 
				vl_diferenca_w	:= (vl_repasse_normal_w + vl_repasse_item_w) * -1;				
				 
				CALL gerar_repasse_tre(	null, 
							null, 
							vl_diferenca_w, 
							null, 
							null, 
							nr_repasse_terceiro_p, 
							null, 
							nm_usuario_p, 
							null, 
							nr_seq_regra_item_w);
				ie_ajustar_valor_w	:= 'S';							
			else 
				ie_ajustar_valor_w	:= 'N';
			end if;			
			 
			if (ie_forma_calculo_w <> '5') or (coalesce(ie_forma_calculo_w::text, '') = '') then 
				 
				if (ie_condicao_valor_w	= '2') and (ie_tipo_valor_w	= '3') then 
					if (vl_repasse_w	< vl_condicao_w) then 
						vl_item_final_w	:= vl_item_w;
					else 
						vl_item_final_w	:= 0;
					end if;
				end if;
				 
				CALL gerar_repasse_tre(	nr_seq_tipo_valor_w, 
							ie_tipo_valor_w, 
							vl_item_final_w, 
							nr_adiantamento_w, 
							cd_material_w, 
							nr_repasse_terceiro_p, 
							cd_centro_custo_w, 
							nm_usuario_p, 
							nr_seq_regra_w, 
							nr_seq_regra_item_w);
			end if;
 
		end loop;
		close c02;
	end if;
	 
end loop;
close c01;
 
/*INICIO lhalves em 03/08/2011 
Se foi gerada alguma regra para o repasse com tipo de valor diferente de complemento, apenas estas regras devem ser cosnideradas no total do repasse 
O cursor c04, busca as regras de repasse informadas nas regras especiais geradas, e gera um desconto no valor destas regras, para apenas considerar o valor do repasse especial*/
 
if (ie_ajustar_valor_w = 'N') then 
	vl_diferenca_w 	:= 0;
	vl_base_w	:= 0;
 
	open C04;
	loop 
	fetch C04 into	 
		cd_regra_repasse_desc_w;
	EXIT WHEN NOT FOUND; /* apply on C04 */
	 
		if (cd_regra_repasse_desc_w <> 0) then 
			select	coalesce(sum(vl_repasse),0) 
			into STRICT	vl_base_w 
			from (SELECT	a.vl_repasse 
				from	procedimento_repasse a 
				where	a.cd_regra		= cd_regra_repasse_desc_w 
				and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
				
union all
 
				SELECT	a.vl_repasse 
				from	material_repasse a 
				where	a.cd_regra		= cd_regra_repasse_desc_w 
				and	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias3;
		else 
			select	coalesce(sum(vl_repasse),0) 
			into STRICT	vl_base_w 
			from (SELECT	a.vl_repasse 
				from	procedimento_repasse a 
				where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p 
				
union all
 
				SELECT	a.vl_repasse 
				from	material_repasse a 
				where	a.nr_repasse_terceiro	= nr_repasse_terceiro_p) alias2;
		 
		end if;
			 
		vl_diferenca_w	:= coalesce(vl_diferenca_w,0) + coalesce(vl_base_w,0);	
 
	end loop;
	close C04;	
 
	vl_diferenca_w	:= coalesce(vl_diferenca_w,0) * -1;
 
	if (vl_diferenca_w <> 0) then 
 
		CALL gerar_repasse_tre(	null, 
					null, 
					vl_diferenca_w, 
					null, 
					null, 
					nr_repasse_terceiro_p, 
					null, 
					nm_usuario_p, 
					null, 
					nr_seq_regra_item_w);
	end if;
end if;
 
/*Obter quantas regras de complemento para mínimo acordado existme para o terceiro*/
 
select	count(*) 
into STRICT	qt_regra_comple_acordo_w 
from	terceiro_regra_esp a 
where	a.nr_seq_terceiro	= nr_seq_terceiro_w 
and (cd_estabelecimento	= cd_estabelecimento_p or coalesce(cd_estabelecimento::text, '') = '') 
and	dt_referencia_w		between a.dt_inicio_vigencia and fim_dia(dt_fim_vigencia) 
and	ie_situacao		= 'A' 
and	exists (SELECT	1 
	from	terceiro_regra_esp_item b, 
		tipo_valor_repasse_esp c 
	where	b.nr_seq_terc_regra	= a.nr_sequencia 
	and	b.nr_seq_tipo_valor	= c.nr_sequencia 
	and	c.ie_tipo_valor		= '8');
	 
if (qt_regra_comple_acordo_w > 0) then	 
 
	/*Se a quantidade de regras existentes, for menor que a quantidade de itens gerados por estas regras com valor zerado 
	o repasse normal do outro estabelecimento é gerado para descontar (É GERADO COM VALOR POSITIVO, POIS ELE JÁ É DESCONTADO NO INÍCIO)*/
 
	select	coalesce(sum(vl_repasse),0) 
	into STRICT	vl_repasse_ajuste_estab_w 
	from	repasse_terceiro_item a, 
		terceiro_regra_esp b, 
		terceiro_regra_esp_item c, 
		regra_repasse_terceiro d 
	where	a.nr_repasse_terceiro		= nr_repasse_terceiro_p 
	and	a.nr_seq_terc_regra_esp		= b.nr_sequencia 
	and	a.nr_seq_terc_regra_item	= c.nr_sequencia 
	and	b.nr_sequencia			= c.nr_seq_terc_regra 
	and	d.cd_regra			= b.cd_regra_repasse 
	and	d.cd_estabelecimento		<> cd_estabelecimento_p 
	and	((SELECT	count(*) 
		from	repasse_terceiro_item x, 
			terceiro_regra_esp y, 
			terceiro_regra_esp_item z, 
			tipo_valor_repasse_esp w 
		where	x.nr_repasse_terceiro		= a.nr_repasse_terceiro 
		and	x.nr_seq_terc_regra_esp		= y.nr_sequencia 
		and	x.nr_seq_terc_regra_item	= z.nr_sequencia 
		and	y.nr_sequencia			= z.nr_seq_terc_regra 
		and	w.nr_sequencia			= z.nr_seq_tipo_valor 
		and	w.ie_tipo_valor			= '8'		 
		and	x.vl_repasse			= 0) > qt_regra_comple_acordo_w);
end if;
		 
if (vl_repasse_ajuste_estab_w <> 0) then	 
 
	CALL gerar_repasse_tre(	null, 
				null, 
				vl_repasse_ajuste_estab_w, 
				null, 
				null, 
				nr_repasse_terceiro_p, 
				null, 
				nm_usuario_p, 
				null, 
				nr_seq_regra_item_w);
end if;	
 
if (ie_terceiro_deff_w) then 
 
	select	coalesce(sum(a.vl_repasse),0) 
	into STRICT	vl_repasse_real_w 
	from 	repasse_terceiro_item a 
	where 	nr_repasse_terceiro	= nr_repasse_terceiro_p 
	and	(a.nr_seq_terc_regra_esp IS NOT NULL AND a.nr_seq_terc_regra_esp::text <> '') 
	and	not exists (SELECT	1 
			from	terceiro_regra_esp x 
			where	x.nr_seq_regra_ant	= a.nr_seq_terc_regra_esp 
			and	x.ie_condicao_valor	in ('1','3'));
			 
	select	coalesce(obter_valor_repasse(nr_repasse_terceiro_p,'R'),0) vl_titulo 
	into STRICT	vl_repasse_geral_w 
	;	
 
	if	((vl_repasse_real_w - vl_repasse_geral_w) < 0) then 
		vl_repasse_ajuste_w	:= (vl_repasse_real_w - vl_repasse_geral_w);
	else 
		vl_repasse_ajuste_w	:= (vl_repasse_real_w - vl_repasse_geral_w) * -1;
	end if;
	 
	if (vl_repasse_ajuste_w <> 0) then 
	 
		CALL gerar_repasse_tre(	null, 
					null, 
					vl_repasse_ajuste_w, 
					null, 
					null, 
					nr_repasse_terceiro_p, 
					null, 
					nm_usuario_p, 
					null, 
					nr_seq_regra_item_w);
	end if;	
	 
end if;
 
/*Verifica se existe alguma regra para este terceiro para gerar tributos*/
 
select	count(*) 
into STRICT	count_regra_tributo_w 
from	terceiro_regra_esp a 
where	a.nr_seq_terceiro	= nr_seq_terceiro_w 
and (a.cd_estabelecimento	= cd_estabelecimento_p or coalesce(a.cd_estabelecimento::text, '') = '') 
and	dt_referencia_w		between a.dt_inicio_vigencia and fim_dia(dt_fim_vigencia) 
and	ie_situacao		= 'A' 
and	exists (SELECT	1 
		from	terceiro_regra_esp_item x 
		where	x.nr_seq_terc_regra	= a.nr_sequencia 
		and	x.ie_forma_calculo	= '5');	
	 
delete 	from repasse_terc_venc_trib 
where	nr_seq_rep_venc	in (	SELECT	nr_sequencia 
				from	repasse_terceiro_venc 
				where	nr_repasse_terceiro	= nr_repasse_terceiro_p);
 
delete 	from repasse_terceiro_venc 
where	nr_repasse_terceiro	= nr_repasse_terceiro_p;
	 
if (count_regra_tributo_w > 0) then /*Gerar tributos*/
 
	CALL Gerar_Venc_Repasse(nr_repasse_terceiro_p,'S',nm_usuario_p,'N');
else 
	CALL Gerar_Venc_Repasse(nr_repasse_terceiro_p,'N',nm_usuario_p,'N');
end if;
 
commit;
 
end	;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE gerar_terceiro_regra_esp ( NR_REPASSE_TERCEIRO_P bigint, CD_ESTABELECIMENTO_P bigint, IE_TIPO_VALOR_P text, IE_SOMENTE_FORA_P text, NM_USUARIO_P text) FROM PUBLIC;

