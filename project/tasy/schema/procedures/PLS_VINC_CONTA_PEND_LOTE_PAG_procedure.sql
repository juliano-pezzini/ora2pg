-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_vinc_conta_pend_lote_pag ( nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_lote_pag_p pls_lote_pagamento.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

 
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
Finalidade: Vincular conta pendente ao lote de pagamento de produção médica selecionado. 
------------------------------------------------------------------------------------------------------------------- 
Locais de chamada direta: 
[ ] Objetos do dicionário [ X ] Tasy (Delphi/Java) [ ] Portal [ ] Relatórios [ ] Outros: 
 ------------------------------------------------------------------------------------------------------------------ 
Pontos de atenção: 
	Procedure executada no evento vincular_contas_selecionadas_wdlgOkClick 
	da função CorPLS_PP. 
Referências: 
	OPS - Pagamentos de Produção Médica 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 
 
vl_liberado_w			pls_conta_medica_resumo.vl_liberado%type;
nr_seq_prestador_pgto_w		pls_prestador.nr_sequencia%type;
nr_seq_pag_prest_w		pls_pagamento_prestador.nr_sequencia%type;
nr_seq_evento_w			pls_evento.nr_sequencia%type;
nr_seq_pag_prest_novo_w		pls_pagamento_prestador.nr_sequencia%type;
qt_registros_w			integer;
nr_seq_lote_w			pls_lote_pagamento.nr_sequencia%type;
vl_glosa_w			pls_conta_medica_resumo.vl_glosa%type;
nr_seq_evento_item_w		pls_pagamento_item.nr_sequencia%type;
dt_fechamento_w			pls_lote_pagamento.dt_fechamento%type;
tb_nr_seq_pgto_item_w		pls_util_cta_pck.t_number_table;
tb_nr_seq_prest_pgto_w		pls_util_cta_pck.t_number_table;
tb_nr_seq_evento_w		pls_util_cta_pck.t_number_table;
nr_cont_w			integer;

C01 CURSOR(	nr_seq_lote_pag_pc	pls_lote_pagamento.nr_sequencia%type, 
		nr_seq_conta_pc		pls_conta.nr_sequencia%type) FOR 
	SELECT	a.nr_seq_prestador_pgto, 
		a.nr_seq_evento, 
		coalesce(sum(a.vl_liberado),0), 
		coalesce(sum(a.vl_glosa),0) 
	from	pls_conta_medica_resumo a 
	where	a.nr_seq_conta = nr_seq_conta_pc 
	and	a.nr_seq_lote_pgto = nr_seq_lote_pag_pc 
	and	(a.nr_seq_evento IS NOT NULL AND a.nr_seq_evento::text <> '') 
	and	(a.nr_seq_prestador_pgto IS NOT NULL AND a.nr_seq_prestador_pgto::text <> '') 
	and	a.ie_situacao = 'A' 
	group by 
		a.nr_seq_prestador_pgto, 
		a.nr_seq_evento;


BEGIN 
 
if (nr_seq_conta_p IS NOT NULL AND nr_seq_conta_p::text <> '') then 
	-- verifica se o lote de pagamento existe e se o mesmo já está fechado 
	select	max(nr_sequencia), 
		max(dt_fechamento) 
	into STRICT	nr_seq_lote_w, 
		dt_fechamento_w 
	from	pls_lote_pagamento 
	where	nr_sequencia = nr_seq_lote_pag_p;
 
	-- caso não retorne a sequencia no select acima ele não existe 
	if (coalesce(nr_seq_lote_w::text, '') = '') then	 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(208549,'NR_SEQ_LOTE_PAG_P=' || nr_seq_lote_pag_p);
	end if;
	-- se a data de fechamento estiver informada o lote já está fechado 
	if (dt_fechamento_w IS NOT NULL AND dt_fechamento_w::text <> '') then 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(212300,'NR_SEQ_LOTE_PAG_P=' || nr_seq_lote_pag_p);
	end if;	
 
	-- verifica se os itens da conta já não estão vínculados a um pagamento 
	select	count(1) 
	into STRICT	qt_registros_w 
	from	pls_conta_medica_resumo	a 
	where	a.nr_seq_conta = nr_seq_conta_p 
	and	coalesce(a.nr_seq_lote_pgto::text, '') = '' 
	and	(a.nr_seq_evento IS NOT NULL AND a.nr_seq_evento::text <> '') 
	and	(a.nr_seq_prestador_pgto IS NOT NULL AND a.nr_seq_prestador_pgto::text <> '') 
	and	a.ie_situacao = 'A'  LIMIT 1;
 
	-- só processa se existir algum registro 
	if (qt_registros_w > 0) then 
		-- faz o vínculo com o lote 
		update	pls_conta_medica_resumo a 
		set	nr_seq_lote_pgto = nr_seq_lote_pag_p, 
			nm_usuario = nm_usuario_p, 
			dt_atualizacao = clock_timestamp() 
		where	a.nr_seq_conta = nr_seq_conta_p 
		and	coalesce(a.nr_seq_lote_pgto::text, '') = '' 
		and	(a.nr_seq_evento IS NOT NULL AND a.nr_seq_evento::text <> '') 
		and	(a.nr_seq_prestador_pgto IS NOT NULL AND a.nr_seq_prestador_pgto::text <> '') 
		and	a.ie_situacao = 'A';
 
		nr_cont_w := 0;
 
		-- retorna todos os itens 
		open C01(nr_seq_lote_pag_p, nr_seq_conta_p);
		loop 
		fetch C01 into	 
			nr_seq_prestador_pgto_w, 
			nr_seq_evento_w, 
			vl_liberado_w, 
			vl_glosa_w;
		EXIT WHEN NOT FOUND; /* apply on C01 */
			-- verifica se já existe um pagamento para o prestador no lote 
			select	max(a.nr_sequencia) 
			into STRICT	nr_seq_pag_prest_w 
			from	pls_pagamento_prestador a 
			where	a.nr_seq_lote = nr_seq_lote_pag_p 
			and	a.nr_seq_prestador = nr_seq_prestador_pgto_w;
 
			-- se não existir um registro na prestador pagamento ainda, insere e retorna a sequencia 
			if (coalesce(nr_seq_pag_prest_w::text, '') = '') then 
 
				insert into pls_pagamento_prestador( 
					nr_sequencia, nm_usuario_nrec, dt_atualizacao_nrec, 
					nm_usuario, dt_atualizacao, nr_seq_lote, 
					nr_seq_prestador, vl_pagamento 
				) values ( 
					nextval('pls_pagamento_prestador_seq'), nm_usuario_p, clock_timestamp(), 
					nm_usuario_p, clock_timestamp(), nr_seq_lote_pag_p, 
					nr_seq_prestador_pgto_w, vl_liberado_w 
				) returning nr_sequencia into nr_seq_pag_prest_w;
			end if;
 
			if (nr_seq_pag_prest_w IS NOT NULL AND nr_seq_pag_prest_w::text <> '') then 
 
				-- verifica se no pagamento do prestador já existe o evento 
				select 	max(nr_sequencia) 
				into STRICT	nr_seq_evento_item_w 
				from	pls_pagamento_item 
				where	nr_seq_pagamento = nr_seq_pag_prest_w 
				and	nr_seq_evento = nr_seq_evento_w;
 
				-- caso não exista, então insere o mesmo 
				if (coalesce(nr_seq_evento_item_w::text, '') = '') then 
 
					insert into pls_pagamento_item( 
						nr_sequencia, nm_usuario_nrec, dt_atualizacao_nrec, 
						nm_usuario, dt_atualizacao, nr_seq_pagamento, 
						nr_seq_evento, vl_item, vl_glosa 
					) values ( 
						nextval('pls_pagamento_item_seq'), nm_usuario_p, clock_timestamp(), 
						nm_usuario_p, clock_timestamp(), nr_seq_pag_prest_w, 
						nr_seq_evento_w, vl_liberado_w, vl_glosa_w 
					) returning nr_sequencia into nr_seq_evento_item_w;
				-- se existir só faz o update do valor 
				else 
					update	pls_pagamento_item a 
				 	set	a.vl_item = a.vl_item + vl_liberado_w, 
						a.vl_glosa = coalesce(a.vl_glosa,0) + vl_glosa_w 
					where	a.nr_seq_pagamento = nr_seq_pag_prest_w 
					and	a.nr_seq_evento = nr_seq_evento_w;
				end if;
 
				-- salva os registros que foram inserido para fazer update na conta médica resumo 
				if (nr_seq_evento_item_w IS NOT NULL AND nr_seq_evento_item_w::text <> '') then 
				 
					tb_nr_seq_pgto_item_w(nr_cont_w) := nr_seq_evento_item_w;
					tb_nr_seq_prest_pgto_w(nr_cont_w) := nr_seq_prestador_pgto_w;
					tb_nr_seq_evento_w(nr_cont_w) := nr_seq_evento_w;
					nr_cont_w := nr_cont_w +1;
				end if;
 
				CALL pls_atualizar_valor_lote_pag(nr_seq_pag_prest_w, nm_usuario_p);
			end if;
		end loop;
		close C01;
	end if;
 
	-- se tiver algum registro faz o update na pls_conta_medica_resumo 
	if (tb_nr_seq_pgto_item_w.count > 0) then 
	 
		forall i in tb_nr_seq_pgto_item_w.first..tb_nr_seq_pgto_item_w.last 
			update	pls_conta_medica_resumo 
			set	nr_seq_pag_item = tb_nr_seq_pgto_item_w(i) 
			where	nr_seq_lote_pgto = nr_seq_lote_pag_p 
			and	nr_seq_prestador_pgto = tb_nr_seq_prest_pgto_w(i) 
			and	nr_seq_evento = tb_nr_seq_evento_w(i);
	end if;
	 
	commit;
end if;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_vinc_conta_pend_lote_pag ( nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_lote_pag_p pls_lote_pagamento.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

