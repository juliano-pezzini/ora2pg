-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_47 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Aplicar a validação 47 - Validar procedimento x grau de participação para os registros na tabela
	de seleção durante a geração da ocorrência combinada.
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Pontos de atenção:

Alterações:
------------------------------------------------------------------------------------------------------------------
jjung OS 602027 - 10/02/2014 - Criação da procedure.
------------------------------------------------------------------------------------------------------------------
dlehmkuhl OS 688483 - 14/04/2014 -

Alteração:	Modificada a forma de trabalho em relação a atualização dos campos de controle
	que basicamente decidem se a ocorrência será ou não gerada. Foi feita também a
	substituição da rotina obterX_seX_geraX.

Motivo:	Necessário realizar essas alterações para corrigir bugs principalmente no que se
	refere a questão de aplicação de filtros (passo anterior ao da validação). Também
	tivemos um foco especial em performance, visto que a mesma precisou ser melhorada
	para não inviabilizar a nova solicitação que diz que a exceção deve verificar todo
	o atendimento.
------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
-- Dados da tabela de seleção.
dados_tb_sel_w	pls_tipos_ocor_pck.dados_table_selecao_ocor;

-- Procedimentos para gerar ocorrencia na prod local.
cs_procs_ocorrencia CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_ocor_v.nr_id_transacao%type) FOR
	-- Neste primeiro passo seleciona os procedimentos que não tem participante informado e deveriam ter.
	SELECT	sel.nr_sequencia,
		'S' ie_valido,
		'A operadora exige que seja informado um grau de paticipação para este procedimento.' ds_observacao
	from	pls_oc_regra_proc_partic	regra,
		pls_oc_cta_selecao_ocor_v	sel,
		pls_conta_proc_ocor_v		proc
	where	regra.ie_partic_obrigatorio = 'S'
	and	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	proc.nr_sequencia = sel.nr_seq_conta_proc
	and	proc.ie_origem_proced = regra.ie_origem_proced
	and	proc.cd_procedimento = regra.cd_procedimento
	-- Se este procedimento não tiver participantes válidos deve gerar a ocorrência.
	and	not exists (	SELECT	1
				from	pls_proc_participante_ocor_v partic
				where	partic.nr_seq_conta_proc = proc.nr_sequencia
				and	(partic.nr_seq_grau_partic IS NOT NULL AND partic.nr_seq_grau_partic::text <> ''))
	and	coalesce(proc.nr_seq_grau_partic_conta::text, '') = ''
	
union all

	-- Neste passo obtém os procedimentos com grau de participação inválida.
	select	sel.nr_sequencia,
		'S' ie_valido,
		'A apresentação do grau de participação ' || partic.ds_grau_partic ||
		' não é autorizada para este procedimento. ' ds_observacao
	from	pls_oc_cta_selecao_ocor_v	sel,
		pls_proc_participante_ocor_v	partic
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	partic.nr_seq_conta_proc = sel.nr_seq_conta_proc
	and	(partic.nr_seq_grau_partic IS NOT NULL AND partic.nr_seq_grau_partic::text <> '')
	-- Se o participante tiver grau de participação diferente do definido na regra gera ocorrência
	and     exists (select 1
			from 	PLS_OC_REGRA_PROC_PARTIC REGRA
			where 	REGRA.IE_PARTIC_OBRIGATORIO = 'N'
			AND   	PARTIC.IE_ORIGEM_PROCED = REGRA.IE_ORIGEM_PROCED
			AND   	PARTIC.CD_PROCEDIMENTO = REGRA.CD_PROCEDIMENTO
			AND   	PARTIC.NR_SEQ_GRAU_PARTIC NOT IN ( SELECT 	GRAU.NR_SEQ_GRAU_PARTIC
					 FROM   	PLS_PROC_GRAU_PARTIC GRAU
					 WHERE  	GRAU.NR_SEQ_REGRA = REGRA.NR_SEQUENCIA
					 AND    	GRAU.IE_SITUACAO = 'A'
					 AND (coalesce(GRAU.DT_INICIO_VIGENCIA::text, '') = '' OR GRAU.DT_INICIO_VIGENCIA <=  PARTIC.DT_PROCEDIMENTO)
					 AND (coalesce(GRAU.DT_FIM_VIGENCIA::text, '') = '' OR  GRAU.DT_FIM_VIGENCIA >= PARTIC.DT_PROCEDIMENTO)))
	
union all

	select	sel.nr_sequencia,
		'S' ie_valido,
		'A apresentação do grau de participação ' || (	select	x.cd_tiss || ' - ' ||  x.ds_grau_participacao
								from	pls_grau_participacao x
								where	x.nr_sequencia = proc.nr_seq_grau_partic_conta) ||
		' não é autorizada para este procedimento. ' ds_observacao
	from	pls_conta_proc_v proc,
		pls_oc_cta_selecao_ocor_v sel
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	sel.nr_seq_conta_proc = proc.nr_sequencia
	and	(proc.nr_seq_grau_partic_conta IS NOT NULL AND proc.nr_seq_grau_partic_conta::text <> '')
	and	not exists (	select	1
				from	pls_proc_participante x
				where	x.nr_seq_conta_proc = proc.nr_sequencia
				and	x.ie_status <> 'C'
				and	(x.nr_seq_grau_partic IS NOT NULL AND x.nr_seq_grau_partic::text <> ''))
	and	exists (	select	1
				from	pls_oc_regra_proc_partic regra
				where	regra.ie_partic_obrigatorio = 'N'
				and	proc.ie_origem_proced = regra.ie_origem_proced
				and	proc.cd_procedimento = regra.cd_procedimento
				and	proc.nr_seq_grau_partic_conta not in (	select	grau.nr_seq_grau_partic
										from	pls_proc_grau_partic grau
										where	grau.nr_seq_regra = regra.nr_sequencia
										and	grau.ie_situacao = 'A'
										and (coalesce(grau.dt_inicio_vigencia::text, '') = '' or grau.dt_inicio_vigencia <=  proc.dt_procedimento)
										and (coalesce(grau.dt_fim_vigencia::text, '') = '' or  grau.dt_fim_vigencia >= proc.dt_procedimento)));

-- Procedimentos para gerar ocorrência na importação XML
cs_procs_ocorrencia_imp CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_ocor_v.nr_id_transacao%type) FOR
	-- Neste primeiro passo seleciona os procedimentos que não tem participante informado e deveriam ter.
	SELECT	sel.nr_sequencia,
		'S' ie_valido,
		'A operadora exige que seja informado um grau de paticipação para este procedimento.' ds_observacao
	from	pls_oc_regra_proc_partic	regra,
		pls_oc_cta_selecao_ocor_v	sel,
		pls_conta_proc_ocor_v		proc
	where	regra.ie_partic_obrigatorio = 'S'
	and	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	proc.nr_sequencia = sel.nr_seq_conta_proc
	and	proc.ie_origem_proced = regra.ie_origem_proced
	and	proc.cd_procedimento_imp = regra.cd_procedimento
	-- Se este procedimento não tiver participantes válidos deve gerar a ocorrência.
	and	not exists (	SELECT	1
				from	pls_proc_participante_ocor_v partic
				where	partic.nr_seq_conta_proc = proc.nr_sequencia
				and	(partic.cd_grau_partic_imp IS NOT NULL AND partic.cd_grau_partic_imp::text <> ''))
	
union all

	-- Neste passo obtém os procedimentos com grau de participação inválida.
	select	sel.nr_sequencia,
		'S' ie_valido,
		'A apresentação do grau de participação ' || partic.ds_grau_partic_imp ||
		' não é autorizada para este procedimento. ' ds_observacao
	from	pls_oc_cta_selecao_ocor_v	sel,
		pls_proc_participante_ocor_v	partic
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	partic.nr_seq_conta_proc = sel.nr_seq_conta_proc
	and	(partic.cd_grau_partic_imp IS NOT NULL AND partic.cd_grau_partic_imp::text <> '')
	-- Se o participante tiver grau de participação diferente do definido na regra gera ocorrência
	-- Para o xml olha o valor do CD_TISS por que no XML vem este valor informado
	and	exists (select 	1
			from 	pls_oc_regra_proc_partic	regra
			where	regra.ie_partic_obrigatorio = 'N'
			and	partic.ie_origem_proced = regra.ie_origem_proced
			and	partic.cd_procedimento_imp = regra.cd_procedimento
			and	partic.cd_grau_partic_imp not in (	select	coalesce(tipo.cd_tiss,'Nulo')
									from	pls_proc_grau_partic	grau,
										pls_grau_participacao	tipo
									where	grau.nr_seq_regra = regra.nr_sequencia
									and	grau.ie_situacao = 'A'
									and (coalesce(grau.dt_inicio_vigencia::text, '') = '' or grau.dt_inicio_vigencia <= partic.dt_procedimento_imp)
									and (coalesce(grau.dt_fim_vigencia::text, '') = '' or grau.dt_fim_vigencia >= partic.dt_procedimento_imp)
									and	tipo.nr_sequencia = grau.nr_seq_grau_partic));

-- Regras da validação.
cs_regras CURSOR(	nr_seq_combinada_pc	pls_oc_cta_combinada.nr_sequencia%type) FOR
	SELECT	a.ie_valida_proc_vs_grau
	from	pls_oc_cta_val_47 a
	where	a.nr_seq_oc_cta_comb = nr_seq_combinada_pc;

BEGIN

-- Só processa algo com regra válida.
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then

	-- varrer as regras da ocorrência cadastradas
	for	rw_regra_w in cs_regras(dados_regra_p.nr_sequencia) loop

		if (rw_regra_w.ie_valida_proc_vs_grau = 'S') then

			-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
			CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);

			begin
				-- Quando for gerar durante importação do XML deve olhar para os campos IMP;
				-- XML
				if (dados_regra_p.ie_evento = 'IMP') then

					-- Buscar e mandar para o BD.
					open cs_procs_ocorrencia_imp(nr_id_transacao_p);
					loop
						pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_sel_w);
						fetch cs_procs_ocorrencia_imp
						bulk collect into	dados_tb_sel_w.nr_seq_selecao,
									dados_tb_sel_w.ie_valido,
									dados_tb_sel_w.ds_observacao
						limit pls_util_cta_pck.qt_registro_transacao_w;

						exit when dados_tb_sel_w.nr_seq_selecao.count = 0;

						CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(
							dados_tb_sel_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
							'SEQ', dados_tb_sel_w.ds_observacao, dados_tb_sel_w.ie_valido,
							nm_usuario_p);
					end loop;
					close cs_procs_ocorrencia_imp;
				-- Prod local.
				else
					-- Buscar e mandar para o BD.
					open cs_procs_ocorrencia(nr_id_transacao_p);
					loop
						pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_sel_w);
						fetch cs_procs_ocorrencia
						bulk collect into	dados_tb_sel_w.nr_seq_selecao,
									dados_tb_sel_w.ie_valido,
									dados_tb_sel_w.ds_observacao
						limit pls_util_cta_pck.qt_registro_transacao_w;

						exit when dados_tb_sel_w.nr_seq_selecao.count = 0;

						CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(
							dados_tb_sel_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
							'SEQ', dados_tb_sel_w.ds_observacao, dados_tb_sel_w.ie_valido,
							nm_usuario_p);
					end loop;
					close cs_procs_ocorrencia;
				end if;
			exception
			when others then
				-- Fechar os cursores ainda abertos.
				-- Importação
				if (cs_procs_ocorrencia_imp%isopen) then

					close cs_procs_ocorrencia_imp;
				end if;
				-- Produção local.
				if (cs_procs_ocorrencia%isopen) then

					close cs_procs_ocorrencia;
				end if;

				-- Tratar erro gerado, será inserido registro no log e abortado o processo exibindo mensagem de erro.
				CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(dados_regra_p, sqlerrm, nr_id_transacao_p, nm_usuario_p);
			end;

			-- seta os registros que serão válidos ou inválidos após o processamento
			CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
		end if;
	end loop;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_47 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

