-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_5 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Aplicar a validação de exigência de procedimento, conforme estrutura
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
------------------------------------------------------------------------------------------------------------------
Pontos de atenção:
Nesta validação específicamente não é atualizado o ie_valido_temp para N pois a logica da regra
vai em contra-partida das demais.

Alterações:
------------------------------------------------------------------------------------------------------------------
jjung OS 601993 - 11/06/2013 - Criação da rotina.
------------------------------------------------------------------------------------------------------------------
jjung OS 602057 - 18/06/2013

 Alteração:	Retirado o campo dados_filtro_w.ie_excecao e substituído pelo ie_gera_ocorrencia.

 Motivo:	Foi identificado que a lógica do campo ie_excecao era muito confusa e poderia
	trazer problemas.
 ------------------------------------------------------------------------------------------------------------------
 jjung 29/06/2013

Alteração:	Adicionado parametro nos métodos de atualização dos campos IE_VALIDO e IE_VALIDO_TEMP
	da PLS_TIPOS_OCOR_PCK

Motivo:	Se tornou necessário diferenciar os filtros das validações na hora de realizar esta operação
	para que os filtros de exceção funcionem corretamente.
------------------------------------------------------------------------------------------------------------------
dlehmkuhl OS 688483 - 14/04/2014 -

Alteração:	Modificada a forma de trabalho em relação a atualização dos campos de controle
	que basicamente decidem se a ocorrência será ou não gerada. Foi feita também a
	substituição da rotina obter_se_gera.

Motivo:	Necessário realizar essas alterações para corrigir bugs principalmente no que se
	refere a questão de aplicação de filtros (passo anterior ao da validação). Também
	tivemos um foco especial em performance, visto que a mesma precisou ser melhorada
	para não inviabilizar a nova solicitação que diz que a exceção deve verificar todo
	o atendimento.
------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
ds_sql_proc_w		varchar(32000);
ds_restr_w		varchar(32000);

var_cur_w 		integer;
var_exec_w		integer;
var_retorno_w		integer;
qt_cnt_w		integer;

nr_seq_selecao_w	dbms_sql.number_table;
ie_valido_w		dbms_sql.varchar2_table;
ds_observacao_w		dbms_sql.varchar2_table;

dados_filtro_w		pls_tipos_ocor_pck.dados_filtro;
ie_registro_valido_w	varchar(1);

-- Informações da validação de exigência de procedimento
C02 CURSOR(	nr_seq_oc_cta_comb_p	dados_regra_p.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia	nr_seq_validacao,
		a.nr_seq_estrutura,
		a.ie_exige_procedimento
	from	pls_oc_cta_val_exig_proc a
	where	a.nr_seq_oc_cta_comb = nr_seq_oc_cta_comb_p
	and	a.ie_exige_procedimento <> 'N';

BEGIN

if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then

	-- Obter o controle padrão para quantidade de registros que será enviada a cada vez para a tabela de seleção.
	qt_cnt_w := pls_cta_consistir_pck.qt_registro_transacao_w;

	ds_sql_proc_w 	:= ds_sql_proc_w ||	'select	sel.nr_sequencia nr_seq_selecao, ' 	|| pls_tipos_ocor_pck.enter_w ||
						'	:ie_registro_valido,		'	|| pls_tipos_ocor_pck.enter_w ||
						'	null ds_observacao		'	|| pls_tipos_ocor_pck.enter_w ||
						'from	pls_oc_cta_selecao_ocor_v 	sel, ' 	|| pls_tipos_ocor_pck.enter_w ||
						'	pls_conta_ocor_v 		conta ' || pls_tipos_ocor_pck.enter_w ||
						'where	sel.nr_seq_conta = conta.nr_sequencia ' || pls_tipos_ocor_pck.enter_w ||
						'and	sel.nr_id_transacao = :nr_id_transacao ' || pls_tipos_ocor_pck.enter_w ||
						'and	sel.ie_valido = '|| pls_tipos_ocor_pck.aspas_w || 'S' || pls_tipos_ocor_pck.aspas_w || pls_tipos_ocor_pck.enter_w;

	-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
	CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p, 'S');

	-- Buscar os dados da validação cadastrada para a regra.
	for	r_C02_w in C02(dados_regra_p.nr_sequencia) loop

		-- Deve ter esta informação para que possamos buscar os procedimentos que fazem parte da estrutura
		if (r_C02_w.nr_seq_estrutura IS NOT NULL AND r_C02_w.nr_seq_estrutura::text <> '') then

			-- gerencia a atualização da tabela TM
			CALL pls_gerencia_upd_obj_pck.atualizar_objetos('tasy', 'PLS_OC_CTA_TRATAR_VAL_5', 'PLS_ESTRUTURA_OCOR_TM');

			ie_registro_valido_w := 'N';

			-- Verificar a regra de tipos de exigência
			-- Regra Todos: 	Deve gerar a ocorrência se todos os procedimentos da regra não estiverem na conta
			-- Solução:		Buscar todos os procedimentos da estrutura e retirar os procedimentos que estão na conta.
			--		Caso não sobre nenhum então todos estão na conta e não será gerada a ocorrência. Caso sobre então nem todos estão na conta e será gerada a ocorrência.
			if (r_C02_w.ie_exige_procedimento = 'T') then
				if (dados_regra_p.ie_evento = 'IMP') then
					ds_restr_w := ds_restr_w || 	'and	not exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'		select	est.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			est.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_estrutura_ocor_tm est'|| pls_tipos_ocor_pck.enter_w ||
									'		where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
									'		minus '|| pls_tipos_ocor_pck.enter_w ||
									'		select	proc.cd_procedimento_imp, '|| pls_tipos_ocor_pck.enter_w ||
									'			proc.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w;
				else
					ds_restr_w := ds_restr_w || 	'and	not exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'		select	est.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			est.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_estrutura_ocor_tm est'|| pls_tipos_ocor_pck.enter_w ||
									'		where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
									'		minus '|| pls_tipos_ocor_pck.enter_w ||
									'		select	proc.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			proc.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w;
				end if;
			-- Regra Ao menos Um:	Deve gerar a ocorrência caso não exista ao menos um item da conta na estrutura.
			--  Solução:		Buscar um procedimento da conta que exista na estrutura, caso encontre não será gerada a ocorrência, pois pelo menos um item da conta está na estrutura.
			--		Caso não encontre então nenhum item da conta está na estrutura e deve ser gerada a ocorrência.
			elsif (r_C02_w.ie_exige_procedimento = 'U') then
				if (dados_regra_p.ie_evento = 'IMP') then
					ds_restr_w := ds_restr_w ||	'and	exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'		select	1 '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		and	exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'				select	1 '|| pls_tipos_ocor_pck.enter_w ||
									'				from	pls_estrutura_ocor_tm est '|| pls_tipos_ocor_pck.enter_w ||
									'				where	est.nr_seq_estrutura = :nr_seq_estrutura'|| pls_tipos_ocor_pck.enter_w ||
									'				and 	est.ie_origem_proced = proc.ie_origem_proced'|| pls_tipos_ocor_pck.enter_w ||
									'				and	est.cd_procedimento = proc.cd_procedimento_imp '|| pls_tipos_ocor_pck.enter_w ||
									'				) '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w;
				else
					ds_restr_w := ds_restr_w ||	'and	exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'		select	1 '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_segurado = conta.nr_seq_segurado '|| pls_tipos_ocor_pck.enter_w ||
									'		and 	proc.cd_guia_referencia = conta.cd_guia_referencia '|| pls_tipos_ocor_pck.enter_w ||
									'		and	exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'				select	1 '|| pls_tipos_ocor_pck.enter_w ||
									'				from	pls_estrutura_ocor_tm est '|| pls_tipos_ocor_pck.enter_w ||
									'				where	est.nr_seq_estrutura = :nr_seq_estrutura'|| pls_tipos_ocor_pck.enter_w ||
									'				and 	est.ie_origem_proced = proc.ie_origem_proced'|| pls_tipos_ocor_pck.enter_w ||
									'				and	est.cd_procedimento = proc.cd_procedimento'|| pls_tipos_ocor_pck.enter_w ||
									'				) '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w;
				end if;
			-- Regra Somente os itens da regra: 	Deve ser gerada a ocorrência se a conta não tem exatamente os mesmos itens que a regra.
			-- Solução:			Buscar todos os itens da conta e retirar os itens da estrutura. Buscar todos os itens da estrutura e remover os da conta.
			--			Caso sobre algum item em algum dos dois casos quer dizer que os resultados são diferentes e então será gerada a ocorrência.
			elsif (r_C02_w.ie_exige_procedimento = 'S') then
				if (dados_regra_p.ie_evento = 'IMP') then
					ds_restr_w := ds_restr_w ||	'and	 not exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'		(select	est.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			est.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_estrutura_ocor_tm est'|| pls_tipos_ocor_pck.enter_w ||
									'		where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
									'		minus '|| pls_tipos_ocor_pck.enter_w ||
									'		select	proc.cd_procedimento_imp, '|| pls_tipos_ocor_pck.enter_w ||
									'			proc.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w ||
									'		union ' || pls_tipos_ocor_pck.enter_w ||
									'		( '|| pls_tipos_ocor_pck.enter_w ||
									'		select	proc.cd_procedimento_imp, '|| pls_tipos_ocor_pck.enter_w ||
									'			proc.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		minus '|| pls_tipos_ocor_pck.enter_w ||
									'		select	est.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			est.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_estrutura_ocor_tm est'|| pls_tipos_ocor_pck.enter_w ||
									'		where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w ||
									'	) ' || pls_tipos_ocor_pck.enter_w;
				else
					ds_restr_w := ds_restr_w ||	'and	 not exists ( '|| pls_tipos_ocor_pck.enter_w ||
									'		(select	est.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			est.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_estrutura_ocor_tm est'|| pls_tipos_ocor_pck.enter_w ||
									'		where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
									'		minus '|| pls_tipos_ocor_pck.enter_w ||
									'		select	proc.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			proc.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w ||
									'		union ' || pls_tipos_ocor_pck.enter_w ||
									'		( '|| pls_tipos_ocor_pck.enter_w ||
									'		select	proc.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			proc.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_conta_proc_ocor_v proc '|| pls_tipos_ocor_pck.enter_w ||
									'		where	proc.nr_seq_conta = conta.nr_sequencia '|| pls_tipos_ocor_pck.enter_w ||
									'		minus '|| pls_tipos_ocor_pck.enter_w ||
									'		select	est.cd_procedimento, '|| pls_tipos_ocor_pck.enter_w ||
									'			est.ie_origem_proced '|| pls_tipos_ocor_pck.enter_w ||
									'		from	pls_estrutura_ocor_tm est'|| pls_tipos_ocor_pck.enter_w ||
									'		where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
									'		) ' || pls_tipos_ocor_pck.enter_w ||
									'	) ' || pls_tipos_ocor_pck.enter_w;
				end if;
			end if;

			ds_sql_proc_w 	:= ds_sql_proc_w || ds_restr_w;

			-- Abrir um novo cursor
			var_cur_w := dbms_sql.open_cursor;
			begin
				-- Criar cursor com o sql dinâmico
				dbms_sql.parse(var_cur_w, ds_sql_proc_w, 1);

				dbms_sql.bind_variable(var_cur_w, ':nr_id_transacao', nr_id_transacao_p);
				dbms_sql.bind_variable(var_cur_w, ':nr_seq_estrutura', r_C02_w.nr_seq_estrutura);
				dbms_sql.bind_variable(var_cur_w, ':ie_registro_valido', ie_registro_valido_w);

				-- Definir para o DBMS_SQL que o retorno do select será  preenchido em arrays, definindo a quantidade de linhas que o array terá a cada iteração do loop e a posição inicial que estes ocuparão no array.
				dbms_sql.define_array(var_cur_w, 1, nr_seq_selecao_w, qt_cnt_w, 1);
				dbms_sql.define_array(var_cur_w, 2, ie_valido_w, qt_cnt_w, 1);
				dbms_sql.define_array(var_cur_w, 3, ds_observacao_w, qt_cnt_w, 1);

				/* Executar select  dinâmico*/

				var_exec_w := dbms_sql.execute(var_cur_w);
				loop
					-- O fetch rows irá preencher os buffers do Oracle com as linhas que serão passadas para a lista quando o COLUMN_VALUE for chamado.
					var_retorno_w := dbms_sql.fetch_rows(var_cur_w);

					-- Zerar as listas para que o mesmo valor não seja inserido mais de uma vez na tabela.
					nr_seq_selecao_w	:= pls_util_cta_pck.num_table_vazia_w;
					ie_valido_w		:= pls_util_cta_pck.vchr2_table_vazia_w;
					ds_observacao_w		:= pls_util_cta_pck.vchr2_table_vazia_w;

					-- Obter as listas que foram populadas.
					dbms_sql.column_value(var_cur_w, 1, nr_seq_selecao_w);
					dbms_sql.column_value(var_cur_w, 2, ie_valido_w);
					dbms_sql.column_value(var_cur_w, 3, ds_observacao_w);

					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	nr_seq_selecao_w, pls_util_cta_pck.clob_table_vazia_w,
											'SEQ', ds_observacao_w, ie_valido_w, nm_usuario_p);

					-- Quando o número de linhas que foram aplicadas no array for diferente do definido significa que esta foi a última iteração do loop e que todas as linhas foram passadas.
					exit when var_retorno_w != qt_cnt_w;
				end loop;
				dbms_sql.close_cursor(var_cur_w);
			exception
				when others then
				if (dbms_sql.is_open(var_cur_w)) then
					-- Fechar os cursores que continuam abertos, os cursores que utilizam FOR - LOOP não necessitam serem fechados, serão fechados automáticamente.
					dbms_sql.close_cursor(var_cur_w);
				end if;

				-- Tratar erro gerado no sql dinâmico, será inserido registro no log e abortado o processo exibindo mensagem de erro.
				CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(dados_regra_p, ds_sql_proc_w, nr_id_transacao_p, nm_usuario_p);
			end;
		end if;
	end loop; --C02
	-- seta os registros que serão válidos ou inválidos após o processamento
	CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_5 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

