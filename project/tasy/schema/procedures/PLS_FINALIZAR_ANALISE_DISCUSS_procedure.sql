-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_finalizar_analise_discuss (nr_seq_analise_p bigint, nr_seq_grupo_atual_p bigint, cd_estabelecimento_p text, nm_usuario_p text, ie_encerrar_analise_p text default 'N') AS $body$
DECLARE

 
qt_recurso_w			double precision;
vl_recurso_w			double precision;
qt_aceita_w			double precision;
vl_aceito_w			double precision;
qt_negada_w			double precision;
vl_negado_w			double precision;
ie_tipo_item_w			varchar(1);
nr_seq_motivo_aceite_w		bigint;
nr_seq_motivo_neg_w		bigint;
ds_parecer_w			varchar(4000);
nr_seq_analise_parecer_w	bigint;
ie_analise_grupo_w		bigint;
nr_seq_grupo_analise_w		bigint;
nr_seq_grupo_w			bigint;
nm_usuario_exec_w		varchar(255);
ie_existe_usuario_grupo_w	bigint;
ie_existe_grupos_abertos_w	bigint;
nr_seq_regra_w			bigint;
ie_existe_grupo_final_w		varchar(1);
ie_existe_final_anali_w		varchar(1);
qt_grupos_analise_w		bigint;
nr_seq_disc_proc_w		bigint;
nr_seq_disc_mat_w		bigint;
nr_sequencia_w			bigint;
nr_seq_discussao_w		bigint;
ie_status_analise_w		pls_analise_conta.ie_status%type;

c01 CURSOR FOR 
	SELECT	a.nr_sequencia, 
		a.nr_seq_discussao, 
		a.nr_seq_disc_proc, 
		a.nr_seq_disc_mat, 
		coalesce(qt_recurso,0), 
		coalesce(vl_recurso,0), 
		coalesce(qt_aceita,0), 
		coalesce(vl_aceito,0), 
		coalesce(qt_negada,0), 
		coalesce(vl_negado,0), 
		coalesce(ie_tipo_item,'W') 
	from	w_pls_discussao_item a 
	where	a.nr_seq_analise	= nr_seq_analise_p;
	
c02 CURSOR(nr_seq_analise_pc	w_pls_discussao_item.nr_seq_analise%type) FOR 
	SELECT	distinct c.nr_seq_lote_contest 
	from	w_pls_discussao_item		a, 
		pls_contestacao_discussao	b, 
		pls_lote_discussao		c 
	where	b.nr_sequencia		= a.nr_seq_discussao 
	and	c.nr_sequencia		= b.nr_seq_lote 
	and	a.nr_seq_analise	= nr_seq_analise_pc;

BEGIN 
if (nr_seq_analise_p > 0) and (nr_seq_grupo_atual_p > 0) then 
	 
	update	pls_auditoria_conta_grupo 
	set	dt_liberacao 	= clock_timestamp() 
	where	nr_sequencia	= (	SELECT	max(nr_sequencia) 
					from	pls_auditoria_conta_grupo 
					where	nr_seq_grupo 		= nr_seq_grupo_atual_p	 
					and	nr_seq_analise		= nr_seq_analise_p 
					and	coalesce(dt_liberacao::text, '') = ''		 
					and	nr_seq_ordem 		= (	select	min(nr_seq_ordem)		 
										from	pls_auditoria_conta_grupo 
										where	nr_seq_grupo 		= nr_seq_grupo_atual_p	 
										and	nr_seq_analise		= nr_seq_analise_p 
										and	coalesce(dt_liberacao::text, '') = ''	));
 
	CALL pls_gravar_inicio_fim_analise(nr_seq_analise_p, nr_seq_grupo_atual_p, 'F',nm_usuario_p);
	 
	select	count(*) 
	into STRICT	ie_existe_grupos_abertos_w 
	from	pls_auditoria_conta_grupo a		 
	where	a.nr_seq_analise = nr_seq_analise_p 
	and	coalesce(a.dt_liberacao::text, '') = '';
 
	/*Fazer verificação se existe grupos de analise ainda em aberto se não houver fechar a analise*/
 
	if (ie_existe_grupos_abertos_w = 0) then 
		 
		/*Obter o grupo responsavel por fechar a conta*/
 
		SELECT * FROM pls_obter_grupo_fechar_analise(nr_seq_analise_p, cd_estabelecimento_p, nr_seq_regra_w, nr_seq_grupo_w) INTO STRICT nr_seq_regra_w, nr_seq_grupo_w;
		 
		if (coalesce(nr_seq_grupo_w,0) > 0) then 
			ie_existe_grupo_final_w := 'S';
		 
			/*obter se este grupo já foi inserido na análise*/
 
			select	CASE WHEN count(nr_sequencia)=0 THEN 'N'  ELSE 'S' END  
			into STRICT	ie_existe_final_anali_w 
			from	pls_auditoria_conta_grupo 
			where	nr_seq_grupo = nr_seq_grupo_w 
			and	nr_seq_analise = nr_seq_analise_p;
		else		 
			/*Caso não haja regra de grupo de finalização*/
 
			ie_existe_grupo_final_w := 'N';
		end if;	
		 
		/*Se não existe grupo de finalização na análise esta é encerrada*/
 
		if (ie_existe_grupo_final_w = 'N') then		 
			update	pls_analise_conta 
			set	dt_liberacao_analise	= clock_timestamp(), 
				ie_status 		= 'L', 
				dt_final_analise	= clock_timestamp() 
			where	nr_sequencia = nr_seq_analise_p;
		else			 
			/*Se o grupo de finalização existir na análise.*/
 
			if (ie_existe_final_anali_w = 'S') then 
				select	count(nr_sequencia) 
				into STRICT	qt_grupos_analise_w 
				from	pls_auditoria_conta_grupo 
				where	nr_seq_analise = nr_seq_analise_p;
				 
				/*Se existir mais de uma grupo de analise*/
 
				if (qt_grupos_analise_w > 1) and (pls_obter_se_auditor_grupo(nr_seq_grupo_w, nm_usuario_p) = 'N') then 
					/*Se o grupo de finalização existir na análise então seu sua liberação é desfeita. Permitindo que o mesmo se torne o fluxo da vez. */
 
					CALL pls_desf_final_grupo_analise(nr_seq_analise_p, nr_seq_grupo_w, null, nm_usuario_p, cd_estabelecimento_p,'N');
				else 
					/*Se existir somente o grupo do auditor então é liberado a análise.*/
 
					update	pls_analise_conta 
					set	dt_liberacao_analise	= clock_timestamp(), 
						ie_status = 'L', 
						dt_final_analise	= clock_timestamp() 
					where	nr_sequencia = nr_seq_analise_p;
				end if;
			else 
				/*Se o grupo de finalização não existir na análise este é acrescentado*/
 
				CALL pls_inserir_grupo_analise(nr_seq_analise_p, nr_seq_grupo_w, 'Grupo inserido através da regra de finalização '||nr_seq_regra_w, 
							nr_seq_grupo_atual_p, 'N', nm_usuario_p, cd_estabelecimento_p);
			end if;
		end if;
				 
	end if;		
	 
	/* Atualizar a discussão */
 
	open c01;
	loop 
	fetch c01 into 
		nr_sequencia_w, 
		nr_seq_discussao_w, 
		nr_seq_disc_proc_w, 
		nr_seq_disc_mat_w, 
		qt_recurso_w, 
		vl_recurso_w, 
		qt_aceita_w, 
		vl_aceito_w, 
		qt_negada_w, 
		vl_negado_w, 
		ie_tipo_item_w;
	EXIT WHEN NOT FOUND; /* apply on c01 */
		begin 
		/* Atualizar valor da conta em discussão */
 
		CALL pls_atualiza_valores_discussao(nr_seq_discussao_w);
		 
		select	max(nr_sequencia) 
		into STRICT	nr_seq_analise_parecer_w 
		from	pls_analise_parecer_disc 
		where	nr_seq_w_disc_item = nr_sequencia_w;
 
		select	max(nr_seq_motivo_aceite), 
			max(nr_seq_motivo_neg), 
			max(ds_parecer) 
		into STRICT	nr_seq_motivo_aceite_w, 
			nr_seq_motivo_neg_w, 
			ds_parecer_w 
		from	pls_analise_parecer_disc 
		where	nr_seq_w_disc_item 	= nr_sequencia_w 
		and	nr_sequencia		= nr_seq_analise_parecer_w;
 
		if (ie_tipo_item_w in ('P','R')) and (nr_seq_disc_proc_w IS NOT NULL AND nr_seq_disc_proc_w::text <> '') then 
			update	pls_discussao_proc 
			set	ds_parecer			= ds_parecer_w, 
				dt_atualizacao			= clock_timestamp(), 
				nm_usuario			= nm_usuario_p, 
				nr_seq_motivo_glosa_aceita	= nr_seq_motivo_aceite_w, 
				nr_seq_motivo_glosa_neg		= nr_seq_motivo_neg_w, 
				qt_aceita			= qt_aceita_w, 
				qt_negada			= qt_negada_w, 
				qt_recurso			= qt_recurso_w, 
				vl_aceito			= vl_aceito_w, 
				vl_negado			= vl_negado_w, 
				vl_recurso			= vl_recurso_w 
			where	nr_sequencia 			= nr_seq_disc_proc_w;
		elsif (ie_tipo_item_w = 'M') and (nr_seq_disc_mat_w IS NOT NULL AND nr_seq_disc_mat_w::text <> '') then 
			update	pls_discussao_mat 
			set	ds_parecer			= ds_parecer_w, 
				dt_atualizacao			= clock_timestamp(), 
				nm_usuario			= nm_usuario_p, 
				nr_seq_motivo_glosa_aceita	= nr_seq_motivo_aceite_w, 
				nr_seq_motivo_glosa_neg		= nr_seq_motivo_neg_w, 
				qt_aceita			= qt_aceita_w, 
				qt_negada			= qt_negada_w, 
				qt_recurso			= qt_recurso_w, 
				vl_aceito			= vl_aceito_w, 
				vl_negado			= vl_negado_w, 
				vl_recurso			= vl_recurso_w 
			where	nr_sequencia 			= nr_seq_disc_mat_w;
		end if;
		end;
	end loop;
	close c01;
	 
	CALL pls_inserir_hist_analise(null, nr_seq_analise_p, 7, 
				 null, null, null, 
				 null, null, nr_seq_grupo_atual_p, 
				 nm_usuario_p, cd_estabelecimento_p);
end if;
 
CALL pls_atualizar_grupo_penden(nr_seq_analise_p, cd_estabelecimento_p, nm_usuario_p);
 
-- Busca o status atual da análise 
select	max(ie_status) 
into STRICT	ie_status_analise_w 
from	pls_analise_conta 
where	nr_sequencia	= nr_seq_analise_p;
 
-- se a análise já esta encerrada ou finalizada 
if (ie_status_analise_w in ('L', 'T')) then 
 
	-- Localiza os lotes de contestação a serem atualizados 
	for r_c02_w in c02(nr_seq_analise_p) loop 
	 
		CALL pls_atualizar_valores_contest(r_c02_w.nr_seq_lote_contest, 'S');
	end loop; -- fim loop dos lotes de contestação 
	
end if; -- fim se a análise já esta encerrada ou finalizada 
 
-- Se é para finalizar a análise 
if (ie_encerrar_analise_p = 'S') then
 
	if (ie_status_analise_w = 'L') then 
	 
		CALL pls_alterar_status_analise_cta(nr_seq_analise_p, 'T', 'PLS_FINALIZAR_ANALISE_DISCUSS', nm_usuario_p, cd_estabelecimento_p);
	end if;
end if;
 
 
commit;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_finalizar_analise_discuss (nr_seq_analise_p bigint, nr_seq_grupo_atual_p bigint, cd_estabelecimento_p text, nm_usuario_p text, ie_encerrar_analise_p text default 'N') FROM PUBLIC;

