-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE contas_originais AS (nr_seq_conta		bigint,
				cd_guia			varchar(30),
				cd_guia_referencia	varchar(30),
				cd_guia_conta		varchar(30),
				nr_seq_tipo_acomodacao   bigint,
				nr_seq_protocolo	bigint,
				nr_seq_segurado		bigint,
				ie_tipo_guia		varchar(10),
				ie_regime_internacao 	varchar(1),
				ie_carater_internacao	varchar(1),
				nr_seq_tipo_atendimento	bigint,
				nr_seq_saida_spsadt	bigint,
				ie_origem_conta		varchar(3),
				nr_seq_fatura		bigint,
				cd_senha_externa	varchar(30),
				dt_emissao		timestamp,
				ie_tipo_conta		varchar(10),
				ie_tipo_segurado	varchar(10));
CREATE TYPE contas AS (nr_seq_conta		bigint,
			nr_seq_segurado		bigint);
CREATE TYPE analise AS (nr_seq_analise		bigint,
			nr_seq_segurado		bigint);
CREATE TYPE conta_analise AS (	nr_seq_conta		bigint,
				ie_tipo_guia		varchar(10),
				nr_seq_prestador_exec	varchar(10),
				nr_seq_tipo_atendimento	bigint,
				ie_origem_conta		varchar(10),
				ie_conta_intercambio	varchar(10));
CREATE TYPE protocolo AS (nr_seq_protocolo		bigint);


CREATE OR REPLACE PROCEDURE pls_gerar_analise_lote_nova ( nr_seq_lote_p pls_protocolo_conta.nr_seq_lote_conta%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, ie_xml_p text, ie_origem_regra_p text) AS $body$
DECLARE


ie_status_w					ptu_fatura.ie_status%type;
ie_commit_w					varchar(1) := 'N';
nr_seq_conta_w				bigint;
nr_seq_segurado_w			bigint;
nr_seq_protocolo_w			bigint;
ie_tipo_guia_w				varchar(3);
nr_seq_tipo_atendimento_w	bigint;
ie_origem_conta_w			varchar(3);
nr_seq_analise_w			bigint;
nr_seq_prestador_exec_w		bigint;
ie_conta_intercambio_w		varchar(10);
qt_pos_estab_w				bigint;
ie_geracao_pos_estabelecido_w	varchar(255);
nr_seq_log_exec_w			pls_cta_log_exec.nr_sequencia%type;
qt_itens_sem_analise_w		integer;
ie_origem_protocolo_w		pls_protocolo_conta.ie_origem_protocolo%type;
nr_seq_via_acesso_w			pls_regra_via_acesso.nr_sequencia%type;
ie_status_prov_pagto_w		pls_parametro_contabil.ie_status_prov_pagto%type;
cont_w						integer;
nr_lote_contabilizado_w		pls_conta_medica_resumo.nr_lote_contabil_prov%type;
qt_coparticipacao_mens_w	integer;
qt_conta_medica_resumo_w	integer;
qt_lote_fat_w				integer;
nr_lote_contabil_w			pls_protocolo_conta.nr_lote_contabil%type;
nr_lote_contabil_prov_w		pls_protocolo_conta.nr_lote_contabil_prov%type;
nr_lote_contab_pag_w		pls_protocolo_conta.nr_lote_contab_pag%type;
nr_lote_prov_copartic_w		pls_protocolo_conta.nr_lote_prov_copartic%type;
ie_origem_filtro_w			varchar(1);
ie_funcao_pagamento_w		pls_parametro_pagamento.ie_funcao_pagamento%type;
qt_trigger_w				integer;
qt_analise_encerrada_w		integer;

/* Cursor para os protocolos */

C_prot CURSOR FOR
	SELECT	a.nr_sequencia
	from	pls_protocolo_conta	a
	where	a.nr_seq_lote_conta	= nr_seq_lote_p
	and	a.ie_status 		!= '4'
	and	exists (	SELECT	1
				from	pls_conta x
				where	x.nr_seq_protocolo = a.nr_sequencia);

/* Cursor para gerar as novas contas de honorario */

C_contas_orig CURSOR FOR
	SELECT	a.nr_sequencia,
		a.cd_guia,
		a.cd_guia_referencia,
		coalesce(a.cd_guia_referencia, a.cd_guia),
		a.nr_seq_tipo_acomodacao, 
		a.nr_seq_protocolo,  
		a.nr_seq_segurado,   
		coalesce(a.ie_tipo_guia,'X'), 
		a.ie_regime_internacao,   
		a.ie_carater_internacao,  
		a.nr_seq_tipo_atendimento,
		a.nr_seq_saida_spsadt,    
		a.ie_origem_conta,
		a.nr_seq_fatura,
		a.cd_senha_externa,
		/*a.dt_emissao Alterado para dt_atendimento_referencia */

		a.dt_atendimento_referencia
	from	pls_conta 		a,
		pls_protocolo_conta 	b
	where	b.nr_sequencia 		= a.nr_seq_protocolo
	and	b.nr_seq_lote_conta	= nr_seq_lote_p
	and	b.ie_status 		!= '4'
	and	coalesce(a.nr_seq_conta_referencia::text, '') = ''
	and	a.ie_status 		!= 'C'
	order by trunc(coalesce(a.dt_atendimento_referencia,coalesce(a.dt_atendimento,clock_timestamp()))), a.vl_total_imp;
	
/* Cursor para analises geradas */

C_analise CURSOR FOR
	SELECT	nr_seq_analise,
		nr_seq_segurado
	from (SELECT	b.nr_seq_analise,
			b.nr_seq_segurado
		from	pls_conta		b,
			pls_protocolo_conta	a
		where	a.nr_sequencia		= b.nr_seq_protocolo
		and	a.nr_seq_lote_conta 	= nr_seq_lote_p
		and	(b.nr_seq_analise IS NOT NULL AND b.nr_seq_analise::text <> '')
		and	a.ie_status 		!= '4'
		and	b.ie_status 		!= 'C'
		order by
			trunc(coalesce(b.dt_atendimento_referencia,coalesce(b.dt_atendimento,clock_timestamp()))),b.vl_total_imp,
			b.nr_seq_analise) alias5
		group by
			nr_seq_analise,
			nr_seq_segurado;

/* Cursor para todas as contas da analise */

C_conta_analise CURSOR FOR
	SELECT	a.nr_sequencia,
		a.ie_tipo_guia,
		a.nr_seq_prestador_exec,
		a.nr_seq_tipo_atendimento,
		a.ie_origem_conta,
		coalesce(a.ie_tipo_conta,'O')
	from	pls_conta a
	where	a.nr_seq_analise	= nr_seq_analise_w
	order by trunc(coalesce(a.dt_atendimento_referencia,coalesce(a.dt_atendimento,clock_timestamp()))), vl_total_imp;
	
/* Cursor para o log das contas que nao geraram analise*/

C_contas_log CURSOR FOR
	SELECT 	nr_sequencia
	from	pls_conta_v
	where	nr_seq_lote_conta	 = nr_seq_lote_p
	and	ie_status		!= 'C'
	and	ie_tipo_protocolo	<> 'R'
	and	coalesce(nr_seq_analise::text, '') = '';

				
type vetor_conta_orig is table of contas_originais index by integer;


/* -----------------------------------Todas contas ---------------------------------------------------------------------*/

			
type vetor_conta is table of contas index by integer;


/* ------------------------------------------Analises-------------------------------------------------- */

			
type vetor_analise is table of analise index by integer;

vetor_analise_w		vetor_analise;
total_analise		bigint	:= 1;
ind_analise		bigint	:= 1;

/* ---------------------------------------- Contas da analise -------------------------------------------- */

			
type vetor_conta_analise is table of conta_analise index by integer;

vetor_conta_analise_w		vetor_conta_analise;
total_conta_analise		bigint	:= 1;
ind_conta_analise		bigint	:= 1;

/* ---------------------------------------- Protocolos ------------------------------------------------- */

			
type vetor_protocolo is table of protocolo index by integer;

vetor_protocolo_w		vetor_protocolo;
total_protocolo			bigint	:= 1;
ind_protocolo			bigint	:= 1;
qt_regras_prazo			integer;
	
BEGIN
-- incluida a chamada da rotina aqui para que verifique se nenhuma JOB 'morreu'
CALL pls_cria_job_cta_med();

-- gerencia a atualizacao da tabela TM
CALL pls_gerencia_upd_obj_pck.atualizar_objetos(nm_usuario_p, 'PLS_GERAR_ANALISE_LOTE_NOVA', 'PLS_ESTRUTURA_MATERIAL_TM');
CALL pls_gerencia_upd_obj_pck.atualizar_objetos(nm_usuario_p, 'PLS_GERAR_ANALISE_LOTE_NOVA', 'PLS_GRUPO_MATERIAL_TM');

begin
	select	coalesce(a.ie_geracao_pos_estabelecido, 'F')
	into STRICT	ie_geracao_pos_estabelecido_w
	from	pls_parametros	a
	where	a.cd_estabelecimento	= cd_estabelecimento_p;
exception
when no_data_found then
	ie_geracao_pos_estabelecido_w	:= 'F';
end;

select	coalesce(max(ie_funcao_pagamento), '1')
into STRICT	ie_funcao_pagamento_w
from	pls_parametro_pagamento
where	cd_estabelecimento  = cd_estabelecimento_p;

select	coalesce(ie_status_prov_pagto,'NC')
into STRICT	ie_status_prov_pagto_w
from	pls_parametro_contabil
where	cd_estabelecimento	= cd_estabelecimento_p;

--Realiza uma serie de valdidacaes para verificar se ainda e possivel gerar a consistencia da conta
for C_contas_orig_w in C_contas_orig() loop
	if (ie_status_prov_pagto_w = 'F') then	
		select	max(coalesce(nr_lote_contabil_prov,0)) nr_lote_contabil
		into STRICT	nr_lote_contabilizado_w
		from	pls_conta_medica_resumo
		where	nr_seq_conta = C_contas_orig_w.nr_sequencia
		and	coalesce(nr_lote_contabil_prov,0) <> 0;
		
		if (coalesce(nr_lote_contabilizado_w, 0) > 0) then		
			/* A conta ja foi contabilizada no lote #@NR_LOTE_CONTABILIZADO#@. */

			CALL wheb_mensagem_pck.exibir_mensagem_abort(324839, 'NR_LOTE_CONTABILIZADO=' || nr_lote_contabilizado_w);	
		end if;
	end if;
	
	select	  max(g.ie_status)
	into STRICT	  ie_status_w
	from      ptu_fatura g
	where     g.nr_sequencia  = C_contas_orig_w.nr_seq_fatura
	and	  g.ie_status	 in ('CA','E');

	if (ie_status_w = 'CA') then	
		--A fatura da conta #@NR_SEQ_CONTA#@ esta cancelada. Nao e possivel desfazer a finalizacao dos grupos.
		
		CALL wheb_mensagem_pck.exibir_mensagem_abort(236201,'NR_SEQ_CONTA='||C_contas_orig_w.nr_sequencia);	
	elsif (ie_status_w = 'E') then	
		--A fatura da conta #@NR_SEQ_CONTA#@ esta encerrada. Nao e possivel desfazer a finalizacao dos grupos.	
	
		CALL wheb_mensagem_pck.exibir_mensagem_abort(236202, 'NR_SEQ_CONTA='||C_contas_orig_w.nr_sequencia);
	end if;

	select	count(1)
	into STRICT	cont_w
	from	pls_prot_conta_titulo a,
		pls_protocolo_conta b,
		pls_conta c
	where	a.nr_seq_protocolo	= b.nr_sequencia
	and	b.nr_sequencia		= c.nr_seq_protocolo
	and	c.nr_sequencia		= C_contas_orig_w.nr_sequencia;

	select	count(1)
	into STRICT	qt_coparticipacao_mens_w
	from	pls_conta_coparticipacao
	where	nr_seq_conta		= C_contas_orig_w.nr_sequencia
	and	(nr_seq_mensalidade_seg IS NOT NULL AND nr_seq_mensalidade_seg::text <> '');

	/*Caso tiver pagamento de producao para a conta nao pode desfazer o fechamento*/

	select	sum(qt)
	into STRICT	qt_conta_medica_resumo_w
	from (
		SELECT	count(1) qt
		from	pls_conta_medica_resumo
		where	nr_seq_conta = c_contas_orig_w.nr_sequencia
		and	ie_situacao = 'A'
		and	(nr_seq_lote_pgto IS NOT NULL AND nr_seq_lote_pgto::text <> '')
		
union all

		SELECT	count(1) qt
		from	pls_conta_medica_resumo
		where	nr_seq_conta = c_contas_orig_w.nr_sequencia
		and	ie_situacao = 'A'
		and	(nr_seq_pp_lote IS NOT NULL AND nr_seq_pp_lote::text <> '')
	) alias5;

	select	max(nr_lote_contabil),
		max(nr_lote_contabil_prov),
		max(nr_lote_contab_pag),
		max(nr_lote_prov_copartic)
	into STRICT	nr_lote_contabil_w,
		nr_lote_contabil_prov_w,
		nr_lote_contab_pag_w,
		nr_lote_prov_copartic_w
	from	pls_protocolo_conta
	where	nr_sequencia = c_contas_orig_w.nr_seq_protocolo;
		
	select	count(1)	
	into STRICT	qt_lote_fat_w
	from	pls_conta_pos_estabelecido a,
		pls_lote_faturamento b
	where	a.nr_seq_lote_fat = b.nr_sequencia
	and	a.nr_seq_conta	= C_contas_orig_w.nr_sequencia
	and	(a.nr_seq_lote_fat IS NOT NULL AND a.nr_seq_lote_fat::text <> '')
	and	((a.ie_situacao	= 'A') or (coalesce(a.ie_situacao::text, '') = ''))
	and	b.ie_tipo_lote <> 'A';
	
	if (qt_lote_fat_w > 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190837);
	end if;
	
	if (qt_conta_medica_resumo_w > 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190838);
	end if;

	if (qt_coparticipacao_mens_w > 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190839);
	end if;

	if (cont_w > 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190841);
	end if;

	/* Lepinski - OSs 389180 e 381715 - Conforme conversa com Adriano, nao permitir desfazer o fechamento da conta, caso a mesma ja esteja em lote de contabilizacao */

	if (coalesce(nr_lote_contabil_w,0) <> 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190842, 'NR_LOTE_CONTABIL_W=' || nr_lote_contabil_w);
	end if;
	if (coalesce(nr_lote_contab_pag_w,0) <> 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190845, 'NR_LOTE_CONTABIL_W=' || nr_lote_contab_pag_w);
	end if;

	if (coalesce(nr_lote_prov_copartic_w,0) <> 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(190849, 'NR_LOTE_CONTABIL_W=' || nr_lote_prov_copartic_w);
	end if;
end loop;

/* Abrir vetor das contas originais do lote de analise */

update	pls_lote_protocolo_conta
set	dt_ga_gerar_honor_inicio = clock_timestamp()
where	nr_sequencia = nr_seq_lote_p;

commit;

select	max(nr_sequencia)
into STRICT	nr_seq_via_acesso_w
from	pls_regra_via_acesso;

select 	COUNT(1)
into STRICT	qt_trigger_w
from 	user_triggers 
where 	trigger_name = 'PLS_CONTA_ATUAL' 
AND 	STATUS = 'ENABLED';

if (qt_trigger_w = 0) then
	CALL exec_sql_dinamico('tasy','alter trigger pls_conta_atual enable');
end if;
	
--atualizar contas da analise com as campos atualziados via trigger
update	pls_conta conta
set	cd_guia_referencia	= cd_guia_referencia
where	conta.nr_seq_protocolo	in (	SELECT	prot.nr_sequencia
					from	pls_protocolo_conta prot
					where	prot.nr_seq_lote_conta = nr_seq_lote_p);

/*atualiza a view responsavel por ordenar as regras de preco quando existir regra de ordenacao*/

CALL pls_grava_log_execucao_temp('Inicio geracao views regra de preco lote ' || nr_seq_lote_p, 'geracao_analise', nm_usuario_p);
CALL pls_cta_consistir_pck.gera_views_valorizacao();
CALL pls_grava_log_execucao_temp('Fim geracao views regra de preco lote ' || nr_seq_lote_p, 'geracao_analise', nm_usuario_p);
	
CALL pls_grava_log_execucao_temp('Inicio geracao contas de honorario', 'geracao_analise', nm_usuario_p);

-- Gera as contas de honorario individual de acordo com o cadastro de regras em OPS - Cadastro de Regras, OPS - Contas medicas -> Abertura automatica de contas. Desconsidera

--as regra de execucao cirurgica
CALL pls_cta_gera_hono_indiv_pck.gera_conta_hono_indiv(	nr_seq_lote_p, null, null,
							null, null, nm_usuario_p,
							cd_estabelecimento_p);
		
CALL pls_cta_gera_hono_indiv_pck.gera_conta_material(	nr_seq_lote_p, null, null,
							null, null, nm_usuario_p,
							cd_estabelecimento_p);		

--lancamento automatico de honorarios para execucao cirurgica
CALL pls_cta_gera_hono_cirurgia_pck.gera_conta_hono_indiv(  nr_seq_lote_p, null, null, nm_usuario_p,cd_estabelecimento_p);							
							
							
CALL pls_grava_log_execucao_temp('Fim geracao contas de honorario', 'geracao_analise', nm_usuario_p);

CALL pls_grava_log_execucao_temp('Inicio vinculo de contas a analise', 'geracao_analise', nm_usuario_p);

/* Gerar analise */

nr_seq_log_exec_w := pls_cta_processo_pck.executa_processo(	nr_seq_lote_p, null, null, null, null, null, null, null, '31,', null, nm_usuario_p, cd_estabelecimento_p, null, nr_seq_log_exec_w);

CALL pls_grava_log_execucao_temp('Fim vinculo de contas a analise', 'geracao_analise', nm_usuario_p);

update	pls_lote_protocolo_conta
set	dt_ga_gerar_honor_fim = clock_timestamp()
where	nr_sequencia = nr_seq_lote_p;

commit;

/* ----------------------------------- Consistencia Contas ------------------------------------*/

update	pls_lote_protocolo_conta
set	dt_ga_consiste_cta_inicio = clock_timestamp()
where	nr_sequencia = nr_seq_lote_p;

commit;

select 	max(ie_origem_protocolo)
into STRICT	ie_origem_protocolo_w
from	pls_protocolo_conta
where	nr_sequencia	= nr_seq_lote_p;

/* Abrir vetor das analises geradas para o lote */

ind_analise	:= 1;
vetor_analise_w.delete;

-- alimenta o campo nr_seq_conta_princ das contas que estao no lote
CALL pls_insere_conta_princ(nr_seq_lote_p, null, null);

-- cria os registros necessarios na tabela mat/proc regra
CALL pls_filtro_regra_preco_cta_pck.cria_registro_regra(	'P', nr_seq_lote_p, null,
							null, null, null,
							null, null, cd_estabelecimento_p,
							nm_usuario_p);

CALL pls_grava_log_execucao_temp('Inicio alimentacao vetor das analises geradas para o lote', 'geracao_analise', nm_usuario_p);

open c_analise;
loop
fetch c_analise into	
	nr_seq_analise_w,
	nr_seq_segurado_w;
EXIT WHEN NOT FOUND; /* apply on c_analise */
	begin
	vetor_analise_w[ind_analise].nr_seq_analise		:= nr_seq_analise_w;
	vetor_analise_w[ind_analise].nr_seq_segurado		:= nr_seq_segurado_w;
		
	ind_analise	:= ind_analise + 1;
	end;
end loop;
close c_analise;

CALL pls_grava_log_execucao_temp('Fim alimentacao vetor das analises geradas para o lote', 'geracao_analise', nm_usuario_p);

CALL pls_grava_log_execucao_temp('Inicio processamento autogerado lote ' || nr_seq_lote_p, 'geracao_analise', nm_usuario_p);	
CALL pls_gerencia_autogerado_pck.pls_define_se_autogerado(	nr_seq_lote_p, null, null,
							null, nm_usuario_p, cd_estabelecimento_p);
CALL pls_grava_log_execucao_temp('Fim processamento autogerado lote ' || nr_seq_lote_p, 'geracao_analise', nm_usuario_p);	

if (pls_util_cta_pck.pls_usa_rn_qtde_exec_regra = 'S') then

	CALL pls_grava_log_execucao_temp('Inicio quantidade execucao regras nova lote ' || nr_seq_lote_p, 'geracao_analise', nm_usuario_p);	
	nr_seq_log_exec_w := pls_cta_processo_pck.executa_processo(	nr_seq_lote_p, null, null, null, null, null, null, null, '14,', null, nm_usuario_p, cd_estabelecimento_p, null, nr_seq_log_exec_w);
	CALL pls_grava_log_execucao_temp('Fim quantidade execucao regras nova lote ' || nr_seq_lote_p, 'geracao_analise', nm_usuario_p);	
end if;

if (coalesce(nr_seq_via_acesso_w::text, '') = '') then

	CALL pls_grava_log_execucao_temp('Inicio via de acesso', 'valorizacao', nm_usuario_p);

	CALL pls_util_cta_pck.pls_gerencia_via_acesso( 	nr_seq_lote_p, null, null,
							null, null,null,
							null, nm_usuario_p, cd_estabelecimento_p );
	commit;
	
	CALL pls_grava_log_execucao_temp('Fim via de acesso', 'valorizacao', nm_usuario_p);
end if;

--primeira parte da consistrncia da conta mrdica	
total_analise := vetor_analise_w.count;
CALL pls_grava_log_execucao_temp('Inicio leitura das analises geradas para o lote', 'geracao_analise', nm_usuario_p);

for ind_analise in 1.. total_analise loop
	
	nr_seq_analise_w		:= vetor_analise_w[ind_analise].nr_seq_analise;
	nr_seq_segurado_w		:= vetor_analise_w[ind_analise].nr_seq_segurado;
			
	CALL pls_grava_log_execucao_temp('Inicio abertura das contas da analise', 'geracao_analise', nm_usuario_p);

	for  C_conta_analise_w in C_conta_analise loop
		begin
		CALL pls_grava_log_execucao_temp('Inicio pls_consistir_conta conta ' || C_conta_analise_w.nr_sequencia, 'geracao_analise', nm_usuario_p);
		CALL pls_consistir_conta(C_conta_analise_w.nr_sequencia, cd_estabelecimento_p, nm_usuario_p, 'S', 'S', ie_xml_p, ie_origem_regra_p,'N','P');
		CALL pls_grava_log_execucao_temp('Fim pls_consistir_conta conta ' || C_conta_analise_w.nr_sequencia, 'geracao_analise', nm_usuario_p);
		end;
	end loop;

	CALL pls_grava_log_execucao_temp('Fim abertura das contas da analise', 'geracao_analise', nm_usuario_p);
end loop;

CALL pls_grava_log_execucao_temp('Fim leitura das analises geradas para o lote', 'geracao_analise', nm_usuario_p);
--geracao dos valores
if (ie_origem_protocolo_w	= 'A') then
	ie_origem_filtro_w	:= 'I';
else
	ie_origem_filtro_w	:= 'N';
end if;
--Regra de quantidade de execucao por simultaneo e concorrente
CALL pls_qtde_execucao_pck.pls_gerencia_qtde_execucao(null, null, null,
					         null, nr_seq_lote_p,nm_usuario_p, 
						 cd_estabelecimento_p);
--regra de valorizacao diferenciada
CALL pls_cta_gerar_val_dif(	nr_seq_lote_p, null, null,
			null, null, cd_estabelecimento_p,
			nm_usuario_p, null);
			
CALL pls_cp_cta_gerar_combinada(	ie_origem_filtro_w, nr_seq_lote_p, null,
				null, null, null,
				null, null, null,
				cd_estabelecimento_p, nm_usuario_p);

CALL pls_grava_log_execucao_temp('Inicio pls_recalcular_conta lote de analise ' || nr_seq_lote_p,  'geracao_analise', nm_usuario_p);
/* Felipe - OS 293898 - Todas as rotinas de valores serao chamadas na rotina abaixo */

CALL pls_recalcular_conta(null, nm_usuario_p,'C','N','N',null, nr_seq_lote_p);
CALL pls_grava_log_execucao_temp('Fim pls_recalcular_conta lote de analise ' || nr_seq_lote_p,  'geracao_analise', nm_usuario_p);	
	
--segunda parte do processo de consistencia da conta medica
total_analise := vetor_analise_w.count;
CALL pls_grava_log_execucao_temp('Inicio leitura das analises geradas para o lote', 'geracao_analise', nm_usuario_p);
for ind_analise in 1.. total_analise loop
	begin
	
	nr_seq_analise_w		:= vetor_analise_w[ind_analise].nr_seq_analise;
	nr_seq_segurado_w		:= vetor_analise_w[ind_analise].nr_seq_segurado;

	CALL pls_grava_log_execucao_temp('Inicio abertura das contas da analise', 'geracao_analise', nm_usuario_p);
	for  C_conta_analise_w in C_conta_analise() loop
		begin
		CALL pls_grava_log_execucao_temp('Inicio pls_consistir_conta conta ' || C_conta_analise_w.nr_sequencia, 'geracao_analise', nm_usuario_p);
		CALL pls_consistir_conta(C_conta_analise_w.nr_sequencia, cd_estabelecimento_p, nm_usuario_p, 'S', 'S', ie_xml_p, ie_origem_regra_p,'N','Q');
		CALL pls_grava_log_execucao_temp('Fim pls_consistir_conta conta ' || C_conta_analise_w.nr_sequencia, 'geracao_analise', nm_usuario_p);
		end;
	end loop;

	CALL pls_grava_log_execucao_temp('Fim abertura das contas da analise', 'geracao_analise', nm_usuario_p);
		
	end;
end loop;
--Geracao das ocorrencias combinadas
CALL pls_grava_log_execucao_temp('Fim leitura das analises geradas para o lote', 'geracao_analise', nm_usuario_p);
CALL pls_grava_log_execucao_temp('Inicio geracao da ocorrencia combinada das analises geradas para o lote', 'geracao_analise', nm_usuario_p);
--ocorrencia combinadda
CALL pls_oc_cta_gerar_combinada(	'CC', 'A', nr_seq_lote_p, null, null, null, null, null, null, null, null,
				null, null, null, cd_estabelecimento_p, nm_usuario_p);
commit;
CALL pls_grava_log_execucao_temp('Fim geracao da ocorrencia combinada das analises geradas para o lote', 'geracao_analise', nm_usuario_p);
--Ultima parte da consistencia da conta medica 

--liberacao automatica
total_analise := vetor_analise_w.count;
CALL pls_grava_log_execucao_temp('Inicio leitura das analises geradas para o lote part2', 'geracao_analise', nm_usuario_p);
for ind_analise in 1.. total_analise loop
	begin
	
	nr_seq_analise_w		:= vetor_analise_w[ind_analise].nr_seq_analise;
	nr_seq_segurado_w		:= vetor_analise_w[ind_analise].nr_seq_segurado;
			
	/* Abrir vetor das contas daquela analise */

	vetor_conta_analise_w.delete;
	ind_conta_analise	:= 1;
	CALL pls_grava_log_execucao_temp('Inicio abertura das contas da analise part2', 'geracao_analise', nm_usuario_p);
	open C_conta_analise;
	loop
	fetch C_conta_analise into	
		nr_seq_conta_w,
		ie_tipo_guia_w,
		nr_seq_prestador_exec_w,
		nr_seq_tipo_atendimento_w,
		ie_origem_conta_w,
		ie_conta_intercambio_w;
	EXIT WHEN NOT FOUND; /* apply on C_conta_analise */
		begin
		vetor_conta_analise_w[ind_conta_analise].nr_seq_conta		:= nr_seq_conta_w;
		
		vetor_conta_analise_w[ind_conta_analise].ie_tipo_guia		:= ie_tipo_guia_w;
		vetor_conta_analise_w[ind_conta_analise].nr_seq_prestador_exec	:= nr_seq_prestador_exec_w;
		vetor_conta_analise_w[ind_conta_analise].nr_seq_tipo_atendimento := nr_seq_tipo_atendimento_w;
		vetor_conta_analise_w[ind_conta_analise].ie_origem_conta	:= ie_origem_conta_w;
		vetor_conta_analise_w[ind_conta_analise].ie_conta_intercambio	:= ie_conta_intercambio_w;
		
		ind_conta_analise	:= ind_conta_analise + 1;
		end;
	end loop;
	close C_conta_analise;
	CALL pls_grava_log_execucao_temp('Fim abertura das contas da analise part2', 'geracao_analise', nm_usuario_p);
	
	ind_conta_analise	:= 1;
	total_conta_analise := vetor_conta_analise_w.count;
	for ind_conta_analise in 1.. total_conta_analise loop
		begin
		nr_seq_conta_w	:= vetor_conta_analise_w[ind_conta_analise].nr_seq_conta;
		--insert into francisco values ('conta=' || nr_seq_conta_w,ind_analise,ind_conta_analise);

		/* Consistir conta */

		CALL pls_grava_log_execucao_temp('Inicio pls_consistir_conta conta part2 ' || nr_seq_conta_w, 'geracao_analise', nm_usuario_p);
		CALL pls_consistir_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p, 'S', 'S', ie_xml_p, ie_origem_regra_p,'N','U');
		CALL pls_grava_log_execucao_temp('Fim pls_consistir_conta conta part2' || nr_seq_conta_w, 'geracao_analise', nm_usuario_p);
		/*E necessario atualizar o status do protocolo para que o mesmo nao fique invalido*/

		
		CALL pls_grava_log_execucao_temp('Inicio pls_atualiza_status_pag conta part2' || nr_seq_conta_w, 'geracao_analise', nm_usuario_p);
		pls_atualiza_status_pag(nr_seq_conta_w,nm_usuario_p);
		CALL pls_grava_log_execucao_temp('Fim pls_atualiza_status_pag conta part2' || nr_seq_conta_w, 'geracao_analise', nm_usuario_p);
		
		if (ie_geracao_pos_estabelecido_w = 'C') then
			select	count(1)
			into STRICT	qt_pos_estab_w
			from	pls_conta_pos_estabelecido a
			where	a.nr_seq_conta	= nr_seq_conta_w
			and	((ie_situacao	= 'A') or (coalesce(ie_situacao::text, '') = ''))
			and	((a.nr_seq_conta_proc IS NOT NULL AND a.nr_seq_conta_proc::text <> '') or (a.nr_seq_conta_mat IS NOT NULL AND a.nr_seq_conta_mat::text <> ''))  LIMIT 1;
			
			if (qt_pos_estab_w > 0) then /* Tratado para gerar analise de pos somente quando haver itens de pos */
				CALL pls_grava_log_execucao_temp('Inicio geracao analise pos estabelecido conta part2' || nr_seq_conta_w, 'geracao_analise', nm_usuario_p);
				CALL pls_gerar_analise_pos_estab(nr_seq_conta_w, nm_usuario_p, cd_estabelecimento_p,'C');
				CALL pls_grava_log_execucao_temp('Inicio geracao analise pos estabelecido conta part2' || nr_seq_conta_w, 'geracao_analise', nm_usuario_p);
			
			end if;
		end if;
		end;
	end loop;
	end;
end loop;
CALL pls_grava_log_execucao_temp('Fim leitura das analises geradas para o lote part2', 'geracao_analise', nm_usuario_p);

update	pls_lote_protocolo_conta
set	dt_ga_consiste_cta_fim = clock_timestamp()
where	nr_sequencia	= nr_seq_lote_p;

commit;
/* ----------------------------------- Fim  Consistencia Contas ------------------------------------*/



/* ----------------------------------- Fluxo de analise ------------------------------------*/

update	pls_lote_protocolo_conta
set	dt_ga_fluxo_analise_inicio = clock_timestamp()
where	nr_sequencia	= nr_seq_lote_p;

commit;

--Leitura da regra de agrupamento da analise

--Vinculo das contas a regra
CALL pls_agrupamento_analise_pck.verificar_regra_an_agrup(	nr_seq_lote_p, nm_usuario_p, cd_estabelecimento_p);
--Aplica o status correto para a analise gerada e se for necessario troca a informacao de lote
CALL pls_agrupamento_analise_pck.verifica_regra_agrup_analise(nr_seq_lote_p,	nm_usuario_p,cd_estabelecimento_p);
--Vincula as guias de resumo de internacao, e verifica se ja existem guias aguando guia a serem vinculadas
CALL pls_agrupamento_analise_pck.verifica_analise_aguar_guia(nr_seq_lote_p,nm_usuario_p,cd_estabelecimento_p);

/* Gerar fluxo de analise, etc */

CALL pls_grava_log_execucao_temp('Inicio finalizar geracao da analise', 'geracao_analise', nm_usuario_p);
total_analise := vetor_analise_w.count;
for ind_analise in 1.. total_analise loop
	begin
	
	--Em casos onde  sao finalizadas no processo de agrupamento, ocasionavam erro devido a consistencia presente na tratar_analise_consistida e 

	--devido a isso,  essas analises nao serao executadas nesse processo(Por estarem ja finalizadas, nao necessitarao esse processamento).
	
	select 	count(1)
	into STRICT	qt_analise_encerrada_w
	from	pls_analise_conta
	where 	nr_sequencia = vetor_analise_w[ind_analise].nr_seq_analise
	and		ie_status = 'T';
	
	
	if (qt_analise_encerrada_w = 0) then
	
		nr_seq_analise_w		:= vetor_analise_w[ind_analise].nr_seq_analise;
		nr_seq_segurado_w		:= vetor_analise_w[ind_analise].nr_seq_segurado;
				
		CALL pls_tratar_analise_consistida(nr_seq_analise_w,cd_estabelecimento_p,nm_usuario_p);
		
		select	max(nr_sequencia)
		into STRICT	nr_seq_conta_w
		from	pls_conta
		where	nr_seq_analise = nr_seq_analise_w
		and	ie_tipo_guia	!= '6';

		if (nr_seq_conta_w IS NOT NULL AND nr_seq_conta_w::text <> '') then
			CALL pls_atualizar_agrup_analise(nr_seq_conta_w,nm_usuario_p,'C','N');
			CALL pls_analise_atualizar_id_itens(nr_seq_conta_w, nm_usuario_p, cd_estabelecimento_p, 'N');
		end if;
	end if;
		
	end;
end loop;
CALL pls_grava_log_execucao_temp('Fim finalizar geracao da analise', 'geracao_analise', nm_usuario_p);

CALL pls_grava_log_execucao_temp('Inicio processo glosa automatica ocorrencias', 'geracao_analise', nm_usuario_p);
CALL pls_aplica_glosa_aut(	null,nr_seq_lote_p,	nm_usuario_p,
						cd_estabelecimento_p);
CALL pls_grava_log_execucao_temp('Fim processo glosa automatica ocorrencias', 'geracao_analise', nm_usuario_p);

update	pls_lote_protocolo_conta
set	DT_GA_FLUXO_ANALISE_FIM = clock_timestamp()
where	nr_sequencia	= nr_seq_lote_p;

commit;

--Verificacao se ja existem guias regradas e definicao do status da analise e geracao do lote

/* ----------------------------------- Fim fluxo de analise ------------------------------------*/



/* Abrir vetor de todos os protocolos do lote de analise */

ind_protocolo	:= 1;
open C_prot;
loop
fetch C_prot into	
	nr_seq_protocolo_w;
EXIT WHEN NOT FOUND; /* apply on C_prot */
	begin
	vetor_protocolo_w[ind_protocolo].nr_seq_protocolo	:= nr_seq_protocolo_w;
	ind_protocolo	:= ind_protocolo + 1;
	end;
end loop;
close C_prot;

/* ----------------------------------- Inicio prazo analise  ------------------------------------*/



-- verifica se existe alguma regra valida para o prazo de analise
select	count(1)
into STRICT	qt_regras_prazo
from	pls_regra_prazo_an_cta
where	clock_timestamp() between dt_inicio_vigencia and coalesce(dt_fim_vigencia, clock_timestamp());

-- se existem regras validas, realiza o processo de determinar o prazo
if (qt_regras_prazo > 0) then
	
	for i in vetor_analise_w.first..vetor_analise_w.last loop
		
		CALL pls_analise_cta_pck.determinar_prazo_analise(vetor_analise_w[i].nr_seq_analise, 'S');
	end loop;
end if;
/* ----------------------------------- Fim prazo analise ------------------------------------*/



/* ----------------------------------- Inicio atualizacao protocolos ------------------------------------*/

update	pls_lote_protocolo_conta
set	DT_GA_ATUAL_PROT_INICIO = clock_timestamp()
where	nr_sequencia	= nr_seq_lote_p;

commit;

CALL pls_grava_log_execucao_temp('Inacio atualizacao dados do protocolo', 'geracao_analise', nm_usuario_p);
total_protocolo := vetor_protocolo_w.count;
for ind_protocolo in 1.. total_protocolo loop
	begin
	nr_seq_protocolo_w	:= vetor_protocolo_w[ind_protocolo].nr_seq_protocolo;

	/* Gerar valores */

	CALL pls_gerar_valores_protocolo(nr_seq_protocolo_w, nm_usuario_p);
	/* Alterar status */

	CALL pls_altera_status_protocolo(nr_seq_protocolo_w, 'L', 'N', cd_estabelecimento_p, nm_usuario_p);
	end;
end loop;
CALL pls_grava_log_execucao_temp('Fim atualizacao dados do protocolo', 'geracao_analise', nm_usuario_p);

-- verifica se e a nova funcao do pagamento, se for chama a rotina para todas as analises, para salvar o nr_seq_pp_evento
if (ie_funcao_pagamento_w = '2') or (obter_se_base_wheb = 'S') then
	if (vetor_analise_w.count > 0) then
		for i in vetor_analise_w.first..vetor_analise_w.last loop
			CALL pls_pp_cta_evento_combinada(	vetor_analise_w[i].nr_seq_analise, null, ie_funcao_pagamento_w, cd_estabelecimento_p, nm_usuario_p);
		end loop;
	end if;
end if;

-- Alimenta a regra de abertura de pacote no faturamento
CALL pls_tratar_abertura_pct_fat(null, null, null, nr_seq_lote_p, cd_estabelecimento_p, nm_usuario_p);

update	pls_lote_protocolo_conta
set	dt_ga_atual_prot_fim = clock_timestamp()
where	nr_sequencia	= nr_seq_lote_p;

commit;

/* ----------------------------------- Fim atualizacao protocolos ------------------------------------*/



--Verificacao se todas as contas contidas no lote estao vinculadas a uma analise
select 	count(1)
into STRICT 	qt_itens_sem_analise_w
from	pls_conta_v
where	nr_seq_lote_conta	 = nr_seq_lote_p
and	ie_status		!= 'C'
and	ie_tipo_protocolo	<> 'R'
and	coalesce(nr_seq_analise::text, '') = '';

if (qt_itens_sem_analise_w > 0) then

		for  C_contas_log_w in C_contas_log loop
				insert	into	pls_conta_log(ds_alteracao, dt_alteracao, dt_atualizacao,
						dt_atualizacao_nrec, nm_usuario, nm_usuario_alteracao,
						nm_usuario_nrec, nr_seq_conta,  nr_sequencia)
				values (	'Realizado processo de geracao de analise, porem, a conta nao foi vinculada a nenhum nr_seq_analise ', clock_timestamp(), clock_timestamp(),
						clock_timestamp(), nm_usuario_p, nm_usuario_p,
						nm_usuario_p, C_contas_log_w.nr_sequencia, nextval('pls_conta_log_seq'));
						commit;
		end loop;

	CALL wheb_mensagem_pck.exibir_mensagem_abort(289504);
end if;

CALL pls_processar_regra_audit_ptu( nr_seq_lote_p, nm_usuario_p);

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_analise_lote_nova ( nr_seq_lote_p pls_protocolo_conta.nr_seq_lote_conta%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, ie_xml_p text, ie_origem_regra_p text) FROM PUBLIC;

