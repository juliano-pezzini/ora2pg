-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_86 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) is ie_valido_w varchar(1) RETURNS bigint AS $body$
DECLARE


ie_retorno_w	smallint;
BEGIN
	ie_retorno_w := 0;
	if (coalesce(nr_seq_prestador_p::text, '') = '') then
		ie_retorno_w	:= 1;

	--Somente para importação de xml
	elsif (ie_evento_p = 'IMP') then

		select 	count(1)
		into STRICT	qt_prest_w
		from	pls_prestador a
		where	a.nr_sequencia = nr_seq_prestador_p;

		if (qt_prest_w = 0) then
			ie_retorno_w	:= 2;
		end if;
	end if;

return ie_retorno_w;
end;

/*
	Atualmente, a informação de CNES apenas existe para prestador executor da conta. Separei nessa função aqui para centralizar manutenção pois
	em algum momento essa informação pode também existir para outros tipos de prestadores e nesse caso apenas será necessário fazer a chamada para
	ela nos outros tipos de prestadores.
*/
function valida_cnes_prestador(	nr_seq_prestador_p	pls_prestador.nr_sequencia%type,
				cd_cnes_p		pls_conta.cd_cnes%type,
				ie_tipo_validacao_p	pls_oc_cta_val_dado_pres.ie_valida_cnes%type)
				return			number is

ie_retorno_w	number(1);
begin

	ie_retorno_w := 0;
	if (coalesce(cd_cnes_p::text, '') = '') then
		if (ie_tipo_validacao_p <> 'S') then
			ie_retorno_w := 1;
		end if;
	else
		select 	coalesce(substr(pls_obter_cnes_prestador(a.nr_sequencia),1,40),'X')
		into STRICT	cd_cnes_prest_w
		from 	pls_prestador a
		where 	a.nr_sequencia = nr_seq_prestador_p;

		if	(cd_cnes_p <> cd_cnes_prest_w AND cd_cnes_p <> '9999999') then
			ie_retorno_w := 1;
		end if;
	end if;

return ie_retorno_w;

end;

/*Apenas o tamanho dos respectivos campos é validado aqui*/

function valida_cpf_cnpj( 	cd_cpf_p	pls_conta.cd_cpf_executor_imp%type,
				cd_cnpj_p	pls_conta.cd_cgc_executor_imp%type)
				return		number is

ie_retorno_w	number(1);
begin
	ie_retorno_w := 0;
	if (cd_cpf_p IS NOT NULL AND cd_cpf_p::text <> '') then
		if (length(cd_cpf_p) <> 11) then
			ie_retorno_w := 1;
		end if;
	end if;

	if (cd_cnpj_p IS NOT NULL AND cd_cnpj_p::text <> '') then
		if (length(cd_cnpj_p) <> 14) then
			ie_retorno_w := 2;
		end if;
	end if;

return ie_retorno_w;
end;

begin

-- Deve exisitr informação da regra para executar a validação
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '')  then

	select	coalesce(max(ie_prestador_participante), 'S')
	into STRICT	ie_prestador_participante_w
	from	pls_param_importacao_conta
	where	cd_estabelecimento = dados_regra_p.cd_estabelecimento;

	-- Buscar a parametrização da validação conforme cadastrado pelos usuarios.
	for r_C01_w in C01(dados_regra_p.nr_sequencia) loop

		-- seta os registros que serão válidos ou inválidos após o processamento
		CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);

		--Limpa estruturas em memória
		pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);

		--Se prestador executor
		if (r_C01_w.ie_tipo_prestador = '1') then

			for r_C02_w in C02(nr_id_transacao_p) loop

				dados_tb_selecao_w.ds_observacao(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then

					ie_retorno_prest_w := valida_prestador_informado(r_C02_w.nr_seq_prestador_exec, dados_regra_p.ie_evento);

					if (ie_retorno_prest_w = 1) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Prestador não informado.';

					elsif (ie_retorno_prest_w = 2) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Se ie_retorno_w for diferente de 0 então que dizer que já caiu lá em cima, então não precisa mais verificar
				if (r_c01_w.ie_valida_cnes in ('S', 'V')  and ie_retorno_prest_w = 0) then
					if (dados_regra_p.ie_evento = 'IMP') then
						ie_retorno_prest_w := valida_cnes_prestador(r_C02_w.nr_seq_prestador_exec, r_C02_w.cd_cnes_executor_imp, r_c01_w.ie_valida_cnes);
					else
						ie_retorno_prest_w := valida_cnes_prestador(r_C02_w.nr_seq_prestador_exec, r_C02_w.cd_cnes, r_c01_w.ie_valida_cnes);
					end if;

					if (ie_retorno_prest_w = 1) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):=  'CNES do prestador executor não é válido';

					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S' and dados_regra_p.ie_evento = 'IMP') and (ie_retorno_prest_w = 0)then

					if ((r_C02_w.cd_cpf_executor_imp IS NOT NULL AND r_C02_w.cd_cpf_executor_imp::text <> '') or (r_c02_w.cd_cgc_executor_imp IS NOT NULL AND r_c02_w.cd_cgc_executor_imp::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C02_w.cd_cpf_executor_imp, r_c02_w.cd_cgc_executor_imp);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				if (r_c01_w.ie_prestador_informado = 'S') and
					((coalesce(r_c02_w.nr_seq_prestador_exec::text, '') = '') and ((r_c02_w.cd_cpf_executor_imp IS NOT NULL AND r_c02_w.cd_cpf_executor_imp::text <> '') or (r_c02_w.cd_cgc_executor_imp IS NOT NULL AND r_c02_w.cd_cgc_executor_imp::text <> '') or (r_c02_w.nr_seq_prestador_exec_imp IS NOT NULL AND r_c02_w.nr_seq_prestador_exec_imp::text <> '') or (r_c02_w.cd_prestador_exec_imp IS NOT NULL AND r_c02_w.cd_prestador_exec_imp::text <> ''))) then
					dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Dados do prestador executor contidos no arquivo XML, no entanto não localizado na base';
				end if;


				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  dados_tb_selecao_w.ds_observacao, de modo  que uma condição da regra
				--não se sobreponha às outras.
				dados_tb_selecao_w.nr_seq_selecao(nr_idx_w):=	r_C02_w.nr_seq_selecao;

				if ((dados_tb_selecao_w.ds_observacao(nr_idx_w) IS NOT NULL AND (dados_tb_selecao_w.ds_observacao(nr_idx_w))::text <> '')) then
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'S';
				else
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
											'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido, nm_usuario_p);
					nr_idx_w := 0;
					pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;

		--Se prestador atendimento
		elsif (r_C01_w.ie_tipo_prestador = '2') then
			for r_C02_w in C02(nr_id_transacao_p) loop

				dados_tb_selecao_w.ds_observacao(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C02_w.nr_seq_prestador_atend, dados_regra_p.ie_evento);

					if (ie_retorno_prest_w = 1) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S' and dados_regra_p.ie_evento = 'IMP') and (ie_retorno_prest_w = 0)then

					if ((r_C02_w.cd_cpf_prest_atend IS NOT NULL AND r_C02_w.cd_cpf_prest_atend::text <> '') or (r_c02_w.cd_cgc_prest_atend IS NOT NULL AND r_c02_w.cd_cgc_prest_atend::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C02_w.cd_cpf_prest_atend, r_c02_w.cd_cgc_prest_atend);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				if (r_c01_w.ie_prestador_informado = 'S') and
					((coalesce(r_c02_w.nr_seq_prestador_atend::text, '') = '') and ((r_c02_w.cd_cgc_prest_atend IS NOT NULL AND r_c02_w.cd_cgc_prest_atend::text <> '') or (r_c02_w.cd_cpf_prest_atend IS NOT NULL AND r_c02_w.cd_cpf_prest_atend::text <> '') or (r_c02_w.nr_seq_prestador_prot_imp IS NOT NULL AND r_c02_w.nr_seq_prestador_prot_imp::text <> '') or (r_c02_w.cd_prestador_imp IS NOT NULL AND r_c02_w.cd_prestador_imp::text <> ''))) then
					dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Dados do prestador atendimento contidos no arquivo XML, no entanto não localizado na base';
				end if;


				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  dados_tb_selecao_w.ds_observacao, de modo  que uma condição da regra
				--não se sobreponha às outras.
				dados_tb_selecao_w.nr_seq_selecao(nr_idx_w):=	r_C02_w.nr_seq_selecao;
				if ((dados_tb_selecao_w.ds_observacao(nr_idx_w) IS NOT NULL AND (dados_tb_selecao_w.ds_observacao(nr_idx_w))::text <> '')) then
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'S';
				else
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
											'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido, nm_usuario_p);
					nr_idx_w := 0;
					pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;
		--Se prestador solicitante
		elsif (r_C01_w.ie_tipo_prestador = '3') then
			for r_C02_w in C02(nr_id_transacao_p) loop

				dados_tb_selecao_w.ds_observacao(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C02_w.nr_seq_prestador_solic, dados_regra_p.ie_evento);

					if (ie_retorno_prest_w = 1) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S' and dados_regra_p.ie_evento = 'IMP') and (ie_retorno_prest_w = 0)then

					if ((r_C02_w.cd_cpf_prest_solic IS NOT NULL AND r_C02_w.cd_cpf_prest_solic::text <> '') or (r_c02_w.cd_cgc_prest_solic IS NOT NULL AND r_c02_w.cd_cgc_prest_solic::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C02_w.cd_cpf_prest_solic, r_c02_w.cd_cgc_prest_solic);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				if (r_c01_w.ie_prestador_informado = 'S') and
					((coalesce(r_c02_w.nr_seq_prestador_solic::text, '') = '') and ((r_c02_w.cd_cgc_prest_solic IS NOT NULL AND r_c02_w.cd_cgc_prest_solic::text <> '') or (r_c02_w.cd_cpf_prest_solic IS NOT NULL AND r_c02_w.cd_cpf_prest_solic::text <> '') or (r_c02_w.nr_seq_prestador_imp IS NOT NULL AND r_c02_w.nr_seq_prestador_imp::text <> '') or (r_c02_w.cd_prestador_solic_imp IS NOT NULL AND r_c02_w.cd_prestador_solic_imp::text <> ''))) then
					dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Dados do prestador solicitante contidos no arquivo XML, no entanto não localizado na base';
				end if;

				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  dados_tb_selecao_w.ds_observacao, de modo  que uma condição da regra
				--não se sobreponha às outras.
				dados_tb_selecao_w.nr_seq_selecao(nr_idx_w):=	r_C02_w.nr_seq_selecao;
				if ((dados_tb_selecao_w.ds_observacao(nr_idx_w) IS NOT NULL AND (dados_tb_selecao_w.ds_observacao(nr_idx_w))::text <> '')) then
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'S';
				else
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
											'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido, nm_usuario_p);
					nr_idx_w := 0;
					pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;

		--Se prestador participante
		elsif (r_C01_w.ie_tipo_prestador = '4') then

			for r_C03_w in C03(nr_id_transacao_p) loop


				dados_tb_selecao_w.ds_observacao(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C03_w.nr_seq_prestador_exec, dados_regra_p.ie_evento);

					if (ie_retorno_prest_w = 1) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						dados_tb_selecao_w.ds_observacao(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S' and dados_regra_p.ie_evento = 'IMP') and (ie_retorno_prest_w = 0)then

					if ((r_C03_w.cd_cpf_executor IS NOT NULL AND r_C03_w.cd_cpf_executor::text <> '') or (r_C03_w.cd_cgc_executor IS NOT NULL AND r_C03_w.cd_cgc_executor::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C03_w.cd_cpf_executor, r_C03_w.cd_cgc_executor);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						dados_tb_selecao_w.ds_observacao(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				if (r_c01_w.ie_prestador_informado = 'S') and
					((coalesce(r_c03_w.nr_seq_prestador_exec::text, '') = '') and ((r_c03_w.cd_cpf_executor IS NOT NULL AND r_c03_w.cd_cpf_executor::text <> '' AND ie_prestador_participante_w = 'N') or (r_c03_w.cd_prestador_imp IS NOT NULL AND r_c03_w.cd_prestador_imp::text <> ''))) then
					dados_tb_selecao_w.ds_observacao(nr_idx_w):= 'Dados do prestador participante contidos no arquivo XML, no entanto não localizado na base';
				end if;

				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  dados_tb_selecao_w.ds_observacao, de modo  que uma condição da regra
				--não se sobreponha às outras.
				dados_tb_selecao_w.nr_seq_selecao(nr_idx_w):=	r_C03_w.nr_seq_selecao;
				if ((dados_tb_selecao_w.ds_observacao(nr_idx_w) IS NOT NULL AND (dados_tb_selecao_w.ds_observacao(nr_idx_w))::text <> '')) then
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'S';
				else
					dados_tb_selecao_w.ie_valido(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
											'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido, nm_usuario_p);
					nr_idx_w := 0;
					pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;
		end if;
	end loop;

	if (nr_idx_w > 0) then
		CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
								'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido, nm_usuario_p);
	end if;

	-- seta os registros que serão válidos ou inválidos após o processamento
	CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_86 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) is ie_valido_w varchar(1) FROM PUBLIC;

