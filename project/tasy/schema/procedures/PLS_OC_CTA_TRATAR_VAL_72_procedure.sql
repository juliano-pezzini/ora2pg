-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_72 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE



/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Validar ações sobre os itens na análise. Esta validação irá verificar se o item sofreu
alguma ação de inclusão ou substituição na análise de contas médicas.

-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Alterações:
------------------------------------------------------------------------------------------------------------------
Alteração:	jjung 20/082014 OS 766472 - Criação da rotina.
------------------------------------------------------------------------------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
nr_seq_protocolo_w		pls_protocolo_conta.nr_sequencia%type;
qt_conta_protocolo_w		integer;

ds_periodo_w			varchar(50);
vl_total_protocolo_w		bigint;
qt_variacao_min_qtde_w		bigint;
vl_variacao_min_qtde_w		bigint;
qt_variacao_max_qtde_w		bigint;
vl_variacao_max_qtde_w		bigint;
qt_variacao_min_vl_w		bigint;
vl_variacao_min_vl_w		bigint;
qt_variacao_max_vl_w		bigint;
vl_variacao_max_vl_w		bigint;
vl_comparacao_w			bigint;
qt_comparacao_w			bigint;

ie_valido_w			pls_oc_cta_selecao_ocor_v.ie_valido%type;
ds_observacao_w			pls_oc_cta_selecao_ocor_v.ds_observacao%type;

bind_sql_valor_w		sql_pck.t_dado_bind;
cursor_w			sql_pck.t_cursor;
ds_sql_w			varchar(4000);
ds_restricao_w			varchar(2000);
dados_tb_selecao_w		pls_tipos_ocor_pck.dados_table_selecao_ocor;
i				integer;

-- Regras de validação da ocorrência selecionada
c_val CURSOR(	nr_seq_oc_cta_comb_p	dados_regra_p.nr_sequencia%type) FOR
	SELECT	a.ie_data_referencia
		, a.ie_tipo_contador
		, a.qt_variacao_menor
		, a.qt_variacao_maior
		, a.qt_var_conta_menor
		, a.qt_var_conta_maior
	from	pls_oc_cta_val_prod_med a
	where	a.nr_seq_oc_cta_comb	= nr_seq_oc_cta_comb_p;

-- Protocolos na tabela de seleção
cs_prot_selecao CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_ocor_v.nr_id_transacao%type
				, dados_regra_pc	pls_tipos_ocor_pck.dados_regra) FOR
	SELECT	a.nr_sequencia nr_seq_selecao
		, b.nr_seq_protocolo
		, CASE WHEN dados_regra_pc.ie_evento='IMP' THEN  b.dt_protocolo_imp  ELSE b.dt_protocolo END  dt_protocolo
		, b.dt_recebimento_prot
		, b.ie_tipo_guia
		, b.nr_seq_prestador_prot
		, (	SELECT	count(1)
			from	pls_conta_ocor_v	x
			where	x.nr_seq_protocolo = b.nr_seq_protocolo) qt_conta
		, (	select	sum(CASE WHEN dados_regra_pc.ie_evento='IMP' THEN  x.vl_total_imp  ELSE x.vl_total END )
			from	pls_conta_ocor_v	x
			where	x.nr_seq_protocolo = b.nr_seq_protocolo) vl_total
	from	pls_oc_cta_selecao_ocor_v	a
		, pls_conta_ocor_v		b
	where	a.nr_id_transacao	= nr_id_transacao_pc
	and	a.ie_valido		= 'S'
	and	b.nr_sequencia		= a.nr_seq_conta
	and	(b.nr_seq_protocolo IS NOT NULL AND b.nr_seq_protocolo::text <> '')
	order by b.nr_seq_protocolo;
BEGIN

-- Não processa se não tem a regra.
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '')  then

	-- Varrer as regras cadastradas para a ocorrência.
	for r_val_w in c_val(dados_regra_p.nr_sequencia) loop

		-- Verificar se tem algum campo para considerar na regra
		if ((r_val_w.qt_variacao_menor IS NOT NULL AND r_val_w.qt_variacao_menor::text <> '') or (r_val_w.qt_variacao_maior IS NOT NULL AND r_val_w.qt_variacao_maior::text <> '') or
			(r_val_w.qt_var_conta_menor IS NOT NULL AND r_val_w.qt_var_conta_menor::text <> '') or (r_val_w.qt_var_conta_maior IS NOT NULL AND r_val_w.qt_var_conta_maior::text <> '')) then

			ds_sql_w :=	'select	count(1) qt_conta ' || pls_util_pck.enter_w ||
					'	, sum(conta.vl_total) '	|| pls_util_pck.enter_w ||
					'from	pls_conta_ocor_v conta ' || pls_util_pck.enter_w ||
					'where	conta.ie_situacao_protocolo not in (''RE'', ''A'') ' || pls_util_pck.enter_w ||
					'and	conta.ie_tipo_protocolo in (''I'', ''C'') ' || pls_util_pck.enter_w ||
					'and	conta.nr_seq_prestador_prot = :nr_seq_prestador ' || pls_util_pck.enter_w ||
					'and	conta.ie_tipo_guia = :ie_tipo_guia ';

			i := 0;

			CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);

			-- Varrer os protocolos que estão na tabela de seleção, o cursor está ordenado para que cada protocolo seja processado apenas uma vez.
			for rw_prot_sel_w in cs_prot_selecao(nr_id_transacao_p, dados_regra_p) loop

				-- Só processa quando muda de protocolo e na primeira linha
				if (coalesce(nr_seq_protocolo_w::text, '') = '' or nr_seq_protocolo_w <> rw_prot_sel_w.nr_seq_protocolo) then

					ie_valido_w	:= 'N';
					ds_observacao_w	:= null;

					ds_restricao_w	:= '';
					bind_sql_valor_w.delete;

					bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador', rw_prot_sel_w.nr_seq_prestador_prot, bind_sql_valor_w);
					bind_sql_valor_w := sql_pck.bind_variable(':ie_tipo_guia', rw_prot_sel_w.ie_tipo_guia, bind_sql_valor_w);

					case(r_val_w.ie_tipo_contador)

						-- Por envio considera só o último protocolo
						when 'E' then
							begin
							ds_periodo_w := 'envio';
							ds_restricao_w :=	ds_restricao_w || pls_util_pck.enter_w ||
										'and conta.nr_seq_protocolo = (	select	max(prot_ant.nr_sequencia) ' || pls_util_pck.enter_w ||
										'				from	pls_protocolo_conta_v prot_ant ' || pls_util_pck.enter_w ||
										'				where	prot_ant.nr_seq_prestador = :nr_seq_prestador ' || pls_util_pck.enter_w ||
										'				and	prot_ant.ie_tipo_guia = :ie_tipo_guia ' || pls_util_pck.enter_w ||
										'				and	prot_ant.ie_situacao not in (''RE'', ''A'') ' || pls_util_pck.enter_w ||
										'				and	prot_ant.dt_recebimento < :dt_recebimento ) ';

							bind_sql_valor_w := sql_pck.bind_variable(':dt_recebimento', rw_prot_sel_w.dt_recebimento_prot, bind_sql_valor_w);

							end;

						-- Por semena só da última semana
						when 'S' then
							begin
							ds_periodo_w := 'semana';
							-- Data de referência para o cálculo do período.
							-- Recebimento do protocolo.
							if (r_val_w.ie_data_referencia = 'R') then

								ds_restricao_w := 	ds_restricao_w || pls_util_pck.enter_w ||
											'and conta.dt_recebimento_prot between :dt_recebimento - 7 and :dt_recebimento ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_recebimento', rw_prot_sel_w.dt_recebimento_prot, bind_sql_valor_w);
							-- Data do protocolo
							elsif (r_val_w.ie_data_referencia = 'M') then

								ds_restricao_w := 	ds_restricao_w || pls_util_pck.enter_w ||
											'and conta.dt_protocolo between :dt_protocolo - 7 and :dt_protocolo ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_protocolo', rw_prot_sel_w.dt_protocolo, bind_sql_valor_w);
							end if;
							end;

						-- Diariamente pega de um dia atrá somente.
						when 'D' then
							begin
							ds_periodo_w := 'dia';
							-- Data de referência para o cálculo do período.
							-- Recebimento do protocolo.
							if (r_val_w.ie_data_referencia = 'R') then

								ds_restricao_w := 	ds_restricao_w || pls_util_pck.enter_w ||
											'and conta.dt_recebimento_prot between :dt_recebimento - 1 and :dt_recebimento ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_recebimento', rw_prot_sel_w.dt_recebimento_prot, bind_sql_valor_w);
							-- Data do protocolo
							elsif (r_val_w.ie_data_referencia = 'M') then

								ds_restricao_w := 	ds_restricao_w || pls_util_pck.enter_w ||
											'and conta.dt_protocolo between :dt_protocolo - 1 and :dt_protocolo ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_protocolo', rw_prot_sel_w.dt_protocolo, bind_sql_valor_w);
							end if;
							end;
					end case;

					begin
						bind_sql_valor_w := sql_pck.executa_sql_cursor(ds_sql_w || ds_restricao_w, bind_sql_valor_w);
						fetch cursor_w into qt_conta_protocolo_w, vl_total_protocolo_w;
						close cursor_w;
					exception
					when others then
						-- se o cursor estiver fecha
						if (cursor_w%isopen) then

							close cursor_w;
						end if;

						-- Gerencia o erro lançado, limpa a tabela para esta transação.
						CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(dados_regra_p, ds_sql_w || ds_restricao_w, nr_id_transacao_p, nm_usuario_p);
					end;

					-- Calcular a variação de quantidade
					qt_variacao_min_qtde_w	:= (qt_conta_protocolo_w * dividir(r_val_w.qt_var_conta_menor, 100));
					vl_variacao_min_qtde_w	:= qt_conta_protocolo_w + qt_variacao_min_qtde_w;
					qt_variacao_max_qtde_w	:= (qt_conta_protocolo_w * dividir(r_val_w.qt_var_conta_maior, 100));
					vl_variacao_max_qtde_w	:= qt_conta_protocolo_w + qt_variacao_max_qtde_w;
					qt_comparacao_w		:= rw_prot_sel_w.qt_conta;

					-- Calcular a variação de valor
					qt_variacao_min_vl_w	:= (vl_total_protocolo_w * dividir(r_val_w.qt_variacao_menor, 100));
					vl_variacao_min_vl_w	:= vl_total_protocolo_w + qt_variacao_min_vl_w;
					qt_variacao_max_vl_w	:= (vl_total_protocolo_w * dividir(r_val_w.qt_variacao_maior, 100));
					vl_variacao_max_vl_w	:= vl_total_protocolo_w + qt_variacao_max_vl_w;
					vl_comparacao_w		:= rw_prot_sel_w.vl_total;

					-- Verificar se foi definido uma variação mínima de quantidade de conta
					if (r_val_w.qt_var_conta_menor IS NOT NULL AND r_val_w.qt_var_conta_menor::text <> '') then

						if (vl_variacao_min_qtde_w > qt_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'A quantidade de contas apresentadas para este protocolo é inferior ' ||
										'a quantidade permitida pela operadora. Conforme o estabelecido pela ' ||
										'operadora é necessário um crescimento mínimo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_var_conta_menor, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Contas do último período: ' || qt_conta_protocolo_w || pls_util_pck.enter_w ||
										'Contas desta apresentação: ' || rw_prot_sel_w.qt_conta || pls_util_pck.enter_w ||
										'Variação mínima (qtde)): ' || qt_variacao_min_qtde_w;
						end if;
					end if;

					-- Verificar se foi definido uma variação máxima de quantidade de conta
					if (r_val_w.qt_var_conta_maior IS NOT NULL AND r_val_w.qt_var_conta_maior::text <> '') then

						if (vl_variacao_max_qtde_w < qt_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'A quantidade de contas apresentadas para este protocolo é superior ' ||
										'a quantidade permitida pela operadora. Conforme o estabelecido pela ' ||
										'operadora é permitido um crescimento máximo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_var_conta_maior, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Contas do último período: ' || qt_conta_protocolo_w || pls_util_pck.enter_w ||
										'Contas desta apresentação: ' || rw_prot_sel_w.qt_conta || pls_util_pck.enter_w ||
										'Variação máxima (qtde): ' || qt_variacao_max_qtde_w;
						end if;
					end if;

					-- Verificar se foi definido uma variação máxima de quantidade de conta
					if (r_val_w.qt_variacao_menor IS NOT NULL AND r_val_w.qt_variacao_menor::text <> '') then

						if (vl_variacao_min_vl_w > vl_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'O valor apresentado para este protocolo é inferior ' ||
										'ao permitido pela operadora. Conforme o estabelecido pela ' ||
										'operadora é necessário um crescimento mínimo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_variacao_menor, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Valor do último período: ' || campo_mascara_virgula_casas(vl_total_protocolo_w, 2) || pls_util_pck.enter_w ||
										'Valor desta apresentação: ' || campo_mascara_virgula_casas(rw_prot_sel_w.vl_total, 2) || pls_util_pck.enter_w ||
										'Variação mínima (valor): ' || campo_mascara_virgula_casas(qt_variacao_min_vl_w, 2);
						end if;
					end if;

					-- Verificar se foi definido uma variação máxima de quantidade de conta
					if (r_val_w.qt_variacao_maior IS NOT NULL AND r_val_w.qt_variacao_maior::text <> '') then

						if (vl_variacao_min_vl_w < vl_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'O valor apresentado para este protocolo é superior ' ||
										'ao permitido pela operadora. Conforme o estabelecido pela ' ||
										'operadora é permitido um crescimento maximo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_variacao_maior, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Valor do último período: ' || campo_mascara_virgula_casas(vl_total_protocolo_w, 2) || pls_util_pck.enter_w ||
										'Valor desta apresentação: ' || campo_mascara_virgula_casas(rw_prot_sel_w.vl_total, 2) || pls_util_pck.enter_w ||
										'Variação máxima (valor): ' || campo_mascara_virgula_casas(qt_variacao_max_vl_w, 2);
						end if;
					end if;
				end if;

				-- alimenta os dados.
				if (ie_valido_w = 'S') then

					dados_tb_selecao_w.nr_seq_selecao(i)	:= rw_prot_sel_w.nr_seq_selecao;
					dados_tb_selecao_w.ie_valido(i)		:= ie_valido_w;
					dados_tb_selecao_w.ds_observacao(i)	:= ds_observacao_w;

					-- Se tem a quantidade estipulada manda para o banco.
					if (i = pls_cta_consistir_pck.qt_registro_transacao_w) then

						CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w
												, 'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido
												, nm_usuario_p);

						pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);

						i := 0;
					else
						i := i + 1;
					end if;
				end if;

				-- Grava a sequencia do protocolo para calcular só uma vez;
				nr_seq_protocolo_w := rw_prot_sel_w.nr_seq_protocolo;
			end loop; -- Protocolos na seleção
			-- Se sobrou alguénm manda para o banco.;
			if (dados_tb_selecao_w.nr_seq_selecao.count > 0) then

				CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w
										, 'SEQ', dados_tb_selecao_w.ds_observacao, dados_tb_selecao_w.ie_valido
										, nm_usuario_p);
			end if;

			-- Atualiza o campo "quente" para os dados validos.
			CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
		end if;
	end loop; -- Validações
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_72 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

