-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE gerar_ativ_furt_dec ( dt_entrada_p timestamp, dt_saida_p timestamp, nm_usuario_p text, ds_os_p text, qt_os_p bigint) AS $body$
DECLARE


nr_sequencia_w			bigint;
CD_PESSOA_SOLICITANTE_W		varchar(255);
NR_SEQ_GRUPO_DES_W		bigint;
dt_entrada_w			timestamp;
qt_usuario_controle_w		bigint;
nr_seq_usuario_controle_w	bigint;
nr_seq_atividade_w		bigint;
qt_os_dia_w			bigint;
dt_previsto_saida_w		timestamp;
nr_seq_funcao_w			bigint;
QT_MIN_NREG_w			bigint;
qt_tempo_atividade_w		bigint;
qt_vezes_w			bigint;
ie_nreg_w			varchar(1) := 'N';

BEGIN

nr_seq_grupo_des_w := 412;

select	max(cd_pessoa_fisica)
into STRICT	cd_pessoa_solicitante_w
from	usuario
where	nm_usuario = nm_usuario_p;

dt_entrada_w := dt_entrada_p;

<<dias>>
while 	dt_entrada_w <= dt_saida_p loop

	begin

	CALL philips_param_pck.set_nr_seq_idioma(1);

	if (OBTER_SE_DIA_UTIL(dt_entrada_w, 1) = 'S') then

	-- se nao houver usuario_controle, cria
	select	max(nr_sequencia)
	into STRICT	nr_seq_usuario_controle_w
	from	USUARIO_CONTROLE
	where	nm_usuario = nm_usuario_p
	and	trunc(dt_entrada) = trunc(dt_entrada_w);

	if (coalesce(nr_seq_usuario_controle_w::text, '') = '') then

		select	nextval('usuario_controle_seq')
		into STRICT	nr_seq_usuario_controle_w
		;

		insert into USUARIO_CONTROLE(
			NR_SEQUENCIA,
			DT_ATUALIZACAO,
			NM_USUARIO,
			DT_ENTRADA,
			DT_SAIDA,
			QT_MIN_INTERVALO,
			QT_MIN_OS,
			QT_MIN_ATIVIDADE,
			QT_MIN_TOTAL,
			QT_MIN_NREG,
			DT_REFERENCIA,
			QT_MIN_LANCHE,
			QT_MIN_NORMAL,
			QT_MIN_EXTRA)
		values (nr_seq_usuario_controle_w,
			dt_entrada_w,
			nm_usuario_p,
			trunc(dt_entrada_w) + ((1/24) * 8),
			null,
			75,
			0,
			0,
			0,
			0,
			trunc(dt_entrada_w),
			30,
			0,
			0);

		dt_previsto_saida_w := obter_data_prevista_saida(nr_seq_usuario_controle_w);

		update	USUARIO_CONTROLE
		set	dt_saida = dt_previsto_saida_w
		where	nr_sequencia = nr_seq_usuario_controle_w;

		CALL ATUALIZAR_ATIV_USUARIO(nr_seq_usuario_controle_w);

	elsif (nr_seq_usuario_controle_w > 0) then

		dt_previsto_saida_w := obter_data_prevista_saida(nr_seq_usuario_controle_w);

		update	USUARIO_CONTROLE
		set	dt_saida = coalesce(dt_saida, dt_previsto_saida_w)
		where	nr_sequencia = nr_seq_usuario_controle_w;

		CALL ATUALIZAR_ATIV_USUARIO(nr_seq_usuario_controle_w);

	end if;

	-- se nao houverem 4 OS no dia...
	select	count(*)
	into STRICT	qt_os_dia_w
	from	man_ordem_servico_v2 v,
		man_ordem_serv_ativ a
	where	v.nr_sequencia    = a.nr_seq_ordem_serv
	and	trunc(a.dt_atividade) = trunc(dt_entrada_w)
	and	a.nm_usuario_exec     = nm_usuario_p;

	CALL ATUALIZAR_ATIV_USUARIO(nr_seq_usuario_controle_w);

	select	max(QT_MIN_NREG)
	into STRICT	QT_MIN_NREG_w
	from	usuario_controle
	where	nm_usuario = nm_usuario_p
	and	trunc(dt_entrada) = trunc(dt_entrada_w);

	if (qt_os_dia_w < qt_os_p) or (QT_MIN_NREG_w > 10) then

		--Raise_application_error(-20011,QT_MIN_NREG_w || ' / ' || qt_os_dia_w || ' / ' || trunc(QT_MIN_NREG_w / (4 - qt_os_dia_w)));
		qt_tempo_atividade_w := ceil(QT_MIN_NREG_w / greatest((qt_os_p - qt_os_dia_w), 1));
		qt_tempo_atividade_w := greatest(qt_tempo_atividade_w, 10);

		qt_os_dia_w := greatest(qt_os_dia_w, 1);


		if (qt_os_dia_w >= qt_os_p) and (QT_MIN_NREG_w > 10) then

			CALL criar_OS_atividade_dec(	cd_pessoa_solicitante_w,
						dt_entrada_w,
						ds_os_p,
						nm_usuario_p,
						nr_seq_grupo_des_w,
						qt_tempo_atividade_w,
                        1,
						nr_seq_usuario_controle_w,
						nm_usuario_p);

		else
			<<atividades>>

			for i in qt_os_dia_w..qt_os_p loop
				begin
				-- criar OS
				CALL criar_OS_atividade_dec(	cd_pessoa_solicitante_w,
							ds_os_p,
							dt_entrada_w,
							nm_usuario_p,
							nr_seq_grupo_des_w,
							qt_tempo_atividade_w,
                            i,
							nr_seq_usuario_controle_w,
							nm_usuario_p);

				end;
			end loop atividades;

		end if;

	end if;

	end if;

	dt_entrada_w := dt_entrada_w + 1;
	end;
end loop dias;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE gerar_ativ_furt_dec ( dt_entrada_p timestamp, dt_saida_p timestamp, nm_usuario_p text, ds_os_p text, qt_os_p bigint) FROM PUBLIC;

