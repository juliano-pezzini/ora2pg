-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_atualizar_agrup_analise ( nr_seq_conta_p pls_conta.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, ie_acao_p text, ie_commit_p text) AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Atualizar o campo NR_SEQ_AGRUP_ANALISE para procedimentos iguais
para tratar visualização na análise
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ X ]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Pontos de atenção:

ie_acao_p	- C - Consistência da conta
		- CI - Consistência do item
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
tb_seq_w			pls_util_cta_pck.t_number_table;
tb_seq_agrup_analise_w		pls_util_cta_pck.t_number_table;
cursor_w			sql_pck.t_cursor;
nr_indice_w			integer;
nr_seq_agrup_analise_w		pls_conta_proc.nr_seq_agrup_analise%type;
nr_seq_proc_w			pls_conta_proc.nr_sequencia%type;
ie_tipo_guia_w			varchar(2);
cd_estabelecimento_w		smallint;
ie_analise_cm_nova_w		varchar(3);
cd_guia_ok_w			pls_conta.cd_guia_ok%type;
nr_seq_segurado_w		pls_conta.nr_seq_segurado%type;
nr_seq_analise_w		pls_analise_conta.nr_sequencia%type;
ds_restricao_w			varchar(4000);
ds_sql_w			varchar(4000);
ds_sql_orig_w			varchar(4000);

-- todos os procedimentos da análise
c_proc_anal CURSOR(	nr_seq_analise_pc	pls_analise_conta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_conta_proc
	from	pls_conta_proc_v a
	where	a.nr_seq_analise = nr_seq_analise_pc;

-- obter primeiro os procedimentos a agrupar
C01 CURSOR(	cd_guia_ok_pc		pls_conta.cd_guia_ok%type,
		nr_seq_segurado_pc	pls_conta.nr_seq_segurado%type,
		nr_seq_analise_pc	pls_analise_conta.nr_sequencia%type) FOR
	SELECT	min(a.nr_sequencia) nr_sequencia,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.dt_procedimento_real_trunc dt_procedimento_real_trunc,
		a.hr_inicio_proc,
		a.ie_tipo_despesa
	from	pls_conta_proc_v 	a
	where	a.cd_guia_referencia	= cd_guia_ok_pc
	and	a.nr_seq_segurado	= nr_seq_segurado_pc
	and	a.nr_seq_analise	= nr_seq_analise_pc
	and	a.ie_tipo_despesa	in (1,4)
	and	a.ie_status_conta	<> 'C'
	group by
		a.cd_procedimento,
		a.ie_origem_proced,
		a.dt_procedimento_real_trunc,
		a.hr_inicio_proc,
		a.ie_tipo_despesa
	having	count(1) > 1;

procedure atualiza_proc(	tb_seq_upd_p		pls_util_cta_pck.t_number_table,
				tb_seq_agrup_analise_p	pls_util_cta_pck.t_number_table) is;
BEGIN

if (tb_seq_upd_p.count > 0) then

	forall i in tb_seq_upd_p.first .. tb_seq_upd_p.last
		update	pls_conta_proc set
			nr_seq_agrup_analise	= tb_seq_agrup_analise_p(i)
		where	nr_sequencia		= tb_seq_upd_p(i);
	commit;
end if;

end;

begin

select	max(a.cd_guia_ok),
	max(a.ie_tipo_guia),
	max(a.cd_estabelecimento),
	max(a.nr_seq_segurado),
	max(a.nr_seq_analise)
into STRICT	cd_guia_ok_w,
	ie_tipo_guia_w,
	cd_estabelecimento_w,
	nr_seq_segurado_w,
	nr_seq_analise_w
from	pls_conta a
where	a.nr_sequencia	= nr_seq_conta_p;

-- busca parâmetro para decidir qual caminho irá buscar (atual ou o que está em testes)
select	ie_analise_cm_nova
into STRICT	ie_analise_cm_nova_w
from	table(pls_parametros_pck.f_retorna_param(cd_estabelecimento_w));

-- Já vai atualizar os itens das contas de honorário quando fizer das principais
if (ie_analise_cm_nova_w = 'S') and
	((ie_tipo_guia_w != '6') or (ie_acao_p = 'CI'))then

	CALL wheb_usuario_pck.set_ie_executar_trigger('N');

	-- Limpa o campo nr_seq_agrup_analise de todos os procedimento da análise
	open c_proc_anal(nr_seq_analise_w);
	loop
		tb_seq_w.delete;

		fetch c_proc_anal bulk collect into tb_seq_w
		limit pls_util_pck.qt_registro_transacao_w;

		exit when tb_seq_w.count = 0;

		forall i in tb_seq_w.first .. tb_seq_w.last
			update	pls_conta_proc
			set	nr_seq_agrup_analise  = NULL
			where 	nr_sequencia = tb_seq_w(i);
		commit;
	end loop;
	close c_proc_anal;

	ds_sql_orig_w	:= 	'select proc.nr_sequencia,' || pls_util_pck.enter_w ||
				'	:nr_seq_agrup_analise_pc' || pls_util_pck.enter_w ||
				'from	pls_conta_proc_v proc' || pls_util_pck.enter_w ||
				'where	proc.nr_seq_analise 		= :nr_seq_analise_pc' || pls_util_pck.enter_w ||
				'and	proc.ie_status_conta		<> ''C'' '||pls_util_pck.enter_w||
				'and	proc.nr_seq_segurado		= :nr_seq_segurado_pc'||pls_util_pck.enter_w||
				'and	proc.cd_guia_referencia 	= :cd_guia_referencia_pc'||pls_util_pck.enter_w||
				'and	proc.ie_origem_proced		= :ie_origem_proced_pc'||pls_util_pck.enter_w||
				'and	proc.cd_procedimento		= :cd_procedimento_pc'||pls_util_pck.enter_w||
				'and	proc.ie_tipo_despesa		= :ie_tipo_despesa_pc'||pls_util_pck.enter_w||
				'and	proc.dt_procedimento_real_trunc	= :dt_procedimento_pc'||pls_util_pck.enter_w;

	nr_indice_w := 0;
	tb_seq_w.delete;
	tb_seq_agrup_analise_w.delete;

	for r_c01_w in C01(cd_guia_ok_w, nr_seq_segurado_w, nr_seq_analise_w) loop

		ds_restricao_w := null;

		-- decide se filtra ou não pelo horário do procedimento
		if (coalesce(r_c01_w.hr_inicio_proc::text, '') = '') then
			ds_restricao_w := ds_restricao_w || ' and proc.hr_inicio_proc	is null'||pls_util_pck.enter_w;
		else
			ds_restricao_w := ds_restricao_w || ' and proc.hr_inicio_proc	= :hr_inicio_proc_pc'||pls_util_pck.enter_w;
		end if;

		ds_sql_w := ds_sql_orig_w || pls_util_pck.enter_w || ds_restricao_w;

		-- abertura do cursor
		if (coalesce(r_c01_w.hr_inicio_proc::text, '') = '') then
			open cursor_w for EXECUTE ds_sql_w using 	r_c01_w.nr_sequencia, nr_seq_analise_w,
								nr_seq_segurado_w, cd_guia_ok_w,
								r_c01_w.ie_origem_proced, r_c01_w.cd_procedimento,
								r_c01_w.ie_tipo_despesa, r_c01_w.dt_procedimento_real_trunc;
		else
			open cursor_w for EXECUTE ds_sql_w using 	r_c01_w.nr_sequencia, nr_seq_analise_w,
								nr_seq_segurado_w, cd_guia_ok_w,
								r_c01_w.ie_origem_proced, r_c01_w.cd_procedimento,
								r_c01_w.ie_tipo_despesa, r_c01_w.dt_procedimento_real_trunc,
								r_c01_w.hr_inicio_proc;
		end if;

		loop

		fetch cursor_w into nr_seq_proc_w, nr_seq_agrup_analise_w;

		EXIT WHEN NOT FOUND; /* apply on cursor_w */

			tb_seq_w(nr_indice_w) := nr_seq_proc_w;
			tb_seq_agrup_analise_w(nr_indice_w) := nr_seq_agrup_analise_w;

			-- se atingiu a quantidade envia para o banco
			if (nr_indice_w >= pls_util_pck.qt_registro_transacao_w) then

				atualiza_proc(	tb_seq_w, tb_seq_agrup_analise_w);

				tb_seq_w.delete;
				tb_seq_agrup_analise_w.delete;
				nr_indice_w := 0;
			else
				nr_indice_w := nr_indice_w + 1;
			end if;
		end loop;
		close cursor_w;
	end loop;
	-- se sobrou alguma coisa manda para o banco
	atualiza_proc(	tb_seq_w, tb_seq_agrup_analise_w);
	tb_seq_w.delete;
	tb_seq_agrup_analise_w.delete;

	if (ie_commit_p = 'S') then
		commit;
	end if;

	CALL wheb_usuario_pck.set_ie_executar_trigger('S');
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_atualizar_agrup_analise ( nr_seq_conta_p pls_conta.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, ie_acao_p text, ie_commit_p text) FROM PUBLIC;

