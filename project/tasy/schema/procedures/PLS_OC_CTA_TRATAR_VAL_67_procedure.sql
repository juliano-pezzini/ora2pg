-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_67 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE



/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Validar se determinado campo de determinada está ou não informado, se o mesmo deveria estar,
	de acordo com a regra de negócio da operadora.
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Alterações:
------------------------------------------------------------------------------------------------------------------
Alteração:	jjung 15/08/2014 - Criação da rotina.
------------------------------------------------------------------------------------------------------------------
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
ds_sql_w		varchar(1000);
nm_atributo_w		varchar(500);
nm_atrib_ref_w		varchar(500);

cs_cursor_w		pls_util_pck.t_cursor;

dados_tb_selecao_w	pls_tipos_ocor_pck.dados_table_selecao_ocor;

idx			integer;

ds_dado_w		varchar(2000);
nr_seq_selecao_w	pls_oc_cta_selecao_ocor_v.nr_sequencia%type;
qt_caracter_atrib_w	integer;

-- Dados da regra de validação de atributo do item.
c_validacao CURSOR(	nr_seq_oc_cta_comb_p	dados_regra_p.nr_sequencia%type) FOR
	SELECT	a.nr_seq_regra_atrib
	from	pls_oc_cta_val_atrib_item a
	where	a.nr_seq_oc_cta_comb	= nr_seq_oc_cta_comb_p;

-- Dados da regra de atributo.
c_regra CURSOR(	nr_sequencia_p	pls_regra_atrib_ocor_item.nr_sequencia%type) FOR
	SELECT	a.nm_tabela,
		a.nm_atributo,
		a.ie_obrigatorio,
		(SELECT	count(1)
		from	tabela_atributo x
		where	x.nm_tabela = a.nm_tabela
		and	x.nm_atributo = a.nm_atributo || '_IMP') qt_imp,
		coalesce(obter_desc_expressao(b.cd_exp_label, b.ds_label), ( select 	substr(obter_desc_expressao(max(coalesce(ta.cd_exp_label, va.cd_exp_label)), max(coalesce(ta.ds_label, va.ds_label))) , 1, 255)
									from  	tabela_visao    tv,
										tabela_visao_atributo  va,
										tabela_atributo    ta
									where 	tv.nm_tabela =a.nm_tabela
									and    	va.nm_atributo = a.nm_atributo
									and  	va.nr_sequencia = tv.nr_sequencia
									and  	ta.nm_tabela = tv.nm_tabela
									and  	ta.nm_atributo = va.nm_atributo)) ds_label,
		a.qt_minimo_caracter
	from	pls_regra_atrib_ocor_item	a,
		tabela_atributo			b
	where	a.nr_sequencia	= nr_sequencia_p
	and	a.ie_situacao	= 'A'
	and	b.nm_tabela	= a.nm_tabela
	and	b.nm_atributo	= a.nm_atributo;

procedure gravar_selecao(dados_tb_selecao_p	in out pls_tipos_ocor_pck.dados_table_selecao_ocor) is;
BEGIN

CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(
		dados_tb_selecao_p.nr_seq_selecao, pls_util_cta_pck.clob_table_vazia_w,
		'SEQ', dados_tb_selecao_p.ds_observacao, dados_tb_selecao_p.ie_valido, nm_usuario_p);

pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_p);

end;

begin

idx := 0;

-- Só processa se tiver uma  regra informada
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then

	-- Busca qual regra deve ser processada
	for r_val_w in c_validacao(dados_regra_p.nr_sequencia) loop

		-- Se tem regra informada vai atrá dos dados.
		if (r_val_w.nr_seq_regra_atrib IS NOT NULL AND r_val_w.nr_seq_regra_atrib::text <> '') then

			-- Autaliza a flag temporária de todos os itens para definir qual deve ficar ativo e qual não deve.
			CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);

			-- Busca os dados da regra de atributo selecionada.
			for r_regra_w in c_regra(r_val_w.nr_seq_regra_atrib) loop

				-- Se for na importação verifica se tem o campo IMP
				if (dados_regra_p.ie_evento = 'IMP' and r_regra_w.qt_imp > 0) then

					nm_atributo_w := r_regra_w.nm_atributo || '_IMP';
				else
					nm_atributo_w := r_regra_w.nm_atributo;
				end if;

				-- Verifica a tabela para saber qual atributo da seleção usar.
				if (r_regra_w.nm_tabela = 'PLS_CONTA_PROC') then

					nm_atrib_ref_w := 'nr_seq_conta_proc';

				elsif (r_regra_w.nm_tabela = 'PLS_CONTA_MAT') then

					nm_atrib_ref_w := 'nr_seq_conta_mat';
				end if;

				-- Monta o sql para buscar o dado, sempre retorna ele como varchar2 de 2000 por causa do dbms_sql.varchar2_table que é só desse tamanho.
				ds_sql_w :=	'select	substr(item.' || nm_atributo_w || ', 1, 2000) ds_item,  ' || pls_util_pck.enter_w ||
						'	sel.nr_sequencia nr_seq_selecao ' || pls_util_pck.enter_w ||
						'from	pls_oc_cta_selecao_ocor_v sel, ' || pls_util_pck.enter_w ||
						'	' || r_regra_w.nm_tabela || ' item ' || pls_util_pck.enter_w ||
						'where	sel.nr_id_transacao = :nr_id_transacao ' || pls_util_pck.enter_w ||
						'and	sel.ie_valido = ''S'' ' || pls_util_pck.enter_w ||
						'and	item.nr_sequencia = sel.' || nm_atrib_ref_w;

				open cs_cursor_w for EXECUTE ds_sql_w
				using nr_id_transacao_p;

				begin
					loop

					fetch cs_cursor_w into ds_dado_w, nr_seq_selecao_w;
					EXIT WHEN NOT FOUND; /* apply on cs_cursor_w */

					-- Começa a observação, o item só será adicionado na tabela de seleção se tiver alguma inconsistência portanto a observação das inconsistências devem ser concatenadas
					-- com esta.
					dados_tb_selecao_w.ds_observacao(idx) := 'Foram encontradas inconsistências na informação deste item, confira abaixo: ' ||
								pls_util_pck.enter_w;

					-- Se for obrigatório e o dado estiver nulo então vai marcar o item para gerar a ocorrencia
					if (r_regra_w.ie_obrigatorio = 'S' and coalesce(ds_dado_w::text, '') = '') then

						dados_tb_selecao_w.nr_seq_selecao(idx) := nr_seq_selecao_w;
						dados_tb_selecao_w.ds_observacao(idx) := dados_tb_selecao_w.ds_observacao(idx) ||
										'O campo "' || r_regra_w.ds_label || '" deve ser informado.' ||
										pls_util_pck.enter_w;
						dados_tb_selecao_w.ie_valido(idx) := 'S';

						idx := idx + 1;
					elsif (r_regra_w.qt_minimo_caracter IS NOT NULL AND r_regra_w.qt_minimo_caracter::text <> '') then
						-- Para evitar o desperdício de processamento, foi colocado para contar os caracteres apenas quando
						-- a regra for de quantidade mínima.
						qt_caracter_atrib_w := length(ds_dado_w);

						-- Se a quantidade de caracteres informada no campo for maior ou igual a quantidade definida na regra, não será gerada a ocorrência
						if (coalesce(qt_caracter_atrib_w::text, '') = '' or
							qt_caracter_atrib_w < r_regra_w.qt_minimo_caracter) then

							dados_tb_selecao_w.nr_seq_selecao(idx) := nr_seq_selecao_w;
							dados_tb_selecao_w.ds_observacao(idx) := dados_tb_selecao_w.ds_observacao(idx) ||
											'O campo "' || r_regra_w.ds_label || '" deve possuir uma quantidade mínima de caracteres.' ||
											pls_util_pck.enter_w;
							dados_tb_selecao_w.ie_valido(idx) := 'S';

							idx := idx + 1;
						end if;
					end if;

					-- sempre que o indice atual atingir o tamanho máximo grava na tabela.
					if (idx = pls_util_cta_pck.qt_registro_transacao_w) then

						gravar_selecao(dados_tb_selecao_w);
						idx := 0;
					end if;

					end loop;
					close cs_cursor_w;
				exception when others then

					-- se deu erro então fecha o cursor se ficou aberto
					if (cs_cursor_w%isopen) then
						close cs_cursor_w;
					end if;

					-- Limpa a tabela de seleção e passa o erro adiante
					CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(dados_regra_p, ds_sql_w, nr_id_transacao_p, nm_usuario_p, 'N');
				end;

				-- Se sobrou algum registro ainda nas tabelas manda para o banco.
				if (dados_tb_selecao_w.nr_seq_selecao.count > 0) then

					gravar_selecao(dados_tb_selecao_w);
				end if;
			end loop;

			-- Marca como inválido todos os itens que não foram selecionados
			CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
		end if;
	end loop;

end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_67 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

