-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_72_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) AS $body$
DECLARE



_ora2pg_r RECORD;
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Validar ações sobre os itens na análise. Esta validação irá verificar se o item sofreu
alguma ação de inclusão ou substituição na análise de contas médicas.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
nr_seq_protocolo_w		pls_protocolo_conta.nr_sequencia%type;
qt_conta_protocolo_w		integer;
ds_periodo_w			varchar(50);
vl_total_protocolo_w		bigint;
qt_variacao_min_qtde_w		bigint;
vl_variacao_min_qtde_w		bigint;
qt_variacao_max_qtde_w		bigint;
vl_variacao_max_qtde_w		bigint;
qt_variacao_min_vl_w		bigint;
vl_variacao_min_vl_w		bigint;
qt_variacao_max_vl_w		bigint;
vl_variacao_max_vl_w		bigint;
vl_comparacao_w			bigint;
qt_comparacao_w			bigint;
ie_valido_w			pls_oc_cta_selecao_imp.ie_valido%type;
ds_observacao_w			pls_oc_cta_selecao_imp.ds_observacao%type;
tb_seq_selecao_w		pls_util_cta_pck.t_number_table;
tb_valido_w			pls_util_cta_pck.t_varchar2_table_1;
tb_observacao_w			pls_util_cta_pck.t_varchar2_table_4000;
bind_sql_valor_w		sql_pck.t_dado_bind;
cursor_w			sql_pck.t_cursor;
ds_sql_w			varchar(4000);
ds_restricao_integradas_w	varchar(2000);
ds_restricao_importando_w	varchar(2000);
i				integer;

-- Regras de validação da ocorrência selecionada
c_val CURSOR(	nr_seq_oc_cta_comb_p	pls_oc_cta_combinada.nr_sequencia%type) FOR
	SELECT	a.ie_data_referencia,
		a.ie_tipo_contador,
		a.qt_variacao_menor,
		a.qt_variacao_maior,
		a.qt_var_conta_menor,
		a.qt_var_conta_maior
	from	pls_oc_cta_val_prod_med a
	where	a.nr_seq_oc_cta_comb	= nr_seq_oc_cta_comb_p;

-- Protocolos na tabela de seleção
cs_prot_selecao CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_imp.nr_id_transacao%type) FOR
	SELECT	a.nr_sequencia 		nr_seq_selecao,
		b.nr_sequencia		nr_seq_protocolo,
		b.dt_transacao		dt_protocolo,
		b.dt_recebimento_conv	dt_recebimento_prot,
		b.ie_tipo_guia,
		b.nr_seq_prestador_conv	nr_seq_prestador_prot,
		(	SELECT	count(1)
			from	pls_conta_imp	x
			where	x.nr_seq_protocolo = b.nr_sequencia) qt_conta,
		(	select	sum(x.vl_total_geral)
			from	pls_conta_imp	x
			where	x.nr_seq_protocolo = b.nr_sequencia) vl_total
	from	pls_oc_cta_selecao_imp	a,
		pls_protocolo_conta_imp	b
	where	a.nr_id_transacao	= nr_id_transacao_pc
	and	a.ie_valido		= 'S'
	and	b.nr_sequencia		= a.nr_seq_conta
	and	(b.nr_sequencia IS NOT NULL AND b.nr_sequencia::text <> '')
	order by b.nr_sequencia;
BEGIN

-- Não processa se não tem a regra.
if (nr_seq_combinada_p IS NOT NULL AND nr_seq_combinada_p::text <> '')  then

	-- Varrer as regras cadastradas para a ocorrência.
	for r_val_w in c_val(nr_seq_combinada_p) loop

		-- Verificar se tem algum campo para considerar na regra
		if ((r_val_w.qt_variacao_menor IS NOT NULL AND r_val_w.qt_variacao_menor::text <> '') or (r_val_w.qt_variacao_maior IS NOT NULL AND r_val_w.qt_variacao_maior::text <> '') or
			(r_val_w.qt_var_conta_menor IS NOT NULL AND r_val_w.qt_var_conta_menor::text <> '') or (r_val_w.qt_var_conta_maior IS NOT NULL AND r_val_w.qt_var_conta_maior::text <> '')) then

			i := 0;

			-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
			CALL pls_ocor_imp_pck.atualiza_campo_auxiliar('V', ie_regra_excecao_p, nr_id_transacao_p, null);

			-- Incializar as listas para cada regra.
			SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

			-- Varrer os protocolos que estão na tabela de seleção, o cursor está ordenado para que cada protocolo seja processado apenas uma vez.
			for rw_prot_sel_w in cs_prot_selecao(nr_id_transacao_p) loop

				-- Só processa quando muda de protocolo e na primeira linha
				if (coalesce(nr_seq_protocolo_w::text, '') = '' or nr_seq_protocolo_w <> rw_prot_sel_w.nr_seq_protocolo) then

					ie_valido_w	:= 'N';
					ds_observacao_w	:= null;

					ds_restricao_integradas_w	:= '';
					ds_restricao_importando_w	:= '';
					bind_sql_valor_w.delete;

					bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador', rw_prot_sel_w.nr_seq_prestador_prot, bind_sql_valor_w);
					bind_sql_valor_w := sql_pck.bind_variable(':ie_tipo_guia', rw_prot_sel_w.ie_tipo_guia, bind_sql_valor_w);

					case(r_val_w.ie_tipo_contador)

						-- Por envio considera só o último protocolo
						when 'E' then
							begin
							ds_periodo_w := 'envio';
							ds_restricao_integradas_w :=	ds_restricao_integradas_w || pls_util_pck.enter_w ||
										' and conta.nr_seq_protocolo =(	select	max(prot_ant.nr_sequencia) ' || pls_util_pck.enter_w ||
										'				from	pls_protocolo_conta_v prot_ant ' || pls_util_pck.enter_w ||
										'				where	prot_ant.nr_seq_prestador = :nr_seq_prestador ' || pls_util_pck.enter_w ||
										'				and	prot_ant.ie_tipo_guia = :ie_tipo_guia ' || pls_util_pck.enter_w ||
										'				and	prot_ant.ie_situacao not in (''RE'', ''A'') ' || pls_util_pck.enter_w ||
										'				and	prot_ant.dt_recebimento < :dt_recebimento ) ';

							--Para as tabelas imp, já traz a tabela protocolo no select principal, só adicionando a restrição da data aqui
							ds_restricao_importando_w :=	ds_restricao_importando_w || pls_util_pck.enter_w ||
										' and	prot.dt_recebimento_conv < :dt_recebimento  ';

							bind_sql_valor_w := sql_pck.bind_variable(':dt_recebimento', rw_prot_sel_w.dt_recebimento_prot, bind_sql_valor_w);

							end;

						-- Por semena só da última semana
						when 'S' then
							begin
							ds_periodo_w := 'semana';
							-- Data de referência para o cálculo do período.
							-- Recebimento do protocolo.
							if (r_val_w.ie_data_referencia = 'R') then

								ds_restricao_integradas_w := 	ds_restricao_integradas_w || pls_util_pck.enter_w ||
											'and conta.dt_recebimento_prot between :dt_recebimento - 7 and :dt_recebimento ';

								ds_restricao_importando_w := 	ds_restricao_importando_w || pls_util_pck.enter_w ||
											'and prot.dt_recebimento_conv between :dt_recebimento - 7 and :dt_recebimento ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_recebimento', rw_prot_sel_w.dt_recebimento_prot, bind_sql_valor_w);
							-- Data do protocolo
							elsif (r_val_w.ie_data_referencia = 'M') then

								ds_restricao_integradas_w := 	ds_restricao_integradas_w || pls_util_pck.enter_w ||
											'and conta.dt_protocolo between :dt_protocolo - 7 and :dt_protocolo ';

								ds_restricao_importando_w := 	ds_restricao_importando_w || pls_util_pck.enter_w ||
											'and prot.dt_transacao between :dt_protocolo - 7 and :dt_protocolo ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_protocolo', rw_prot_sel_w.dt_protocolo, bind_sql_valor_w);
							end if;
							end;

						-- Diariamente pega de um dia atrá somente.
						when 'D' then
							begin
							ds_periodo_w := 'dia';
							-- Data de referência para o cálculo do período.
							-- Recebimento do protocolo.
							if (r_val_w.ie_data_referencia = 'R') then

								ds_restricao_integradas_w := 	ds_restricao_integradas_w || pls_util_pck.enter_w ||
												'and conta.dt_recebimento_prot between :dt_recebimento - 1 and :dt_recebimento ';

								ds_restricao_importando_w := 	ds_restricao_importando_w || pls_util_pck.enter_w ||
												'and prot.dt_recebimento_conv between :dt_recebimento - 1 and :dt_recebimento ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_recebimento', rw_prot_sel_w.dt_recebimento_prot, bind_sql_valor_w);
							-- Data do protocolo
							elsif (r_val_w.ie_data_referencia = 'M') then

								ds_restricao_integradas_w := 	ds_restricao_integradas_w || pls_util_pck.enter_w ||
												'and conta.dt_protocolo between :dt_protocolo - 1 and :dt_protocolo ';

								ds_restricao_importando_w := 	ds_restricao_importando_w || pls_util_pck.enter_w ||
												'and conta.dt_transacao between :dt_protocolo - 1 and :dt_protocolo ';

								bind_sql_valor_w := sql_pck.bind_variable(':dt_protocolo', rw_prot_sel_w.dt_protocolo, bind_sql_valor_w);
							end if;
							end;
					end case;

					/*
						Busca por contas do mesmo prestador e tipo de guia . Para importação, deve ser considerado o que já foi integrado, através
						das tabelas "quentes" e o que está em importação ainda, através das tabelas IMP, sendo que nessas deve ser considerado a
						situação do protocolo, desconsiderando o que já está integrado, pois nesse caso, retornará na segunda parte do Union, já
						nas tabelas "quentes".
					*/
					ds_sql_w :=	' select	count(1) 	qt_conta, ' 	|| pls_util_pck.enter_w ||
							'	 	sum(vl_total) 	vl_total '	|| pls_util_pck.enter_w ||
							' from '|| pls_util_pck.enter_w ||
							'      (select	conta.vl_total_geral vl_total' 	|| pls_util_pck.enter_w ||
							' 	from		pls_conta_imp conta, ' 	|| pls_util_pck.enter_w ||
							' 			pls_protocolo_conta_imp prot ' || pls_util_pck.enter_w ||
							' 	where		conta.nr_seq_protocolo = prot.nr_sequencia ' || pls_util_pck.enter_w ||
							' 	and		prot.ie_situacao not in (''RE'', ''T'') ' || pls_util_pck.enter_w ||
							' 	and		prot.nr_seq_prestador_conv = :nr_seq_prestador ' || pls_util_pck.enter_w ||
							' 	and		prot.ie_tipo_guia = :ie_tipo_guia ' || pls_util_pck.enter_w ||
							ds_restricao_importando_w||pls_util_pck.enter_w ||
							' 	union all '|| pls_util_pck.enter_w 	||
							' 	select	conta.vl_total ' || pls_util_pck.enter_w ||
							' 	from		pls_conta_ocor_v conta ' || pls_util_pck.enter_w ||
							' 	where		conta.ie_situacao_protocolo not in (''RE'', ''A'') ' || pls_util_pck.enter_w ||
							' 	and		conta.ie_tipo_protocolo in (''I'', ''C'') ' || pls_util_pck.enter_w ||
							' 	and		conta.nr_seq_prestador_prot = :nr_seq_prestador ' || pls_util_pck.enter_w ||
							' 	and		conta.ie_tipo_guia = :ie_tipo_guia '|| pls_util_pck.enter_w ||
							ds_restricao_integradas_w||' )';

					begin
						bind_sql_valor_w := sql_pck.executa_sql_cursor(ds_sql_w, bind_sql_valor_w);
						fetch cursor_w into qt_conta_protocolo_w, vl_total_protocolo_w;
						close cursor_w;
					exception
					when others then
						-- se o cursor estiver fecha
						if (cursor_w%isopen) then

							close cursor_w;
						end if;

						-- Gerencia o erro lançado, limpa a tabela para esta transação.
						CALL pls_ocor_imp_pck.trata_erro_sql_dinamico(nr_seq_combinada_p, null, ds_sql_w, nr_id_transacao_p, wheb_usuario_pck.get_nm_usuario, 'S');

					end;

					-- Calcular a variação de quantidade
					qt_variacao_min_qtde_w	:= (qt_conta_protocolo_w * dividir(r_val_w.qt_var_conta_menor, 100));
					vl_variacao_min_qtde_w	:= qt_conta_protocolo_w + qt_variacao_min_qtde_w;
					qt_variacao_max_qtde_w	:= (qt_conta_protocolo_w * dividir(r_val_w.qt_var_conta_maior, 100));
					vl_variacao_max_qtde_w	:= qt_conta_protocolo_w + qt_variacao_max_qtde_w;
					qt_comparacao_w		:= rw_prot_sel_w.qt_conta;

					-- Calcular a variação de valor
					qt_variacao_min_vl_w	:= (vl_total_protocolo_w * dividir(r_val_w.qt_variacao_menor, 100));
					vl_variacao_min_vl_w	:= vl_total_protocolo_w + qt_variacao_min_vl_w;
					qt_variacao_max_vl_w	:= (vl_total_protocolo_w * dividir(r_val_w.qt_variacao_maior, 100));
					vl_variacao_max_vl_w	:= vl_total_protocolo_w + qt_variacao_max_vl_w;
					vl_comparacao_w		:= rw_prot_sel_w.vl_total;

					-- Verificar se foi definido uma variação mínima de quantidade de conta
					if (r_val_w.qt_var_conta_menor IS NOT NULL AND r_val_w.qt_var_conta_menor::text <> '') then

						if (vl_variacao_min_qtde_w > qt_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'A quantidade de contas apresentadas para este protocolo é inferior ' ||
										'a quantidade permitida pela operadora. Conforme o estabelecido pela ' ||
										'operadora é necessário um crescimento mínimo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_var_conta_menor, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Contas do último período: ' || qt_conta_protocolo_w || pls_util_pck.enter_w ||
										'Contas desta apresentação: ' || rw_prot_sel_w.qt_conta || pls_util_pck.enter_w ||
										'Variação mínima (qtde)): ' || qt_variacao_min_qtde_w;
						end if;
					end if;

					-- Verificar se foi definido uma variação máxima de quantidade de conta
					if (r_val_w.qt_var_conta_maior IS NOT NULL AND r_val_w.qt_var_conta_maior::text <> '') then

						if (vl_variacao_max_qtde_w < qt_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'A quantidade de contas apresentadas para este protocolo é superior ' ||
										'a quantidade permitida pela operadora. Conforme o estabelecido pela ' ||
										'operadora é permitido um crescimento máximo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_var_conta_maior, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Contas do último período: ' || qt_conta_protocolo_w || pls_util_pck.enter_w ||
										'Contas desta apresentação: ' || rw_prot_sel_w.qt_conta || pls_util_pck.enter_w ||
										'Variação máxima (qtde): ' || qt_variacao_max_qtde_w;
						end if;
					end if;

					-- Verificar se foi definido uma variação máxima de quantidade de conta
					if (r_val_w.qt_variacao_menor IS NOT NULL AND r_val_w.qt_variacao_menor::text <> '') then

						if (vl_variacao_min_vl_w > vl_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'O valor apresentado para este protocolo é inferior ' ||
										'ao permitido pela operadora. Conforme o estabelecido pela ' ||
										'operadora é necessário um crescimento mínimo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_variacao_menor, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Valor do último período: ' || campo_mascara_virgula_casas(vl_total_protocolo_w, 2) || pls_util_pck.enter_w ||
										'Valor desta apresentação: ' || campo_mascara_virgula_casas(rw_prot_sel_w.vl_total, 2) || pls_util_pck.enter_w ||
										'Variação mínima (valor): ' || campo_mascara_virgula_casas(qt_variacao_min_vl_w, 2);
						end if;
					end if;

					-- Verificar se foi definido uma variação máxima de quantidade de conta
					if (r_val_w.qt_variacao_maior IS NOT NULL AND r_val_w.qt_variacao_maior::text <> '') then

						if (vl_variacao_min_vl_w < vl_comparacao_w) then

							ie_valido_w 	:= 'S';
							ds_observacao_w	:= 	'O valor apresentado para este protocolo é superior ' ||
										'ao permitido pela operadora. Conforme o estabelecido pela ' ||
										'operadora é permitido um crescimento maximo de ' ||
										campo_mascara_virgula_casas(r_val_w.qt_variacao_maior, 4) ||
										'% em um período de um(a) ' || ds_periodo_w || '.' || pls_util_pck.enter_w ||
										'Valor do último período: ' || campo_mascara_virgula_casas(vl_total_protocolo_w, 2) || pls_util_pck.enter_w ||
										'Valor desta apresentação: ' || campo_mascara_virgula_casas(rw_prot_sel_w.vl_total, 2) || pls_util_pck.enter_w ||
										'Variação máxima (valor): ' || campo_mascara_virgula_casas(qt_variacao_max_vl_w, 2);
						end if;
					end if;
				end if;

				-- alimenta os dados.
				if (ie_valido_w = 'S') then

					tb_seq_selecao_w(i)	:= rw_prot_sel_w.nr_seq_selecao;
					tb_valido_w(i)		:= ie_valido_w;
					tb_observacao_w(i)	:= ds_observacao_w;

					-- Se tem a quantidade estipulada manda para o banco.
					if (i = pls_cta_consistir_pck.qt_registro_transacao_w) then

						CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w, nr_id_transacao_p,'SEQ');

						SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

						i := 0;
					else
						i := i + 1;
					end if;
				end if;

				-- Grava a sequencia do protocolo para calcular só uma vez;
				nr_seq_protocolo_w := rw_prot_sel_w.nr_seq_protocolo;
			end loop; -- Protocolos na seleção
			-- Se sobrou algo, manda para o banco.;
			if (tb_seq_selecao_w.count > 0) then

				CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w, nr_id_transacao_p,'SEQ');
			end if;

			-- seta os registros que serão válidos ou inválidos após o processamento
			CALL pls_ocor_imp_pck.atualiza_campo_valido('V', 'N', ie_regra_excecao_p, null, nr_id_transacao_p, null);

		end if;
	end loop; -- Validações
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_72_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) FROM PUBLIC;

