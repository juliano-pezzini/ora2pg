-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE sus_liberar_laudo_colmeia ( nr_seq_laudo_p bigint, nm_usuario_p text, nr_atendimento_p bigint, nr_apac_p bigint) AS $body$
DECLARE

 
 
qt_inco_laudo_w			smallint	:= 0;
cd_inconsistencia_w		sus_inconsistencia_laudo.cd_inconsistencia%type;
ds_inconsistencia_w		sus_inconsistencia_laudo.ds_inconsistencia%type;
ds_erro_w			sus_erro_imp_colmeia.ds_erro%type;
ie_classificacao_w		sus_laudo_paciente.ie_classificacao%type;

C01 CURSOR FOR 
	SELECT	b.cd_inconsistencia, 
		b.ds_inconsistencia 
	from	sus_inconsistencia_laudo b, 
		sus_inco_reg_laudo a 
	where	a.nr_seq_inconsistencia = b.nr_sequencia 
	and	a.nr_seq_laudo = nr_seq_laudo_p 
	and	b.ie_permite_liberar	= 'N' 
	order by 1,2;

type		fetch_array is table of c01%rowtype;
a_array 	fetch_array;
i		integer := 1;
type vetor is table of fetch_array index by integer;
vetor_c01_w			vetor;

BEGIN 
 
select	count(1) 
into STRICT	qt_inco_laudo_w 
from	sus_inconsistencia_laudo	b, 
	sus_inco_reg_laudo		a 
where	a.nr_seq_inconsistencia	= b.nr_sequencia 
and	a.nr_seq_laudo		= nr_seq_laudo_p 
and	b.ie_permite_liberar	= 'N'  LIMIT 1;
 
if (qt_inco_laudo_w > 0) then 
	begin 
 
	open c01;
	loop 
	fetch c01 bulk collect into a_array limit 100000;
		vetor_c01_w(i) := a_array;
		i := i + 1;
	EXIT WHEN NOT FOUND; /* apply on c01 */
	end loop;
	close c01;
 
	for i in 1..vetor_c01_w.count loop 
		begin 
		a_array := vetor_c01_w(i);
		for z in 1..a_array.count loop 
			begin 
			cd_inconsistencia_w		:= a_array[z].cd_inconsistencia;
			ds_inconsistencia_w		:= a_array[z].ds_inconsistencia;
 
			ds_erro_w := substr(cd_inconsistencia_w||' - '||ds_inconsistencia_w|| 
						wheb_mensagem_pck.get_texto(312318,'nr_atendimento_p='||nr_atendimento_p||';'||'nr_seq_laudo_p='||nr_seq_laudo_p),1,2000);
 
			insert into sus_erro_imp_colmeia( 
				ds_erro, 
				dt_atualizacao, 
				nm_usuario, 
				dt_atualizacao_nrec, 
				nm_usuario_nrec, 
				nr_atendimento, 
				nr_seq_interno, 
				nr_sequencia) 
			values (	ds_erro_w, 
				clock_timestamp(), 
				nm_usuario_p, 
				clock_timestamp(), 
				nm_usuario_p, 
				nr_atendimento_p, 
				nr_seq_laudo_p, 
				nextval('sus_erro_imp_colmeia_seq'));
 
			end;
		end loop;
		end;
	end loop;
 
	update	sus_laudo_paciente 
	set	dt_liberacao 	= clock_timestamp(), 
		dt_atualizacao	= clock_timestamp(), 
		nm_usuario	= nm_usuario_p 
	where	nr_seq_interno	= nr_seq_laudo_p;
 
	end;
end if;
 
begin 
select	coalesce(ie_classificacao,1) 
into STRICT	ie_classificacao_w 
from	sus_laudo_paciente 
where	nr_seq_interno = nr_seq_laudo_p  LIMIT 1;
exception 
when others then 
	ie_classificacao_w := 1;
end;
 
if (ie_classificacao_w in (11,12,13)) then 
	CALL sus_gerar_apac_laudo_colmeia(nr_seq_laudo_p,nr_apac_p,nm_usuario_p);
end if;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE sus_liberar_laudo_colmeia ( nr_seq_laudo_p bigint, nm_usuario_p text, nr_atendimento_p bigint, nr_apac_p bigint) FROM PUBLIC;

