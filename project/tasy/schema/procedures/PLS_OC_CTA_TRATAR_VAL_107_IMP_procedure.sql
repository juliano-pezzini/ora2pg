-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_107_imp ( nr_seq_oc_cta_comb_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) AS $body$
DECLARE


_ora2pg_r RECORD;
cd_senha_ref_w		pls_conta.cd_senha%type;
ds_observacao_w		pls_oc_cta_selecao_imp.ds_observacao%type;
cd_senha_valida_w	pls_conta.cd_senha%type;
nr_idx_w			integer := 0;
qt_regra_nsenha_w	integer;	

tb_seq_selecao_w	pls_util_cta_pck.t_number_table;
tb_valido_w			pls_util_cta_pck.t_varchar2_table_1;
tb_observacao_w		pls_util_cta_pck.t_varchar2_table_4000;
ds_observacao_1_w	varchar(255);
ds_observacao_2_w	varchar(255);
ds_observacao_3_w	varchar(255);
ds_observacao_4_w	varchar(255);
ds_observacao_5_w	varchar(255);
dt_base_vel_w		timestamp;
nr_trans_origem_w	ptu_resposta_autorizacao.nr_seq_origem%type;
		
C01 CURSOR(nr_seq_oc_cta_comb_pc	pls_oc_cta_combinada.nr_sequencia%type) FOR
	SELECT	coalesce(ie_tipo_senha,'S') ie_tipo_senha,
		coalesce(qt_min_caracteres,0) qt_min_caracteres,
		ds_carac_valido,
		nr_seq_regra_nsenha,
		coalesce(ie_senha_autorizada,'N') ie_senha_autorizada,
		coalesce(ie_validade_expirada,'N') ie_validade_expirada,
		coalesce(ie_data_base_val, 'R') ie_data_base_val,
		coalesce(ie_comparar_origem,'N') ie_comparar_origem
	from	pls_oc_cta_val_nsenha
	where	nr_seq_oc_cta_comb = nr_seq_oc_cta_comb_pc;

C02 CURSOR(nr_id_transacao_pc	pls_oc_cta_selecao_imp.nr_id_transacao%type) FOR
	SELECT	conta.cd_senha,
		sel.nr_sequencia nr_seq_selecao,
		conta.nr_seq_guia_conv,
		( 	SELECT 	min(dt_execucao_conv)
			from	pls_conta_proc_imp
			where 	nr_seq_conta = conta.nr_sequencia) dt_min_proced,
		(select	max(x.cd_senha)
		 from	pls_guia_plano x
		 where	x.nr_sequencia = conta.nr_seq_guia_conv) cd_senha_guia,
		(select	fim_dia(max(x.dt_validade_senha))
		 from	pls_guia_plano x
		 where	x.nr_sequencia = conta.nr_seq_guia_conv) dt_validade,
		conta.dt_atendimento_conv dt_atendimento,
		clock_timestamp() dt_recebimento,
		(select max(nr_seq_origem)
		 from ptu_resposta_autorizacao ptu,
			pls_guia_plano x
		 where ptu.nr_seq_guia = x.nr_sequencia
		 and   x.nr_sequencia = conta.nr_seq_guia_conv) nr_trans_origem,
		conta.nr_seq_segurado_conv
	from	pls_oc_cta_selecao_imp	sel,
		pls_conta_imp		conta		
	where	conta.nr_sequencia	= sel.nr_seq_conta
	and	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido 		= 'S';
	
BEGIN

-- Somente entra na validacao se tiver algo cadastrado na regra
if (nr_seq_oc_cta_comb_p IS NOT NULL AND nr_seq_oc_cta_comb_p::text <> '') then
	--Senha nao possui quantidade minima de caracteres valida.
	ds_observacao_1_w:= wheb_mensagem_pck.get_texto(791843);
	--Quantidade minima: 
	ds_observacao_2_w:= wheb_mensagem_pck.get_texto(791844) || ': ';
	--Quantidade de caracteres: 
	ds_observacao_3_w:= wheb_mensagem_pck.get_texto(791845) || ': ';
	--A senha possui caracteres invalidos
	ds_observacao_4_w:= wheb_mensagem_pck.get_texto(791846);
	--Senha nao e valida. Regra de numero de senha invalida
	ds_observacao_5_w:= wheb_mensagem_pck.get_texto(791847);
	
	
	for r_C01_w in C01(nr_seq_oc_cta_comb_p) loop
		
		-- Somente abre o cursor das contas se tiver algum tipo de senha para validar
		if (r_C01_w.ie_tipo_senha IS NOT NULL AND r_C01_w.ie_tipo_senha::text <> '') then
		
			-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
			CALL pls_ocor_imp_pck.atualiza_campo_auxiliar(	'V',
									'N', 
									nr_id_transacao_p, 
									null);
					
			--limpa as variaveis
			SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
		
			for r_C02_w in C02(nr_id_transacao_p) loop
				
				-- Limpa as variaveis
				cd_senha_ref_w 		:= null;
				ds_observacao_w 	:= null;
				cd_senha_valida_w	:= null;
				qt_regra_nsenha_w	:= 0;
				
				dt_base_vel_w:= r_C02_w.dt_recebimento;
				if (r_C01_w.ie_data_base_val = 'A') then
					begin
					dt_base_vel_w:= r_C02_w.dt_atendimento;
					end;
				elsif (r_C01_w.ie_data_base_val = 'P') then
					
					dt_base_vel_w := r_C02_w.dt_min_proced;
										
				end if;
				
				-- Verifica qual sera o campo de senha referencia
				if (r_C01_w.ie_tipo_senha = 'S') then
					
					cd_senha_ref_w := r_C02_w.cd_senha;
					
				end if;
				
				-- Somente ira realizar as validacoes se tiver senha informada na conta
				if (cd_senha_ref_w IS NOT NULL AND cd_senha_ref_w::text <> '') then
					
					-- Somente ira continuar verificando se a primeira validacao nao deve erar ocorrencia
					if (coalesce(ds_observacao_w::text, '') = '') then
						
						-- Caso a quantidade minina de caracteres esteja informada e o tamanho da senha seja menor

						-- que a quantidade minima, grava a observacao
						if (r_C01_w.qt_min_caracteres > 0) and (length(cd_senha_ref_w) < r_C01_w.qt_min_caracteres) then
							ds_observacao_w := 	ds_observacao_1_w || pls_util_pck.enter_w ||
										ds_observacao_2_w || r_C01_w.qt_min_caracteres || '.' || pls_util_pck.enter_w ||
										ds_observacao_3_w || length(cd_senha_ref_w) || '.';
						end if;
						
						
						if (coalesce(ds_observacao_w::text, '') = '') then							
							if (r_C01_w.ie_comparar_origem = 'S') then							
							
								select max(b.nr_seq_origem)
								into STRICT nr_trans_origem_w
								from 	pls_guia_plano a,
									ptu_resposta_autorizacao b
								where a.nr_sequencia = b.nr_seq_guia
								and nr_seq_origem = cd_senha_ref_w
								and a.nr_seq_segurado = r_C02_w.nr_seq_segurado_conv;
								
								if (coalesce(nr_trans_origem_w::text, '') = '') then
									
									if (cd_senha_ref_w <> r_C02_w.nr_trans_origem) then
									nr_trans_origem_w := r_C02_w.nr_trans_origem;
									ds_observacao_w := 	'A senha na conta esta diferente da transacao de origem da requisicao. ' || pls_util_pck.enter_w ||
														'Senha da conta: ' || cd_senha_ref_w || '.' || pls_util_pck.enter_w ||
														 'Transacao de origem da autorizacao: ' || nr_trans_origem_w|| '.';
									end if;									
								end if;							
							end if;							
						end if;	
						
						-- Somente ira continuar verificando se nenhuma validacao gerou ocorrencia
						if (coalesce(ds_observacao_w::text, '') = '') then
							
							-- Caso exista restricao por caracter valido
							if (r_C01_w.ds_carac_valido IS NOT NULL AND r_C01_w.ds_carac_valido::text <> '') then
								-- Retira os caracteres que nao sao validos
								cd_senha_valida_w := regexp_replace(cd_senha_ref_w, '[^'|| r_C01_w.ds_carac_valido ||']', '');
								
								-- Caso o resultado seja nulo, ou diferente do original, grava a observacao
								if (coalesce(cd_senha_valida_w::text, '') = '') or (cd_senha_valida_w <> cd_senha_ref_w) then
									ds_observacao_w := ds_observacao_4_w;
								end if;
							end if;
							
							-- Somente ira continuar verificando se nenhuma validacao gerou ocorrencia
							if (coalesce(ds_observacao_w::text, '') = '') then
								
								-- Cso tenha informado regra de numero de senha
								if (r_C01_w.nr_seq_regra_nsenha IS NOT NULL AND r_C01_w.nr_seq_regra_nsenha::text <> '') then
									
									select	count(1)
									into STRICT	qt_regra_nsenha_w
									from	pls_regra_nsenha b
									where	b.nr_sequencia	= r_c01_w.nr_seq_regra_nsenha
									and	b.ie_situacao 	= 'A'
									and	exists (SELECT	1
											from	pls_itens_regra_nsenha a
											where	a.nr_seq_regra_nsenha = b.nr_sequencia
											and	a.cd_senha = cd_senha_ref_w);
									
									-- Caso exista uma regra pra senha, grava a observacao
									if (qt_regra_nsenha_w > 0) then
										ds_observacao_w := ds_observacao_5_w || ': ' || r_c01_w.nr_seq_regra_nsenha;
									end if;
								end if;
								
								if (coalesce(ds_observacao_w::text, '') = '') then
									
									if (r_C02_w.nr_seq_guia_conv IS NOT NULL AND r_C02_w.nr_seq_guia_conv::text <> '') and (r_C02_w.cd_senha_guia <> cd_senha_ref_w) and (r_c01_w.ie_senha_autorizada = 'S') then
													-- A senha informada esta diferente da senha autorizada
										ds_observacao_w := 	wheb_mensagem_pck.get_texto(787039) || pls_util_pck.enter_w ||
													wheb_mensagem_pck.get_texto(326271) || ': ' || cd_senha_ref_w || '.' || pls_util_pck.enter_w ||
													wheb_mensagem_pck.get_texto(306267) || ': ' || r_C02_w.cd_senha_guia || '.';
									end if;
									
									if (coalesce(ds_observacao_w::text, '') = '') then
										
										if (r_C02_w.nr_seq_guia_conv IS NOT NULL AND r_C02_w.nr_seq_guia_conv::text <> '') and (r_C02_w.dt_validade < r_C02_w.dt_atendimento) and (r_C01_w.ie_validade_expirada = 'S') then
											ds_observacao_w :=	wheb_mensagem_pck.get_texto(787043) || '.' || pls_util_pck.enter_w ||
														wheb_mensagem_pck.get_texto(286730) || ': ' || r_C02_w.dt_atendimento || '.' || pls_util_pck.enter_w ||
														wheb_mensagem_pck.get_texto(759795) || ': ' || r_C02_w.dt_validade || '.';
										end if;
									end if;
								end if;
							end if;
						end if;
					end if;
					
					-- Caso, em algum momento, gerou alguma observacao, joga no array
					if (ds_observacao_w IS NOT NULL AND ds_observacao_w::text <> '') then
						
						tb_valido_w(nr_idx_w)		:= 'S';
						tb_seq_selecao_w(nr_idx_w)	:= r_C02_w.nr_seq_selecao;
						tb_observacao_w(nr_idx_w)	:= ds_observacao_w;
						
						-- Se o numero de registros ultrapassou a quantidade por transacao, manda pro banco,

						-- Caso contrario, incrementa o contador
						if (nr_idx_w >= pls_util_cta_pck.qt_registro_transacao_w) then
							--Grava as informacoes na tabela de selecao
							CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w,
													tb_valido_w,
													tb_observacao_w, 
													nr_id_transacao_p, 
													'SEQ');
							--limpa as variaveis
							SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
							
							-- Zera as variaveis
							nr_idx_w := 0;
							
						else
							nr_idx_w := nr_idx_w + 1;
						end if;
					end if;
				end if;
			end loop;
			-- Caso tenha sobrado algo, manda pro banco
			if (nr_idx_w > 0) then
				--Grava as informacaes na tabela de selecao
				CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w,
										tb_valido_w,
										tb_observacao_w, 
										nr_id_transacao_p, 
										'SEQ');
			end if;
			
			-- seta os registros que serao validos ou invalidos apos o processamento 
			CALL pls_ocor_imp_pck.atualiza_campo_valido('V',
								'N', 
								ie_regra_excecao_p, 
								null,
								nr_id_transacao_p, 
								null);
		end if;
	end loop;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_107_imp ( nr_seq_oc_cta_comb_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) FROM PUBLIC;

