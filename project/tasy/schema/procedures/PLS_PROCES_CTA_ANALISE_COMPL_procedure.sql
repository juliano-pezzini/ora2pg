-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_proces_cta_analise_compl () AS $body$
DECLARE

			
qt_registros_w			integer;
cd_estabelecimento_w		pls_lote_protocolo_conta.cd_estabelecimento%type;
ds_erro_w			pls_cta_lt_ger_lote_compl.ds_falha%type;
ds_stack_w			varchar(4000);
ds_err_stack_w			varchar(4000);
ds_sqlerrm_w			varchar(4000);
nm_id_sid_w			pls_cta_lt_ger_lote_compl.nm_id_sid%type;
nm_id_serial_w			pls_cta_lt_ger_lote_compl.nm_id_serial%type;
ie_status_final_w		pls_cta_lt_ger_lote_compl.ie_status%type;
dados_sid_w			pls_util_pck.dados_sid;
ie_status_lote_conta_w		pls_lote_protocolo_conta.ie_status%type;

-- Prevençao de DeadLock
qt_ora_deadlock_w	integer;

c00 CURSOR FOR
	SELECT	nr_sequencia,
		nm_id_sid,
		nm_id_serial
	from	pls_cta_lt_ger_lote_compl
	where	ie_status	= 'I'
	and	(nm_id_sid IS NOT NULL AND nm_id_sid::text <> '')
	and	(nm_id_serial IS NOT NULL AND nm_id_serial::text <> '');
			

--Adicionado o exists, para garantir que nao irá gerar análise de lote que contenha algum protocolo ainda nao finalizado na digitaçao de 

--contas pelo portal, ocorreram casos onde conta estava inconsistente  vinculada a protocolo nao finalizado e já tinha análise, gerando problemas

--ao consistir essa conta.			
C01 CURSOR FOR
	SELECT	a.nr_sequencia,
		a.nr_seq_lote_protocolo,
		a.nm_usuario_nrec,
		coalesce(a.qt_reprocesso, 0) qt_reprocesso
	from	pls_cta_lt_ger_lote_compl a
	where	a.ie_status	= 'P'
	and 	not exists ( 	SELECT	1
				from	pls_protocolo_conta b
				where	b.nr_seq_lote_conta = a.nr_seq_lote_protocolo
				and	b.ie_situacao in ('A','RE','I'));

BEGIN

--Verifica processos que foram iniciados, mas a sessao nao está ativa
for r_c00_w in C00 loop

	--Caso a sessao nao está ativa, entao coloca como pendente para processar novamente
	if (pls_util_pck.obter_se_sessao_ativa(r_c00_w.nm_id_sid,r_c00_w.nm_id_serial) = 'N') then
		update	pls_cta_lt_ger_lote_compl
		set	ie_status	= 'P'
		where	nr_sequencia	= r_c00_w.nr_sequencia
		and	ie_status	= 'I';
	end if;

end loop;

dados_sid_w := pls_util_pck.obter_sid_sessao_atual;

for r_c01_w in C01 loop

	--setar o log na package wheb_usuario_pck para nao gerar registros indevidos nas triggers de alteraçao
	CALL wheb_usuario_pck.set_nm_usuario(r_c01_w.nm_usuario_nrec);
	
	select	count(1)
	into STRICT	qt_registros_w
	from	pls_cta_lt_ger_lote_compl
	where	nr_sequencia	= r_c01_w.nr_sequencia
	and	ie_status	in ('P','X');
	
	--Verifica se ainda está pendente o registro ou com falha
	if (qt_registros_w	> 0) then
		--Marca o registro para inicio de processamento
		update 	pls_cta_lt_ger_lote_compl
		set	ie_status		= 'I',
			dt_inicio_geracao	= clock_timestamp(),
			nm_id_sid		= dados_sid_w.nm_id_sid,
			nm_id_serial		= dados_sid_w.nm_id_serial
		where	nr_sequencia		= r_c01_w.nr_sequencia;
		
		commit;
		
		select	max(cd_estabelecimento),
			max(ie_status)
		into STRICT	cd_estabelecimento_w,
			ie_status_lote_conta_w
		from	pls_lote_protocolo_conta
		where	nr_sequencia	= r_c01_w.nr_seq_lote_protocolo;
		
		ds_erro_w		:= '';
		ie_status_final_w	:= 'F';
		
		--Se o lote de análise já estiver gerado, entao já finaliza o processo
		if (coalesce(ie_status_lote_conta_w,'U') = 'A') then
			update	pls_cta_lt_ger_lote_compl
			set	ds_falha	= ds_erro_w,
				ie_status	= ie_status_final_w,
				dt_fim_geracao  = clock_timestamp()
			where	nr_sequencia	= r_c01_w.nr_sequencia;
			
			commit;
		else
			--Gera o lote de análise
			begin
			CALL pls_gerar_analise_lote(	r_c01_w.nr_seq_lote_protocolo,'N','N',
						cd_estabelecimento_w, r_c01_w.nm_usuario_nrec, null,
						'N',null);
			exception
			when others then
				ds_stack_w := dbms_utility.format_call_stack;
				ds_err_stack_w := dbms_utility.format_error_backtrace;
				ds_sqlerrm_w := sqlerrm;
				ie_status_final_w := 'X';
				
				ds_erro_w := substr(	'Erro: ' || ds_sqlerrm_w || pls_util_pck.enter_w || pls_util_pck.enter_w ||
							'Stack:' || pls_util_pck.enter_w ||
							ds_stack_w || pls_util_pck.enter_w ||
							'Error Back Trace: ' || pls_util_pck.enter_w ||
							ds_err_stack_w,1,4000);
				-- se detectou um deadlock na mensagem de erro, deve jogar para processar novamente
				select	position('ORA-00060' in ds_erro_w)
				into STRICT	qt_ora_deadlock_w
				;
				
				if (qt_ora_deadlock_w > 0) and (coalesce(r_c01_w.qt_reprocesso, 0) < 3) then
				
					update	pls_xml_lote
					set	ie_status			= 'VAL'
					where	nr_seq_lote			= r_c01_w.nr_seq_lote_protocolo;
					
					update	pls_lote_protocolo_conta
					set	dt_geracao_analise	 = NULL,
						ie_status		= 'U',
						ds_mensagem_erro	= ds_erro_w
					where	nr_sequencia		= r_c01_w.nr_seq_lote_protocolo;
					
					update	pls_cta_lt_ger_lote_compl
					set	qt_reprocesso	= r_c01_w.qt_reprocesso + 1
					where	nr_sequencia	= r_c01_w.nr_sequencia;
					
					ie_status_final_w := 'P';
				
				end if;
			end;
			
			--Apenas verifica se ocorreu erro ao gerar o lote de análise
			select	count(1)
			into STRICT	qt_registros_w
			from	pls_cta_lt_ger_lote_compl
			where	nr_sequencia	= r_c01_w.nr_sequencia
			and	ie_status	= 'X';
			
			--Marca o registro para fim de processamento
			if (qt_registros_w	= 0) then
				update	pls_cta_lt_ger_lote_compl
				set	ds_falha	= ds_erro_w,
					ie_status	= ie_status_final_w,
					dt_fim_geracao  = CASE WHEN ie_status_final_w='P' THEN  null  ELSE clock_timestamp() END
				where	nr_sequencia	= r_c01_w.nr_sequencia;
			end if;
			
			commit;
		end if;
		
		
		
	end if;
end loop;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_proces_cta_analise_compl () FROM PUBLIC;

