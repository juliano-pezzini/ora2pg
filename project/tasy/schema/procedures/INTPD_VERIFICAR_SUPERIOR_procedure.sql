-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE intpd_verificar_superior ( nr_sequencia_p bigint, ie_integrar_p INOUT text) AS $body$
DECLARE


ds_sql_w 			varchar(4000);
ds_atributo_w		varchar(4000);
nm_tabela_w 		tabela_sistema.nm_tabela%type;
ds_where_w 		varchar(4000);
nr_seq_documento_w 	intpd_fila_transmissao.nr_seq_documento%type;
nr_seq_item_documento_w 	intpd_fila_transmissao.nr_seq_item_documento%type;
ds_retorno_w 		varchar(255);
nr_seq_superior_w 		intpd_fila_transmissao.nr_seq_superior%type;
nr_seq_evento_w		intpd_eventos.nr_sequencia%type;
ie_status_reg_sup_w 	intpd_fila_transmissao.ie_status%type;
ie_evento_w		intpd_fila_transmissao.ie_evento%type;
ie_evento_superior_w	intpd_fila_transmissao.ie_evento%type;
qt_lista_pend_w		bigint := 0;
qt_regra_evento_superior_w 	bigint := 0;
qt_processando_w		bigint := 0;
nr_sequencia_pendente_w		bigint := 0;


c08 CURSOR FOR
SELECT 	nr_sequencia,
	nr_seq_evento_sup
from	intpd_evento_superior a
where	nr_seq_evento = nr_seq_evento_w;
c08_w	c08%rowtype;

c09 CURSOR FOR
SELECT 	nr_sequencia,
	nm_atributo
from	intpd_evento_superior_item
where	nr_seq_evento_sup = c08_w.nr_sequencia;
c09_w	c09%rowtype;

c10 CURSOR FOR
SELECT 	a.nm_atributo
from	indice i,
	indice_atributo a
where	i.nm_tabela = a.nm_tabela
and	i.nm_indice = a.nm_indice
and	i.ie_tipo = 'PK'
and	upper(i.nm_tabela) = upper(nm_tabela_w)
order by 	a.nr_sequencia;
c10_w	c10%rowtype;
		

BEGIN

select	max(ie_evento),
	max(nr_seq_documento),
	max(nr_seq_item_documento),
	max(nr_seq_superior)
into STRICT	ie_evento_w,
	nr_seq_documento_w,
	nr_seq_item_documento_w,
	nr_seq_superior_w
from	intpd_fila_transmissao
where	nr_sequencia = nr_sequencia_p;

select	max(a.nr_sequencia),
	count(b.nr_sequencia)
into STRICT	nr_seq_evento_w,
	qt_regra_evento_superior_w
from	intpd_eventos a,
	intpd_evento_superior b
where	a.nr_sequencia = b.nr_seq_evento
and	a.ie_evento = ie_evento_w;

if (qt_regra_evento_superior_w > 0) then
	begin
	
	ie_integrar_p := 'N';
	
	open c08;
	loop
	fetch c08 into	
		c08_w;
	EXIT WHEN NOT FOUND; /* apply on c08 */
		begin
		
		ds_atributo_w := '';
		
		open c09;
		loop
		fetch c09 into	
			c09_w;
		EXIT WHEN NOT FOUND; /* apply on c09 */
			begin
			
			if (coalesce(c09_w.nm_atributo,'X') <> 'X') then
				ds_atributo_w := substr(ds_atributo_w || c09_w.nm_atributo || ', ',1,255);
			end if;
		
			end;
		end loop;
		close c09;
	
		ds_atributo_w := substr(ds_atributo_w,1,instr(ds_atributo_w,',',-1)-1);
		
			select	max(nm_tabela)
			into STRICT	nm_tabela_w
			from	table(intpd_retorno_int_superior_pck.intpd_obter_tabela_evento(nr_seq_evento_w,nr_seq_item_documento_w));		
	
		if	((coalesce(ds_atributo_w,'X') <> 'X') and (coalesce(nm_tabela_w,'X') <> 'X')) then

			ds_where_w := '';
			
			open c10;
			loop
			fetch c10 into	
				c10_w;
			EXIT WHEN NOT FOUND; /* apply on c10 */
				begin
				if (coalesce(c10_w.nm_atributo,'X') <> 'X') then
					if (coalesce(ds_where_w::text, '') = '') then
						ds_where_w := ' and ' || c10_w.nm_atributo || ' = ' || nr_seq_documento_w;
					else
						ds_where_w := ds_where_w || ' and ' || c10_w.nm_atributo || ' = ' || nr_seq_item_documento_w; /*PK composta*/
					end if; 	
				end if;
				end;
			end loop;
			close c10;
				
			ds_sql_w := 	'select ' || ds_atributo_w ||
					' from ' || nm_tabela_w || 
					' where 1 = 1 ' || ds_where_w;

			ds_retorno_w := Obter_valor_Dinamico_char_bv(ds_sql_w, null, ds_retorno_w);

			if (coalesce(trim(both ds_retorno_w),'X') <> 'X') then
				begin
				
				select	max(ie_evento)
				into STRICT	ie_evento_superior_w
				from	intpd_eventos
				where	nr_sequencia = c08_w.nr_seq_evento_sup;

				select 	max(nr_sequencia)
				into STRICT	nr_seq_superior_w
				from	intpd_fila_transmissao
				where 	ie_evento = ie_evento_superior_w
				and	nr_seq_documento = ds_retorno_w
				and	ie_operacao = 'I'; /*Se tem um INSERT ja pode processar a integração filha*/
				
				if (coalesce(nr_seq_superior_w,0) > 0) then

					update	intpd_fila_transmissao
					set	nr_seq_superior = nr_seq_superior_w
					where	nr_sequencia = nr_sequencia_p;

					select 	count(*)
					into STRICT	qt_lista_pend_w
					from	intpd_lista_pend_superior
					where	nr_seq_fila = nr_sequencia_p
					and	nr_seq_fila_superior = nr_seq_superior_w;					
						
					
					if (qt_lista_pend_w = 0) then
						CALL intpd_inserir_lista_pend(nr_sequencia_p, nr_seq_superior_w, 'Tasy');
					end if;
					
					select 	max(ie_status)
					into STRICT	ie_status_reg_sup_w
					from	intpd_fila_transmissao
					where 	nr_sequencia = nr_seq_superior_w;
					
					if (coalesce(ie_status_reg_sup_w,'S') <> 'S') then
						update	intpd_fila_transmissao
						set	ie_status = 'AS'
						where	nr_sequencia = nr_sequencia_p;
					else /*Se o registro superior está processado, o dependente também pode ser processado, se for o próximo e não haver nenhum outro processando ainda*/
						select 	count(1)
						into STRICT	qt_processando_w
						from	intpd_fila_transmissao
						where 	nr_seq_superior = nr_seq_superior_w
						and	nr_sequencia < nr_sequencia_p
						and 	ie_status in ('R', 'E')
						and	((ie_evento_w not in ('214','161')) or
							((ie_evento_w in ('214','161')) and (nr_seq_documento  = nr_seq_documento_w)));
							/*Dava problema quando tinha dois atendimentos da mesma pessoa física na fila de transmissao. 							
							Se dava algum erro no primeiro atendimento, quando gerava o segundo atendimento, ele ficava pendente esperando o primeiro ser processado.
							Com essa alteração que fizemos. os atendimento posteriores serão processados normalmente.*/
						select 	coalesce(min(nr_sequencia),0)
						into STRICT	nr_sequencia_pendente_w
						from	intpd_fila_transmissao
						where 	nr_seq_superior = nr_seq_superior_w
						and	nr_sequencia < nr_sequencia_p
						and 	ie_status = 'P'
						and	((ie_evento_w not in ('214','161')) or
							((ie_evento_w in ('214','161')) and (nr_seq_documento  = nr_seq_documento_w)));
							
						if	((nr_sequencia_pendente_w = 0) or (qt_processando_w = 0))  then
							ie_integrar_p := 'S';
						end if;						
					end if;
				else /*Se não existe registro superior na fila de transmissão, o dependente pode ser processado*/
					ie_integrar_p := 'S';
				end if;				
				end;
			else
				ie_integrar_p := 'S';
			end if;
		else /*Se não existir atributo e/ou tabela corretamente cadastrados, segue o fluxo normal processando o registro*/
			ie_integrar_p := 'S';
		end if;
		end;
	end loop;
	close c08;	
	end;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE intpd_verificar_superior ( nr_sequencia_p bigint, ie_integrar_p INOUT text) FROM PUBLIC;

