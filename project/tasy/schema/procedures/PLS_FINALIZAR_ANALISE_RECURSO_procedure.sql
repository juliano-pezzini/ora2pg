-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_finalizar_analise_recurso (nr_seq_analise_p pls_analise_conta.nr_sequencia%type, nr_id_transacao_p pls_analise_conta_rec.nr_id_transacao%type, nr_seq_grupo_atual_p pls_grupo_auditor.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, ie_encerrar_analise_p text default 'N', ie_encaminha_prot_p text default 'N') AS $body$
DECLARE


ie_existe_grupos_abertos_w	integer;
nr_seq_regra_w			bigint;
nr_seq_grupo_w			bigint;
ie_existe_grupo_final_w		varchar(1);
ie_existe_final_anali_w		varchar(1);
qt_grupos_analise_w		integer;
ie_status_analise_w		pls_analise_conta.ie_status%type;
ds_parecer_w			pls_analise_parecer_rec.ds_parecer%type;
nr_seq_parecer_w		pls_analise_parecer_rec.nr_sequencia%type;
nr_seq_conta_rec_w		pls_analise_conta_rec.nr_sequencia%type;
qt_registro_w			integer;
ie_finaliza_sem_itens_pend_w	pls_parametros_rec_glosa.ie_finaliza_sem_itens_pend%type;
ie_grupo_pendente_w		varchar(1);
qt_grupo_pend_w			integer;
t_contas_w    			pls_util_cta_pck.t_number_table;
index_w        			integer;
ds_observacao_w			varchar(4000);
nr_seq_ultima_conta_w		pls_rec_glosa_conta.nr_seq_conta%type;
ds_log_call_w			varchar(1500);

c01 CURSOR(	nr_seq_analise_pc		pls_analise_conta_rec.nr_seq_analise%type,
		nr_id_transacao_pc		pls_analise_conta_rec.nr_id_transacao%type) FOR
	SELECT	a.nr_seq_conta_rec,
		a.nr_seq_proc_rec,
		a.nr_seq_mat_rec,
		a.nr_seq_conta
	from	pls_analise_conta_rec a
	where	a.nr_seq_analise	= nr_seq_analise_pc
	and	a.nr_id_transacao	= nr_id_transacao_pc;
				
c02 CURSOR(	nr_seq_analise_pc		pls_analise_conta_rec.nr_seq_analise%type,
		nr_id_transacao_pc		pls_analise_conta_rec.nr_id_transacao%type) FOR
	SELECT	distinct a.nr_seq_conta_rec
	from	pls_analise_conta_rec a
	where	a.nr_seq_analise	= nr_seq_analise_pc
	and	a.nr_id_transacao	= nr_id_transacao_pc;
				
BEGIN

ds_observacao_w := 'nr_seq_analise_p= '||nr_seq_analise_p;

t_contas_w.delete;
if (nr_seq_analise_p > 0) and (nr_seq_grupo_atual_p > 0) then
	
	select	coalesce(ie_finaliza_sem_itens_pend,'N')
	into STRICT	ie_finaliza_sem_itens_pend_w
	from	pls_parametros_rec_glosa
	where	cd_estabelecimento = cd_estabelecimento_p;
	
	if (ie_finaliza_sem_itens_pend_w = 'S') then
		ie_grupo_pendente_w := pls_obter_se_grupo_pend_rec(nr_seq_analise_p, null, null, nr_seq_grupo_atual_p, 'A');
		
		if (ie_grupo_pendente_w = 'S') then
			CALL wheb_mensagem_pck.exibir_mensagem_abort('Existem itens pendentes de an?lise para o grupo auditor. Favor verificar atrav?s do campo "Pendentes".');
		end if;
	end if;
	
	update	pls_auditoria_conta_grupo
	set	dt_liberacao 	= clock_timestamp()
	where	nr_sequencia	= (	SELECT	max(nr_sequencia)
					from	pls_auditoria_conta_grupo
					where	nr_seq_grupo 		= nr_seq_grupo_atual_p	
					and	nr_seq_analise		= nr_seq_analise_p
					and	coalesce(dt_liberacao::text, '') = ''		
					and	nr_seq_ordem 		= (	select	min(nr_seq_ordem)		 
										from	pls_auditoria_conta_grupo
										where	nr_seq_grupo 		= nr_seq_grupo_atual_p	
										and	nr_seq_analise		= nr_seq_analise_p
										and	coalesce(dt_liberacao::text, '') = ''	));

	CALL pls_gravar_inicio_fim_analise(nr_seq_analise_p, nr_seq_grupo_atual_p, 'F', nm_usuario_p);
	
	select	count(*)
	into STRICT	ie_existe_grupos_abertos_w
	from	pls_auditoria_conta_grupo a		
	where	a.nr_seq_analise = nr_seq_analise_p
	and	coalesce(a.dt_liberacao::text, '') = '';

	/*Fazer verificacao se existe grupos de analise ainda em aberto se nao houver  fechar a analise*/

	if (ie_existe_grupos_abertos_w = 0) then
		
		/*Obter o grupo responsavel por fechar a conta*/

		SELECT * FROM pls_obter_grupo_fechar_analise(nr_seq_analise_p, cd_estabelecimento_p, nr_seq_regra_w, nr_seq_grupo_w) INTO STRICT nr_seq_regra_w, nr_seq_grupo_w;
		
		if (coalesce(nr_seq_grupo_w,0) > 0) then
			ie_existe_grupo_final_w := 'S';
		
			/*obter se este grupo ja foi inserido na analise*/

			select	CASE WHEN count(nr_sequencia)=0 THEN 'N'  ELSE 'S' END
			into STRICT	ie_existe_final_anali_w
			from	pls_auditoria_conta_grupo
			where	nr_seq_grupo = nr_seq_grupo_w
			and	nr_seq_analise = nr_seq_analise_p;
		else		
			/*Caso nao haja regra de grupo de finalizacao*/

			ie_existe_grupo_final_w := 'N';
		end if;	
		
		/*Se nao existe grupo de finalizacao na analise esta eh encerrada*/

		if (ie_existe_grupo_final_w = 'N') then		
			update	pls_analise_conta
			set	dt_liberacao_analise	= clock_timestamp(),
				ie_status 		= 'L',
				dt_final_analise	= clock_timestamp()
			where	nr_sequencia = nr_seq_analise_p;
		else			
			/*Se o grupo de finalizacao existir na analise.*/

			if (ie_existe_final_anali_w = 'S') then
				select	count(nr_sequencia)
				into STRICT	qt_grupos_analise_w
				from	pls_auditoria_conta_grupo
				where	nr_seq_analise = nr_seq_analise_p;
				
				/*Se existir mais de uma grupo de analise*/

				if (qt_grupos_analise_w > 1) and (pls_obter_se_auditor_grupo(nr_seq_grupo_w, nm_usuario_p) = 'N') then
					/*Se o grupo de finalizacao existir na analise entao seu sua liberacao e desfeita. Permitindo que o mesmo se torne o fluxo da vez. */

					CALL pls_desf_final_grupo_analise(nr_seq_analise_p, nr_seq_grupo_w, null, nm_usuario_p, cd_estabelecimento_p,'N');
				else
					/*Se existir somente o grupo do auditor entao e liberado a analise.*/

					update	pls_analise_conta
					set	dt_liberacao_analise	= clock_timestamp(),
						ie_status = 'L',
						dt_final_analise	= clock_timestamp()
					where	nr_sequencia = nr_seq_analise_p;
				end if;
			else
				/*Se o grupo de finalizacao nao existir na analise este eh acrescentado*/

				CALL pls_inserir_grupo_analise(nr_seq_analise_p, nr_seq_grupo_w, 'Grupo inserido atrav?s da regra de finaliza??o '||nr_seq_regra_w,
							nr_seq_grupo_atual_p, 'N', nm_usuario_p, cd_estabelecimento_p);
			end if;
		end if;
				
	end if;		
	
	/* Atualizar a discussao */

	index_w := 0;
	for c01_w in c01( nr_seq_analise_p, nr_id_transacao_p) loop
		
		if (c01_w.nr_seq_proc_rec IS NOT NULL AND c01_w.nr_seq_proc_rec::text <> '') then
		
			select	max(nr_sequencia)
			into STRICT	nr_seq_parecer_w
			from	pls_analise_parecer_rec
			where	nr_seq_proc_rec	= c01_w.nr_seq_proc_rec
			and	(ds_parecer IS NOT NULL AND ds_parecer::text <> '');
			
			select	max(ds_parecer)
			into STRICT	ds_parecer_w
			from	pls_analise_parecer_rec
			where	nr_sequencia	= nr_seq_parecer_w;
			
			update	pls_rec_glosa_proc
			set	ds_justificativa_oper	= substr(ds_parecer_w,1,150)
			where	nr_sequencia		= c01_w.nr_seq_proc_rec;
		
		elsif (c01_w.nr_seq_mat_rec IS NOT NULL AND c01_w.nr_seq_mat_rec::text <> '') then
		
			select	max(nr_sequencia)
			into STRICT	nr_seq_parecer_w
			from	pls_analise_parecer_rec
			where	nr_seq_mat_rec	= c01_w.nr_seq_mat_rec
			and	(ds_parecer IS NOT NULL AND ds_parecer::text <> '');
			
			select	max(ds_parecer)
			into STRICT	ds_parecer_w
			from	pls_analise_parecer_rec
			where	nr_sequencia	= nr_seq_parecer_w;
			
			update	pls_rec_glosa_mat
			set	ds_justificativa_oper	= substr(ds_parecer_w,1,150)
			where	nr_sequencia		= c01_w.nr_seq_mat_rec;
			
		end if;
		
		if (c01_w.nr_seq_conta_rec IS NOT NULL AND c01_w.nr_seq_conta_rec::text <> '') then
		
			select	max(nr_sequencia)
			into STRICT	nr_seq_parecer_w
			from	pls_analise_parecer_rec
			where	nr_seq_conta_rec	= c01_w.nr_seq_conta_rec
			and	(ds_parecer IS NOT NULL AND ds_parecer::text <> '');
			
			select	max(ds_parecer)
			into STRICT	ds_parecer_w
			from	pls_analise_parecer_rec
			where	nr_sequencia	= nr_seq_parecer_w;
			
			update	pls_rec_glosa_conta
			set	ds_justificativa_oper	= substr(ds_parecer_w,1,150)
			where	nr_sequencia		= c01_w.nr_seq_conta_rec;
			
		end if;
					
		t_contas_w(index_w) := c01_w.nr_seq_conta_rec;
		index_w := index_w + 1;
		nr_seq_ultima_conta_w := c01_w.nr_seq_conta;
	end loop;
	
	select	count(1)
	into STRICT	qt_grupo_pend_w
	from	pls_auditoria_conta_grupo
	where	nr_seq_analise = nr_seq_analise_p
	and	coalesce(dt_liberacao::text, '') = '';	
	
	if (qt_grupo_pend_w > 0) then
		CALL pls_alterar_status_analise_cta(nr_seq_analise_p, 'A', 'PLS_FINALIZAR_ANALISE_RECURSO', nm_usuario_p, cd_estabelecimento_p);
	elsif (ie_encerrar_analise_p = 'S') then -- Se o paranetro permitir, encerra a analise
		CALL pls_alterar_status_analise_cta(nr_seq_analise_p, 'T', 'PLS_FINALIZAR_ANALISE_RECURSO', nm_usuario_p, cd_estabelecimento_p);
	end if;
	
	select	max(ie_status)
	into STRICT	ie_status_analise_w
	from	pls_analise_conta
	where	nr_sequencia	= nr_seq_analise_p;
	
	-- Somente ira fechar as contas de recurso, caso a analise esteja encerrada. OS 1063216 - aedemuth
	if (ie_status_analise_w in ('T','L')) then
		-- Fechar conta recurso de glosa 
		
			ds_observacao_w := ds_observacao_w||' Fez chamada para a pls_fechar_rec_glosa_conta. ';
			for r_c02_w in C02(nr_seq_analise_p, nr_id_transacao_p) loop				
				CALL pls_fechar_rec_glosa_conta( r_c02_w.nr_seq_conta_rec, null, nm_usuario_p, cd_estabelecimento_p, ie_encaminha_prot_p );
			end loop;

	end if;
	
	CALL pls_inserir_hist_analise(null, nr_seq_analise_p, 7, null, null, null, null, null, nr_seq_grupo_atual_p, nm_usuario_p, cd_estabelecimento_p);
end if;

CALL pls_atualizar_grupo_penden(nr_seq_analise_p, cd_estabelecimento_p, nm_usuario_p);

--Apenas pega esse seq de conta para guardar o log na tabela plsprco
if ( coalesce(nr_seq_ultima_conta_w::text, '') = '') then
	select	max(nr_seq_conta)
	into STRICT	nr_seq_ultima_conta_w
	from	pls_analise_conta_rec a
	where	a.nr_seq_analise	= nr_seq_analise_p;	
end if;


ds_observacao_w := ds_observacao_w||' nr_seq_grupo_atual_p= '||nr_seq_grupo_atual_p||
		'nr_id_transacao_p= '||nr_id_transacao_p||' ie_encaminha_prot_p = '||ie_encaminha_prot_p;
			
--salvando log na tabela de conta, atraves da conta origem	
if (nr_seq_ultima_conta_w IS NOT NULL AND nr_seq_ultima_conta_w::text <> '')	then

	ds_log_call_w := substr(pls_obter_detalhe_exec(false),1,1500);
	insert into plsprco_cta( 	nr_sequencia, dt_atualizacao, nm_usuario,
					dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
					ds_log, ds_log_call, ds_funcao_ativa, 
					ie_aplicacao_tasy, nm_maquina, ie_opcao,
					nr_seq_conta)
			values ( 	nextval('plsprco_cta_seq'), clock_timestamp(), substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuario nao identificado '),1,14),
					clock_timestamp(), substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuario nao identificado '),1,14), 'PLS_CONTA', 
					ds_observacao_w, ds_log_call_w, obter_funcao_ativa, 
					pls_se_aplicacao_tasy, wheb_usuario_pck.get_machine, CASE WHEN coalesce(wheb_usuario_pck.get_nm_usuario::text, '') = '' THEN  1  ELSE 2 END ,
					nr_seq_ultima_conta_w);
						
end if;					

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_finalizar_analise_recurso (nr_seq_analise_p pls_analise_conta.nr_sequencia%type, nr_id_transacao_p pls_analise_conta_rec.nr_id_transacao%type, nr_seq_grupo_atual_p pls_grupo_auditor.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, ie_encerrar_analise_p text default 'N', ie_encaminha_prot_p text default 'N') FROM PUBLIC;

