-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE atualizar_repasse_retorno ( NR_SEQ_RETORNO_P bigint, NM_USUARIO_P text) AS $body$
DECLARE


dt_retorno_w			timestamp;
nr_seq_ret_item_w			bigint;
nr_interno_conta_w			bigint;
cd_autorizacao_w			varchar(20);
ie_libera_repasse_w		varchar(5);
vl_pago_w			double precision;
vl_glosado_w			double precision;
vl_guia_w			double precision;
vl_amenor_w			double precision;
vl_item_original_w			double precision;
nr_seq_repasse_w			bigint;
vl_repasse_w			double precision;
nr_seq_proc_w			bigint;
nr_seq_mat_w			bigint;
vl_glosa_repasse_w		double precision;
ie_status_retorno_w			varchar(1);
ie_existe_regra_w			smallint;
vl_pago_total_w			double precision;
vl_glosa_w			double precision;
vl_pendente_w			double precision;
vl_cobrado_w			double precision;
vl_glosa_item_w			double precision;
pr_glosa_w			double precision;
vl_adicional_w			double precision;
pr_adicional_w			double precision;
pr_amenor_w			double precision;
ie_repasse_amenor_audit_w		varchar(1);
ie_lib_rep_item_w			varchar(2);
ie_adicional_retorno_w		varchar(2);
ie_ratear_adicional_w		varchar(1);
vl_amaior_w			double precision;
ie_acao_glosa_w			varchar(1);
valor_soma_amenor_w		double precision;
valor_soma_glosado_w		double precision;
ie_glosar_valor_fixo_w		varchar(255);
nr_seq_repasse_atual_w		bigint;
vl_repasse_calc_w			double precision;
cd_estabelecimento_w		smallint;
valor_amenor_w			double precision	:= 0;
valor_glosado_w			double precision	:= 0;
ie_libera_repasse_ret_w		varchar(1)	:= 'S';
nr_seq_proc_rep_novo_w		bigint	:= null;
nr_seq_mat_rep_novo_w		bigint	:= null;
ie_status_retorno_param_w		varchar(2)	:= 'U';
ie_repasse_ret_orig_w		varchar(1)	:= 'R';
ie_repasse_maior_w		varchar(255)	:= 'L';
qt_mat_repasse_w			bigint	:= 0;
qt_proced_repasse_w		bigint	:= 0;

C01 CURSOR FOR
SELECT 	a.nr_sequencia,
	a.nr_interno_conta,
	a.cd_autorizacao,
	a.ie_libera_repasse,
	a.vl_pago,
	CASE WHEN a.ie_glosa='S' THEN  a.vl_glosado  ELSE 0 END ,
	a.vl_amenor,
	b.vl_guia,
	coalesce(a.vl_adicional,0)
from 	conta_paciente_guia b,
	convenio_retorno_item a
where 	a.nr_interno_conta		= b.nr_interno_conta
and 	a.cd_autorizacao		= b.cd_autorizacao
and 	a.nr_seq_retorno		= nr_seq_retorno_p
and	a.ie_libera_repasse	<> 'U'
order  by	2, 3;

C02 CURSOR FOR
SELECT	b.nr_seq_procedimento,
	b.nr_sequencia,
	b.vl_repasse,
	0 vl_glosado,
	a.vl_procedimento,
	to_char(null) ie_acao_glosa,
	a.vl_repasse_calc
from	procedimento_repasse b,
	procedimento_paciente a
where	a.nr_sequencia				= b.nr_seq_procedimento
and	a.nr_interno_conta				= nr_interno_conta_w
and	coalesce(a.nr_doc_convenio, cd_autorizacao_w)	= cd_autorizacao_w
and	ie_lib_rep_item_w				= 'N'
and	b.ie_status				= 'A'
and	((obter_se_criterio_valor_fixo(a.nr_seq_proc_crit_repasse, null) = 'N')
	 or (ie_glosar_valor_fixo_w = 'N'))

union	all

select	b.nr_seq_procedimento,
	b.nr_sequencia,
	b.vl_repasse,
	x.vl_glosa,
	coalesce(x.vl_cobrado,a.vl_procedimento), /* Francisco - OS 175062 - 30/11/09 - Tive que tratar pelo valor cobrado, */
	coalesce(x.ie_acao_glosa,y.ie_acao_glosa),    /* pois quando informado por participante, é utilizado o vl medico e não grava nr_seq_partic */
	a.vl_repasse_calc
FROM convenio_retorno_item c, procedimento_repasse b, procedimento_paciente a, convenio_retorno_glosa x
LEFT OUTER JOIN motivo_glosa y ON (x.cd_motivo_glosa = y.cd_motivo_glosa)
WHERE a.nr_sequencia				= b.nr_seq_procedimento and a.nr_sequencia				= x.nr_seq_propaci and x.nr_seq_ret_item				= c.nr_sequencia  and a.nr_interno_conta				= nr_interno_conta_w and coalesce(a.nr_doc_convenio, cd_autorizacao_w)	= cd_autorizacao_w and coalesce(x.cd_pessoa_fisica,coalesce(b.cd_medico,'X'))	= coalesce(b.cd_medico,'X') /* Francisco - 185233 - 17/12/2009 - Para o medico principal */
  and x.vl_glosa				<> 0 and ie_lib_rep_item_w				= 'S' /* OS 122341 - Liberar repasse por ítem */
  and b.ie_status				= 'A' and coalesce(x.nr_seq_partic::text, '') = '' /* Francisco - OS 137396 - 30/09/2009 */
  and (coalesce(b.nr_seq_partic::text, '') = '' or not exists (select	1
						from	convenio_retorno_glosa z
						where	z.nr_seq_propaci = a.nr_sequencia
						and	(z.nr_seq_partic IS NOT NULL AND z.nr_seq_partic::text <> ''))) /* Francisco - OS 175062 - 30/11/09 - Fiz essa restricao
											para os casos onde foi informado o medico principal por participante */
  and ((obter_se_criterio_valor_fixo(a.nr_seq_proc_crit_repasse, null) = 'N') or (ie_glosar_valor_fixo_w = 'N')) and c.nr_seq_retorno	= NR_SEQ_RETORNO_P /* Francisco - OS 137396 - 30/09/2009 - Nao considerar itens glosados de outro retorno */
union all

/* Francisco - OS 137396 - 30/09/2009  - Separei em 2 selects para tratar participantes */

select	b.nr_seq_procedimento,
	b.nr_sequencia,
	b.vl_repasse,
	x.vl_glosa,
	coalesce(c.vl_participante,a.vl_procedimento),
	coalesce(x.ie_acao_glosa,y.ie_acao_glosa),
	c.vl_repasse_calc
FROM convenio_retorno_item d, procedimento_participante c, procedimento_repasse b, procedimento_paciente a, convenio_retorno_glosa x
LEFT OUTER JOIN motivo_glosa y ON (x.cd_motivo_glosa = y.cd_motivo_glosa)
WHERE a.nr_sequencia				= b.nr_seq_procedimento and a.nr_sequencia				= x.nr_seq_propaci and c.nr_sequencia				= a.nr_sequencia and c.nr_seq_partic				= x.nr_seq_partic and x.nr_seq_partic				= b.nr_seq_partic and x.nr_seq_ret_item				= d.nr_sequencia  and a.nr_interno_conta				= nr_interno_conta_w and coalesce(a.nr_doc_convenio, cd_autorizacao_w)	= cd_autorizacao_w and x.vl_glosa		<> 0 and ie_lib_rep_item_w	= 'S' /* OS 122341 - Liberar repasse por ítem */
  and b.ie_status		= 'A' and (x.nr_seq_partic IS NOT NULL AND x.nr_seq_partic::text <> '') and ((obter_se_criterio_valor_fixo(a.nr_seq_proc_crit_repasse, null) = 'N') or (ie_glosar_valor_fixo_w = 'N')) and d.nr_seq_retorno	= NR_SEQ_RETORNO_P /*Francisco - OS 137396 - 30/09/2009 -  Nao considerar itens glosados de outro retorno */
 
union	all

select	b.nr_seq_procedimento,
		b.nr_sequencia,
		b.vl_repasse,
		0 vl_glosa,
		a.vl_procedimento,
		to_char(null) ie_acao_glosa,
		a.vl_repasse_calc
from	procedimento_repasse b,
		procedimento_paciente a
where	a.nr_sequencia		= b.nr_seq_procedimento
and	not exists (select 1
			from	convenio_retorno_glosa x
			where	x.nr_seq_propaci = a.nr_sequencia
			and 	x.vl_glosa <> 0
			and	coalesce(x.cd_pessoa_fisica,coalesce(b.cd_medico,'X')) = coalesce(b.cd_medico,'X')
			and (x.nr_seq_partic = b.nr_seq_partic or coalesce(x.nr_seq_partic::text, '') = '')  /* Francisco - OS 169464 - 11/11/2009 */
			and	x.nr_seq_ret_item	= nr_seq_ret_item_w)
			/* OS 122341 - Liberar repasse por ítem */

and		a.nr_interno_conta	= nr_interno_conta_w
and		coalesce(a.nr_doc_convenio, cd_autorizacao_w) = cd_autorizacao_w
and		ie_lib_rep_item_w	= 'S'
and		b.ie_status		= 'A'
and		((obter_se_criterio_valor_fixo(a.nr_seq_proc_crit_repasse, null) = 'N') or (ie_glosar_valor_fixo_w = 'N'))

union	all

select	d.nr_seq_procedimento,
		d.nr_sequencia,
		d.vl_repasse,
		c.vl_glosa,
		e.vl_procedimento,
		to_char(null) ie_acao_glosa,
		e.vl_repasse_calc
from	procedimento_paciente e,
		procedimento_repasse d,
		convenio_retorno_glosa c,
		convenio_retorno_item b,
		convenio_retorno a

where	e.nr_sequencia		= c.nr_seq_propaci
and		c.nr_seq_ret_item	= b.nr_sequencia
and		b.nr_seq_retorno	= a.nr_sequencia
and		e.nr_sequencia		= d.nr_seq_procedimento
and		e.nr_interno_conta	= nr_interno_conta_w
and		coalesce(e.nr_doc_convenio,cd_autorizacao_w)		= cd_autorizacao_w
and		d.ie_status		= 'D'
and		((obter_se_criterio_valor_fixo(e.nr_seq_proc_crit_repasse, null) = 'N') or (ie_glosar_valor_fixo_w = 'N'))
and		a.nr_sequencia		<> nr_seq_retorno_p;

C03 CURSOR FOR
SELECT	b.nr_seq_material,
		b.nr_sequencia,
		b.vl_repasse,
		0 vl_glosa,
		a.vl_material,
		to_char(null) ie_acao_glosa,
		a.vl_repasse_calc
from	material_repasse b,
		material_atend_paciente a
where	a.nr_sequencia		= b.nr_seq_material
and		a.nr_interno_conta	= nr_interno_conta_w
and		coalesce(a.nr_doc_convenio,cd_autorizacao_w)		= cd_autorizacao_w
and		b.ie_status		= 'A'
and		ie_lib_rep_item_w	= 'N'

union	all

select	b.nr_seq_material,
	b.nr_sequencia,
	b.vl_repasse,
	c.vl_glosa,
	a.vl_material,
	coalesce(c.ie_acao_glosa,d.ie_acao_glosa),
	a.vl_repasse_calc
FROM convenio_retorno_item e, material_repasse b, material_atend_paciente a, convenio_retorno_glosa c
LEFT OUTER JOIN motivo_glosa d ON (c.cd_motivo_glosa = d.cd_motivo_glosa)
WHERE a.nr_sequencia		= b.nr_seq_material and a.nr_sequencia		= c.nr_seq_matpaci and c.nr_seq_ret_item	= e.nr_sequencia  and c.vl_glosa		<> 0 and a.nr_interno_conta	= nr_interno_conta_w and coalesce(a.nr_doc_convenio,cd_autorizacao_w)		= cd_autorizacao_w and b.ie_status		= 'A' and ie_lib_rep_item_w	= 'S' /* OS 122341 - Liberar repasse por ítem */
  and ((obter_se_criterio_valor_fixo(null, a.nr_seq_mat_crit_repasse) = 'N') or (ie_glosar_valor_fixo_w = 'N')) and e.nr_seq_retorno	= nr_seq_retorno_p /*Francisco - OS 137396 - 30/09/2009 -  Nao considerar itens glosados de outro retorno */
union	all

select	b.nr_seq_material,
	b.nr_sequencia,
	b.vl_repasse,
	0 vl_glosa,
	a.vl_material,
	to_char(null) ie_acao_glosa,
	a.vl_repasse_calc
from	material_repasse b,
	material_atend_paciente a
where	a.nr_sequencia		= b.nr_seq_material
and	a.nr_interno_conta	= nr_interno_conta_w
and	coalesce(a.nr_doc_convenio,cd_autorizacao_w)		= cd_autorizacao_w
and	not exists (select 1 from convenio_retorno_glosa x where x.nr_seq_matpaci = a.nr_sequencia and x.vl_glosa <> 0) 	/* OS 122341 - Liberar repasse por ítem */
and	b.ie_status		= 'A'
and	ie_lib_rep_item_w	= 'S'
and		((obter_se_criterio_valor_fixo(null, a.nr_seq_mat_crit_repasse) = 'N') or (ie_glosar_valor_fixo_w = 'N'))

union	all

select	d.nr_seq_material,
	d.nr_sequencia,
	d.vl_repasse,
	c.vl_glosa,
	e.vl_material,
	to_char(null) ie_acao_glosa,
	e.vl_repasse_calc
from	material_atend_paciente e,
	material_repasse d,
	convenio_retorno_glosa c,
	convenio_retorno_item b,
	convenio_retorno a

where	e.nr_sequencia		= c.nr_seq_matpaci
and	c.nr_seq_ret_item	= b.nr_sequencia
and	b.nr_seq_retorno	= a.nr_sequencia
and	e.nr_sequencia		= d.nr_seq_material
and	e.nr_interno_conta	= nr_interno_conta_w
and	coalesce(e.nr_doc_convenio,cd_autorizacao_w)		= cd_autorizacao_w
and	d.ie_status		= 'D'
and		((obter_se_criterio_valor_fixo(null, e.nr_seq_mat_crit_repasse) = 'N') or (ie_glosar_valor_fixo_w = 'N'))
and	a.nr_sequencia		<> nr_seq_retorno_p;

C04 CURSOR FOR
SELECT	nr_seq_propaci,
	nr_seq_matpaci,
	vl_glosa,
	vl_amaior
from	convenio_retorno_glosa
where	nr_seq_ret_item = nr_seq_ret_item_w
and ((nr_seq_propaci IS NOT NULL AND nr_seq_propaci::text <> '') or (nr_seq_matpaci IS NOT NULL AND nr_seq_matpaci::text <> ''));

C05 CURSOR FOR
SELECT  b.nr_sequencia,
	b.vl_repasse
from	regra_repasse_terceiro c,
	procedimento_repasse b
where	b.cd_regra		= c.cd_regra
and	c.ie_acao_glosa 	= 'R'
and	b.ie_status		= 'A'
and	b.nr_seq_procedimento	= nr_seq_proc_w

UNION ALL

select	d.nr_sequencia,
	d.vl_repasse
from	procedimento_repasse d,
	convenio_retorno_glosa c,
	convenio_retorno_item b,
	convenio_retorno a
where	d.nr_seq_ret_glosa	= c.nr_sequencia
and	c.nr_seq_ret_item	= b.nr_sequencia
and	b.nr_seq_retorno	= a.nr_sequencia
and	d.ie_status		= 'D'
and	d.nr_seq_procedimento	= nr_seq_proc_w
and	a.nr_sequencia		<> nr_seq_retorno_p;

C06 CURSOR FOR
SELECT	b.nr_sequencia,
	b.vl_repasse
from	regra_repasse_terceiro c,
	material_repasse b
where	b.cd_regra		= c.cd_regra
and	c.ie_acao_glosa 	= 'R'
and	b.ie_status		= 'A'
and	b.nr_seq_material	= nr_seq_mat_w

union all

select	d.nr_sequencia,
	d.vl_repasse
from	material_repasse d,
	convenio_retorno_glosa c,
	convenio_retorno_item b,
	convenio_retorno a
where	d.nr_seq_ret_glosa	= c.nr_sequencia
and	c.nr_seq_ret_item	= b.nr_sequencia
and	b.nr_seq_retorno	= a.nr_sequencia
and	d.ie_status		= 'D'
and	d.nr_seq_material	= nr_seq_mat_w
and	a.nr_sequencia		<> nr_seq_retorno_p;


BEGIN

select	CASE WHEN b.ie_data_lib_repasse_ret='F' THEN coalesce(a.dt_baixa_cr, a.dt_fechamento) WHEN b.ie_data_lib_repasse_ret='R' THEN a.dt_retorno WHEN b.ie_data_lib_repasse_ret='E' THEN  a.dt_fechamento END ,
	b.ie_adicional_retorno,
	CASE WHEN b.ie_repasse_amenor_audit='S' THEN 'D'  ELSE 'U' END ,
	coalesce(B.ie_lib_rep_item, 'N'),
	a.cd_estabelecimento
into STRICT	dt_retorno_w,
	ie_adicional_retorno_w,
	ie_repasse_amenor_audit_w,
	ie_lib_rep_item_w,
	cd_estabelecimento_w
from	parametro_faturamento b,
	convenio_retorno a
where	a.nr_sequencia		= nr_seq_retorno_p
and	a.cd_estabelecimento	= b.cd_estabelecimento;

select	coalesce(max(ie_libera_repasse_ret),'S'),
	coalesce(max(ie_status_retorno),'U'),
	coalesce(max(ie_repasse_ret_orig),'R'),
	coalesce(max(ie_repasse_maior),'L')
into STRICT	ie_libera_repasse_ret_w,
	ie_status_retorno_param_w,
	ie_repasse_ret_orig_w,
	ie_repasse_maior_w
from	parametro_repasse
where	cd_estabelecimento	= cd_estabelecimento_w;

/* Francisco - OS 176801 - 12/11/2009 */

if (ie_status_retorno_param_w = 'A') then
	ie_repasse_amenor_audit_w	:= 'A';
end if;

ie_glosar_valor_fixo_w := obter_param_usuario(27, 130, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_glosar_valor_fixo_w);

open C01;
loop
fetch C01 into
	nr_seq_ret_item_w,
	nr_interno_conta_w,
	cd_autorizacao_w,
	ie_libera_repasse_w,
	vl_pago_w,
	vl_glosado_w,
	vl_amenor_w,
	vl_guia_w,
	vl_adicional_w;
EXIT WHEN NOT FOUND; /* apply on C01 */

	pr_glosa_w		:= 0;
	pr_adicional_w		:= 0;
	pr_amenor_w		:= 0;
	valor_glosado_w 	:= 0;
	valor_amenor_w 		:= 0;

	select 	coalesce(sum(vl_repasse),0)
	into STRICT 	vl_glosa_repasse_w
	from (SELECT coalesce(sum(vl_repasse),0) vl_repasse
		from procedimento_repasse
		where nr_seq_ret_glosa in (	select nr_sequencia
						from convenio_retorno_glosa
						where nr_seq_ret_item = nr_seq_ret_item_w)
		
union all

		SELECT coalesce(sum(vl_repasse),0)
		from material_repasse
		where nr_seq_ret_glosa in (	select nr_sequencia
						from convenio_retorno_glosa
						where nr_seq_ret_item = nr_seq_ret_item_w)) alias8;

	ie_status_retorno_w := 'U';

	select  sum(a.vl_pago)
	into STRICT	vl_pago_total_w
	from 	convenio_retorno_item a,
		convenio_retorno b
	where 	nr_interno_conta	= nr_interno_conta_w
	and	a.nr_seq_retorno	= b.nr_sequencia
	and 	((ie_status_retorno	= 'F') or (nr_seq_retorno = nr_seq_retorno_p))
	and	cd_autorizacao	 	= cd_autorizacao_w;

	/* se o valor pago for igual ao valor da guia (pagamento total), o repasse deve ser liberado */

	if (ie_libera_repasse_w <> 'N' or (vl_pago_total_w >= vl_guia_w and ie_libera_repasse_ret_w = 'S')) and
		(vl_pago_total_w	>= vl_guia_w or
		vl_pago_w		>= vl_guia_w or
		ie_libera_repasse_w	= 'S' or
		(
		(vl_amenor_w + vl_glosado_w) > 0 and
		(vl_glosa_repasse_w = (vl_amenor_w + vl_glosado_w) or
		ie_libera_repasse_w = 'G')
		)) then

		ie_status_retorno_w := 'R';

	elsif (vl_glosado_w >= vl_guia_w) then

		ie_status_retorno_w := 'G';		-- glosado
	end if;

	if (vl_adicional_w > 0) then

		select	coalesce(sum(coalesce(vl_amaior,0)),0)
		into STRICT	vl_amaior_w
		from	convenio_retorno_glosa
		where	nr_seq_ret_item		= nr_seq_ret_item_w;

		if (vl_amaior_w > 0) and (vl_amaior_w <> vl_adicional_w) then

			/* O valor adicional informado na guia da conta não bate com o valor lançado nos itens adicionais da guia!
			Conta: nr_interno_conta_w
			Autorização: cd_autorizacao_w */
			CALL wheb_mensagem_pck.exibir_mensagem_abort(187072,
							'NR_INTERNO_CONTA_W='||nr_interno_conta_w||';'||
							'CD_AUTORIZACAO_W='||cd_autorizacao_w);
		end if;

	end if;

	if (ie_status_retorno_w = 'U') and (ie_libera_repasse_ret_w = 'S') then

		select	count(*)
		into STRICT	ie_existe_regra_w
		from	regra_repasse_terceiro
		where	ie_acao_glosa = 'R';

		if (ie_existe_regra_w > 0) then
			open C04;
			loop
			fetch C04 into
				nr_seq_proc_w,
				nr_seq_mat_w,
				vl_glosa_w,
				vl_amaior_w;
			EXIT WHEN NOT FOUND; /* apply on C04 */

				if (nr_seq_proc_w IS NOT NULL AND nr_seq_proc_w::text <> '') then

					select	sum(vl_repasse),
						sum(CASE WHEN ie_status='A' THEN  vl_repasse  ELSE 0 END ),
						sum(distinct vl_procedimento)
					into STRICT	vl_repasse_w,
						vl_pendente_w,
						vl_cobrado_w
					from	regra_repasse_terceiro c,
						procedimento_repasse b,
						procedimento_paciente a
					where	a.nr_sequencia		= b.nr_seq_procedimento
					and	b.cd_regra		= c.cd_regra
					and	c.ie_acao_glosa 	= 'R'
					and	a.nr_sequencia		= nr_seq_proc_w;

					if (vl_repasse_w = vl_pendente_w) then



						pr_glosa_w	:= dividir_sem_round(vl_glosa_w,vl_cobrado_w);
						pr_adicional_w := dividir_sem_round(vl_amaior_w,vl_amaior_w);

						open c05;
						loop
						fetch C05 into
							nr_seq_repasse_w,
							vl_repasse_w;
						EXIT WHEN NOT FOUND; /* apply on C05 */

							if (pr_glosa_w > 0) then
								update	procedimento_repasse
								set	nr_seq_item_retorno	= nr_seq_ret_item_w,
									vl_repasse		= vl_repasse - (vl_repasse * pr_glosa_w),
									vl_liberado		= vl_repasse - (vl_repasse * pr_glosa_w),
									ie_status		= 'R',
									dt_liberacao		= dt_retorno_w,
									nm_usuario		= nm_usuario_p,
									dt_atualizacao		= clock_timestamp(),
									nm_usuario_lib		= nm_usuario_p
								where	nr_sequencia		= nr_seq_repasse_w;

								SELECT * FROM desdobrar_procmat_repasse(nr_seq_repasse_w, null, 'G', (vl_repasse_w * pr_glosa_w), nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

							elsif (pr_adicional_w > 0) then -- Edgar 07/12/2005, OS 25323,
								--Liberar valor adicional por item
								update	procedimento_repasse
								set	nr_seq_item_retorno	= nr_seq_ret_item_w,
									ie_status		= 'R',
									dt_liberacao		= dt_retorno_w,
									nm_usuario		= nm_usuario_p,
									dt_atualizacao		= clock_timestamp(),
									nm_usuario_lib		= nm_usuario_p,
									vl_liberado		= CASE WHEN ie_repasse_maior_w='V' THEN  vl_repasse  ELSE vl_liberado END  -- afstringari 191885 03/02/2010
								where	nr_sequencia		= nr_seq_repasse_w;

								SELECT * FROM desdobrar_procmat_repasse(nr_seq_repasse_w, null, 'R', (vl_repasse_w * pr_adicional_w), nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

								update	procedimento_repasse
								set	nr_seq_item_retorno	= nr_seq_ret_item_w,
									ie_status		= 'R',
									dt_liberacao		= dt_retorno_w,
									nm_usuario		= nm_usuario_p,
									dt_atualizacao		= clock_timestamp(),
									nm_usuario_lib		= nm_usuario_p,
									vl_liberado		= vl_repasse
								where	nr_sequencia		= nr_seq_proc_rep_novo_w;

							end if;
						end loop;
						close c05;

					end if;
				else
					select	sum(vl_repasse),
						sum(CASE WHEN ie_status='A' THEN  vl_repasse  ELSE 0 END ),
						sum(vl_material)
					into STRICT	vl_repasse_w,
						vl_pendente_w,
						vl_cobrado_w
					from	regra_repasse_terceiro c,
						material_repasse b,
						material_atend_paciente a
					where	a.nr_sequencia		= b.nr_seq_material
					and	b.cd_regra		= c.cd_regra
					and	c.ie_acao_glosa 	= 'R'
					and	a.nr_sequencia		= nr_seq_mat_w;

					if (vl_repasse_w = vl_pendente_w) then

						pr_glosa_w := (vl_glosa_w / vl_cobrado_w);
						pr_adicional_w	:= (vl_amaior_w / vl_cobrado_w);

						open c06;
						loop
						fetch C06 into
							nr_seq_repasse_w,
							vl_repasse_w;
						EXIT WHEN NOT FOUND; /* apply on C06 */

							if (pr_glosa_w > 0) then
								update	material_repasse
								set	nr_seq_item_retorno = nr_seq_ret_item_w,
									vl_repasse	= vl_repasse - (vl_repasse * pr_glosa_w),
									vl_liberado	= vl_repasse - (vl_repasse * pr_glosa_w),
									ie_status	= 'R',
									dt_liberacao	= dt_retorno_w,
									nm_usuario	= nm_usuario_p,
									dt_atualizacao	= clock_timestamp(),
									nm_usuario_lib	= nm_usuario_p
								where	nr_sequencia	= nr_seq_repasse_w;

								SELECT * FROM desdobrar_procmat_repasse(null, nr_seq_repasse_w, 'G', (vl_repasse_w * pr_glosa_w), nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

							elsif (pr_adicional_w > 0) then -- Edgar 07/12/2005, OS 25323,
								--Liberar valor adicional por item
								update	material_repasse
								set	nr_seq_item_retorno = nr_seq_ret_item_w,
									ie_status	= 'R',
									dt_liberacao	= dt_retorno_w,
									nm_usuario	= nm_usuario_p,
									dt_atualizacao	= clock_timestamp(),
									nm_usuario_lib	= nm_usuario_p,
									vl_liberado	= CASE WHEN ie_repasse_maior_w='v' THEN  vl_repasse  ELSE vl_liberado END  -- afstringari 191885 03/02/2010
								where	nr_sequencia	= nr_seq_repasse_w;

								SELECT * FROM desdobrar_procmat_repasse(null, nr_seq_repasse_w, 'R', (vl_repasse_w * pr_adicional_w), nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

								update	material_repasse
								set	nr_seq_item_retorno = nr_seq_ret_item_w,
									ie_status	= 'R',
									dt_liberacao	= dt_retorno_w,
									nm_usuario	= nm_usuario_p,
									dt_atualizacao	= clock_timestamp(),
									nm_usuario_lib	= nm_usuario_p,
									vl_liberado	= vl_repasse
								where	nr_sequencia	= nr_seq_mat_rep_novo_w;

							end if;
						end loop;
						close c06;
					end if;
				end if;
			end loop;
			close C04;
		end if;
	else
		-- Edgar 07/12/2005, OS 25323, Liberar valor adicional por item // INÍCIO
		ie_ratear_adicional_w	:= 'S';
		if (ie_adicional_retorno_w = 'S') then


			open C04;
			loop
			fetch C04 into
				nr_seq_proc_w,
				nr_seq_mat_w,
				vl_glosa_w,
				vl_amaior_w;
			EXIT WHEN NOT FOUND; /* apply on C04 */


				if (coalesce(vl_amaior_w, 0) > 0) then

					ie_ratear_adicional_w		:= 'N';		-- Só fazer o rateio se não ratear por item
					if (nr_seq_proc_w IS NOT NULL AND nr_seq_proc_w::text <> '') then

						select	count(*)
						into STRICT	qt_proced_repasse_w
						from	procedimento_repasse b,
							procedimento_paciente a
						where	a.nr_sequencia		= b.nr_seq_procedimento
						and	b.nr_seq_procedimento	= nr_seq_proc_w;

						if (coalesce(qt_proced_repasse_w,0) > 0) then

							select	max(a.vl_procedimento)
							into STRICT	vl_cobrado_w
							from	procedimento_paciente a
							where	exists (SELECT	1
								from	regra_repasse_terceiro c,
									procedimento_repasse b
								where	c.ie_acao_glosa		= 'R'
								and	b.cd_regra		= c.cd_regra
								and	b.nr_seq_procedimento	= a.nr_sequencia)
							and	a.nr_sequencia		= nr_seq_proc_w;

							if (coalesce(vl_cobrado_w,0)	<> 0) then

								pr_adicional_w	:= (vl_amaior_w / vl_cobrado_w);

								if (pr_adicional_w > 0) then
									open c05;
									loop
									fetch C05 into
										nr_seq_repasse_w,
										vl_repasse_w;
									EXIT WHEN NOT FOUND; /* apply on C05 */

										update	procedimento_repasse
										set	nr_seq_item_retorno	= nr_seq_ret_item_w,
											ie_status		= 'R',
											dt_liberacao		= dt_retorno_w,
											nm_usuario		= nm_usuario_p,
											dt_atualizacao		= clock_timestamp(),
											nm_usuario_lib		= nm_usuario_p,
											vl_liberado		= CASE WHEN ie_repasse_maior_w='V' THEN  vl_repasse  ELSE vl_liberado END  -- afstringari 191885 03/02/2010
										where	nr_sequencia		= nr_seq_repasse_w;

										SELECT * FROM desdobrar_procmat_repasse(nr_seq_repasse_w, null, 'R', (vl_repasse_w * pr_adicional_w), nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

										update	procedimento_repasse
										set	nr_seq_item_retorno	= nr_seq_ret_item_w,
											ie_status		= 'R',
											dt_liberacao		= dt_retorno_w,
											nm_usuario		= nm_usuario_p,
											dt_atualizacao		= clock_timestamp(),
											nm_usuario_lib		= nm_usuario_p,
											vl_liberado		= vl_repasse
										where	nr_sequencia		= nr_seq_proc_rep_novo_w;

									end loop;
									close c05;

								end if;

							end if;
						end if;
					else

						select	count(*)
						into STRICT	qt_mat_repasse_w
						from	procedimento_repasse
						where	nr_seq_procedimento	= nr_seq_mat_w;

						if (coalesce(qt_mat_repasse_w,0) > 0) then

							select	max(a.vl_material)
							into STRICT	vl_cobrado_w
							from	material_atend_paciente a
							where	exists (SELECT	1
								from	regra_repasse_terceiro c,
									material_repasse b
								where	a.nr_sequencia		= b.nr_seq_material
								and	b.cd_regra		= c.cd_regra
								and	c.ie_acao_glosa 	= 'R')
							and	a.nr_sequencia		= nr_seq_mat_w;

							if (coalesce(vl_cobrado_w,0)	<> 0) then

								pr_adicional_w	:= (vl_amaior_w / vl_cobrado_w);

								if (pr_adicional_w > 0) then
									open c06;
									loop
									fetch C06 into
										nr_seq_repasse_w,
										vl_repasse_w;
									EXIT WHEN NOT FOUND; /* apply on C06 */

										update	material_repasse
										set	nr_seq_item_retorno = nr_seq_ret_item_w,
											ie_status	= 'R',
											dt_liberacao	= dt_retorno_w,
											nm_usuario	= nm_usuario_p,
											dt_atualizacao	= clock_timestamp(),
											nm_usuario_lib	= nm_usuario_p,
											vl_liberado	= CASE WHEN ie_repasse_maior_w='v' THEN  vl_repasse  ELSE vl_liberado END  -- afstringari 191885 03/02/2010
										where	nr_sequencia	= nr_seq_repasse_w;

										SELECT * FROM desdobrar_procmat_repasse(null, nr_seq_repasse_w, 'R', (vl_repasse_w * pr_adicional_w), nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

										update	material_repasse
										set	nr_seq_item_retorno = nr_seq_ret_item_w,
											ie_status	= 'R',
											dt_liberacao	= dt_retorno_w,
											nm_usuario	= nm_usuario_p,
											dt_atualizacao	= clock_timestamp(),
											nm_usuario_lib	= nm_usuario_p,
											vl_liberado	= vl_repasse
										where	nr_sequencia	= nr_seq_mat_rep_novo_w;

									end loop;
									close c06;

								end if;
							end if;
						end if;
					end if;
				end if;
			end loop;
			close C04;
		end if;
		-- Edgar 07/12/2005, OS 25323, Liberar valor adicional por item // FIM
		pr_glosa_w			:= 0;
		pr_adicional_w			:= 0;
		pr_amenor_w			:= 0;



		if (ie_lib_rep_item_w	= 'N') then
			if (ie_libera_repasse_w = 'G') then
				if (vl_glosado_w > 0) then
					pr_glosa_w	:= dividir_sem_round(vl_glosado_w, vl_guia_w);
				end if;
				if (vl_amenor_w > 0) then
					pr_amenor_w	:= dividir_sem_round(vl_amenor_w, vl_guia_w);
				elsif (ie_ratear_adicional_w = 'S') and (vl_adicional_w > 0) then
					pr_adicional_w	:= dividir_sem_round(vl_adicional_w, vl_guia_w);
				end if;
			end if;
		end if;




		valor_soma_amenor_w	:= 0;
		valor_soma_glosado_w	:= 0;
		nr_seq_repasse_atual_w	:= null;

		open C02;
		loop
		fetch C02 into
			nr_seq_proc_w,
			nr_seq_repasse_w,
			vl_repasse_w,
			vl_glosa_item_w,
			vl_item_original_w,
			ie_acao_glosa_w,
			vl_repasse_calc_w;
		EXIT WHEN NOT FOUND; /* apply on C02 */

			if (ie_lib_rep_item_w	= 'S') then
				pr_glosa_w			:= 0;
				pr_adicional_w			:= 0;
				pr_amenor_w			:= 0;
				valor_glosado_w			:= 0;
				valor_amenor_w			:= 0;

				if (ie_libera_repasse_w = 'G') then

					/*  Francisco - 23/03/2009 - OS 124513
						Se tiver os 2 valores no mesmo item tem que tratar pela acao da glosa */
					if (vl_glosado_w > 0) and (vl_amenor_w > 0) and (ie_acao_glosa_w IS NOT NULL AND ie_acao_glosa_w::text <> '') then

						if (ie_acao_glosa_w = 'A') then
							pr_glosa_w	:= dividir_sem_round(vl_glosa_item_w, vl_item_original_w);
						elsif (ie_acao_glosa_w = 'R') then
							pr_amenor_w	:= dividir_sem_round(vl_glosa_item_w,vl_item_original_w);
						elsif (ie_ratear_adicional_w = 'S') and (vl_adicional_w > 0) then
							pr_adicional_w	:= dividir_sem_round(vl_adicional_w, vl_guia_w);
						end if;
					else

						if (vl_glosado_w > 0) and (vl_glosa_item_w > 0) then
							pr_glosa_w	:= dividir_sem_round(vl_glosa_item_w, vl_item_original_w);
						end if;
						if (vl_amenor_w > 0) then

							/* pr_amenor_w	:= dividir_sem_round(vl_amenor_w, vl_guia_w);
							Francisco - 09/03/2009 - OS 124513 Troquei esta linha pelas abaixo*/
							if (vl_glosa_item_w > 0) then
								pr_amenor_w	:= dividir_sem_round(vl_glosa_item_w,vl_item_original_w);
							end if;
						elsif (ie_ratear_adicional_w = 'S') and (vl_adicional_w > 0) then
							pr_adicional_w	:= dividir_sem_round(vl_adicional_w, vl_guia_w);
						end if;
					end if;
				end if;
			end if;


			if (pr_glosa_w <> 0) then

				valor_glosado_w	:= vl_repasse_w * pr_glosa_w;

				/* Francisco - OS 176801 - 25/11/2009 */

				if (ie_repasse_ret_orig_w = 'O') then
					valor_glosado_w	:= coalesce(vl_repasse_calc_w,vl_repasse_w) * pr_glosa_w;
				end if;

				SELECT * FROM desdobrar_procmat_repasse(nr_seq_repasse_w, null, 'G', valor_glosado_w, nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;
			end if;

			if (pr_amenor_w <> 0) then

				-- Jacson 06/03/2006 OS 30239
				valor_amenor_w	:= vl_repasse_w * pr_amenor_w;


				/* Francisco - OS 176801 - 25/11/2009 */

				if (ie_repasse_ret_orig_w = 'O') then
					valor_amenor_w	:= coalesce(vl_repasse_calc_w,vl_repasse_w) * pr_amenor_w;
				end if;

				SELECT * FROM desdobrar_procmat_repasse(nr_seq_repasse_w, null, ie_repasse_amenor_audit_w, valor_amenor_w, nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;
			end if;

			/* Francisco - OS 124513 - 24/03/2009 - Tem que somar, para os casos onde há mais de um item glosado por proc repassado */

			if (ie_lib_rep_item_w	= 'S') then
				if (nr_seq_repasse_w = nr_seq_repasse_atual_w) then
					valor_soma_amenor_w	:= valor_soma_amenor_w + valor_amenor_w;
					valor_soma_glosado_w	:= valor_soma_glosado_w + valor_glosado_w;
				else
					valor_soma_amenor_w	:= valor_amenor_w;
					valor_soma_glosado_w	:= valor_glosado_w;
				end if;

				vl_repasse_w := vl_repasse_w - valor_soma_glosado_w - valor_soma_amenor_w;
			else
				vl_repasse_w := vl_repasse_w - valor_glosado_w - valor_amenor_w;
			end if;



			if (pr_glosa_w = 0) and (ie_adicional_retorno_w = 'S') and (pr_adicional_w <> 0) then

				/* Edgar 15/03/2010, OS 191885, coloquei este r.aise para rastrear o processo do cliente
				r.aise_application_error(-20011, 'vl_adicional_w = ' || vl_adicional_w || chr(13) || chr(10) ||
							'ie_adicional_retorno_w (S)= ' || ie_adicional_retorno_w || chr(13) || chr(10) ||
							'ie_lib_rep_item_w (N) = ' || ie_lib_rep_item_w || chr(13) || chr(10) ||
							'ie_libera_repasse_w (G) = ' || ie_libera_repasse_w || chr(13) || chr(10) ||
							'ie_ratear_adicional_w (S)= ' || ie_ratear_adicional_w  || chr(13) || chr(10) ||
							'pr_adicional_w = ' || pr_adicional_w);
				*/
				-- Edgar 26/11/2005, tratar repasse proporcional ao adicional
				SELECT * FROM desdobrar_procmat_repasse(nr_seq_repasse_w, null, 'R', vl_repasse_w * pr_adicional_w, nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

				update	procedimento_repasse
				set	nr_seq_item_retorno	= nr_seq_ret_item_w,
					dt_liberacao		= dt_retorno_w,
					vl_liberado		= vl_repasse_w * pr_adicional_w,
					nm_usuario_lib		= nm_usuario_p
				where	nr_sequencia		= nr_seq_proc_rep_novo_w;

			end if;

			if (ie_lib_rep_item_w	= 'S') then
				update	procedimento_repasse
				set	nr_seq_item_retorno = nr_seq_ret_item_w,
					vl_repasse	= CASE WHEN pr_glosa_w=0 THEN  CASE WHEN pr_amenor_w=0 THEN  vl_repasse  ELSE vl_repasse_w END   ELSE vl_repasse_w END ,
					vl_liberado	= CASE WHEN ie_status_retorno_w='R' THEN  vl_repasse_w  ELSE 0 END ,
					ie_status	= coalesce(ie_status_retorno_w,ie_status),
					dt_liberacao	= dt_retorno_w,
					nm_usuario	= nm_usuario_p,
					dt_atualizacao	= clock_timestamp(),
					nm_usuario_lib	= nm_usuario_p
				where	nr_sequencia	= nr_seq_repasse_w;
			else

				update	procedimento_repasse
				set	nr_seq_item_retorno = nr_seq_ret_item_w,
					vl_repasse	= CASE WHEN pr_glosa_w=0 THEN  CASE WHEN pr_amenor_w=0 THEN  vl_repasse  ELSE vl_repasse_w END   ELSE vl_repasse_w END ,
					vl_liberado	= CASE WHEN ie_status_retorno_w='R' THEN  vl_repasse_w  ELSE 0 END ,
					ie_status	= coalesce(ie_status_retorno_w,ie_status),
					dt_liberacao	= dt_retorno_w,
					nm_usuario	= nm_usuario_p,
					dt_atualizacao	= clock_timestamp(),
					nm_usuario_lib	= nm_usuario_p
				where	nr_sequencia	= nr_seq_repasse_w;
			end if;

			nr_seq_repasse_atual_w	:= nr_seq_repasse_w;

		end loop;
		close C02;

		if (ie_lib_rep_item_w	= 'S') then
			pr_glosa_w			:= 0;
			pr_adicional_w			:= 0;
			pr_amenor_w			:= 0;
		end if;

		valor_soma_amenor_w	:= 0;
		valor_soma_glosado_w	:= 0;
		nr_seq_repasse_atual_w	:= null;

		open C03;
		loop
		fetch C03 into
			nr_seq_mat_w,
			nr_seq_repasse_w,
			vl_repasse_w,
			vl_glosa_item_w,
			vl_item_original_w,
			ie_acao_glosa_w,
			vl_repasse_calc_w;
		EXIT WHEN NOT FOUND; /* apply on C03 */


			if (ie_lib_rep_item_w	= 'S') then
				pr_glosa_w			:= 0;
				pr_adicional_w			:= 0;
				pr_amenor_w			:= 0;
				valor_glosado_w			:= 0;
				valor_amenor_w			:= 0;

				if (ie_libera_repasse_w = 'G') then
					/*  Francisco - 23/03/2009 - OS 124513
						Se tiver os 2 valores no mesmo item tem que tratar pela acao da glosa */
					if (vl_glosado_w > 0) and (vl_amenor_w > 0) and (vl_glosa_item_w > 0) and (ie_acao_glosa_w IS NOT NULL AND ie_acao_glosa_w::text <> '') then

						if (ie_acao_glosa_w = 'A') then
							pr_glosa_w	:= dividir_sem_round(vl_glosa_item_w, vl_item_original_w);
						elsif (ie_acao_glosa_w = 'R') then
							pr_amenor_w	:= dividir_sem_round(vl_glosa_item_w,vl_item_original_w);
						elsif (ie_ratear_adicional_w = 'S') and (vl_adicional_w > 0) then
							pr_adicional_w	:= dividir_sem_round(vl_adicional_w, vl_guia_w);
						end if;
					else

						if (vl_glosado_w > 0) and (vl_glosa_item_w > 0) then
							pr_glosa_w	:= dividir_sem_round(vl_glosa_item_w, vl_item_original_w);
						end if;
						if (vl_amenor_w > 0) then

							/*pr_amenor_w	:= dividir_sem_round(vl_amenor_w, vl_guia_w);
							Francisco - 09/03/2009 - OS 124513 Troquei esta linha pelas abaixo*/
							if (vl_glosa_item_w > 0) then
								pr_amenor_w	:= dividir_sem_round(vl_glosa_item_w,vl_item_original_w);
							else
								pr_amenor_w	:= dividir_sem_round(vl_amenor_w, vl_guia_w);
							end if;
						elsif (ie_ratear_adicional_w = 'S') and (vl_adicional_w > 0) then
							pr_adicional_w	:= dividir_sem_round(vl_adicional_w, vl_guia_w);
						end if;
					end if;
				end if;
			end if;

			if (pr_glosa_w <> 0) then

				valor_glosado_w	:= vl_repasse_w * pr_glosa_w;

				/* Francisco - OS 176801 - 25/11/2009 */

				if (ie_repasse_ret_orig_w = 'O') then
					valor_glosado_w	:= coalesce(vl_repasse_calc_w,vl_repasse_w) * pr_glosa_w;
				end if;

				SELECT * FROM desdobrar_procmat_repasse(null, nr_seq_repasse_w, 'G', valor_glosado_w, nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

				/* Francisco - 22/04/2009 - Comentei.. - OS 138442 - Estava descontando o valor glosado 2 vezes
				if	(ie_lib_rep_item_w	= 'N') then
					vl_repasse_w := vl_repasse_w - (vl_repasse_w * pr_glosa_w);
				end if;*/
			end if;

			if (pr_amenor_w <> 0) then

				-- Jacson 06/03/2006 OS 30239
				valor_amenor_w	:= vl_repasse_w * pr_amenor_w;


				/* Francisco - OS 176801 - 25/11/2009 */

				if (ie_repasse_ret_orig_w = 'O') then
					valor_amenor_w	:= coalesce(vl_repasse_calc_w,vl_repasse_w) * pr_amenor_w;
				end if;

				SELECT * FROM desdobrar_procmat_repasse(null, nr_seq_repasse_w, ie_repasse_amenor_audit_w, valor_amenor_w, nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

				/* Francisco - 22/04/2009 - Comentei.. - OS 138442 - Estava descontando o valor glosado 2 vezes
				if	(ie_lib_rep_item_w	= 'N') then
					vl_repasse_w := vl_repasse_w - (vl_repasse_w * pr_amenor_w);
				end if;*/
			end if;

			/* Francisco - OS 124513 - 24/03/2009 - Tem que somar, para os casos onde há mais de um item glosado por mat repassado */

			if (ie_lib_rep_item_w	= 'S') then
				if (nr_seq_repasse_w = nr_seq_repasse_atual_w) then
					valor_soma_amenor_w	:= valor_soma_amenor_w + valor_amenor_w;
					valor_soma_glosado_w	:= valor_soma_glosado_w + valor_glosado_w;
				else
					valor_soma_amenor_w	:= valor_amenor_w;
					valor_soma_glosado_w	:= valor_glosado_w;
				end if;

				vl_repasse_w := vl_repasse_w - valor_soma_glosado_w - valor_soma_amenor_w;
			else
				vl_repasse_w := vl_repasse_w - valor_glosado_w - valor_amenor_w;
			end if;

			if (pr_glosa_w = 0) and (ie_adicional_retorno_w = 'S') and (pr_adicional_w <> 0) then

				-- Edgar 26/11/2005, tratar repasse proporcional ao adicional
				SELECT * FROM desdobrar_procmat_repasse(null, nr_seq_repasse_w, 'R', vl_repasse_w * pr_adicional_w, nm_usuario_p, nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w) INTO STRICT nr_seq_proc_rep_novo_w, nr_seq_mat_rep_novo_w;

				update	material_repasse
				set	nr_seq_item_retorno	= nr_seq_ret_item_w,
					dt_liberacao		= dt_retorno_w,
					vl_liberado		= vl_repasse_w * pr_adicional_w,
					nm_usuario_lib		= nm_usuario_p
				where	nr_sequencia		= nr_seq_mat_rep_novo_w;

			end if;

			/*dbms_output.put_line('Valor repasse: ' || vl_repasse_w || ' Vl glosa= ' || valor_glosado_w ||
					' valor amenor= ' || valor_amenor_w);*/
			if (ie_lib_rep_item_w	= 'S') then
				update	material_repasse
				set	nr_seq_item_retorno = nr_seq_ret_item_w,
					vl_repasse	= CASE WHEN pr_glosa_w=0 THEN  CASE WHEN pr_amenor_w=0 THEN  vl_repasse  ELSE vl_repasse_w END   ELSE vl_repasse_w END ,
					vl_liberado	= CASE WHEN ie_status_retorno_w='R' THEN  vl_repasse_w  ELSE 0 END ,
					ie_status	= coalesce(ie_status_retorno_w,ie_status),
					dt_liberacao	= dt_retorno_w,
					nm_usuario	= nm_usuario_p,
					dt_atualizacao	= clock_timestamp(),

					nm_usuario_lib	= nm_usuario_p
				where	nr_sequencia	= nr_seq_repasse_w;
			else

				update	material_repasse
				set	nr_seq_item_retorno = nr_seq_ret_item_w,
					vl_repasse	= CASE WHEN pr_glosa_w=0 THEN  vl_repasse  ELSE vl_repasse_w END ,
					vl_liberado	= CASE WHEN ie_status_retorno_w='R' THEN  vl_repasse_w  ELSE 0 END ,
					ie_status	= coalesce(ie_status_retorno_w,ie_status),
					dt_liberacao	= dt_retorno_w,
					nm_usuario	= nm_usuario_p,
					dt_atualizacao	= clock_timestamp(),
					nm_usuario_lib	= nm_usuario_p
				where	nr_sequencia	= nr_seq_repasse_w;
			end if;

			nr_seq_repasse_atual_w	:= nr_seq_repasse_w;

		end loop;
		close C03;
	end if;
end loop;
close C01;

CALL atualizar_repasse_retorno_fixo(nr_seq_retorno_p, nm_usuario_p);

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE atualizar_repasse_retorno ( NR_SEQ_RETORNO_P bigint, NM_USUARIO_P text) FROM PUBLIC;

