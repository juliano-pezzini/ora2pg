-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_obter_regra_via_acesso ( nr_seq_conta_p bigint, nm_usuario_p text, nr_seq_regra_p INOUT text, ie_evento_p text default 'CC') AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:
Listar todos os procedimentos da conta e verificar através da rotina pls_obter_se_conta_simul se existe uma regra válida.
Esta procedure irá retornar a sequência de todas as regras encontradas. Estas regras irão servir como base para a continuidade do processo de atualização da via de acesso.
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[  ]  Objetos do dicionário [ x] Tasy (Delphi/Java) [   ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------

Pontos de atenção:

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 
/*	ie_evento_p:
	CC  - Consistir Conta
	IMP - Importacao Conta Portal
*/
cd_guia_referencia_w		varchar(20);
nr_seq_segurado_w		bigint;
nr_seq_regra_w			bigint;
cd_procedimento_w		bigint;
ie_origem_proced_w		bigint;
dt_procedimento_w		timestamp;
dt_inicio_proc_w		varchar(15);
dt_fim_proc_w			varchar(15);
ie_simultaneo_w			varchar(255);
nr_seq_regra_ww			varchar(255);
nr_seq_regra_aux_w		bigint := 0;
nr_seq_conta_proc_w		pls_conta_proc.nr_sequencia%type;
ie_evento_w			varchar(3);
ie_tipo_intercambio_w		pls_tipo_via_acesso.ie_tipo_intercambio%type;
ie_tipo_intercambio_via_w	pls_tipo_via_acesso.ie_tipo_intercambio%type;
/* Ler os procedimentos da conta */

C00 CURSOR FOR
	SELECT (case when ie_evento_w = 'IMP' then a.cd_procedimento_imp else a.cd_procedimento end) cd_procedimento,
		(case when ie_evento_w = 'IMP' then null else a.ie_origem_proced end) ie_origem_proced,
		(case when ie_evento_w = 'IMP' then a.dt_procedimento_imp else a.dt_procedimento end) dt_procedimento,
		(case when ie_evento_w = 'IMP' then to_char(dt_inicio_proc_imp,'hh24:mi:ss') else to_char(dt_inicio_proc,'hh24:mi:ss') end) dt_inicio_proc,
		(case when ie_evento_w = 'IMP' then to_char(dt_fim_proc_imp,'hh24:mi:ss') else to_char(dt_fim_proc,'hh24:mi:ss') end) dt_fim_proc,
		a.nr_sequencia,
		pls_obter_dados_conta(a.nr_seq_conta, 'TI1') ie_tipo_intercambio		
	from	pls_conta_proc	a
	where	a.nr_seq_conta	= nr_seq_conta_p
	and	coalesce(ie_via_obrigatoria,'N') 	= 'S'
	order by cd_procedimento,
		ie_origem_proced,
		dt_procedimento,
		dt_inicio_proc,
		dt_fim_proc,
		nr_sequencia;

/* Ler as regras de via de acesso onde os procedimentos da regra de encaixam com os procedimentos da conta */

C01 CURSOR FOR
	SELECT	a.nr_sequencia,
		coalesce(a.ie_tipo_intercambio, 'X') ie_tipo_intercambio
	from	pls_tipo_via_acesso	a,
		pls_proc_via_acesso	b
	where	a.nr_sequencia		= b.nr_seq_regra
	and	a.ie_situacao		= 'A'
	group by a.nr_sequencia, coalesce(a.ie_tipo_intercambio, 'X')
	order by count(b.nr_sequencia),
		sum(b.qt_procedimento);


BEGIN
ie_evento_w := ie_evento_p;


select	coalesce(cd_guia_referencia,cd_guia),
	nr_seq_segurado
into STRICT	cd_guia_referencia_w,
	nr_seq_segurado_w
from	pls_conta
where	nr_sequencia	= nr_seq_conta_p;

nr_seq_regra_ww	:= null;

open C00;
loop
fetch C00 into
	cd_procedimento_w,
	ie_origem_proced_w,
	dt_procedimento_w,
	dt_inicio_proc_w,
	dt_fim_proc_w,
	nr_seq_conta_proc_w,
	ie_tipo_intercambio_w;
EXIT WHEN NOT FOUND; /* apply on C00 */
	begin
	open C01;
	loop
	fetch C01 into	
		nr_seq_regra_w,
		ie_tipo_intercambio_via_w;
	EXIT WHEN NOT FOUND; /* apply on C01 */
		begin

		-- antes de fazer as validações mais pesadas, verifica se o tipo de intercambio é compativel
		if	((ie_tipo_intercambio_via_w = ie_tipo_intercambio_w) or (ie_tipo_intercambio_via_w = 'X')) or
			((ie_tipo_intercambio_via_w = 'A') and (ie_tipo_intercambio_w in ('E','N'))) then -- se for "ambos", então deve obrigar algum intercambio no protocolo
		
			/* Ponto mais importante da procedure onde é verificado se a regra é válida para a verificação do procedimento da conta. */

			ie_simultaneo_w	:= pls_obter_se_conta_simul(dt_procedimento_w, to_date(dt_inicio_proc_w,'hh24:mi:ss'), to_date(dt_fim_proc_w,'hh24:mi:ss'), nr_seq_conta_p, nr_seq_regra_w);

			if (ie_simultaneo_w	= 'S') then
				/* Caso seja válido, o sistema irá gerar uma string com todas as as regras válidas. */

				if (nr_seq_regra_aux_w <> nr_seq_regra_w) then

					nr_seq_regra_ww	:= nr_seq_regra_w || ',' || nr_seq_regra_ww;
				end if;
				
				nr_seq_regra_aux_w	:= nr_seq_regra_w;
			end if;
		end if;
		end;
	end loop;
	close C01;
	end;
end loop;
close C00;

nr_seq_regra_p	:= substr(nr_seq_regra_ww,1,length(nr_seq_regra_ww)-1);

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_obter_regra_via_acesso ( nr_seq_conta_p bigint, nm_usuario_p text, nr_seq_regra_p INOUT text, ie_evento_p text default 'CC') FROM PUBLIC;

