-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_insere_guia_proc_mat_pct ( nr_seq_conta_p pls_conta.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, ie_forcar_atualizar_p text) AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Varre os itens que são baseados em pacotos da temporaria PLS_CONTA_POS_PAC_FAT
	no pós, e correlaciona a autorização e seu respectivo item.

	Essas informações serão necessárias na formação do PTU
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------
Pontos de atenção:
Alterações:
-------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
-- vai atualizar mesmo quando já possuir informação nos campos, por padrão vem como 'N' (Não) por questões de performance
ie_forcar_atualizar_w		varchar(1);
ie_novo_pos_estab_w		pls_visible_false.ie_novo_pos_estab%type;

nr_seq_guia_w			pls_conta.nr_seq_guia%type;
nr_seq_segurado_w 		pls_segurado.nr_sequencia%type;
cd_estabelecimento_w		estabelecimento.cd_estabelecimento%type;

-- temporarios para performance
nr_seq_guia_proc_tmp_w		pls_conta_pos_pac_fat.nr_seq_guia_proc%type;
nr_seq_guia_mat_tmp_w		pls_conta_pos_pac_fat.nr_seq_guia_mat%type;

-- tabelas virtuais da carga
tb_nr_seq_conta_pos_pac_fat_w	dbms_sql.number_table;
tb_cd_procedimento_w		dbms_sql.number_table;
tb_ie_origem_proced_w		dbms_sql.number_table;
tb_nr_seq_material_w		dbms_sql.number_table;
tb_qt_item_w			dbms_sql.number_table;
tb_nr_seq_guia_w		dbms_sql.number_table;
tb_nr_seq_guia_proc_w		dbms_sql.number_table;
tb_nr_seq_guia_mat_w		dbms_sql.number_table;


-- tabelas virtuais para gravar no banco
tb_nr_sequencia_grv_w		dbms_sql.number_table;
tb_nr_seq_guia_grv_w		dbms_sql.number_table;
tb_nr_seq_guia_grv_proc_w	dbms_sql.number_table;
tb_nr_seq_guia_mat_grv_w	dbms_sql.number_table;

-- indices
j				integer;

-- Carrega os itens de pós
c01 CURSOR(	nr_seq_conta_pc	pls_conta.nr_sequencia%type,
		ie_novo_pos_pc	pls_visible_false.ie_novo_pos_estab%type) FOR
	-- Pos antigo
	SELECT	a.nr_sequencia nr_seq_conta_pos_pac_fat,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.nr_seq_material,
		coalesce(a.qt_procedimento,1) qt_item,
		a.nr_seq_guia,
		a.nr_seq_guia_proc,
		a.nr_seq_guia_mat
	from	pls_conta_pos_pac_fat		a,
		pls_conta_pos_estabelecido	b
	where	a.nr_seq_conta_pos		= b.nr_sequencia
	and	b.nr_seq_conta			= nr_seq_conta_pc
	and	b.ie_situacao			= 'A'
	and	ie_novo_pos_pc			= 'N'
	
union all

	-- Pos novo, será feito os joins com o proc e mat, mas será mantido a carga do cd_procedimento e nr_seq_mat igual, para respeitar as conversões
	SELECT	a.nr_sequencia nr_seq_conta_pos_pac_fat,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.nr_seq_material,
		coalesce(a.qt_procedimento,1) qt_item,
		a.nr_seq_guia,
		a.nr_seq_guia_proc,
		a.nr_seq_guia_mat
	from	pls_conta_pos_pac_fat		a,
		pls_conta_pos_proc		b
	where	a.nr_seq_pos_proc		= b.nr_sequencia
	and	b.nr_seq_conta			= nr_seq_conta_pc
	and	ie_novo_pos_pc			= 'S'
	
union all

	select	a.nr_sequencia nr_seq_conta_pos_pac_fat,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.nr_seq_material,
		coalesce(a.qt_procedimento,1) qt_item,
		a.nr_seq_guia,
		a.nr_seq_guia_proc,
		a.nr_seq_guia_mat
	from	pls_conta_pos_pac_fat		a,
		pls_conta_pos_mat		b
	where	a.nr_seq_pos_mat		= b.nr_sequencia
	and	b.nr_seq_conta			= nr_seq_conta_pc
	and	ie_novo_pos_pc			= 'S';

-- Busca do procedimento na autorizaçao
c02 CURSOR(	nr_seq_segurado_pc	pls_segurado.nr_sequencia%type,
		nr_seq_guia_pc		pls_conta.nr_seq_guia%type,
		cd_procedimento_pc	pls_conta_pos_pac_fat.cd_procedimento%type,
		ie_origem_proced_pc	pls_conta_pos_pac_fat.ie_origem_proced%type,
		nr_seq_conta_pc		pls_conta.nr_sequencia%type,
		ie_novo_pos_pc		pls_visible_false.ie_novo_pos_estab%type) FOR
	-- autorizações "diretas"
	SELECT	b.nr_sequencia,
		b.qt_autorizada
	from	pls_guia_plano		a,
		pls_guia_plano_proc	b
	where	a.nr_sequencia 		= b.nr_seq_guia
	and	a.nr_seq_segurado 	= nr_seq_segurado_pc
	and	a.nr_sequencia 		= nr_seq_guia_pc
	and 	b.cd_procedimento	= cd_procedimento_pc
	and	b.ie_origem_proced	= ie_origem_proced_pc
	and	a.ie_status		= '1'
	and	b.ie_status 		in ('L', 'P', 'S')
	and	not exists (	-- pos antigo
					SELECT	1
					from	pls_conta_pos_pac_fat		x,
						pls_conta_pos_estabelecido	y
					where	x.nr_seq_guia_proc		= b.nr_sequencia
					and	x.nr_seq_conta_pos		= y.nr_sequencia
					and	y.nr_seq_conta			= nr_seq_conta_pc
					and	y.ie_situacao			= 'A'
					and	ie_novo_pos_pc			= 'N'
					
union all

					-- pos novo (proc)
					select	1
					from	pls_conta_pos_pac_fat	x,
						pls_conta_pos_proc	y
					where	x.nr_seq_pos_proc	= y.nr_sequencia
					and	x.nr_seq_guia_proc	= b.nr_sequencia
					and	y.nr_seq_conta		= nr_seq_conta_pc
					and	ie_novo_pos_pc		= 'S'
					
union all

					-- pos novo (mat), dependendo da conversão, pode cair aqui
					select	1
					from	pls_conta_pos_pac_fat	x,
						pls_conta_pos_mat	y
					where	x.nr_seq_pos_mat	= y.nr_sequencia
					and	x.nr_seq_guia_mat	= b.nr_sequencia
					and	y.nr_seq_conta		= nr_seq_conta_pc
					and	ie_novo_pos_pc		= 'S'
					-- conta médica, não pegar o que ja pode ter sido vinculado em um item "aberto"
					
union all

					select	1
					from	pls_conta_proc x
					where	x.nr_seq_guia_proc	= b.nr_sequencia
					and	x.nr_seq_conta		= nr_seq_conta_pc)
	
union all

	-- resumo de internacao e prorrogacao
	select	b.nr_sequencia,
		b.qt_autorizada
	from	pls_guia_plano		a,
		pls_guia_plano_proc	b
	where	a.nr_sequencia 		= b.nr_seq_guia
	and	a.nr_seq_segurado 	= nr_seq_segurado_pc
	and	a.nr_seq_guia_ok	= nr_seq_guia_pc
	and	a.ie_tipo_guia		in ('2','8')
	and 	b.cd_procedimento	= cd_procedimento_pc
	and	b.ie_origem_proced	= ie_origem_proced_pc
	and	a.ie_status		= '1'
	and	b.ie_status 		in ('L', 'P', 'S')
	and	not exists (	-- pos antigo
					select	1
					from	pls_conta_pos_pac_fat		x,
						pls_conta_pos_estabelecido	y
					where	x.nr_seq_guia_proc		= b.nr_sequencia
					and	x.nr_seq_conta_pos		= y.nr_sequencia
					and	y.nr_seq_conta			= nr_seq_conta_pc
					and	y.ie_situacao			= 'A'
					and	ie_novo_pos_pc			= 'N'
					
union all

					-- pos novo (proc)
					select	1
					from	pls_conta_pos_pac_fat	x,
						pls_conta_pos_proc	y
					where	x.nr_seq_pos_proc	= y.nr_sequencia
					and	x.nr_seq_guia_proc	= b.nr_sequencia
					and	y.nr_seq_conta		= nr_seq_conta_pc
					and	ie_novo_pos_pc		= 'S'
					
union all

					-- pos novo (mat), dependendo da conversão, pode cair aqui
					select	1
					from	pls_conta_pos_pac_fat	x,
						pls_conta_pos_mat	y
					where	x.nr_seq_pos_mat	= y.nr_sequencia
					and	x.nr_seq_guia_mat	= b.nr_sequencia
					and	y.nr_seq_conta		= nr_seq_conta_pc
					and	ie_novo_pos_pc		= 'S'
					-- conta médica, não pegar o que ja pode ter sido vinculado em um item "aberto"
					
union all

					select	1
					from	pls_conta_proc x
					where	x.nr_seq_guia_proc	= b.nr_sequencia
					and	x.nr_seq_conta		= nr_seq_conta_pc);

-- carrega os materiais da autorização
c03 CURSOR(	nr_seq_segurado_pc	pls_segurado.nr_sequencia%type,
		nr_seq_guia_pc		pls_conta.nr_seq_guia%type,
		nr_seq_material_pc	pls_conta_pos_pac_fat.nr_seq_material%type,
		nr_seq_conta_pc		pls_conta.nr_sequencia%type,
		ie_novo_pos_pc		pls_visible_false.ie_novo_pos_estab%type) FOR
	--  autorizações "diretas"
	SELECT	b.nr_sequencia,
		b.qt_autorizada
	from	pls_guia_plano		a,
		pls_guia_plano_mat	b
	where	a.nr_sequencia 		= b.nr_seq_guia
	and	a.nr_seq_segurado 	= nr_seq_segurado_pc
	and	a.nr_sequencia		= nr_seq_guia_pc
	and 	b.nr_seq_material	= nr_seq_material_pc
	and	a.ie_status		= '1'
	and	b.ie_status 		in ('L', 'P', 'S')
	and	not exists (	-- pos antigo
						SELECT	1
						from	pls_conta_pos_pac_fat		x,
							pls_conta_pos_estabelecido	y
						where	x.nr_seq_guia_proc		= b.nr_sequencia
						and	x.nr_seq_conta_pos		= y.nr_sequencia
						and	y.nr_seq_conta			= nr_seq_conta_pc
						and	y.ie_situacao			= 'A'
						and	ie_novo_pos_pc			= 'N'
						
union all

						-- pos novo (proc)
						select	1
						from	pls_conta_pos_pac_fat	x,
							pls_conta_pos_proc	y
						where	x.nr_seq_pos_proc	= y.nr_sequencia
						and	x.nr_seq_guia_proc	= b.nr_sequencia
						and	y.nr_seq_conta		= nr_seq_conta_pc
						and	ie_novo_pos_pc		= 'S'
						
union all

						-- pos novo (mat), dependendo da conversão, pode cair aqui
						select	1
						from	pls_conta_pos_pac_fat	x,
							pls_conta_pos_mat	y
						where	x.nr_seq_pos_mat	= y.nr_sequencia
						and	x.nr_seq_guia_mat	= b.nr_sequencia
						and	y.nr_seq_conta		= nr_seq_conta_pc
						and	ie_novo_pos_pc		= 'S')
	
union all

	-- resumo de internacao e prorrogacao
	select	b.nr_sequencia,
		b.qt_autorizada
	from	pls_guia_plano		a,
		pls_guia_plano_mat	b
	where	a.nr_sequencia 		= b.nr_seq_guia
	and	a.nr_seq_segurado 	= nr_seq_segurado_pc
	and	a.nr_seq_guia_ok 	= nr_seq_guia_pc
	and	a.ie_tipo_guia		in ('2','8')
	and 	b.nr_seq_material	= nr_seq_material_pc
	and	a.ie_status		= '1'
	and	b.ie_status 		in ('L', 'P', 'S')
	and	not exists (	-- pos antigo
						select	1
						from	pls_conta_pos_pac_fat		x,
							pls_conta_pos_estabelecido	y
						where	x.nr_seq_guia_proc		= b.nr_sequencia
						and	x.nr_seq_conta_pos		= y.nr_sequencia
						and	y.nr_seq_conta			= nr_seq_conta_pc
						and	y.ie_situacao			= 'A'
						and	ie_novo_pos_pc			= 'N'
						
union all

						-- pos novo (proc)
						select	1
						from	pls_conta_pos_pac_fat	x,
							pls_conta_pos_proc	y
						where	x.nr_seq_pos_proc	= y.nr_sequencia
						and	x.nr_seq_guia_proc	= b.nr_sequencia
						and	y.nr_seq_conta		= nr_seq_conta_pc
						and	ie_novo_pos_pc		= 'S'
						
union all

						-- pos novo (mat), dependendo da conversão, pode cair aqui
						select	1
						from	pls_conta_pos_pac_fat	x,
							pls_conta_pos_mat	y
						where	x.nr_seq_pos_mat	= y.nr_sequencia
						and	x.nr_seq_guia_mat	= b.nr_sequencia
						and	y.nr_seq_conta		= nr_seq_conta_pc
						and	ie_novo_pos_pc		= 'S');
BEGIN

-- somente executa se tiver conta informada
if (nr_seq_conta_p IS NOT NULL AND nr_seq_conta_p::text <> '') then

	-- inicializa os parametros
	ie_forcar_atualizar_w := coalesce(ie_forcar_atualizar_p,'N');


	-- primeiro busca na conta as informações necessárias.
	select	max(a.nr_seq_guia),
		max(nr_seq_segurado),
		max(cd_estabelecimento)
	into STRICT	nr_seq_guia_w,
		nr_seq_segurado_w,
		cd_estabelecimento_w
	from	pls_conta	a
	where	a.nr_sequencia	= nr_seq_conta_p;

	select	coalesce(max(a.ie_novo_pos_estab),'N')
	into STRICT	ie_novo_pos_estab_w
	from	pls_visible_false	a
	where	a.cd_estabelecimento	= cd_estabelecimento_w;

	-- verifica se existe uma guia, se não existir não executa mais nada (performance)
	if (nr_seq_guia_w IS NOT NULL AND nr_seq_guia_w::text <> '') then

		-- Via de regra, devera tentar localizar primeiro um item na autorização que seja 100% compatível, atraves do
		-- do segurado, seq da guia (ou no caso de internação e prorrogação, pelo nr_seq_guia_ok) , codigo do item, origem e quantidade
		-- quando não for possivel apurar pela quantidade, então pega-se o primeiro ignorando apenas a quantidade
		-- para Fins de performance, será executado apenas uma busca, e será avaliado a quantidade no laço, para evitar mais uma sub consulta
		-- No caso, a primeira iteração no laço vai atribuir o codigo independente da quantidade, e o laço vai seguir, se encontrar um item com quantidade igual
		-- então será guardado o novo codigo
		-- incializa o indice de gravação
		j := 0;
		-- carrega os itens a serem avaliados
		open c01(nr_seq_conta_p, ie_novo_pos_estab_w);
		loop
		fetch c01 bulk collect into	tb_nr_seq_conta_pos_pac_fat_w,
						tb_cd_procedimento_w,
						tb_ie_origem_proced_w,
						tb_nr_seq_material_w,
						tb_qt_item_w,
						tb_nr_seq_guia_w,
						tb_nr_seq_guia_proc_w,
						tb_nr_seq_guia_mat_w limit pls_util_pck.qt_registro_transacao_w;

		exit when tb_nr_seq_conta_pos_pac_fat_w.count = 0;

			for i in tb_nr_seq_conta_pos_pac_fat_w.first..tb_nr_seq_conta_pos_pac_fat_w.last loop

				-- se for "procedimento"
				if	(((tb_cd_procedimento_w(i) IS NOT NULL AND (tb_cd_procedimento_w(i))::text <> '')) and ((tb_ie_origem_proced_w(i) IS NOT NULL AND (tb_ie_origem_proced_w(i))::text <> ''))) then

					-- antes de abrir o curso, verfica se ja existe o registro gravado, se tiver não deverá ser alterado, portanto não será executado o restante
					-- Se o parametro marcar para forcar a atualização, então devera continuar mesmo que ja possua informações
					if	(((coalesce(tb_nr_seq_guia_w(i)::text, '') = '') and (coalesce(tb_nr_seq_guia_proc_w(i)::text, '') = '')) or (ie_forcar_atualizar_w = 'S')) then

						-- inicializa para a primeira iteração do laco
						nr_seq_guia_proc_tmp_w := null;

						-- abre a busca na autorização pelo item
						for r_c02_w in c02(	nr_seq_segurado_w,
									nr_seq_guia_w,
									tb_cd_procedimento_w(i),
									tb_ie_origem_proced_w(i),
									nr_seq_conta_p,
									ie_novo_pos_estab_w ) loop

							-- a primeira iteração vai ter o seq temp null, então atribui ele de qualquer forma, independente da quantidade
							-- Tambem é comparada a quantidade, se for identica, será guardado o valor
							if	((coalesce(nr_seq_guia_proc_tmp_w::text, '') = '') or (tb_qt_item_w(i) = r_c02_w.qt_autorizada)) then

								nr_seq_guia_proc_tmp_w := r_c02_w.nr_sequencia;
							end if;


						end loop; -- fim loop itens na autorização
						-- se encontrou um sequencia, então guarda ele na lista para gravar
						if (nr_seq_guia_proc_tmp_w IS NOT NULL AND nr_seq_guia_proc_tmp_w::text <> '') then

							tb_nr_sequencia_grv_w(j)	:= tb_nr_seq_conta_pos_pac_fat_w(i);
							tb_nr_seq_guia_grv_w(j)		:= nr_seq_guia_w;
							tb_nr_seq_guia_grv_proc_w(j)	:= nr_seq_guia_proc_tmp_w;
							tb_nr_seq_guia_mat_grv_w(j)	:= null;
							j := j + 1;
						end if;
					end if; -- fim verifica procedimento
				else
					-- senão considera como material
					-- antes de abrir o curso, verfica se ja existe o registro gravado, se tiver não deverá ser alterado, portanto não será executado o restante
					-- Se o parametro marcar para forcar a atualização, então devera continuar mesmo que ja possua informações
					if	(((coalesce(tb_nr_seq_guia_w(i)::text, '') = '') and (coalesce(tb_nr_seq_guia_mat_w(i)::text, '') = '')) or (ie_forcar_atualizar_w = 'S')) then

						-- inicializa para a primeira iteração do laco
						nr_seq_guia_mat_tmp_w := null;

						-- abre a busca na autorização pelo item
						for r_c03_w in c03(	nr_seq_segurado_w,
									nr_seq_guia_w,
									tb_nr_seq_material_w(i),
									nr_seq_conta_p,
									ie_novo_pos_estab_w ) loop

							-- a primeira iteração vai ter o seq temp null, então atribui ele de qualquer forma, independente da quantidade
							-- Tambem é comparada a quantidade, se for identica, será guardado o valor
							if	((coalesce(nr_seq_guia_mat_tmp_w::text, '') = '') or (tb_qt_item_w(i) = r_c03_w.qt_autorizada)) then

								nr_seq_guia_mat_tmp_w := r_c03_w.nr_sequencia;
							end if;

						end loop; -- fim loop itens na autorização
						-- se encontrou um sequencia, então guarda ele na lista para gravar
						if (nr_seq_guia_mat_tmp_w IS NOT NULL AND nr_seq_guia_mat_tmp_w::text <> '') then

							tb_nr_sequencia_grv_w(j)	:= tb_nr_seq_conta_pos_pac_fat_w(i);
							tb_nr_seq_guia_grv_w(j)		:= nr_seq_guia_w;
							tb_nr_seq_guia_grv_proc_w(j)	:= null;
							tb_nr_seq_guia_mat_grv_w(j)	:= nr_seq_guia_mat_tmp_w;
							j := j + 1;
						end if;
					end if;  --fim verifica material
				end if; -- fim tipo item
			end loop; -- navegou pelos itens
			-- apaga os itens
			tb_nr_seq_conta_pos_pac_fat_w.delete;
			tb_cd_procedimento_w.delete;
			tb_ie_origem_proced_w.delete;
			tb_nr_seq_material_w.delete;
			tb_qt_item_w.delete;
			tb_nr_seq_guia_w.delete;
			tb_nr_seq_guia_proc_w.delete;
			tb_nr_seq_guia_mat_w.delete;

			-- verifica se atinguiu o limite, manda para o banco
			if (tb_nr_sequencia_grv_w.count >= pls_util_pck.qt_registro_transacao_w) then

				forall x in tb_nr_sequencia_grv_w.first..tb_nr_sequencia_grv_w.last
					update	pls_conta_pos_pac_fat
					set	nr_seq_guia		= tb_nr_seq_guia_grv_w(x),
						nr_seq_guia_proc	= tb_nr_seq_guia_grv_proc_w(x),
						nr_seq_guia_mat		= tb_nr_seq_guia_mat_grv_w(x)
					where	nr_sequencia		= tb_nr_sequencia_grv_w(x);
				-- Limpa a carga
				j := 0;
				tb_nr_sequencia_grv_w.delete;
				tb_nr_seq_guia_grv_w.delete;
				tb_nr_seq_guia_grv_proc_w.delete;
				tb_nr_seq_guia_mat_grv_w.delete;

			end if;


		end loop; -- fim itens
		if (c01%isopen) then

			close c01;
		end if;


		-- verifica se "sobrou" registro, então envia para o banco
		if (tb_nr_sequencia_grv_w.count > 0) then

			forall x in tb_nr_sequencia_grv_w.first..tb_nr_sequencia_grv_w.last
				update	pls_conta_pos_pac_fat
				set	nr_seq_guia		= tb_nr_seq_guia_grv_w(x),
					nr_seq_guia_proc	= tb_nr_seq_guia_grv_proc_w(x),
					nr_seq_guia_mat		= tb_nr_seq_guia_mat_grv_w(x)
				where	nr_sequencia		= tb_nr_sequencia_grv_w(x);
			-- Limpa a carga
			j := 0;
			tb_nr_sequencia_grv_w.delete;
			tb_nr_seq_guia_grv_w.delete;
			tb_nr_seq_guia_grv_proc_w.delete;
			tb_nr_seq_guia_mat_grv_w.delete;
		end if;
	end if;
end if; -- fim conta informada
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_insere_guia_proc_mat_pct ( nr_seq_conta_p pls_conta.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, ie_forcar_atualizar_p text) FROM PUBLIC;

