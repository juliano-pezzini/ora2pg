-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_cod_material ( nr_seq_material_p bigint, nm_usuario_p text) AS $body$
DECLARE


nr_seq_ger_cod_w		bigint;
ie_regra_numero_w		varchar(2);
ds_rotina_digito_w		varchar(15);
i 				bigint	:= 1;	

cd_mascara_cod_w		varchar(30);
cd_material_mascara_w		varchar(30);
cd_caract_digitos_w		varchar(30);
cd_material_w			varchar(30);
cd_material_final_w		varchar(30);
cd_numero_fixo_w		varchar(30);
cd_caract_w			varchar(30);

qt_digitos_w			bigint;
qt_caract_fixos_w		bigint;
qt_dig_verific_w		bigint	:= 0;
									
					

BEGIN
if (nr_seq_material_p IS NOT NULL AND nr_seq_material_p::text <> '') then
	begin
	/*Obter o número da regra*/

	select	pls_obter_regra_cod_mat(a.nr_seq_estrut_mat,a.nr_sequencia,a.ie_tipo_despesa,clock_timestamp())
	into STRICT	nr_seq_ger_cod_w
	from	pls_material a
	where	nr_sequencia	= nr_seq_material_p;	
	exception
	when others then
		nr_seq_ger_cod_w := null;
	end;
	
	if (nr_seq_ger_cod_w IS NOT NULL AND nr_seq_ger_cod_w::text <> '') then	
		/*Obter máscara, rotina de digitos e a regra do código, da regra* */

		select	ie_regra_numero,
			cd_mascara_cod,
			ds_rotina_digito
		into STRICT	ie_regra_numero_w,
			cd_mascara_cod_w,
			ds_rotina_digito_w
		from 	pls_regra_geracao_cod_mat
		where	nr_sequencia	= nr_seq_ger_cod_w;
		
		if (ie_regra_numero_w IS NOT NULL AND ie_regra_numero_w::text <> '') and (cd_mascara_cod_w IS NOT NULL AND cd_mascara_cod_w::text <> '') and (ds_rotina_digito_w IS NOT NULL AND ds_rotina_digito_w::text <> '') then
			/*Verificar os carácteres da regra*/

			while(i <= length(cd_mascara_cod_w)) loop	
				if (substr(cd_mascara_cod_w,i,1) <> '#') and (substr(cd_mascara_cod_w,i,1) <> 'D') then
					/*Obter os números fixos da regra*/

					cd_material_mascara_w := cd_material_mascara_w || substr(cd_mascara_cod_w,i,1);
				elsif (substr(cd_mascara_cod_w,i,1) = '#') then
					/*Obter as variáveis da regra*/

					if (substr(cd_mascara_cod_w,i-1,1) <> '#') and (substr(cd_mascara_cod_w,i-1,1) <> 'D') then
						cd_numero_fixo_w 	:= substr(cd_material_mascara_w,1,i-1);		
						cd_material_mascara_w 	:= null;	
					end if;
					
					cd_caract_digitos_w	:= cd_caract_digitos_w || '#';
					
					if (substr(cd_mascara_cod_w,i+1,1) <> '#') then
						cd_caract_w   		:= cd_caract_digitos_w;
						cd_caract_digitos_w	:= null;		
					end if;
				elsif (substr(cd_mascara_cod_w,i,1) = 'D') then
					qt_dig_verific_w	:= qt_dig_verific_w + 1;
				end if;
				
				i := i + 1;
			end loop;
			
			/*Obter a quantidade de caracteres fixos e variáveis*/

			qt_digitos_w		:= length(cd_caract_w);
			qt_caract_fixos_w	:= length(cd_numero_fixo_w);
			
			if (ie_regra_numero_w = 'S') then
				/*Incrementar em 1 o maior código*/

				select	lpad((substr(max(a.cd_material_ops),qt_caract_fixos_w + 1,qt_digitos_w))::numeric  + 1,qt_digitos_w,'0')
				into STRICT	cd_caract_w
				from	pls_material a
				where	substr(a.cd_material_ops,1,qt_caract_fixos_w) = cd_numero_fixo_w;
				
				if (coalesce(cd_caract_w::text, '') = '') then
					cd_caract_w	:= lpad(1,qt_digitos_w,'0');
				end if;
			elsif (ie_regra_numero_w = 'ML') then			
				/*Obter o menor código livre */

				select	lpad((substr(min(a.cd_material_ops),qt_caract_fixos_w + 1,qt_digitos_w))::numeric  + 1,qt_digitos_w,'0')
				into STRICT	cd_caract_w	
				from	pls_material a
				where	not exists (SELECT 1
						from    pls_material x
						where   (substr(a.cd_material_ops,qt_caract_fixos_w + 1,qt_digitos_w))::numeric  + 1 =
								(substr(x.cd_material_ops,qt_caract_fixos_w + 1,qt_digitos_w))::numeric 
						and	substr(x.cd_material_ops,1,qt_caract_fixos_w) = cd_numero_fixo_w
						)
				and	length(a.cd_material_ops) > qt_caract_fixos_w
				and	substr(a.cd_material_ops,1,qt_caract_fixos_w) = cd_numero_fixo_w;

				/*Se não encontrou, incrementar em 1 o maior código */

				if (coalesce(cd_caract_w::text, '') = '') then
					select	lpad((substr(max(a.cd_material_ops),qt_caract_fixos_w + 1,qt_digitos_w))::numeric  + 1,qt_digitos_w,'0')
					into STRICT	cd_caract_w
					from	pls_material a
					where	substr(a.cd_material_ops,1,qt_caract_fixos_w) = cd_numero_fixo_w;
					
					if (coalesce(cd_caract_w::text, '') = '') then
						cd_caract_w	:= lpad(1,qt_digitos_w,'0');
					end if;
				end if;
			end if;	
			/*Junta os números fixos e o código gerado*/

			cd_material_w	:=	cd_numero_fixo_w || cd_caract_w;

			if (ds_rotina_digito_w IS NOT NULL AND ds_rotina_digito_w::text <> '') then
				/*Adiciona ao código o digito verificador*/

				cd_material_final_w := cd_material_w || lpad(Calcula_Digito(ds_rotina_digito_w, cd_material_w),qt_dig_verific_w,'0');
			end if;	
			
			update	pls_material
			set	cd_material_ops = cd_material_final_w,
				nm_usuario	= nm_usuario_p,
				dt_atualizacao  = clock_timestamp()
			where	nr_sequencia 	= nr_seq_material_p;
			
			commit;
		end if;	
	end if;
end if;	

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_cod_material ( nr_seq_material_p bigint, nm_usuario_p text) FROM PUBLIC;

