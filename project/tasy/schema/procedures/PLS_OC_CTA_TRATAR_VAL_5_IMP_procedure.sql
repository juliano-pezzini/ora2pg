-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_5_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) AS $body$
DECLARE


_ora2pg_r RECORD;
tb_seq_selecao_w	pls_util_cta_pck.t_number_table;
tb_valido_w		pls_util_cta_pck.t_varchar2_table_1;
tb_observacao_w		pls_util_cta_pck.t_varchar2_table_4000;

-- Informações da validação de exigência de procedimento
C01 CURSOR(	nr_seq_oc_cta_comb_pc	pls_oc_cta_combinada.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia	nr_seq_validacao,
		a.nr_seq_estrutura,
		a.ie_exige_procedimento
	from	pls_oc_cta_val_exig_proc a
	where	a.nr_seq_oc_cta_comb = nr_seq_oc_cta_comb_pc;

-- Verificar a regra de tipos de exigência
-- Regra Todos: 	Deve gerar a ocorrência se todos os procedimentos da regra não estiverem na conta
-- Solução:		Buscar todos os procedimentos da estrutura e retirar os procedimentos que estão na conta.
--		Caso não sobre nenhum então todos estão na conta e não será gerada a ocorrência. Caso sobre então nem todos estão na conta e será gerada a ocorrência.
C02 CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_imp.nr_id_transacao%type,
		nr_seq_estrutura_pc	pls_estrutura_ocor_tm.nr_seq_estrutura%type)FOR
	SELECT	sel.nr_sequencia,
		'N' ie_valido,
		null ds_observacao
	from	pls_oc_cta_selecao_imp sel
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	not exists (	SELECT	est.cd_procedimento,
					est.ie_origem_proced
				from	pls_estrutura_ocor_tm est
				where	est.nr_seq_estrutura = nr_seq_estrutura_pc
				EXCEPT
				select	proc.cd_procedimento_conv,
					proc.ie_origem_proced_conv
				from	pls_conta_proc_imp proc
				where	proc.nr_seq_conta = sel.nr_seq_conta);

-- Regra Ao menos Um:	Deve gerar a ocorrência caso não exista ao menos um item da conta na estrutura.
--  Solução:		Buscar um procedimento da conta que exista na estrutura, caso encontre não será gerada a ocorrência, pois pelo menos um item da conta está na estrutura.
--		Caso não encontre então nenhum item da conta está na estrutura e deve ser gerada a ocorrência.
C03 CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_imp.nr_id_transacao%type,
		nr_seq_estrutura_pc	pls_estrutura_ocor_tm.nr_seq_estrutura%type) FOR
	SELECT	conta.nr_sequencia,
		'N' ie_valido,
		null ds_observacao
	from	pls_conta_imp conta
	where	exists (SELECT	1
			from	pls_oc_cta_selecao_imp sel
			where	sel.nr_id_transacao = nr_id_transacao_pc
			and	sel.ie_valido = 'S'
			and	sel.nr_seq_conta = conta.nr_sequencia)
	and	exists (	select	1
			from	pls_estrutura_ocor_tm est,
				pls_conta_proc_imp proc
			where	est.nr_seq_estrutura = nr_seq_estrutura_pc
			and	proc.nr_seq_conta = conta.nr_sequencia
			and	proc.cd_procedimento_conv = est.cd_procedimento
			and	proc.ie_origem_proced_conv = est.ie_origem_proced);

-- Regra Somente os itens da regra: 	Deve ser gerada a ocorrência se a conta não tem exatamente os mesmos itens que a regra.
-- Solução:			Buscar todos os itens da conta e retirar os itens da estrutura. Buscar todos os itens da estrutura e remover os da conta.
--			Caso sobre algum item em algum dos dois casos quer dizer que os resultados são diferentes e então será gerada a ocorrência.
C04 CURSOR(	nr_id_transacao_pc	pls_oc_cta_selecao_imp.nr_id_transacao%type,
		nr_seq_estrutura_pc	pls_estrutura_ocor_tm.nr_seq_estrutura%type)FOR
	SELECT	sel.nr_sequencia,
		'N' ie_valido,
		null ds_observacao
	from	pls_oc_cta_selecao_imp sel
	where	sel.nr_id_transacao = nr_id_transacao_pc
 	and	sel.ie_valido = 'S'
	and	not exists(
			(SELECT	est.cd_procedimento,
				est.ie_origem_proced
			from	pls_estrutura_ocor_tm est
			where	est.nr_seq_estrutura = nr_seq_estrutura_pc
			EXCEPT
			select	proc.cd_procedimento_conv,
				proc.ie_origem_proced_conv
			from	pls_conta_proc_imp proc
			where	proc.nr_seq_conta = sel.nr_seq_conta)
			
union all
(select	proc.cd_procedimento_conv,
				proc.ie_origem_proced_conv
			from	pls_conta_proc_imp proc
			where	proc.nr_seq_conta = sel.nr_seq_conta
			EXCEPT
			select	est.cd_procedimento,
				est.ie_origem_proced
			from	pls_estrutura_ocor_tm est
			where	est.nr_seq_estrutura = nr_seq_estrutura_pc)
			);
BEGIN

if (nr_seq_combinada_p IS NOT NULL AND nr_seq_combinada_p::text <> '') and (nr_id_transacao_p IS NOT NULL AND nr_id_transacao_p::text <> '')	then

	-- Buscar os dados da validação cadastrada para a regra.
	for	r_C01_w in C01(nr_seq_combinada_p) loop

		-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
		CALL pls_ocor_imp_pck.atualiza_campo_auxiliar('V', 'N', nr_id_transacao_p, null, 'S');

		-- Incializar as listas para cada regra.
		SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

		-- gerencia a atualização da tabela TM
		CALL pls_gerencia_upd_obj_pck.atualizar_objetos('tasy', 'PLS_OC_CTA_TRATAR_VAL_5_IMP', 'PLS_ESTRUTURA_OCOR_TM');

		-- Deve ter esta informação para que possamos buscar os procedimentos que fazem parte da estrutura
		if (r_C01_w.nr_seq_estrutura IS NOT NULL AND r_C01_w.nr_seq_estrutura::text <> '') then

			--Regra Todos
			if (r_C01_w.ie_exige_procedimento = 'T') then
				begin
					--Abre cursor da regra Todos e gera ocorrência para os registros que vierem no cursor
					open C02(nr_id_transacao_p, r_C01_w.nr_seq_estrutura);
					loop
						fetch C02 bulk collect into	tb_seq_selecao_w, tb_valido_w, tb_observacao_w
						limit pls_util_pck.qt_registro_transacao_w;
						exit when tb_seq_selecao_w.count = 0;

						--Grava as informações na tabela de seleção
						CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w,
												tb_observacao_w, nr_id_transacao_p,
												'SEQ');
						--limpa as variáveis
						SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
					end loop;
					close C02;
				exception
				when others then
					--Fecha cursor
					if (C02%isopen) then

						close C02;
					end if;
				end;
			--Regra Ao menos Um
			elsif (r_C01_w.ie_exige_procedimento = 'U') then

				begin
					--Abre cursor da regra Ao menos Um e gera ocorrência para os registros que vierem no cursor
					open C03(nr_id_transacao_p, r_C01_w.nr_seq_estrutura);
					loop
						fetch C03 bulk collect into	tb_seq_selecao_w, tb_valido_w, tb_observacao_w
						limit pls_util_pck.qt_registro_transacao_w;
						exit when tb_seq_selecao_w.count = 0;

						--Grava as informações na tabela de seleção
						CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w,
												tb_observacao_w, nr_id_transacao_p,
												'SEQ_CONTA');
						--limpa as variáveis
						SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
					end loop;
					close C03;
				exception
				when others then
					--Fecha cursor
					if (C03%isopen) then

						close C03;
					end if;
				end;
			--Regra Somente os itens da regra
			elsif (r_C01_w.ie_exige_procedimento = 'S') then

				begin
					--Abre cursor da regra Somente items da regra e gera ocorrência para os registros que vierem no cursor
					open C04(nr_id_transacao_p, r_C01_w.nr_seq_estrutura);
					loop
						fetch C04 bulk collect into	tb_seq_selecao_w, tb_valido_w, tb_observacao_w
						limit pls_util_pck.qt_registro_transacao_w;
						exit when tb_seq_selecao_w.count = 0;

						--Grava as informações na tabela de seleção
						CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w,
												tb_observacao_w, nr_id_transacao_p,
												'SEQ');
						--limpa as variáveis
						SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
					end loop;
					close C04;
				exception
				when others then
					--Fecha cursor
					if (C04%isopen) then

						close C04;
					end if;
				end;
			end if;

		end if;
	end loop; --C01
	--Se tiver alguma informaçõa grava na tabela
	CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w,
							tb_observacao_w, nr_id_transacao_p,
							'SEQ');

	-- seta os registros que serão válidos ou inválidos após o processamento
	CALL pls_ocor_imp_pck.atualiza_campo_valido('V', 'N',
						ie_regra_excecao_p, null,
						nr_id_transacao_p, null);

end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_5_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) FROM PUBLIC;

