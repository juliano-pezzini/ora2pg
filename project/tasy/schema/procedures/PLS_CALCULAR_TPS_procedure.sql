-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_calcular_tps ( nr_seq_tps_p pls_tps.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

 
ie_abrangencia_w		varchar(3);
ie_segmentacao_w		varchar(3);
ie_arredondar_tps_w		varchar(1);
vl_calculo_w			double precision	:= 0;
vl_base_w			double precision	:= 0;
vl_desconto_w			double precision	:= 0;
vl_total_tps_w			double precision	:= 0;
vl_base_tps_w			double precision	:= 0;
vl_desconto_mp_w		double precision	:= 0;
vl_desc_cota_unica_w		double precision	:= 0;
vl_liquido_w			double precision	:= 0;
vl_desconto_tps_w		double precision	:= 0;
qt_media_benef_ativo_w		double precision	:= 0;
vl_novo_calculo_w		double precision;
vl_nova_base_w			double precision;
vl_novo_desconto_w		double precision;
vl_desconto_ww			double precision;
vl_calculo_ww			double precision;
ie_idade_tps_w			bigint	:= 0;
qt_benef_ativo_w		bigint	:= 0;
qt_total_benef_ativo_w		bigint	:= 0;
qt_primeiro_mes_w		bigint	:= 0;
qt_segundo_mes_w		bigint	:= 0;
qt_terceiro_mes_w		bigint	:= 0;
nr_seq_regra_desc_w		bigint;
nr_seq_grupo_w			bigint;
nr_seq_pls_tps_reg_w		bigint;
nr_seq_pls_tps_reg_grupo_w	bigint;
qt_externos_w			bigint	:= 0;
pr_desc_tps_w			double precision	:= 0;
pr_desconto_w			double precision	:= 0;
qt_mes_w			smallint	:= 0;
ie_faixa_etaria_w		smallint;
dt_periodo_inicial_w		timestamp;
dt_periodo_final_w		timestamp;
dt_periodo_w			timestamp;
qt_regra_grupo_segmentacao_w	bigint;
qt_grupo_seg_w			bigint;
vl_taxa_benef_w			pls_tps.vl_taxa_benef%type;

C01 CURSOR( cd_estabelecimento_pc	estabelecimento.cd_estabelecimento%type) FOR 
	SELECT	a.ie_abrangencia, 
		a.ie_segmentacao, 
		b.vl_dominio 
	from	valor_dominio	b, 
		pls_plano 	a 
	where	b.cd_dominio 	= 2486 
	and	a.cd_estabelecimento = cd_estabelecimento_pc 
	group by 
		a.ie_abrangencia, 
		a.ie_segmentacao, 
		b.vl_dominio 
	
union
 
	SELECT	a.ie_abrangencia, 
		a.ie_segmentacao, 
		b.vl_dominio 
	from	pls_tps_dados_externos	a, 
		valor_dominio		b 
	where	b.cd_dominio 	= 2486 
	and	a.cd_estabelecimento = cd_estabelecimento_pc 
	and	not exists (select	1 
				from	pls_plano	x 
				where	x.ie_segmentacao = a.ie_segmentacao 
				and	x.cd_estabelecimento = cd_estabelecimento_pc) 
	group by 
		a.ie_abrangencia, 
		a.ie_segmentacao, 
		b.vl_dominio 
	order by 
		ie_segmentacao, 
		vl_dominio desc;

C02 CURSOR( cd_estabelecimento_pc	estabelecimento.cd_estabelecimento%type) FOR 
	SELECT	pls_obter_idade_tps(a.cd_pessoa_fisica, dt_periodo_w) ie_idade_tps 
	from	pls_plano	b, 
		pls_segurado	a 
	where	a.nr_seq_plano	= b.nr_sequencia 
	and	(a.dt_liberacao IS NOT NULL AND a.dt_liberacao::text <> '') 
	and	dt_periodo_w between trunc(a.dt_contratacao,'month') and fim_dia(coalesce(a.dt_rescisao,dt_periodo_w)) -- Diether - OS 320461 - Alterado para que o beneficiário seja contado no mesmo mês em que aderiu 
	and	b.ie_abrangencia	= ie_abrangencia_w 
	and	b.ie_segmentacao	= ie_segmentacao_w 
	and	b.cd_estabelecimento 	= cd_estabelecimento_pc 
	and	((coalesce(a.ie_tipo_segurado,'B')	= 'B') or  -- Alterado para buscar só beneficiários de plano de saúde, conversado com Adriano - OS 314429 
		(coalesce(a.ie_tipo_segurado,'B')	= 'R') and (a.nr_seq_contrato IS NOT NULL AND a.nr_seq_contrato::text <> '')); -- Alterado para buscar também beneficiários de responsabilidade assumida - OS 388372 
		-- Alterado para trazer responsabilidade assumida somente de contrato 
C03 CURSOR FOR 
	SELECT	qt_primeiro_mes, 
		qt_segundo_mes, 
		qt_terceiro_mes, 
		ie_abrangencia, 
		ie_segmentacao, 
		ie_faixa_etaria, 
		vl_calculo, 
		vl_desconto, 
		nr_sequencia 
	from	pls_tps_reg 
	where	nr_seq_tps	= nr_seq_tps_p;

TYPE 		fetch_array IS TABLE OF C01%ROWTYPE;
s_array 	fetch_array;
i		integer := 1;
type Vetor is table of fetch_array index by integer;
Vetor_c01_w			Vetor;

TYPE 		fetch_array3 IS TABLE OF C03%ROWTYPE;
s_array3 	fetch_array3;
i3		integer := 1;
type Vetor3 is table of fetch_array3 index by integer;
Vetor_c03_w			Vetor3;

BEGIN 
delete	from pls_tps_reg 
where	nr_seq_tps = nr_seq_tps_p;
 
pls_consistir_se_sib_envio_tps(nr_seq_tps_p, cd_estabelecimento_p, nm_usuario_p);
 
begin /* Obter dados da TPS */
 
select	dt_periodo_inicial, 
	dt_periodo_final, 
	coalesce(vl_taxa_benef,0.5) 
into STRICT	dt_periodo_inicial_w, 
	dt_periodo_final_w, 
	vl_taxa_benef_w 
from	pls_tps 
where	nr_sequencia	= nr_seq_tps_p;
exception when others then 
	CALL wheb_mensagem_pck.exibir_mensagem_abort(188956,'NR_SEQ_TPS='||nr_seq_tps_p);
end;
 
select	coalesce(max(ie_arredondar_tps),'S') 
into STRICT	ie_arredondar_tps_w 
from	pls_parametros 
where	cd_estabelecimento	= cd_estabelecimento_p;
 
select	count(1) 
into STRICT	qt_regra_grupo_segmentacao_w 
from	pls_tps_regra_segmentacao;
 
open C01(cd_estabelecimento_p);
loop 
FETCH C01 BULK COLLECT INTO s_array LIMIT 1000;
	Vetor_c01_w(i) := s_array;
	i := i + 1;
EXIT WHEN NOT FOUND; /* apply on C01 */
END LOOP;
CLOSE C01;
 
for i in 1..Vetor_c01_w.COUNT loop 
	s_array := Vetor_c01_w(i);
	for z in 1..s_array.COUNT loop 
		begin 
		ie_abrangencia_w		:= s_array[z].ie_abrangencia;
		ie_segmentacao_w		:= s_array[z].ie_segmentacao;
		ie_faixa_etaria_w		:= s_array[z].vl_dominio;
 
		qt_mes_w		:= 0;
		qt_primeiro_mes_w	:= 0;
		qt_segundo_mes_w	:= 0;
		qt_terceiro_mes_w	:= 0;
		qt_media_benef_ativo_w	:= 0;
		vl_calculo_w		:= 0;
		vl_base_w		:= 0;
		vl_desconto_w		:= 0;
		pr_desconto_w		:= 0;
		dt_periodo_w	:= dt_periodo_inicial_w;
 
		while dt_periodo_w <= dt_periodo_final_w loop 
			begin 
			qt_mes_w	:= qt_mes_w + 1;
			dt_periodo_w	:= last_day(dt_periodo_w);
			qt_benef_ativo_w	:= 0;
 
			open C02(cd_estabelecimento_p); -- Diether - OS 320461 - Alterei para tirar a function do where pela performance 
			loop
			fetch C02 into 
				ie_idade_tps_w;
			EXIT WHEN NOT FOUND; /* apply on C02 */
				begin 
				if (ie_idade_tps_w = ie_faixa_etaria_w) then 
					qt_benef_ativo_w	:= qt_benef_ativo_w + 1;
				end if;
				end;
			end loop;
			close C02;
 
			/* Somar os dados externos */
 
			select	coalesce(sum(a.qt_beneficiarios),0) 
			into STRICT	qt_externos_w 
			from	pls_tps_dados_externos a 
			where	a.ie_abrangencia = ie_abrangencia_w 
			and	a.ie_segmentacao = ie_segmentacao_w 
			and	a.ie_faixa_etaria = ie_faixa_etaria_w 
			and	a.dt_mes_referencia = trunc(dt_periodo_w,'month');
 
			if (qt_mes_w	= 1) then 
				qt_primeiro_mes_w	:= coalesce(qt_benef_ativo_w,0) + coalesce(qt_externos_w,0);
			elsif (qt_mes_w	= 2) then 
				qt_segundo_mes_w	:= coalesce(qt_benef_ativo_w,0) + coalesce(qt_externos_w,0);
			elsif (qt_mes_w	= 3) then 
				qt_terceiro_mes_w	:= coalesce(qt_benef_ativo_w,0) + coalesce(qt_externos_w,0);
			end if;
 
			dt_periodo_w	:= add_months(dt_periodo_w,1);
			end;
		end loop;
 
		qt_total_benef_ativo_w	:= qt_primeiro_mes_w + qt_segundo_mes_w + qt_terceiro_mes_w;
 
		if (ie_arredondar_tps_w = 'N') then 
			qt_media_benef_ativo_w	:= trunc(dividir_sem_round((qt_total_benef_ativo_w)::numeric,3),2);
		else 
			qt_media_benef_ativo_w	:= round((dividir_sem_round((qt_total_benef_ativo_w)::numeric,3))::numeric,2);
		end if;
 
		if (qt_media_benef_ativo_w	> 0) then 
 
			select	max(nr_seq_grupo) 
			into STRICT	nr_seq_grupo_w 
			from	pls_grupo_segmentacao		a, 
				pls_grupo_seg_item		b 
			where	a.nr_sequencia		= b.nr_seq_grupo 
			and	b.ie_segmentacao	= ie_segmentacao_w;
 
			if (ie_faixa_etaria_w = 1) then 
				vl_calculo_w	:= qt_media_benef_ativo_w * vl_taxa_benef_w;
				pr_desconto_w	:= pls_tps_obter_desconto_reg(ie_abrangencia_w, ie_segmentacao_w); /* Obter o desconto em relação a abrangência e segmentação */
				vl_desconto_w	:= round(dividir_sem_round(((qt_media_benef_ativo_w * vl_taxa_benef_w) * pr_desconto_w),100),2);
				vl_base_w	:= round((qt_media_benef_ativo_w * vl_taxa_benef_w) - dividir_sem_round(((qt_media_benef_ativo_w * vl_taxa_benef_w) * pr_desconto_w),100),2); --dividir_sem_round(((qt_media_benef_ativo_w * 0.5) * pr_desconto_w),100); 
			end if;
 
			/* Tratar agrupamento de segmentação */
 
			select	max(a.nr_sequencia) 
			into STRICT	nr_seq_pls_tps_reg_w 
			from	pls_tps_reg a 
			where	a.nr_seq_tps		= nr_seq_tps_p 
			and	a.ie_faixa_etaria	= ie_faixa_etaria_w 
			and	a.ie_abrangencia	= ie_abrangencia_w 
			and	a.nr_seq_grupo_seg	= nr_seq_grupo_w;
 
			qt_grupo_seg_w		:= 1;
 
			--Verifica se o grupo da segmentação em questão está cadastrado como regra de grupo segmentação na pasta Cadastros/ TPS - Regra grupo de segmentação, se houver ao menos um grupo cadastrado nesta pasta. 
			if (qt_regra_grupo_segmentacao_w <> 0) then 
				select	count(1) 
				into STRICT	qt_grupo_seg_w 
				from	pls_grupo_segmentacao		a, 
					pls_grupo_seg_item		b, 
					pls_tps_regra_segmentacao	c 
				where	a.nr_sequencia		= b.nr_seq_grupo 
				and	a.nr_sequencia		= c.nr_seq_grupo 
				and	b.ie_segmentacao	= ie_segmentacao_w;
			end if;
 
			if (nr_seq_grupo_w IS NOT NULL AND nr_seq_grupo_w::text <> '') then 
				ie_segmentacao_w	:= null;
			end if;
 
			if (qt_grupo_seg_w > 0) then 
				if (nr_seq_pls_tps_reg_w IS NOT NULL AND nr_seq_pls_tps_reg_w::text <> '') then 
					update	pls_tps_reg 
					set	qt_primeiro_mes	= qt_primeiro_mes + qt_primeiro_mes_w, 
						qt_segundo_mes	= qt_segundo_mes + qt_segundo_mes_w, 
						qt_terceiro_mes	= qt_terceiro_mes + qt_terceiro_mes_w, 
						qt_media_beneficiarios = qt_media_beneficiarios + qt_media_benef_ativo_w 
					where	nr_sequencia	= nr_seq_pls_tps_reg_w;
					 
					if (ie_faixa_etaria_w = 1) then 
						/* Recalcular desconto após agrupamento */
						 
						select (qt_media_beneficiarios * vl_taxa_benef_w) 
						into STRICT	vl_novo_calculo_w 
						from	pls_tps_reg a 
						where	nr_sequencia	= nr_seq_pls_tps_reg_w;
 
						update	pls_tps_reg 
						set	vl_calculo	= vl_novo_calculo_w 
						where	nr_sequencia	= nr_seq_pls_tps_reg_w;
						 
						select	round(((vl_calculo * pr_desconto_w)/100),2), 
							round(((qt_media_beneficiarios * vl_taxa_benef_w) - (((qt_media_beneficiarios * vl_taxa_benef_w) * pr_desconto_w)/100)),2) 
						into STRICT	vl_novo_desconto_w, 
							vl_nova_base_w 
						from	pls_tps_reg a 
						where	nr_sequencia	= nr_seq_pls_tps_reg_w;						
						 
						update	pls_tps_reg 
						set	vl_desconto	= vl_novo_desconto_w, 
							vl_base		= vl_nova_base_w 
						where	nr_sequencia	= nr_seq_pls_tps_reg_w;						
					end if;
				else 
					insert into pls_tps_reg(nr_sequencia, 
						nr_seq_tps, 
						dt_mes_registro, 
						ie_abrangencia, 
						ie_segmentacao, 
						ie_faixa_etaria, 
						vl_base, 
						dt_atualizacao, 
						nm_usuario, 
						dt_atualizacao_nrec, 
						nm_usuario_nrec, 
						vl_desconto, 
						qt_primeiro_mes, 
						qt_segundo_mes, 
						qt_terceiro_mes, 
						qt_media_beneficiarios, 
						vl_calculo, 
						nr_seq_grupo_seg) 
					values (	nextval('pls_tps_reg_seq'), 
						nr_seq_tps_p, 
						dt_periodo_w, 
						ie_abrangencia_w, 
						ie_segmentacao_w, 
						ie_faixa_etaria_w, 
						vl_base_w, 
						clock_timestamp(), 
						nm_usuario_p, 
						clock_timestamp(), 
						nm_usuario_p, 
						vl_desconto_w, 
						qt_primeiro_mes_w, 
						qt_segundo_mes_w, 
						qt_terceiro_mes_w, 
						qt_media_benef_ativo_w, 
						vl_calculo_w, 
						nr_seq_grupo_w);				
				end if;
			end if;
		end if;
		end;
	end loop;
end loop;
 
select	coalesce(sum(vl_base),0) vl_base, 
	coalesce(sum(vl_calculo),0), 
	coalesce(sum(vl_desconto),0)	 
into STRICT	vl_total_tps_w, 
	vl_calculo_w, 
	vl_desconto_tps_w 
from	pls_tps_reg 
where	nr_seq_tps	= nr_seq_tps_p;
 
/* Obter o desconto da TPS */
 
SELECT * FROM pls_tps_obter_desconto(nr_seq_tps_p, nr_seq_regra_desc_w, pr_desc_tps_w) INTO STRICT nr_seq_regra_desc_w, pr_desc_tps_w;
vl_desconto_mp_w	:= (vl_total_tps_w * pr_desc_tps_w) + vl_desconto_tps_w;
vl_liquido_w		:= vl_calculo_w - vl_desconto_mp_w;
 
update	pls_tps 
set	vl_base			= vl_total_tps_w, 
	vl_desconto_mp		= vl_desconto_mp_w, 
	vl_desc_cota_unica	= vl_desc_cota_unica_w, 
	vl_liquido		= vl_liquido_w, 
	vl_calculo		= vl_calculo_w, 
	nr_seq_regra_desconto	= nr_seq_regra_desc_w, 
	pr_desconto		= pr_desc_tps_w, 
	dt_geracao_lote		= clock_timestamp() 
where	nr_sequencia		= nr_seq_tps_p;
 
commit;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_calcular_tps ( nr_seq_tps_p pls_tps.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

