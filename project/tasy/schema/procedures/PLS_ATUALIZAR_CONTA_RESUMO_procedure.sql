-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_atualizar_conta_resumo ( nr_seq_conta_p bigint, cd_estabelecimento_p bigint, nm_usuario_p text) AS $body$
DECLARE


ie_tipo_item_w			varchar(1);
ie_status_item_w		varchar(1);
vl_liberado_w			double precision	:= 0;
vl_exame_coleta_w		double precision	:= 0;
cd_procedimento_w		bigint;
nr_seq_prestador_pgto_w		bigint;
qt_contas_taxa_coleta_w		bigint;
nr_seq_proc_w			bigint;
nr_seq_mat_w			bigint;
nr_seq_prest_pgto_coleta_w	bigint;
nr_seq_partic_w			bigint;
nr_seq_item_w			bigint;
ie_origem_proced_w		bigint;
nr_seq_proc_ref_w		bigint;
nm_prestador_pgto_w		varchar(255);
ie_glosa_w			pls_conta_proc.ie_glosa%type;
vl_sum_glosa_w			pls_conta.vl_glosa%type;
vl_glosa_original_w		pls_conta.vl_glosa%type;
vl_glosa_calc_w			pls_conta.vl_glosa%type;
vl_tolerancia_w			pls_conta.vl_glosa%type := 1.00;
vl_dif_glosa_w			pls_conta.vl_glosa%type;
ie_resolveu_dif_w		boolean;
vl_apresentado_w		pls_conta_medica_resumo.vl_apresentado%type;
vl_apresentado_dif_w		pls_conta_medica_resumo.vl_apresentado%type;
vl_apres_w			pls_conta_medica_resumo.vl_apresentado%type;
vl_apresentado_resum_w		pls_conta_medica_resumo.vl_apresentado%type;
qt_proc_w			integer;
ds_tipo_lote_contabil_w		tipo_lote_contabil.ds_tipo_lote_contabil%type;
dt_mes_competencia_w		pls_protocolo_conta.dt_mes_competencia%type;
vl_liberado_item_w		pls_conta_proc.vl_liberado%type;
vl_calculado_item_w			pls_conta_proc.vl_procedimento%type;
ie_prop_glosa_tot_resumo_w	pls_parametros.ie_prop_glosa_tot_resumo%type := 'N';

C01 CURSOR FOR
	/* Felipe 26/02/2011 - a.vl_liberado,  Troquei o vl_liberado pelo procedimento, para poder atualizar corretamente o vl_liberado do procedimento
	Robson - OS - 301504 ,Conforme conversei com o Felipe, voltamos com o VL_LIBERADO
	Felipe - 23/03/2011 - Alterei o valor do prestador para o campo VL_PRESTADOR 
	Felipe - OS 324931 - 28/06/2011 - Quando existir a informacao do fornecedor no material, o pagamento devera ser realizado ao fornecedor */

	/* Valores da CONTA */

	SELECT	'P' ie_tipo_item,
		coalesce(b.nr_seq_prestador_exec,c.nr_seq_prestador),
		a.ie_status,
		a.nr_sequencia nr_seq_item,
		a.nr_sequencia nr_seq_proc,
		null nr_seq_material,
		coalesce(a.vl_prestador,a.vl_liberado),
		a.nr_seq_prest_pgto_coleta,
		a.vl_exame_coleta,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.nr_seq_proc_ref,
		null,
		a.ie_glosa,
		c.dt_mes_competencia,
		a.vl_glosa,
		a.vl_liberado,
		a.vl_procedimento
	from	pls_conta_proc		a,
		pls_conta		b,
		pls_protocolo_conta 	c
	where	a.nr_seq_conta		= b.nr_sequencia
	and	c.nr_sequencia 	= b.nr_seq_protocolo
	and	a.nr_seq_conta	= nr_seq_conta_p
	and	a.ie_status not in ('M', 'D')
	and	b.ie_status != 'S'
	and	b.ie_origem_conta != 'A'
	
union all

	/* Valores do MEDICO EXECUTOR da CONTA */

	SELECT	'C' ie_tipo_item,
		coalesce(b.nr_seq_prestador_exec,c.nr_seq_prestador),
		a.ie_status,
		a.nr_sequencia nr_seq_item,
		a.nr_sequencia nr_seq_proc,
		null nr_seq_material,
		a.vl_pag_medico_conta,
		null,
		0,
		a.cd_procedimento,
		a.ie_origem_proced,
		0,
		null,
		a.ie_glosa,
		c.dt_mes_competencia,
		a.vl_glosa,
		a.vl_liberado,
		a.vl_procedimento
	from	pls_conta_proc		a,
		pls_conta		b,
		pls_protocolo_conta	c
	where	a.nr_seq_conta		= b.nr_sequencia
	and	c.nr_sequencia 		= b.nr_seq_protocolo
	and	a.nr_seq_conta		= nr_seq_conta_p
	and	((a.ie_glosa = 'N') or (coalesce(a.ie_glosa::text, '') = ''))
	and	not exists (select 1 from pls_proc_participante x where x.nr_seq_conta_proc = a.nr_sequencia)
	and	a.ie_status not in ('M', 'D')
	and	b.ie_status != 'S'
	and	a.vl_liberado		> 0
	and	a.vl_pag_medico_conta   > 0
	and	b.ie_origem_conta != 'A'
	
union all

	/* Valores dos materiais */

	select	'M' ie_tipo_item,
		coalesce(b.nr_seq_prestador_exec,c.nr_seq_prestador),
		a.ie_status,
		a.nr_sequencia nr_seq_item,
		null nr_seq_proc,
		a.nr_sequencia nr_seq_material,
		a.vl_liberado,
		null,
		0,
		null cd_procedimento, 
		null ie_origem_proced,
		0,
		null,
		a.ie_glosa,
		c.dt_mes_competencia,
		0,
		0,
		0
	from	pls_conta_mat		a,
		pls_conta		b,
		pls_protocolo_conta	c
	where	a.nr_seq_conta		= b.nr_sequencia
	and	b.nr_seq_protocolo 	= c.nr_sequencia
	and	a.nr_seq_conta		= nr_seq_conta_p
	and	a.ie_status not in ('M', 'D')
	and	b.ie_status != 'S'
	and	b.ie_origem_conta != 'A'
	
union all

	select	'R' ie_tipo_item,
		coalesce(c.nr_seq_prestador_pgto, coalesce(b.nr_seq_prestador_exec,d.nr_seq_prestador)),
		a.ie_status, 
		a.nr_sequencia nr_seq_item,
		a.nr_sequencia nr_seq_proc,
		null nr_seq_material,
		a.vl_prestador,
		null,
		a.vl_exame_coleta,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.nr_seq_proc_ref,
		c.nr_sequencia,
		a.ie_glosa,
		d.dt_mes_competencia,
		a.vl_glosa,
		a.vl_liberado,
		a.vl_procedimento
	from	pls_conta_proc		a,
		pls_conta		b,
		pls_proc_participante	c,
		pls_protocolo_conta	d
	where	a.nr_seq_conta		= b.nr_sequencia
	and	c.nr_seq_conta_proc	= a.nr_sequencia
	and	a.nr_seq_conta		= nr_seq_conta_p
	and	d.nr_sequencia		= b.nr_seq_protocolo
	and	a.ie_status not in ('M', 'D')
	and c.ie_status <> 'C'
	and	b.ie_status != 'S'
	and	((a.ie_glosa = 'N') or (coalesce(a.ie_glosa::text, '') = ''))
	and	b.ie_origem_conta != 'A'
	
union all

	select	'R' ie_tipo_item,
		coalesce(c.nr_seq_prestador_pgto, coalesce(b.nr_seq_prestador_exec,d.nr_seq_prestador)),
		a.ie_status, 
		a.nr_sequencia nr_seq_item,
		a.nr_sequencia nr_seq_proc,
		null nr_seq_material,
		a.vl_prestador,
		null,
		a.vl_exame_coleta,
		a.cd_procedimento,
		a.ie_origem_proced,
		a.nr_seq_proc_ref,
		c.nr_sequencia,
		a.ie_glosa,
		d.dt_mes_competencia,
		a.vl_glosa,
		a.vl_liberado,
		a.vl_procedimento
	from	pls_conta_proc		a,
		pls_conta		b,
		pls_proc_participante	c,
		pls_protocolo_conta	d
	where	a.nr_seq_conta		= b.nr_sequencia
	and	c.nr_seq_conta_proc	= a.nr_sequencia
	and	a.nr_seq_conta		= nr_seq_conta_p
	and	d.nr_sequencia		= b.nr_seq_protocolo
	and	a.ie_status not in ('M', 'D')
	and 	c.ie_status <> 'C'
	and	b.ie_status != 'S'
	and (a.ie_glosa = 'S')
	and	b.ie_origem_conta != 'A'
	and c.vl_glosa > 0
	and ie_prop_glosa_tot_resumo_w = 'S';
	
cs_resumo_proc CURSOR(nr_seq_conta_pc	pls_conta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_resumo,
		a.vl_liberado vl_lib_resumo,
		a.vl_glosa vl_glosa_resumo,
		-- Soma o valor de glosa do resumo para este procedimento
		(SELECT	sum(x.vl_glosa)
		from	pls_conta_medica_resumo x
		where	x.nr_seq_conta_proc = a.nr_seq_conta_proc
		and	x.nr_seq_conta = a.nr_seq_conta
		and	x.ie_tipo_item		<> 'I'
		and (x.ie_situacao = 'A' or coalesce(x.ie_situacao::text, '') = '')) vl_glosa_outros,
		b.vl_liberado vl_lib_conta,
		b.vl_glosa vl_glosa_conta
	from	pls_conta_medica_resumo	a,
		pls_conta_proc		b
	where	a.nr_seq_conta		= nr_seq_conta_pc
	and	(a.nr_seq_conta_proc IS NOT NULL AND a.nr_seq_conta_proc::text <> '')
	and	a.ie_tipo_item		!= 'I'
	and	a.ie_situacao 		= 'A' 
	and	b.nr_sequencia		= a.nr_seq_conta_proc;
	
cs_resumo_mat CURSOR(nr_seq_conta_pc	pls_conta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_resumo,
		a.vl_liberado vl_lib_resumo,
		a.vl_glosa vl_glosa_resumo,
		-- Soma o valor de glosa do resumo para este material
		(SELECT	sum(x.vl_glosa)
		from	pls_conta_medica_resumo x
		where	x.nr_seq_conta_mat	= a.nr_seq_conta_mat
		and	x.nr_seq_conta = a.nr_seq_conta
		and	x.nr_sequencia		<> a.nr_sequencia
		and	x.ie_tipo_item		<> 'I'
		and	x.ie_situacao 		= 'A' ) vl_glosa_outros,
		b.vl_liberado vl_lib_conta,
		b.vl_glosa vl_glosa_conta
	from	pls_conta_medica_resumo	a,
		pls_conta_mat		b
	where	a.nr_seq_conta		= nr_seq_conta_p
	and	(a.nr_seq_conta_mat IS NOT NULL AND a.nr_seq_conta_mat::text <> '')
	and	a.ie_tipo_item		!= 'I'
	and	a.ie_situacao 		= 'A'
	and	b.nr_sequencia		= a.nr_seq_conta_mat;
		
cs_resumo_proc_apres CURSOR(nr_seq_conta_pc	pls_conta.nr_sequencia%type) FOR
	SELECT	a.nr_seq_conta,
		a.nr_sequencia,
		a.vl_procedimento_imp,
		a.vl_liberado
	from	pls_conta_proc	a
	where	a.nr_seq_conta		= nr_seq_conta_pc;
	
procedure atualiza_val_simul_item_glosa(	nr_seq_conta_p		pls_conta.nr_sequencia%type,
											vl_glosa_p			pls_conta_medica_resumo.vl_glosa%type) is

pr_proporcao_w			double precision;
vl_glosa_acumulado_w	pls_conta_medica_resumo.vl_glosa%type := 0;
vl_glosa_w				pls_conta_medica_resumo.vl_glosa%type := 0;
nr_iteracao_w			integer := 0;
nr_seq_proc_ant_w		pls_conta_proc.nr_sequencia%type;											
											
C01 CURSOR FOR
	SELECT	a.nr_sequencia,
			a.vl_liberado,
			a.nr_seq_prestador_pgto,
			( 	SELECT sum( vl_liberado)
				from 	pls_conta_medica_resumo 
				where 	nr_seq_conta = nr_seq_conta_p 
				and 	nr_seq_conta_proc =  a.nr_seq_conta_proc) vl_lib_item,
			count(1) over (partition by b.nr_sequencia) total_registros,
			b.vl_glosa,
			b.nr_sequencia nr_seq_conta_proc
	from	pls_conta_medica_resumo a,
			pls_conta_proc b
	where	a.nr_seq_conta = nr_seq_conta_p
	and 	a.nr_seq_conta_proc = b.nr_sequencia
	and 	b.vl_glosa > 0
	and 	b.vl_liberado = 0
	order by b.nr_sequencia;
	

BEGIN
	
	for r_c01_w in C01 loop
	
	if (coalesce(nr_seq_proc_ant_w::text, '') = '') then		
		nr_seq_proc_ant_w := r_c01_w.nr_seq_conta_proc;	
	end if;	
	-- 72850719
	if (nr_seq_proc_ant_w <> r_c01_w.nr_seq_conta_proc) then	
		vl_glosa_acumulado_w := 0;
		nr_iteracao_w := 0;
		nr_seq_proc_ant_w := r_c01_w.nr_seq_conta_proc;		
	end if;
	
		nr_iteracao_w := nr_iteracao_w + 1;
	
		pr_proporcao_w := dividir( r_c01_w.vl_liberado, r_c01_w.vl_lib_item);
		vl_glosa_w := (r_c01_w.vl_glosa * pr_proporcao_w);
		vl_glosa_acumulado_w := vl_glosa_acumulado_w + vl_glosa_w;
		
		update 	pls_conta_medica_resumo
		set	vl_glosa =  vl_glosa_w,--r_c01_w.vl_liberado,
			vl_liberado = 0,
			vl_lib_original = 0,
			nm_usuario = nm_usuario_p,
			dt_atualizacao = clock_timestamp()
		where 	nr_seq_conta = nr_seq_conta_p
		and 	nr_sequencia = r_c01_w.nr_sequencia;	
		
		vl_glosa_w := vl_glosa_w + (r_c01_w.vl_glosa - vl_glosa_acumulado_w);

		if ( nr_iteracao_w = r_c01_w.total_registros) then
		
		update 	pls_conta_medica_resumo
		set		vl_glosa =  vl_glosa_w,--r_c01_w.vl_liberado,
				vl_liberado = 0,
				vl_lib_original = 0,
				nm_usuario = nm_usuario_p,
				dt_atualizacao = clock_timestamp()
		where 	nr_seq_conta = nr_seq_conta_p
		and 	nr_sequencia = r_c01_w.nr_sequencia;			
		
		end if;
		
	end loop;

end;
	
begin

if (cd_estabelecimento_p IS NOT NULL AND cd_estabelecimento_p::text <> '') then
	select 	coalesce(ie_prop_glosa_tot_resumo, 'N')
	into STRICT	ie_prop_glosa_tot_resumo_w
	from 	pls_parametros
	where 	cd_estabelecimento = cd_estabelecimento_p;
end if;

CALL pls_delete_conta_medica_resumo(nr_seq_conta_p,null,null,nm_usuario_P);

open C01;
loop
fetch C01 into	
	ie_tipo_item_w,
	nr_seq_prestador_pgto_w,
	ie_status_item_w,
	nr_seq_item_w,
	nr_seq_proc_w,
	nr_seq_mat_w,	
	vl_liberado_w,
	nr_seq_prest_pgto_coleta_w,
	vl_exame_coleta_w,
	cd_procedimento_w,
	ie_origem_proced_w,
	nr_seq_proc_ref_w,
	nr_seq_partic_w,
	ie_glosa_w,
	dt_mes_competencia_w,
	vl_glosa_original_w,
	vl_liberado_item_w,
	vl_calculado_item_w;	
EXIT WHEN NOT FOUND; /* apply on C01 */
	begin
	
	/*OS 425485 - Diogo : Retiradas as restricoes para que o prestador pagamento sepre se mantenha atualizado na pls_conta_medica_resumo*/

	if	((coalesce(nr_seq_prestador_pgto_w,0) > 0) or (ie_tipo_item_w = 'I')) then
		/*Se for item diferente de prestador
		    Ou ja existir taxa de coleta para o procedimento na conta*/
		
		if (vl_exame_coleta_w < 0) then
			vl_exame_coleta_w	:= 0;
		end if;
		
		/*Atualizar a referencia do procedimento*/

		if (coalesce(nr_seq_proc_ref_w,0)	<> 0) then
			vl_exame_coleta_w	:= 0;
		end if;
	
		if	((vl_exame_coleta_w <> 0) or (coalesce(nr_seq_prest_pgto_coleta_w,0)	= 0)) then
			
			--Necessario dar uma tratativa diferenciada para item totalmente glosado, para que o recurso de glosa possa ser realizado adequadamente para 

			--casos onde geraria mutiplos prest pagamento para um item ou pagamento para o partcipante e nao executor da conta, alem de proporcionalizar

			--vl glosa no resumo, visando gerar um pagamento proporcional adequado, posteriormente no recurso de glosa.
			if (  vl_glosa_original_w > 0 and vl_liberado_item_w = 0 and vl_calculado_item_w > 0 and ie_tipo_item_w != 'M' and ie_prop_glosa_tot_resumo_w = 'S') then
				
				CALL pls_inserir_res_item_simulacao(	nr_seq_proc_w, nr_seq_partic_w, null,
							ie_tipo_item_w, 0, nm_usuario_p, ''	);
			else
				CALL pls_inserir_conta_resumo_item(	nr_seq_proc_w, nr_seq_partic_w, nr_seq_mat_w,
							ie_tipo_item_w, 0, nm_usuario_p, 
							''	);
			end if;
			
		end if;			
		
		/* Gerar o pagamento do prestador executor do exame de coleta 
		OPS - Prestadores / Prestadores / Exames de coleta */
		if (coalesce(nr_seq_prest_pgto_coleta_w,0) > 0) then
			
			--Necessario dar uma tratativa diferenciada para item totalmente glosado, para que o recurso de glosa possa ser realizado adequadamente para 

			--casos onde geraria multiplos prest pagamento para um item ou pagamento para o partcipante e nao executor da conta, alem de proporcionalizar

			--vl glosa no resumo, visando gerar um pagamento proporcional adequado, posteriormente no recurso de glosa.
			if (  vl_glosa_original_w > 0 and vl_liberado_item_w = 0 and vl_calculado_item_w > 0 and ie_tipo_item_w != 'M' and ie_prop_glosa_tot_resumo_w = 'S') then
				
				CALL pls_inserir_res_item_simulacao(	nr_seq_proc_w, nr_seq_partic_w, null,
							ie_tipo_item_w, 0, nm_usuario_p, ''	);
			else
				/* Inserir o pagamento do prestador da regra */
		
				CALL pls_inserir_conta_resumo_item(	nr_seq_proc_w, nr_seq_partic_w, nr_seq_mat_w,
								ie_tipo_item_w, nr_seq_prest_pgto_coleta_w, nm_usuario_p, 
								''	);
			end if;
								
			nm_prestador_pgto_w:= substr(pls_obter_dados_prestador(nr_seq_prest_pgto_coleta_w,'N'),1,255);
			
			if (coalesce(ie_glosa_w,'N') <> 'S')	then
				/* Atualizar o pagamento da coleta do prestador executor da conta */

				update	pls_conta_medica_resumo
				set	vl_liberado		= vl_liberado_w - vl_exame_coleta_w,
					vl_lib_original		= vl_liberado_w - vl_exame_coleta_w,
					ds_tipo_item		= 'Prestador',
					nr_seq_prestador_pgto	= nr_seq_prest_pgto_coleta_w,
					nm_prestador_pgto	= nm_prestador_pgto_w,
					vl_co_pag		= vl_liberado_w - vl_exame_coleta_w,
					vl_hm			= 0,
					vl_materiais_pag	= 0
				where	nr_seq_conta		= nr_seq_conta_p
				and	coalesce(nr_seq_exame_coleta,0) = 0
				and	nr_seq_item		= nr_seq_item_w
				and	ie_situacao = 'A';
				
				if (vl_exame_coleta_w	<> 0) then
					nm_prestador_pgto_w:= substr(pls_obter_dados_prestador(nr_seq_prestador_pgto_w,'N'),1,255);
					update	pls_conta_medica_resumo
					set	vl_liberado		= vl_exame_coleta_w,
						vl_lib_original		= vl_exame_coleta_w,
						ds_tipo_item		= 'Prestador (Taxa de Coleta)',
						qt_item			= 1,
						nr_seq_prestador_pgto	= nr_seq_prestador_pgto_w,
						nm_prestador_pgto	= nm_prestador_pgto_w,
						vl_hm			= 0,
						vl_materiais_pag	= 0,
						vl_co_pag		= vl_exame_coleta_W
					where	nr_seq_conta		= nr_seq_conta_p
					and	coalesce(nr_seq_exame_coleta,0) > 0				
					and	nr_seq_item		= nr_seq_item_w
					and	ie_situacao = 'A';
				end if;
			end if;
		end if;		
	end if;
	end;
end loop;
close C01;

-- Sessao do descarrego: VL_GLOSA; 

-- Somanr o valor de glosa do resumo
select	sum(a.vl_glosa)
into STRICT	vl_sum_glosa_w
from	pls_conta_medica_resumo	a
where	a.nr_seq_conta = nr_seq_conta_p
and	a.ie_tipo_item <> 'I'
and	a.ie_situacao = 'A';

-- Se o valor de glosa gravado no resumo for maior que o valor de glosa informado no resumo deve ser rateado.
if (vl_sum_glosa_w > vl_glosa_original_w) then
	
	-- Calcula o valor de diferenca entre os valores.
	vl_dif_glosa_w	:= vl_sum_glosa_w - vl_glosa_original_w;
	
	-- Se for maior que o valor de tolerancia nao faremos o acerto e o usuario sera informado via mensagem de erro.
	if (vl_dif_glosa_w <= vl_tolerancia_w) then
		
		ie_resolveu_dif_w	:= false;
		
		-- Varrer os registros do resumo gerados para esta conta.
		for	rw_resumo_w in cs_resumo_proc(nr_seq_conta_p) loop
						
			vl_glosa_calc_w	:= null;
			
			-- Se o valor do resumo tiver maior que o valor original tem que descontar a diferenca.
			if (rw_resumo_w.vl_glosa_outros >  rw_resumo_w.vl_glosa_conta) then
				
				-- calcula o novo valor de glosa pra o registro no resumo
				vl_glosa_calc_w := rw_resumo_w.vl_glosa_resumo - (rw_resumo_w.vl_glosa_outros - rw_resumo_w.vl_glosa_conta);
				
				-- Desconta a diferenca do valor de diferenca da conta
				vl_dif_glosa_w	:= vl_dif_glosa_w - (rw_resumo_w.vl_glosa_resumo - vl_glosa_calc_w);
				
				-- Se nao tem mais diferenca acabou nao precisa mais processar nada.
				if (vl_dif_glosa_w = 0) then
					
					ie_resolveu_dif_w	:= true;
				end if;
			end if;
			
			-- se calculou novo valor de glosa atualiza o item.
			if (vl_glosa_calc_w IS NOT NULL AND vl_glosa_calc_w::text <> '') then
			
				update	pls_conta_medica_resumo
				set	vl_glosa = vl_glosa_calc_w
				where	nr_sequencia = rw_resumo_w.nr_seq_resumo;
			end if;
			
			-- se tiver resolvido sai do loop.
			exit when ie_resolveu_dif_w;
		end loop;
		
		-- Se ja tiver resolvido nem mexe nos materiais.
		if (not ie_resolveu_dif_w) then
			
			-- Varre o resumo dos materiais para a conta e seguir a mesma ideia  dos procedimentos.
			for	rw_resumo_w in cs_resumo_mat(nr_seq_conta_p) loop
							
				vl_glosa_calc_w	:= null;
				
				-- Se o valor de glosa do resumo for maior que do material entao deve descontar a difereca.
				if (rw_resumo_w.vl_glosa_outros >  rw_resumo_w.vl_glosa_conta) then
					
					-- Calcula o novo valor de glosa
					vl_glosa_calc_w := rw_resumo_w.vl_glosa_resumo - (rw_resumo_w.vl_glosa_outros - rw_resumo_w.vl_glosa_conta);
					
					--- atualiza a diferenca;
					vl_dif_glosa_w	:= vl_dif_glosa_w - (rw_resumo_w.vl_glosa_resumo - vl_glosa_calc_w);
					
					-- Se nao tem mais diferenca acabou.
					if (vl_dif_glosa_w = 0) then
						
						ie_resolveu_dif_w	:= true;
					end if;
				end if;
				
				-- Se tem novo valor calculado atualiza o valor do resumo.
				if (vl_glosa_calc_w IS NOT NULL AND vl_glosa_calc_w::text <> '') then
				
					update	pls_conta_medica_resumo
					set	vl_glosa = vl_glosa_calc_w
					where	nr_sequencia = rw_resumo_w.nr_seq_resumo;
				end if;
				
				-- se tiver resolvido nao precisa verificar os demais itens.
				exit when ie_resolveu_dif_w;
			end loop;
		end if;
	end if;
end if;

--Cursor de procedimentos. Divide proporcionalmente o valor apresentado entre os registros 

--na pls_conta_medica_resumo de cada item da conta
for rw_cs_resumo_apres_w in cs_resumo_proc_apres(nr_seq_conta_p) loop
	
	update	pls_conta_medica_resumo
	set	vl_apresentado 	 	= dividir_sem_round((vl_lib_original * rw_cs_resumo_apres_w.vl_procedimento_imp), rw_cs_resumo_apres_w.vl_liberado)
	where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
	and	nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
	and	ie_tipo_item		!= 'I'
	and	ie_situacao		= 'A';

	select	sum(vl_apresentado)
	into STRICT	vl_apresentado_resum_w
	from	pls_conta_medica_resumo
	where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
	and	nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
	and	ie_tipo_item		!= 'I'
	and	ie_situacao		= 'A';
	--Diferenca entre a soma dos valores apresentados dos registros na pls_conta_medica_resumo do procedimento em questao, em relacao ao valor apresentado para o procedimento.
	vl_apresentado_dif_w := rw_cs_resumo_apres_w.vl_procedimento_imp - vl_apresentado_resum_w;

	--Na divisao do valor apresentado, pode ocorrer uma divergencia de valor entre a soma dos registros e o total apresentado do item,

	--entao aqui e feito um ajuste e o ajuste apenas ocorre em um unico item cujo valor apresentado ja seja maior que o valor de ajuste(evita ficar negativo, no caso de ajuste com valor negativo)
	if (vl_apresentado_dif_w <> 0) then
		update	pls_conta_medica_resumo
		set	vl_apresentado = vl_apresentado + vl_apresentado_dif_w
		where	nr_sequencia   =  (	SELECT	max(nr_sequencia)
						from 	pls_conta_medica_resumo
						where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
						and	nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
					--	and	vl_apresentado 		> vl_apresentado_dif_w
						and	ie_tipo_item		!= 'I'
						and	ie_situacao		= 'A')
		and   nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta;
	end if;
	commit;
	
end loop;

for rw_cs_resumo_apres_w in cs_resumo_proc_apres(nr_seq_conta_p) loop
	
	select 	count(1)
	into STRICT	qt_proc_w
	from	pls_conta_medica_resumo
	where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
	and		nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
	and		ie_tipo_item		!= 'I'
	and		ie_situacao			= 'A';
	
	if (qt_proc_w	> 1) then
		update	pls_conta_medica_resumo
		set		vl_apres_ind		= dividir_sem_round((vl_lib_original * rw_cs_resumo_apres_w.vl_procedimento_imp), rw_cs_resumo_apres_w.vl_liberado)
		where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
		and		nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
		and		ie_tipo_item		!= 'I'
		and		ie_situacao			= 'A';

		select	sum(vl_apres_ind)
		into STRICT	vl_apresentado_resum_w
		from	pls_conta_medica_resumo
		where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
		and		nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
		and		ie_tipo_item		!= 'I'
		and		ie_situacao			= 'A';
	
		--Diferenca entre a soma dos valores apresentados dos registros na pls_conta_medica_resumo do procedimento em questao, em relacao ao valor apresentado para o procedimento.
		vl_apresentado_dif_w := rw_cs_resumo_apres_w.vl_procedimento_imp - vl_apresentado_resum_w;

		--Na divisao do valor apresentado, pode ocorrer uma divergencia de valor entre a soma dos registros e o total apresentado do item,

		--entao aqui e feito um ajuste e o ajuste apenas ocorre em um unico item cujo valor apresentado ja seja maior que o valor de ajuste(evita ficar negativo, no caso de ajuste com valor negativo)
		if (vl_apresentado_dif_w <> 0) then
			update	pls_conta_medica_resumo
			set		vl_apres_ind = vl_apresentado + vl_apresentado_dif_w
			where	nr_sequencia   =  (	SELECT	max(nr_sequencia)
										from 	pls_conta_medica_resumo
										where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
										and		nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
										and		ie_tipo_item		!= 'I'
										and		ie_situacao			= 'A')
			and   nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta;
		end if;
	else
		update	pls_conta_medica_resumo
		set		vl_apres_ind	 	= rw_cs_resumo_apres_w.vl_procedimento_imp
		where	nr_seq_conta		= rw_cs_resumo_apres_w.nr_seq_conta
		and		nr_seq_conta_proc	= rw_cs_resumo_apres_w.nr_sequencia
		and		ie_tipo_item		!= 'I'
		and		ie_situacao			= 'A';
	end if;
	
	commit;
	
end loop;

	--Se for procedimento e o item foi totalmente glosado, precisa atualizar valores de glosas proporcionais e zerar valor liberado, ja que nesse caso, chama a 

	--pls_inserir_res_item_sumulacao fazendo simulacao como se valor estivesse liberado, para definir o pretador de pagamento corretamente.
	if (ie_prop_glosa_tot_resumo_w = 'S') then
		atualiza_val_simul_item_glosa( nr_seq_conta_p, vl_glosa_original_w);
	end if;

ds_tipo_lote_contabil_w := pls_atualizar_contab_val_adic(dt_mes_competencia_w, nm_usuario_p, ds_tipo_lote_contabil_w, null, nr_seq_conta_p);

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_atualizar_conta_resumo ( nr_seq_conta_p bigint, cd_estabelecimento_p bigint, nm_usuario_p text) FROM PUBLIC;

