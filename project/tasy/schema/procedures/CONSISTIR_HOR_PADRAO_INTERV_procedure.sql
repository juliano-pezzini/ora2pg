-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE consistir_hor_padrao_interv ( ds_horarios_p text, cd_intervalo_p text, dt_primeiro_horario_p timestamp, ds_erro_p INOUT text, ie_item_cpoe_p text default 'N') AS $body$
DECLARE


ds_hor_aux_w			varchar(2000);
x						bigint;
qt_operacao_w			intervalo_prescricao.qt_operacao%type;
ie_operacao_w			varchar(1);
qt_tamanho_w			bigint;
ds_horarios_w			varchar(2000);
qt_horarios_w			bigint;
qt_pos_atual_w			bigint;
qt_horario_interv_w		bigint;
ds_intervalo_w			varchar(40);
ds_horario_w			varchar(10);
qt_pos_espaco_w			bigint;
ie_invalido_w			varchar(1)	:= 'N';
dt_final_w				timestamp;
dt_horario_w			timestamp;
dt_primeiro_horario_w	timestamp;
dt_horario_anterior_w	timestamp;
ie_novo_dia_w			varchar(1)	:= 'N';
qt_controle_w			bigint;


BEGIN

ds_hor_aux_w	:= substr(replace(replace(ds_horarios_p,' ',''),':',''),1,2000);

x	:= 1;
while(x	< length(ds_horarios_p)) loop
	if (substr(ds_hor_aux_w,x,1) not in ('0','1','2','3','4','5','6','7','8','9')) then
		ds_erro_p	:= wheb_mensagem_pck.get_texto(278801);
		exit;
	end if;
	x	:= x + 1;
end loop;

dt_primeiro_horario_w := trunc(dt_primeiro_horario_p, 'mi');
if (coalesce(ie_item_cpoe_p,'N') = 'S') then
	dt_primeiro_horario_w := to_date(to_char(dt_primeiro_horario_w,'dd/mm/yyyy')||' '||obter_prim_dshorarios(ds_horarios_p)||':00','dd/mm/yyyy hh24:mi:ss');
end if;

dt_final_w	:= (dt_primeiro_horario_w + 1) - 1/86400;

if (coalesce(ds_erro_p::text, '') = '') and (cd_intervalo_p IS NOT NULL AND cd_intervalo_p::text <> '') then

	ds_horarios_w	:= replace(ds_horarios_p,'  ',' ');

	qt_tamanho_w	:= length(ds_horarios_w);
	--Caso o primeiro caracter seja um espaço, este é eliminado
	while(substr(ds_horarios_w,1,1) = ' ') loop
		begin
		ds_horarios_w	:= substr(ds_horarios_w,2,qt_tamanho_w);
		qt_tamanho_w	:= length(ds_horarios_w);
		end;
	end loop;



	--Caso o último caracter seja um espaço, este é eliminado
	while(substr(ds_horarios_w,qt_tamanho_w,1) = ' ') loop
		begin
		ds_horarios_w	:= substr(ds_horarios_w,1,qt_tamanho_w - 1);
		qt_tamanho_w	:= length(ds_horarios_w);
		end;
	end loop;
	qt_tamanho_w	:= length(ds_horarios_w);
	qt_horarios_w	:= 0;
	qt_pos_atual_w	:= 1;


	if (position(' ' in ds_horarios_w)	> 0) or (length(ds_horarios_w)		= 2) or (length(ds_horarios_w)		= 5) then

		--Loop para validar os horários
		while(qt_pos_atual_w	<= qt_tamanho_w) loop
			begin

			--Cada espaço se indica um novo horário
			if (substr(ds_horarios_w,qt_pos_atual_w,1) = ' ') or (qt_pos_atual_w	= 1) then

				--Controlar para pegar a posição correta do primeiro horário da String
				if (qt_pos_atual_w	= 1) then
					qt_controle_w	:= 0;
				else
					qt_controle_w	:= 1;
				end if;

				--Posição do próximo espaço
				qt_pos_espaco_w	:= position(' ' in substr(ds_horarios_w,qt_pos_atual_w + qt_controle_w,qt_tamanho_w));

				--Horário
				if (qt_pos_espaco_w	= 0) then
					ds_horario_w	:= substr(ds_horarios_w,qt_pos_atual_w + qt_controle_w,qt_tamanho_w);
				else
					ds_horario_w	:= substr(ds_horarios_w,qt_pos_atual_w + qt_controle_w,qt_pos_espaco_w - 1);
				end if;


				--Verificar se o horário está no formato hh ou hh:24, e se o mesmo é válido
				if (length(ds_horario_w)	= 5) and (position(':' in ds_horario_w) = 3) then
					if ((substr(ds_horario_w,1,2))::numeric  > 23) or ((substr(ds_horario_w,4,2))::numeric  > 59) then
						ie_invalido_w	:= 'S';
					end if;
				elsif (length(ds_horario_w)	= 2) then
					if ((ds_horario_w)::numeric  > 23) then
						ie_invalido_w	:= 'S';
					else
						ds_horario_w	:= ds_horario_w||':00';

					end if;
				else
					ie_invalido_w	:= 'S';
				end if;

				if (ie_invalido_w	= 'S') then
					ds_erro_p	:= wheb_mensagem_pck.get_texto(278803);
					exit;
				else
					dt_horario_w	:= to_date(to_char(dt_primeiro_horario_w,'dd/mm/yyyy')||' '||ds_horario_w||':00','dd/mm/yyyy hh24:mi:ss');
					if (dt_primeiro_horario_w	> dt_horario_w) or (ie_novo_dia_w	= 'S') or
						(dt_horario_w	<= dt_horario_anterior_w AND dt_horario_anterior_w IS NOT NULL AND dt_horario_anterior_w::text <> '') then
						dt_horario_w	:= dt_horario_w + 1;
						ie_novo_dia_w	:= 'S';
					end if;
					if (dt_horario_w	between dt_primeiro_horario_w	and dt_final_w) then
						qt_horarios_w	:= qt_horarios_w + 1;
						dt_horario_anterior_w	:= dt_horario_w;
					else
						if (coalesce(ie_item_cpoe_p,'N') = 'N') then
							ds_erro_p	:= wheb_mensagem_pck.get_texto(278804);
						end if;
						exit;
					end if;
				end if;
			end if;
			qt_pos_atual_w	:= qt_pos_atual_w	+ 1;
			end;
		end loop;

	end if;

	if (coalesce(ds_erro_p::text, '') = '') then

		select	max(ie_operacao),
			coalesce(max(qt_operacao),0),
			max(ds_intervalo)
		into STRICT	ie_operacao_w,
			qt_operacao_w,
			ds_intervalo_w
		from	intervalo_prescricao
		where	cd_intervalo	= cd_intervalo_p;

		if (ie_operacao_w	in ('F','V','X')) and (qt_horarios_w	<> qt_operacao_w) then
			ds_erro_p	:= wheb_mensagem_pck.get_texto(278805, 'QT_OPERACAO_P=' || qt_operacao_w ||
										';DS_INTERVALO_P=' || ds_intervalo_w);
		elsif (ie_operacao_w	= 'H') and (ceil(qt_horarios_w)	<> ceil(24 / qt_operacao_w)) and (qt_operacao_w <= 24) then
			ds_erro_p	:= wheb_mensagem_pck.get_texto(278806, 'QT_OPERACAO_P=' || ceil(24 / qt_operacao_w) ||
										';DS_INTERVALO_P=' || ds_intervalo_w);
		end if;

	end if;

end if;


end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE consistir_hor_padrao_interv ( ds_horarios_p text, cd_intervalo_p text, dt_primeiro_horario_p timestamp, ds_erro_p INOUT text, ie_item_cpoe_p text default 'N') FROM PUBLIC;

