-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE lista AS (nr_intervalo bigint);


CREATE OR REPLACE PROCEDURE mprev_obter_horarios_agenda ( dt_agenda_p timestamp, nr_seq_equipe_p mprev_equipe_profissional.nr_seq_equipe%type, ie_loc_interno_p mprev_local_atend.ie_interno%type, ie_loc_tipo_atend_p mprev_local_atend.ie_tipo_atendimento%type, cd_agenda_p agenda_turno.cd_agenda%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, qt_intervalo_p INOUT bigint, hr_inicial_p INOUT timestamp, hr_final_p INOUT timestamp, ie_bloqueio_feriado_p INOUT text) AS $body$
DECLARE

type vetor_intervalor is table of lista index by integer;

cd_agenda_w		bigint;
nr_menor_intervalo_w	bigint := 0;
nr_menor_intervalo_ww	bigint;
vetor_intervalos_w	vetor_intervalor;	
nr_dia_semana_w		smallint := pkg_date_utils.get_weekday(dt_agenda_p);
ie_feriado_w		varchar(1);
dt_agenda_w		timestamp;

/* retorno da procedure interna */

ie_bloqueio_feriado_w	varchar(3);
ie_bloqueio_feriado_int_w	varchar(3);

/* Intervalo padrao sera de 30 minutos, por enquanto */

qt_intervalo_padrao_w	integer	:= 0;

/* Variaveis de hr_inicial_p e hr_final_p */

hr_inicial_w	timestamp;
hr_final_w		timestamp;
dti_ano_w		bigint;
dti_month_w		bigint;
dti_day_w		bigint;
dti_hour_w		bigint;
dti_minute_w	bigint;
dtf_ano_w		bigint;
dtf_month_w		bigint;
dtf_day_w		bigint;
dtf_hour_w		bigint;
dtf_minute_w	bigint;

-- Variaveis para calculos
qt_hora_calc_aux_w				smallint := 0;
qt_minutos_hora_inicial_w		integer := 0;
qt_minutos_hora_final_w			integer := 0;
qt_interval_entre_ini_e_fin_w	integer := 0;
qt_total_min_do_interval_w		integer := 0;
qt_diferenca_min_tot_fin_w		integer := 0;

C01 CURSOR(	nr_dia_semana_pc	agenda_turno.ie_dia_semana%type,
		cd_agenda_pc		agenda_turno.cd_agenda%type) FOR
	SELECT	to_date(to_char(dt_agenda_w, 'dd/mm/yyyy') ||' '|| to_char(a.hr_inicial, 'hh24:mi') ,'dd/mm/yyyy hh24:mi') hr_inicial,
		to_date(to_char(dt_agenda_w, 'dd/mm/yyyy') ||' '|| to_char(a.hr_final, 'hh24:mi') ,'dd/mm/yyyy hh24:mi') hr_final,
		nr_minuto_intervalo,
		coalesce(ie_feriado, 'S') ie_feriado
	from	agenda_turno a
	where	cd_agenda = cd_agenda_pc
	and (ie_dia_semana	= nr_dia_semana_pc or (ie_dia_semana = 9 and nr_dia_semana_pc not in (1,7)))
	and	pkg_date_utils.start_of(dt_agenda_p,'DD',0) between a.dt_inicio_vigencia and coalesce(a.dt_final_vigencia, dt_agenda_p)
	and (obter_se_gerar_turno_agecons(a.dt_inicio_vigencia,a.ie_frequencia,dt_agenda_p) = 'S')
    and	((Obter_Semana_Dia_Agecons(dt_agenda_p,a.ie_dia_semana) = coalesce(a.ie_semana,0)) or (coalesce(a.ie_semana,0) = 0));

C02 CURSOR FOR
	SELECT	b.cd_agenda
	from	mprev_equipe_profissional a,
		agenda b
	where	b.cd_pessoa_fisica = a.cd_pessoa_fisica
	and	b.cd_tipo_agenda = '6'
	and	dt_agenda_p between a.dt_inclusao and coalesce(a.dt_exclusao,dt_agenda_p)
	and	a.nr_seq_equipe = nr_seq_equipe_p;

C03 CURSOR FOR
	SELECT	distinct
		b.cd_agenda
	from	mprev_local_atend a,
		mprev_local_atend_agenda b
	where	b.nr_seq_local_atend = a.nr_sequencia
	and	a.ie_situacao = 'A'
	and	b.ie_situacao = 'A'
	and (a.ie_interno = ie_loc_interno_p or coalesce(ie_loc_interno_p::text, '') = '')
	and (a.ie_tipo_atendimento = ie_loc_tipo_atend_p or coalesce(ie_loc_tipo_atend_p::text, '') = '');

-- Carrega os horarios no vetor e alimenta as variaveis de hora e data.
procedure carrega_horarios(	cd_agenda_p		in	agenda_turno.cd_agenda%type,
				nr_dia_semana_p		in	agenda_turno.ie_dia_semana%type,
				ie_feriado_p		in	text,
				ie_bloqueio_feriado_int_p	out	text) is;
BEGIN
-- Comeca negando, se for bloquado por feriado o cursor seta para sim.
ie_bloqueio_feriado_int_p := 'N';

for cr_01 in C01(nr_dia_semana_w, cd_agenda_p) loop
	-- Verificacao da geracao por feriado. 

	-- Se gera em feriado entao nao verifica mais nada

	-- Se nao gera em feriado entao so gera quando for dia util

	-- Se so gera em feriado entao gera quando nao e dia util.
	if	((cr_01.ie_feriado = 'S') or (cr_01.ie_feriado = 'N' and ie_feriado_p = 'N') or (cr_01.ie_feriado = 'F' and ie_feriado_p = 'S'))then
		
		if (coalesce(hr_inicial_w::text, '') = '' or cr_01.hr_inicial < hr_inicial_w) then
			hr_inicial_w := cr_01.hr_inicial;
		end if;

		if (coalesce(hr_final_w::text, '') = '' or cr_01.hr_final > hr_final_w) then
			hr_final_w := cr_01.hr_final;
		end if;
		
		if (qt_intervalo_padrao_w = 0 or cr_01.nr_minuto_intervalo < qt_intervalo_padrao_w) then
			qt_intervalo_padrao_w := cr_01.nr_minuto_intervalo;
		end if;
	else
		ie_bloqueio_feriado_int_p := 'S';
		qt_intervalo_padrao_w := 0;
	end if;
end loop;
end;

begin
ie_bloqueio_feriado_w	:= 'N';
dt_agenda_w	:= pkg_date_utils.start_of(dt_agenda_p,'DD',0);
-- Verificar se e feriado ou dia de semana.
select	CASE WHEN obter_se_feriado(cd_estabelecimento_p,dt_agenda_w)=0 THEN 'N'  ELSE 'S' END
into STRICT	ie_feriado_w
;

if (cd_agenda_p IS NOT NULL AND cd_agenda_p::text <> '') then
	-- Carrega os horarios no vetor de horarios.
	carrega_horarios(cd_agenda_p, nr_dia_semana_w, ie_feriado_w,ie_bloqueio_feriado_int_w);
	
	if (ie_bloqueio_feriado_int_w <> 'N') then
		ie_bloqueio_feriado_w	:= ie_bloqueio_feriado_w;
	end if;
elsif (nr_seq_equipe_p IS NOT NULL AND nr_seq_equipe_p::text <> '') then

	for cr_02 in C02 loop
		-- Carrega os horarios no vetor de horarios.
		carrega_horarios(cr_02.cd_agenda, nr_dia_semana_w, ie_feriado_w,ie_bloqueio_feriado_int_w);
		
		if (ie_bloqueio_feriado_int_w <> 'N') then
			ie_bloqueio_feriado_w	:= ie_bloqueio_feriado_w;
		end if;
	end loop;
	
elsif ((ie_loc_interno_p IS NOT NULL AND ie_loc_interno_p::text <> '') or (ie_loc_tipo_atend_p IS NOT NULL AND ie_loc_tipo_atend_p::text <> '')) then

	for cr_03 in C03 loop
		-- Carrega os horarios no vetor de horarios.		
		carrega_horarios(cr_03.cd_agenda, nr_dia_semana_w, ie_feriado_w,ie_bloqueio_feriado_int_w);
			
		if (ie_bloqueio_feriado_int_w <> 'N') then
			ie_bloqueio_feriado_w	:= ie_bloqueio_feriado_w;
		end if;
	end loop;
end if;

if (dt_agenda_w IS NOT NULL AND dt_agenda_w::text <> '') and (hr_inicial_w IS NOT NULL AND hr_inicial_w::text <> '') then
	
	select	pkg_date_utils.extract_field('YEAR', dt_agenda_w),
			pkg_date_utils.extract_field('MONTH', dt_agenda_w),
			pkg_date_utils.extract_field('DAY', dt_agenda_w),
			pkg_date_utils.extract_field('HOUR', hr_inicial_w),
			pkg_date_utils.extract_field('MINUTE', hr_inicial_w) - qt_intervalo_padrao_w -- Eu diminuo a qt_intervalo_padrao_w do minuto da hora inicial para ter ao menos uma linha de horario bloqueado do tipo: "Sem horario cadastrado" no inicio de qualquer agenda.
	into STRICT	dti_ano_w,
			dti_month_w,
			dti_day_w,
			dti_hour_w,
			dti_minute_w
	;
	
	-- If para calcular qual sera a hora e o minuto inicial da(s) agenda(s) caso a hora seja maior que 0 e o calculo do minuto seja negativo.
	if (dti_hour_w > 0 and dti_minute_w < 0) then
		-- Como o calculo do minuto pode ser menor que 60 negativo, devemos calcular para ver a quantidade de horas que devemos diminuir da hora inicial da agenda.
		qt_hora_calc_aux_w := (-1 * trunc(dti_minute_w/60)) + 1;
		dti_hour_w := dti_hour_w - qt_hora_calc_aux_w;
		dti_minute_w := dti_minute_w + (60 * qt_hora_calc_aux_w);
	end if;
	
	-- Em caso da hora ser zero e o calculo do minuto ser inferior a zero, ou a hora for inferior a 0 entao a hora e o minuto ficam igual a 0.
	if ((dti_hour_w = 0 and dti_minute_w < 0) or (dti_hour_w < 0)) then
		dti_hour_w := 0;
		dti_minute_w := 0;
	end if;
	
	if (dti_minute_w = 60) then
		dti_hour_w := dti_hour_w + 1;
		dti_minute_w := 0;
	end if;
	
	hr_inicial_p := pkg_date_utils.get_DateTime(
		dti_ano_w,    -- YEAR
		dti_month_w,  -- MONTH
		dti_day_w,    -- DAY
		dti_hour_w,   -- hour
		dti_minute_w, -- minute
		0             -- second
		);
	
	select	pkg_date_utils.extract_field('YEAR', dt_agenda_w),
			pkg_date_utils.extract_field('MONTH', dt_agenda_w),
			pkg_date_utils.extract_field('DAY', dt_agenda_w),
			pkg_date_utils.extract_field('HOUR', coalesce(hr_final_w, PKG_DATE_UTILS.GET_TIME('00:00:00'))),
			pkg_date_utils.extract_field('MINUTE', coalesce(hr_final_w, PKG_DATE_UTILS.GET_TIME('00:00:00')))
	into STRICT	dtf_ano_w,
			dtf_month_w,
			dtf_day_w,
			dtf_hour_w,
			dtf_minute_w
	;
	
	-- Calcular a quantidade minutos da hora inicial.
	qt_minutos_hora_inicial_w := dti_hour_w * 60 + dti_minute_w;
	
	-- Calcular a quantidade minutos da hora final.
	qt_minutos_hora_final_w := dtf_hour_w * 60 + dtf_minute_w;
	
	-- Identificar a quantidade de intervalos inteiros que existem desde a hora inicial, ate a hora final do turno, sempre somando mais 1, para quando a hora final do turno for no meio de um intervalo e outro.
	qt_interval_entre_ini_e_fin_w := trunc((qt_minutos_hora_final_w - qt_minutos_hora_inicial_w) / qt_intervalo_padrao_w) + 1;
	
	-- Calcular a quantidade total de minutos a partir da quantidade de intervalos a serem apresentados.
	qt_total_min_do_interval_w := qt_interval_entre_ini_e_fin_w * qt_intervalo_padrao_w;
	
	-- Calcular a diferenca em minutos da data final dos intervalos pela data final do turno.
	qt_diferenca_min_tot_fin_w := qt_total_min_do_interval_w - (qt_minutos_hora_final_w - qt_minutos_hora_inicial_w);
	
	-- Calcular a quantidade total de minutos finais.
	dtf_minute_w := qt_intervalo_padrao_w + dtf_minute_w + qt_diferenca_min_tot_fin_w;
	
	-- If para calcular qual sera a hora e o minuto final da(s) agenda(s) caso o calculo do minuto seja maior ou igual a 60.
	if (dtf_minute_w >= 60) then
		-- Como o calculo do minuto pode ser maior ou igual a 60, devemos calcular para ver a quantidade de horas que devemos aumentar da hora final da agenda.
		qt_hora_calc_aux_w := trunc(dtf_minute_w/60);
		dtf_hour_w := dtf_hour_w + qt_hora_calc_aux_w;
		dtf_minute_w := dtf_minute_w - (60 * qt_hora_calc_aux_w);
	end if;
	
	-- Em caso da hora ser maior que 23 horas entao a hora e o minuto ficam igual ao maximo que pode ser alcancado (23:59).
	if (dtf_hour_w > 23) then
		dtf_hour_w := 23;
		dtf_minute_w := 59;
	end if;
	
	hr_final_p := pkg_date_utils.get_DateTime(
		dtf_ano_w,    -- YEAR
		dtf_month_w,  -- MONTH
		dtf_day_w,    -- DAY
		dtf_hour_w,   -- hour
		dtf_minute_w, -- minute
		0             -- second
		);
end if;

qt_intervalo_p			:= qt_intervalo_padrao_w;
ie_bloqueio_feriado_p	:= ie_bloqueio_feriado_w;

/*Nao pode nunca ter commit neste objeto! */

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE mprev_obter_horarios_agenda ( dt_agenda_p timestamp, nr_seq_equipe_p mprev_equipe_profissional.nr_seq_equipe%type, ie_loc_interno_p mprev_local_atend.ie_interno%type, ie_loc_tipo_atend_p mprev_local_atend.ie_tipo_atendimento%type, cd_agenda_p agenda_turno.cd_agenda%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, qt_intervalo_p INOUT bigint, hr_inicial_p INOUT timestamp, hr_final_p INOUT timestamp, ie_bloqueio_feriado_p INOUT text) FROM PUBLIC;

