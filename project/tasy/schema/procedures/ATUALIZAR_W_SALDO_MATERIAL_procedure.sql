-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE conta AS (cd_material double precision, qt_material double precision, nr_sequencia double precision, vl_material double precision, qt_saldo double precision,
			nr_indice double precision, nr_doc_convenio varchar(30), vl_saldo double precision, dt_atendimento timestamp, dt_conta timestamp);


CREATE OR REPLACE PROCEDURE atualizar_w_saldo_material ( nr_interno_conta_p bigint, nm_usuario_p text) AS $body$
DECLARE

type vetor_conta is table of conta index by integer;


qt_material_w		double precision;
cd_material_w		integer;
nr_sequencia_w		bigint;
vl_material_w		double precision;
nr_doc_convenio_w	varchar(30);
cd_mat_aux_w		integer;
nr_indice_aux_w		double precision;
vl_saldo_w		double precision;
vl_retorno_w		double precision;
vl_lote_auditoria_w	double precision;
vetor_conta_w		vetor_conta;
i			integer;
k			integer;
y			integer;
b			integer;
qt_glosa_conta_w	double precision;
qt_item_negativo_w	double precision;
vl_material_negativo_w	double precision;
qt_item_positivo_w	double precision;
vl_item_positivo_w	double precision;
ie_entrou_w		varchar(1);
dt_conta_w		timestamp;
dt_conta_aux_w		timestamp;

C01 CURSOR FOR
	SELECT	cd_material,
		qt_material,
		nr_sequencia,
		vl_material,
		nr_doc_convenio,
		dt_conta
	from	material_atend_paciente
	where	nr_interno_conta = nr_interno_conta_p
	and	coalesce(cd_motivo_exc_conta::text, '') = ''
	order by cd_material, nr_sequencia; -- Não alterar a ordenação
BEGIN

/* ROTINA SEMELHANTE À
1] versão   OBTER_DADOS_ITEM_AJUSTADO
2] versão AJUSTAR_LOTE_HIST_ITEM_CONTA2 		(Última) - OK
PARA A OPÇÃO 'Q', PORÉM FEITA COM O USO DE VETORESPARA NÃO FAZER CONSULTAS NO BANCO DIVERSAS VEZES.
PERFORMANCE DA GRG 589363  (CUIDADO EXTREMO AO ALTERAR)
Fabrício José Theiss 12/07/2013  */
delete
from	w_saldo_material_conta
where	nm_usuario = nm_usuario_p
and 	nr_interno_conta = nr_interno_conta_p;

i:= 1;
open C01;
loop
fetch C01 into
	cd_material_w,
	qt_material_w,
	nr_sequencia_w,
	vl_material_w,
	nr_doc_convenio_w,
	dt_conta_w;
EXIT WHEN NOT FOUND; /* apply on C01 */
	begin

	vl_saldo_w:= 0;

	select	count(*)
	into STRICT	qt_glosa_conta_w
	from	convenio_retorno 	b,
		convenio_retorno_item 	a
	where	not exists (SELECT	1
			from	convenio_retorno x
			where	x.nr_seq_ret_estorno	= b.nr_sequencia)
	and	coalesce(b.nr_seq_ret_estorno::text, '') = ''
	and	b.ie_status_retorno	= 'F'
	and	a.nr_seq_retorno	= b.nr_sequencia
	and	not exists (select	1
			from	convenio_retorno_glosa x
			where	x.nr_seq_matpaci	= nr_sequencia_w
			and	x.nr_seq_ret_item	= a.nr_sequencia)
	and	a.vl_amenor		<= 0
	and	a.vl_pago		> 0
	and	coalesce(a.cd_autorizacao,'Não Informada')	= coalesce(nr_doc_convenio_w,'Não Informada')
	and	a.nr_interno_conta	= nr_interno_conta_p;

	/* Se existir um retorno com valor pago onde o item não está, significa que ele já foi pago */

	if (qt_glosa_conta_w > 0) then
		vl_saldo_w	:= 0;
	/* senãoo, é necessário consultar os valores do item no retorno e na GRG */

	else

		select	coalesce(sum(CASE WHEN coalesce(a.ie_acao_glosa,b.ie_acao_glosa)='A' THEN a.vl_glosa  ELSE 0 END ),0) + coalesce(sum((obter_dados_ret_movto_glosa(a.nr_sequencia, 3))::numeric ),0)
		into STRICT	vl_retorno_w
		from	motivo_glosa b,
			convenio_retorno_glosa a
		where	a.nr_seq_matpaci	= nr_sequencia_w
		and	a.cd_motivo_glosa	= b.cd_motivo_glosa;

		select	coalesce(sum(a.vl_glosa),0) + coalesce(sum(a.vl_pago),0)
		into STRICT	vl_lote_auditoria_w
		from	lote_audit_hist_item a
		where	a.nr_seq_matpaci	= nr_sequencia_w;

		vl_saldo_w	:= coalesce(vl_material_w,0) - coalesce(vl_retorno_w,0) - coalesce(vl_lote_auditoria_w,0);

	end if;

	vetor_conta_w[i].cd_material		:= cd_material_w;
	vetor_conta_w[i].qt_material		:= qt_material_w;
	vetor_conta_w[i].qt_saldo		:= qt_material_w;
	vetor_conta_w[i].nr_sequencia		:= nr_sequencia_w;
	vetor_conta_w[i].vl_material		:= vl_saldo_w;
	vetor_conta_w[i].vl_saldo		:= vl_saldo_w;
	vetor_conta_w[i].nr_indice		:= i;
	vetor_conta_w[i].nr_doc_convenio	:= nr_doc_convenio_w;
	vetor_conta_w[i].dt_conta		:= dt_conta_w;
	i	:= i + 1;

	end;
end loop;
close C01;


/*
NR_SEQUENCIA CD_MATERIAL QT_MATERIAL VL_MATERIAL  QT_AkUSTE  VL_AJUSTE
------------ ----------- ----------- ----------- ---------- ----------
     4934195          66          10         100          0          0
     4934202          66          -4         -40          0          0
     4934212          66           3       31,65          1        -20
     4934217          66          -7         -70          0          0
     4946213          66           3          30          3         30
     4946214         66          -1         -10          0          0
*/
/* Atualizar as qtdes na tabela  w_saldo_material_conta*/

cd_mat_aux_w	:= 0;
nr_indice_aux_w := 0;
i := vetor_conta_w.count;
for k in 1.. i loop
	begin

	if (vetor_conta_w[k].qt_material < 0) then

		vetor_conta_w[k].qt_saldo	:= 0;
		vetor_conta_w[k].vl_saldo	:= 0;
		cd_mat_aux_w			:= vetor_conta_w[k].cd_material;
		nr_indice_aux_w 		:= vetor_conta_w[k].nr_indice;
		qt_item_negativo_w		:= vetor_conta_w[k].qt_material;
		vl_material_negativo_w		:= vetor_conta_w[k].vl_material;
		dt_conta_aux_w			:= trunc(vetor_conta_w[k].dt_conta);

		while(qt_item_negativo_w	< 0) loop
			begin
			ie_entrou_w := 'N';

			-- Percorrer os positivos
			for b in 1.. i loop
				begin

				if (qt_item_negativo_w >= 0) then
					exit; -- Não tem nenhum positivo com sequência menor que a sequência do item negativo
				end if;

				if (cd_mat_aux_w	= vetor_conta_w[b].cd_material) and (dt_conta_aux_w = trunc(vetor_conta_w[b].dt_conta)) and (vetor_conta_w[b].qt_material > 0) and (vetor_conta_w[b].qt_saldo > 0) and (dividir(vetor_conta_w[b].vl_material, vetor_conta_w[b].qt_material) >= abs(dividir(vetor_conta_w[k].vl_material, vetor_conta_w[k].qt_material))) and (vetor_conta_w[b].nr_indice < nr_indice_aux_w) then

					ie_entrou_w		:= 'S';


					qt_item_positivo_w	:= vetor_conta_w[b].qt_saldo;
					vl_item_positivo_w	:= vetor_conta_w[b].vl_saldo;

					if (qt_item_positivo_w	> abs(qt_item_negativo_w)) then	/* se tiver mais positivo do que negativo, apenas deduz do total */
						vetor_conta_w[b].qt_saldo	:= vetor_conta_w[b].qt_saldo + qt_item_negativo_w;
						vetor_conta_w[b].vl_saldo	:= vetor_conta_w[b].vl_saldo + vl_material_negativo_w;
						qt_item_negativo_w		:= 0;


					elsif (qt_item_positivo_w	= abs(qt_item_negativo_w)) then	/* se a qtd de positivos e negativos for igual, elimina o item */
						vetor_conta_w[b].qt_saldo	:= 0;
						vetor_conta_w[b].vl_saldo	:= 0;
						qt_item_negativo_w		:= 0;


					/* tiver menos positivo do que negativo, elimina o positivo e deduz sua qtd da qtd negativa, depois passa para o próximo item positivo */

					elsif (qt_item_positivo_w	< abs(qt_item_negativo_w)) then

						vetor_conta_w[b].qt_saldo	:= 0;
						vetor_conta_w[b].vl_saldo	:= 0;
						qt_item_negativo_w		:= qt_item_negativo_w + qt_item_positivo_w;
						vl_material_negativo_w		:= vl_material_negativo_w + vl_item_positivo_w;


					/* se a quantidade total de itens negativos supera a quantidade total de itens positivos, é necessário sair do loop */

					elsif (coalesce(qt_item_positivo_w::text, '') = '') then
						qt_item_negativo_w	:= 0;
					end if;

				end if;

				if (cd_mat_aux_w	= vetor_conta_w[b].cd_material) and (vetor_conta_w[b].nr_indice >= nr_indice_aux_w) then
					exit;
				end if;

				if (ie_entrou_w = 'S') then
					exit;
				end if;

				end;
			end loop;

			if (ie_entrou_w = 'N') then

				/* Válvula de escape de inércia - MATERIAIS 'ADJUSTMENT COLUMN'
				--Se a devolução ocorreu antes do lançamento positivo
				-- Aconteceu no item 128599 da conta 2563247 na base de simulação Sirio Libanês.*/
				for y in 1.. i loop
					begin

					if	(qt_item_negativo_w >= 0) then
						exit; -- Não tem nenhum positivo com sequência menor que a sequência do item negativo
					end if;


					if	(cd_mat_aux_w	= vetor_conta_w(y).cd_material) and
						(dt_conta_aux_w = trunc(vetor_conta_w(y).dt_conta)) and
						(vetor_conta_w(y).qt_material > 0) and
						(vetor_conta_w(y).qt_saldo > 0) and
						(dividir(vetor_conta_w(y).vl_material, vetor_conta_w(y).qt_material) >= abs(dividir(vetor_conta_w(k).vl_material, vetor_conta_w(k).qt_material))) and
						(vetor_conta_w(y).nr_indice > nr_indice_aux_w) then

						ie_entrou_w		:= 'S';

						qt_item_positivo_w	:= vetor_conta_w(y).qt_material;
						vl_item_positivo_w	:= vetor_conta_w(y).vl_material;

						if	(qt_item_positivo_w	> abs(qt_item_negativo_w)) then	/* se tiver mais positivo do que negativo, apenas deduz do total */
							vetor_conta_w[y].qt_saldo	:= vetor_conta_w[y].qt_saldo + qt_item_negativo_w;
							vetor_conta_w[y].vl_saldo	:= vetor_conta_w[y].vl_saldo + vl_material_negativo_w;
							qt_item_negativo_w		:= 0;

						elsif (qt_item_positivo_w	= abs(qt_item_negativo_w)) then	/* se a qtd de positivos e negativos for igual, elimina o item */
							vetor_conta_w[y].qt_saldo	:= 0;
							vetor_conta_w[y].vl_saldo	:= 0;
							qt_item_negativo_w		:= 0;

						/* tiver menos positivo do que negativo, elimina o positivo e deduz sua qtd da qtd negativa, depois passa para o próximo item positivo */

						elsif (qt_item_positivo_w	< abs(qt_item_negativo_w)) then

							vetor_conta_w[y].qt_saldo	:= 0;
							vetor_conta_w[y].vl_saldo	:= 0;
							qt_item_negativo_w		:= qt_item_negativo_w + qt_item_positivo_w;
							vl_material_negativo_w		:= vl_material_negativo_w + vl_item_positivo_w;

						/* se a quantidade total de itens negativos supera a quantidade total de itens positivos, é necessário sair do loop */

						elsif (coalesce(qt_item_positivo_w::text, '') = '') then
							qt_item_negativo_w	:= 0;
						end if;

					end if;

					if (ie_entrou_w = 'S') then
						exit;
					end if;

					end;
				end loop;

				if (ie_entrou_w = 'N') then -- Não encontrrou nada
					qt_item_negativo_w	:= 0; --Sair do loop
				end if;

			end if;

			end;
		end loop;

	end if;

	end;
end loop;


-- Percorrer todos e inserir na tabela w
i := vetor_conta_w.count;
for k in 1.. i loop
	begin

	insert	into w_saldo_material_conta(
			cd_material,
			nr_interno_conta,
			qt_item_saldo,
			vl_item_saldo,
			nm_usuario,
			dt_atualizacao,
			nr_sequencia)
		values (vetor_conta_w[k].cd_material,
			nr_interno_conta_p,
			vetor_conta_w[k].qt_saldo,
			vetor_conta_w[k].vl_saldo,
			nm_usuario_p,
			clock_timestamp(),
			vetor_conta_w[k].nr_sequencia);

	end;
end loop;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE atualizar_w_saldo_material ( nr_interno_conta_p bigint, nm_usuario_p text) FROM PUBLIC;

