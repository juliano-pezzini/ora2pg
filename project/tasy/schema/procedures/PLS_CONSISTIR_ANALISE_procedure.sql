-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_consistir_analise ( nr_seq_analise_p pls_analise_conta.nr_sequencia%type, nr_seq_grupo_atual_p pls_grupo_auditor.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


tb_seq_w			pls_util_cta_pck.t_number_table;
nr_seq_conta_w			pls_conta.nr_sequencia%type;
qt_auditoria_w			integer;
qt_1001_w			integer;
nr_seq_lote_w			pls_conta_v.nr_seq_lote_conta%type;
qt_itens_w			integer;
ie_origem_filtro_w		varchar(1);
ie_origem_conta_w		pls_conta.ie_origem_conta%type;
nr_seq_conta_princ_w		pls_conta.nr_seq_conta_princ%type;
dt_atendimento_referencia_w	pls_conta.dt_atendimento_referencia%type;

c_proc_analise CURSOR(	nr_seq_analise_pc	pls_analise_conta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia
	from	pls_conta_proc_v a
	where	a.nr_seq_analise = nr_seq_analise_pc;

C01 CURSOR(	nr_seq_analise_pc	pls_analise_conta.nr_sequencia%type) FOR
	SELECT	c.nr_sequencia nr_seq_conta,
		CASE WHEN(SELECT	max(cp.ie_via_acesso)			from	pls_conta_proc cp			where	cp.nr_seq_conta	= c.nr_sequencia			and	cp.ie_status <> 'D')='M' THEN  5 WHEN(select	max(cp.ie_via_acesso)			from	pls_conta_proc cp			where	cp.nr_seq_conta	= c.nr_sequencia			and	cp.ie_status <> 'D')='D' THEN  3 WHEN(select	max(cp.ie_via_acesso)			from	pls_conta_proc cp			where	cp.nr_seq_conta	= c.nr_sequencia			and	cp.ie_status <> 'D')='U' THEN 1 END  ie_via,
		c.nr_seq_segurado,
		c.ie_origem_conta,
		c.ie_tipo_conta
	from	pls_conta c
	where	c.nr_seq_analise = nr_seq_analise_pc
	order by coalesce(ie_via, 0);

-- Ocorrências inativadas pelo sistema
C05 CURSOR(	nr_seq_conta_pc	pls_conta.nr_sequencia%type) FOR
	SELECT	x.nr_sequencia nr_seq_ocor_benef
	from	pls_ocorrencia_benef	x
	where	x.nr_seq_conta		= nr_seq_conta_pc
	and	x.ie_situacao		= 'I'
	and	x.ie_forma_inativacao	in ('S','US');

-- Contas geradas pela conta atual - Abertura de participantes
-- Tem que consitir quando primeira vez
C06 CURSOR(	nr_seq_conta_pc	pls_conta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_conta
	from	pls_conta a
	where	a.nr_seq_conta_referencia	= nr_seq_conta_pc
	and	coalesce(a.dt_inicio_consistencia::text, '') = '';

C07 CURSOR(nr_seq_analise_pc		pls_analise_conta.nr_sequencia%type)FOR
	SELECT	nr_sequencia
	from	pls_conta c
	where	nr_seq_analise	= nr_seq_analise_pc
	and	not exists (SELECT 1
				from	pls_conta_proc	p
				where	p.nr_seq_conta	= c.nr_sequencia
				and	p.ie_status	!= 'D')
	and	not exists (select 1
				from	pls_conta_mat	p
				where	p.nr_seq_conta	= c.nr_sequencia
				and	p.ie_status	!= 'D')
	and	coalesce(nr_seq_conta_referencia::text, '') = '';
BEGIN
-- Na OS 993661 foi verificado que toda atualização de versão da base teste da Unimed Maringá as tabelas TM eram limpas indevidamente
-- sendo que não ficavam nem os registros para o controle destes updates, na ajustar_base_despesa existe a chamada para a procedure abaixo
-- porém a limpeza acontecia após a ajustar_base_despesa ou a mesma não era executada na atualização de versão, por isso em conversa com Décio e Diogo
-- foi decidido colocar a mesma chamada nesta rotina porém sem que seja criadas as JOBs, apenas é feito um insert na gerencia_upd_obj quando necessário
CALL pls_util_pck.gerencia_tamanho_bloco('AUMENTAR');
begin
	EXECUTE 'ALTER SESSION ENABLE PARALLEL DML';
exception
when others then
	null;
end;
CALL pls_gerencia_inicio_tb_tm('N');

-- gerencia a atualização da tabela TM
CALL pls_gerencia_upd_obj_pck.atualizar_objetos(nm_usuario_p, 'PLS_CONSISTIR_ANALISE', 'PLS_ESTRUTURA_MATERIAL_TM');
CALL pls_gerencia_upd_obj_pck.atualizar_objetos(nm_usuario_p, 'PLS_CONSISTIR_ANALISE', 'PLS_GRUPO_MATERIAL_TM');

-- INÍCIO controles de processos que devem ser executados apenas uma vez
-- valor inicial para sinalizar que deve ser feita a atualização da utilização de itens
pls_util_cta_pck.ie_atualiza_util_guia_w := 'S';
-- valor inicial para sinalizar que deve ser feita a atualização de procedimentos de referência
pls_util_cta_pck.ie_atualiza_proc_ref_w := 'S';

-- alimenta o campo nr_seq_conta_princ das contas da analise
CALL pls_insere_conta_princ(null, nr_seq_analise_p, null);

-- cria os registros necessários nas tabelas mat/proc regra
CALL pls_filtro_regra_preco_cta_pck.cria_registro_regra(	'P', null, null,
							null, null, null,
							null, nr_seq_analise_p, cd_estabelecimento_p,
							nm_usuario_p);
-- FIM controles de processos que devem ser executados apenas uma vez
CALL gravar_processo_longo('Consistência da análise','PLS_CONSISTIR_ANALISE',0);

-- Inativar as glosas e ocorrências antes de consistir
CALL pls_analise_inativar_glo_ocor(nr_seq_analise_p, null, null, null, null, nm_usuario_p);

-- Tabela auxiliar para a geração de ocorrências da análise
insert into w_pls_ocorrencia(dt_atualizacao,
	nm_usuario,
	dt_atualizacao_nrec,
	nm_usuario_nrec,
	nr_seq_analise,
	nr_sequencia)
values (clock_timestamp(),
	nm_usuario_p,
	clock_timestamp(),
	nm_usuario_p,
	nr_seq_analise_p,
	0);
commit;

update	pls_conta_proc
set	ie_via_acesso	= CASE WHEN ie_tx_manual='S' THEN ie_via_acesso  ELSE 'U' END
where	nr_sequencia in (SELECT nr_sequencia
			from	pls_conta_proc_v
			where 	nr_seq_analise	= nr_seq_analise_p
			and	(nr_seq_regra_tipo_exec IS NOT NULL AND nr_seq_regra_tipo_exec::text <> ''));
-- zerar dados dos procedimentos
open c_proc_analise(nr_seq_analise_p);
loop
	tb_seq_w.delete;

	fetch c_proc_analise bulk collect into tb_seq_w
	limit pls_util_pck.qt_registro_transacao_w;

	exit when tb_seq_w.count = 0;

	forall i in tb_seq_w.first .. tb_seq_w.last
		update	pls_conta_proc set
			tx_medico		= CASE WHEN ie_tx_manual='S' THEN  tx_medico  ELSE null END ,
			tx_custo_operacional	= CASE WHEN ie_tx_manual='S' THEN  tx_custo_operacional  ELSE null END ,
			tx_material		= CASE WHEN ie_tx_manual='S' THEN  tx_material  ELSE null END ,
			nr_seq_regra_qtde_exec	 = NULL,
			ie_regra_qtde_execucao	 = NULL,
			nr_seq_regra_tx_proc	 = NULL,
			nr_seq_proc_ref		 = NULL,
			nr_seq_rp_combinada	 = NULL,
			tx_item			= CASE WHEN ie_tx_manual='S' THEN  tx_item  ELSE CASE WHEN ie_via_acesso='M' THEN  50 WHEN ie_via_acesso='D' THEN  70  ELSE 100 END  END ,
			nr_seq_regra_tipo_exec	 = NULL,
			nr_seq_exame_coleta	 = NULL,
			nr_seq_autogerado	 = NULL,
			ie_autogerado		= 'N'
		where	nr_sequencia = tb_seq_w(i);
	commit;
end loop;
close c_proc_analise;

if (pls_util_cta_pck.pls_usa_rn_qtde_exec_regra = 'S') then
	select	count(1),
		max(nr_seq_conta)
	into STRICT	qt_itens_w,
		nr_seq_conta_w
	from	pls_conta_proc_v
	where	nr_seq_analise	= nr_seq_analise_p
	and	ie_status	not in ('M','D');

	if (qt_itens_w	> 0) then
		if (qt_itens_w	<= 1) then
			CALL pls_grava_log_execucao_temp('Início quantidade execução regras antiga conta ' || nr_seq_conta_w, 'geracao_analise_consistir_conta', nm_usuario_p);
			--Abrir os lançamentos dos procedimentos conforme as regras por quantidade de execução
			CALL pls_abrir_proc_qtde_proc_valor(  nr_seq_conta_w, null, nm_usuario_p,cd_estabelecimento_p);
			CALL pls_grava_log_execucao_temp('Fim quantidade execução regras antiga conta ' || nr_seq_conta_w, 'geracao_analise_consistir_conta', nm_usuario_p);
		else
			CALL pls_grava_log_execucao_temp('Início quantidade execução regras nova analise ' , 'consistir_analise', nm_usuario_p);
			CALL pls_regra_qtd_execucao_pck.pls_gerencia_regra_qtd_exec( null, null, null, null, null, nr_seq_analise_p, nm_usuario_p, cd_estabelecimento_p);
			CALL pls_grava_log_execucao_temp('Fim quantidade execução regras nova analise ' , 'consistir_analise', nm_usuario_p);
		end if;
	end if;
end if;

CALL pls_grava_log_execucao_temp('Início valorização diferenciada', 'valorizacao', nm_usuario_p);

select	max(nr_seq_lote_conta),
	max(nr_seq_conta_princ)
into STRICT	nr_seq_lote_w,
	nr_seq_conta_princ_w
from	pls_conta_v
where	nr_seq_analise	= nr_seq_analise_p;


-- OS 643040 Irá gerar a regra de pagamento diferenciado para os itens da conta
CALL pls_cta_gerar_val_dif(	null, null, null,
			null, null, cd_estabelecimento_p,
			nm_usuario_p, nr_seq_analise_p);

CALL pls_grava_log_execucao_temp('Fim valorização diferenciada', 'valorizacao', nm_usuario_p);

for r_C01_w in C01(nr_seq_analise_p) loop

	delete	FROM pls_conta_autor
	where	nr_seq_conta = r_C01_w.nr_seq_conta;
	commit;

	if (r_C01_w.ie_origem_conta = 'A') then

		select	count(1)
		into STRICT	qt_1001_w
		from	tiss_motivo_glosa	b,
			pls_conta_glosa 	a
		where	b.nr_sequencia		= a.nr_seq_motivo_glosa
		and	a.nr_seq_conta		= r_C01_w.nr_seq_conta
		and	b.cd_motivo_tiss	= '1001';

		if	((qt_1001_w = 0) or (r_C01_w.nr_seq_segurado IS NOT NULL AND r_C01_w.nr_seq_segurado::text <> '')) then

			CALL pls_consistir_conta(r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'P', 'S');
		else
			update	pls_conta_glosa
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta		= r_C01_w.nr_seq_conta;
			commit;

			update	pls_ocorrencia_benef
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta		= r_C01_w.nr_seq_conta;
			commit;
		end if;
	else
		CALL pls_consistir_conta(r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'P', 'S');
	end if;

	ie_origem_conta_w := r_C01_w.ie_origem_conta;

	-- busca as contas que foram geradas e consiste a mesma
	-- geradas pelo processo de abertura de contas
	for r_C06_w in C06(r_C01_w.nr_seq_conta) loop
		CALL pls_consistir_conta(r_C06_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'P', 'S');
	end loop;
end loop;

CALL pls_grava_log_execucao_temp('Início processamento autogerado analise ' || nr_seq_analise_p, 'geracao_analise_consistir_conta', nm_usuario_p);
CALL pls_gerencia_autogerado_pck.pls_define_se_autogerado(  null, null, null,null,  nm_usuario_p, cd_estabelecimento_p, nr_seq_analise_p);
CALL pls_grava_log_execucao_temp('Fim processamento autogerado analise ' || nr_seq_analise_p, 'geracao_analise_consistir_conta', nm_usuario_p);

if (ie_origem_conta_w = 'A') then

	ie_origem_filtro_w := 'I';
else
	ie_origem_filtro_w := 'N';
end if;

CALL pls_qtde_execucao_pck.pls_gerencia_qtde_execucao(null, null, null,
					         nr_seq_analise_p, null,nm_usuario_p,
						 cd_estabelecimento_p);

CALL pls_cp_cta_gerar_combinada(	ie_origem_filtro_w, null, null,
				null, null, null,
				null, nr_seq_analise_p, null,
				cd_estabelecimento_p, nm_usuario_p);

CALL pls_grava_log_execucao_temp('Início via de acesso', 'valorizacao', nm_usuario_p);

CALL pls_util_cta_pck.pls_gerencia_via_acesso( 	null, null, null,
						null, null,nr_seq_analise_p,
						null, nm_usuario_p, cd_estabelecimento_p );
commit;

CALL pls_grava_log_execucao_temp('Fim via de acesso', 'valorizacao', nm_usuario_p);

CALL pls_recalcular_conta(null, nm_usuario_p, 'C', 'N', 'N', nr_seq_analise_p,null);


for r_C01_w in C01(nr_seq_analise_p) loop

	if (r_C01_w.ie_origem_conta = 'A') then

		select	count(1)
		into STRICT	qt_1001_w
		from	tiss_motivo_glosa	b,
			pls_conta_glosa 	a
		where	b.nr_sequencia		= a.nr_seq_motivo_glosa
		and	a.nr_seq_conta		= r_C01_w.nr_seq_conta
		and	b.cd_motivo_tiss	= '1001';

		if (qt_1001_w = 0) or (r_C01_w.nr_seq_segurado IS NOT NULL AND r_C01_w.nr_seq_segurado::text <> '') then

			CALL pls_consistir_conta(r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'Q', 'S');
		else
			update	pls_conta_glosa
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta		= r_C01_w.nr_seq_conta;
			commit;

			update	pls_ocorrencia_benef
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta		= r_C01_w.nr_seq_conta;
			commit;
		end if;
	else
		CALL pls_consistir_conta(r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'Q', 'S');
	end if;
end loop;

CALL pls_grava_log_execucao_temp('Início geração da ocorrência combinada das análises '||nr_seq_analise_p, 'consistir_analise', nm_usuario_p);
--ocorrencia combinadda
CALL pls_oc_cta_gerar_combinada(	'CC', 'A', null, null, null, null, null, null, nr_seq_analise_p, 10, null,
				null, null, null, cd_estabelecimento_p, nm_usuario_p);
commit;
CALL pls_grava_log_execucao_temp('Fim geração da ocorrência combinada das análises'||nr_seq_analise_p, 'consistir_analise', nm_usuario_p);

for r_C01_w in C01(nr_seq_analise_p) loop

	if (r_C01_w.ie_origem_conta = 'A') then

		select	count(1)
		into STRICT	qt_1001_w
		from	tiss_motivo_glosa	b,
			pls_conta_glosa 	a
		where	b.nr_sequencia		= a.nr_seq_motivo_glosa
		and	a.nr_seq_conta		= r_C01_w.nr_seq_conta
		and	b.cd_motivo_tiss	= '1001';

		if (qt_1001_w = 0) or (r_C01_w.nr_seq_segurado IS NOT NULL AND r_C01_w.nr_seq_segurado::text <> '') then

			CALL pls_consistir_conta(r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'U', 'S');
		else
			update	pls_conta_glosa
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta		= r_C01_w.nr_seq_conta;
			commit;

			update	pls_ocorrencia_benef
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta		= r_C01_w.nr_seq_conta;
			commit;
		end if;
	else
		CALL pls_consistir_conta(r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p, 'S', 'N', 'N', null, 'N', 'U', 'S');
	end if;

	CALL pls_analise_voltar_itens_pend(nr_seq_analise_p, nr_seq_grupo_atual_p, r_C01_w.nr_seq_conta, cd_estabelecimento_p, nm_usuario_p);

	pls_atualiza_status_pag(r_C01_w.nr_seq_conta, nm_usuario_p);

	CALL pls_atualiza_lib_conta(r_C01_w.nr_seq_conta, 'C', nm_usuario_p);

	-- Atualizar os pareceres das ocorrências que foram inativas automaticamente
	open C05(r_C01_w.nr_seq_conta);
	loop
		tb_seq_w.delete;

		fetch C05 bulk collect into tb_seq_w
		limit pls_util_pck.qt_registro_transacao_w;

		exit when tb_seq_w.count = 0;

		forall i in tb_seq_w.first .. tb_seq_w.last
			update	pls_analise_glo_ocor_grupo a set
				a.ie_status		= 'L'
			where	a.nr_seq_analise	= nr_seq_analise_p
			and	a.ie_status		= 'P'
			and	a.nr_seq_ocor_benef	= tb_seq_w(i);
		commit;
	end loop;
	close C05;

	select	count(1)
	into STRICT	qt_auditoria_w
	from	pls_auditoria_conta_grupo
	where	nr_seq_analise	= nr_seq_analise_p
	and	(dt_liberacao IS NOT NULL AND dt_liberacao::text <> '')  LIMIT 1;

	if (qt_auditoria_w = 0) then
		CALL pls_gerar_grupo_aud_conta(r_C01_w.nr_seq_conta, nr_seq_analise_p, nm_usuario_p, cd_estabelecimento_p);
	end if;
end loop;

select	max(nr_sequencia)
into STRICT	nr_seq_conta_w
from	pls_conta
where	nr_seq_analise = nr_seq_analise_p
and	ie_tipo_guia	!= '6';

CALL pls_grava_log_execucao_temp('Início processo glosa automatica ocorrências', 'consistir_analise', nm_usuario_p);
CALL pls_aplica_glosa_aut(	nr_seq_analise_p,null,	nm_usuario_p,
						cd_estabelecimento_p);
CALL pls_grava_log_execucao_temp('Fim processo glosa automatica ocorrências', 'consistir_analise', nm_usuario_p);

if (nr_seq_conta_w IS NOT NULL AND nr_seq_conta_w::text <> '') then
	CALL pls_atualizar_agrup_analise(nr_seq_conta_w, nm_usuario_p, 'C', 'N');
	CALL pls_analise_atualizar_id_itens(nr_seq_conta_w, nm_usuario_p, cd_estabelecimento_p, 'N');
end if;

	/* Atualizar a tabela de resumo dos valores da conta */

	CALL pls_cta_consistir_pck.gerar_resumo_conta(null, null, null,null, nm_usuario_p, cd_estabelecimento_p, nr_seq_analise_p);

CALL pls_gerar_fluxo_audit_item(nr_seq_analise_p, null, null, null, null, nm_usuario_p);

CALL pls_analise_atualizar_fluxo(nr_seq_analise_p, nr_seq_grupo_atual_p, nm_usuario_p, cd_estabelecimento_p);

-- verifica se a função do pagamento de produção médica é a nova, caso seja faz o vínculo dos eventos
CALL pls_pp_cta_evento_combinada(	nr_seq_analise_p, null, null, cd_estabelecimento_p, nm_usuario_p);

for r_c07_w in C07(nr_seq_analise_p) loop
	begin
	select	max(dt_atendimento_referencia)
	into STRICT	dt_atendimento_referencia_w
	from	pls_conta
	where	nr_seq_conta_referencia	= r_c07_w.nr_sequencia
	and	ie_status		!= 'C';

	if (dt_atendimento_referencia_w IS NOT NULL AND dt_atendimento_referencia_w::text <> '') then
		begin
		update	pls_conta
		set	dt_atendimento_referencia	= dt_atendimento_referencia_w,
			dt_atendimento			= dt_atendimento_referencia_w
		where	nr_sequencia			= r_c07_w.nr_sequencia;

		end;
	end if;
	commit;
	end;
end loop;

-- tratar abertura de pacote do faturamento
CALL pls_tratar_abertura_pct_fat(	null, null, nr_seq_analise_p,
				null, cd_estabelecimento_p, nm_usuario_p);

delete	from w_pls_ocorrencia
where	nr_seq_analise	= nr_seq_analise_p
and	nm_usuario	= nm_usuario_p;
commit;

update	pls_conta
set	ie_consistir_conta_analise	= 'N'
where	nr_seq_analise			= nr_seq_analise_p;
commit;

CALL pls_gerar_justif_automatica(nr_seq_analise_p, nm_usuario_p, 'S');

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_consistir_analise ( nr_seq_analise_p pls_analise_conta.nr_sequencia%type, nr_seq_grupo_atual_p pls_grupo_auditor.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

