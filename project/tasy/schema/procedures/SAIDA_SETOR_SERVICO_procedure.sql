-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE saida_setor_servico (nr_atendimento_p bigint, cd_setor_atendimento_p bigint, cd_motivo_alta_p bigint, dt_alta_p timestamp, nm_usuario_p text) AS $body$
DECLARE


DT_ATUALIZACAO_W						timestamp				:= clock_timestamp();
nr_setores_w			smallint	 := 0;
nr_setores_usuario_w		smallint	 := 0;
ie_status_acerto_w		smallint	:= 0;
nr_setores_int_w		smallint	:= 0;
nr_setores_ps_w			smallint	:= 0;
nr_interno_conta_w		bigint	:= 0;
qt_movto_setor_w		bigint	:= 0;
qt_material_w			bigint	:= 0;
qt_Procedimento_w		bigint	:= 0;
cd_local_estoque_w		smallint	 := 1;
ds_erro_w										varchar(255)	 := '';
cd_motivo_alta_w		smallint	:= 1;
ie_tipo_atendimento_w		smallint	:= 0;
ie_usuario_ps_w			varchar(1);
dt_alta_w			timestamp;
ds_motivo_alta_w		varchar(80);
dt_procedimento_w		timestamp;
dt_procmat_w			timestamp;
dt_material_w			timestamp;
ds_inconsistencia_w		varchar(255)	:= 0;
ie_fecha_atendimento_w		varchar(01)	:= 'S';
ie_fecha_conta_w		varchar(01)	:= 'S';
qt_processo_pendente_w		bigint	:= 0;
cd_setor_atendimento_w		integer;
qt_setores_atend_w		integer;
cd_estabelecimento_w		integer;
qt_proc_sem_laudo_w		integer;
ie_fechar_conta_ps_alta_w	varchar(01);
ie_atend_PS_w			varchar(01);
dt_entrada_unidade_w		timestamp;
nr_seq_interno_w		bigint;
ds_erro_ww			varchar(2000);
vl_conta_w			double precision;
dt_saida_setor_w		timestamp;
ie_mantem_status_alta_w		varchar(1);
nr_seq_agenda_w			    agenda_consulta.nr_sequencia%type;
ie_status_agenda_w		    varchar(2);
cd_tipo_agenda_w		    bigint;

nr_seq_agenda_pac_w		    agenda_paciente.nr_sequencia%type;
ie_status_agenda_pac_w		varchar(2);
cd_tipo_agenda_pac_w		bigint;
ie_tipo_agenda_pac_w		varchar(2);
ie_tipo_agenda_w		varchar(2);
ie_realizar_alt_status_w	varchar(1);
ie_atualiza_apos_alta_w		varchar(1);
qt_mat_w					bigint:=0;
qt_proc_w					bigint:=0;
ie_gera_novo_atend_w		varchar(1);
qt_reg_w			integer;
ie_forma_fechamento_w		parametro_faturamento.ie_forma_fechamento%type;
nr_interno_conta_ww		conta_paciente.nr_interno_conta%type;
qt_regra_alta_tx_diaria_w	bigint;
ie_finalizar_atend_laudo_w	varchar(1);
cd_funcao_w			bigint;
ie_finaliza_atend_w		varchar(1) := 'S';
nr_max_interno_conta_w		conta_paciente.nr_interno_conta%type;
qt_regras_hdm_w			bigint;
qt_procedimentos_pendentes_w integer;
ie_gera_proc_cih_w		varchar(1);
ie_tipo_convenio_w		convenio.ie_tipo_convenio%type;
ie_diaria_dia_ant_w             parametro_faturamento.ie_diaria_dia_ant%type;
dt_entrada_w			atendimento_paciente.dt_entrada%type;

c010 CURSOR FOR
	SELECT	nr_interno_conta,
					coalesce(vl_conta,0)
	from conta_paciente
	where nr_atendimento	 = nr_atendimento_p
	and ie_status_acerto = 1
	and ((ie_atend_ps_w = 'N') or (ie_fechar_conta_ps_alta_w = 'S'))
	and (ie_fechar_conta_ps_alta_w <> 'T')
	and (ie_finaliza_atend_w = 'S')
	and ((ie_fechar_conta_ps_alta_w <> 'R') or ((ie_fechar_conta_ps_alta_w = 'R') and (obter_se_finaliza_atend(nr_atendimento_p,cd_motivo_alta_p) = 'S')));

c020 CURSOR FOR
	SELECT	a.dt_entrada_unidade,
					a.nr_seq_interno
	from atend_paciente_unidade a
	where nr_atendimento				 = nr_atendimento_p
	and cd_setor_Atendimento		 = cd_setor_atendimento_w
	and coalesce(dt_saida_unidade::text, '') = ''
	and not exists (SELECT 1 from setor_atendimento b
					where b.cd_setor_atendimento = cd_setor_atendimento_w
					and	(((obter_dados_param_atend(1, 'AI') = 'S') and (b.cd_classif_setor in ('4','8'))) or
				((obter_dados_param_atend(1, 'AI') = 'N') and (b.cd_classif_setor in ('3','4','8')))));
c03 CURSOR FOR
SELECT	a.nr_sequencia,
	a.ie_status_agenda,
	b.cd_tipo_agenda,
	CASE WHEN b.cd_tipo_agenda=3 THEN 'C' WHEN b.cd_tipo_agenda=4 THEN 'C' WHEN b.cd_tipo_agenda=5 THEN 'S' END
from	agenda b,
	agenda_consulta a
where	a.cd_agenda		= b.cd_agenda
and	a.nr_atendimento	= nr_atendimento_p;


c04 CURSOR FOR
	SELECT	a.nr_sequencia,
		a.ie_status_agenda,
		b.cd_tipo_agenda,
		CASE WHEN cd_tipo_agenda=1 THEN 'CI' WHEN cd_tipo_agenda=2 THEN 'E' END
	from	agenda b,
		agenda_paciente a
	where	a.cd_agenda		= b.cd_agenda
	and	a.ie_status_agenda not in ('C','B','F','I','II')
	and	a.nr_atendimento	= nr_atendimento_p;

C16 CURSOR FOR
	SELECT	a.nr_interno_conta
	from	conta_paciente a
	where	a.nr_atendimento = nr_atendimento_p
	and	a.ie_status_acerto = '1';


BEGIN
	Begin
		ie_atualiza_apos_alta_w := Obter_param_Usuario(67, 204, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_atualiza_apos_alta_w);
		ie_finalizar_atend_laudo_w := Obter_param_usuario(28, 300, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_finalizar_atend_laudo_w);

		cd_funcao_w	:=	coalesce(wheb_usuario_pck.get_cd_funcao,0);
		ie_finaliza_atend_w := 'S';

		select count(*)
		into STRICT qt_procedimentos_pendentes_w
		from prescr_procedimento pp
		inner join prescr_medica pm on pp.nr_prescricao = pm.nr_prescricao
		where coalesce(pp.dt_cancelamento::text, '') = ''
		and pp.ie_status_execucao < '20'
		and pm.nr_atendimento	= nr_atendimento_p;

		if ((cd_funcao_w = 28) and (coalesce(ie_finalizar_atend_laudo_w,'S') = 'N'))
			or ((cd_funcao_w = 28) and (coalesce(ie_finalizar_atend_laudo_w,'S') = 'E') and qt_procedimentos_pendentes_w > 0)then
			ie_finaliza_atend_w := 'N';
		end if;

		dt_procedimento_w	:= null;

		select	coalesce(max(dt_procedimento + 1/1440), dt_atualizacao_w)
		into STRICT	dt_procedimento_w
		from	Procedimento_paciente
		where	nr_atendimento		= nr_atendimento_p;

		select	coalesce(max(dt_atendimento + 1/1440), dt_atualizacao_w)
		into STRICT	dt_material_w
		from	material_atend_paciente
		where	nr_atendimento		= nr_atendimento_p;

		dt_procmat_w := dt_procedimento_w;

		if (dt_material_w <> dt_procedimento_w) then				/*Edilson em 18/05/06 OS 32959 */
			if (dt_material_w > dt_procedimento_w) and (dt_material_w <> dt_atualizacao_w) or (dt_procedimento_w = dt_atualizacao_w) then
				dt_procmat_w := dt_material_w;
			end if;
		end if;

/*	 rotina criada por marcus em 23/08/2003 para possibilitar o processo de alta
	quando	o usuario nao eh do setor de atendimento especifico mas tem acesso ao
	unico setor do atendimento. Exemplos CDI = Radiologia/Tomografia
*/
		select	count(*),
		max(cd_setor_atendimento)
		into STRICT	 qt_setores_atend_w,
				 cd_setor_atendimento_w
		from	atend_paciente_unidade
		where	nr_atendimento			 = nr_atendimento_p;

		if (qt_setores_atend_w	> 1) then
			cd_setor_atendimento_w	:= cd_setor_atendimento_p;
		else
			select	count(*)
			into STRICT	qt_setores_atend_w
			from	usuario_setor
			where	nm_usuario_param	= nm_usuario_p
			and	cd_setor_atendimento	= cd_setor_atendimento_w;

			if (qt_setores_atend_w = 0) then
				cd_setor_atendimento_w	:= cd_setor_atendimento_p;
			end if;
		end if;

		select coalesce(count(*),0)
		into STRICT nr_setores_usuario_w
		from atend_paciente_unidade
		where nr_atendimento			 = nr_atendimento_p
		and cd_setor_Atendimento = cd_setor_atendimento_w;

		select Somente_Numero(coalesce(vl_parametro, vl_parametro_padrao))
		into STRICT cd_motivo_alta_w
		from funcao_parametro
		where cd_funcao = 0
		and nr_sequencia = 30;

		select	coalesce(max(ds_motivo_alta),'X'),
		coalesce(max(ie_gera_novo_atend), 'N')
		into STRICT ds_motivo_alta_w,
				 ie_gera_novo_atend_w
		from	motivo_alta
		where	cd_motivo_alta = coalesce(cd_motivo_alta_p, cd_motivo_alta_w);

		if (ds_motivo_alta_w = 'X') then
			CALL Wheb_mensagem_pck.exibir_mensagem_abort(270839);
		end if;

		select ie_tipo_atendimento,
				 dt_alta,
				 cd_estabelecimento,
				 dt_entrada
		into STRICT ie_tipo_atendimento_w,
			 dt_alta_w,
			 cd_estabelecimento_w,
			 dt_entrada_w
		from atendimento_paciente
		where nr_atendimento = nr_atendimento_p;

		select	 CASE WHEN coalesce(count(*),0)=0 THEN 'N'  ELSE 'S' END
		into STRICT	ie_usuario_ps_w
		from setor_atendimento b,
				 atend_paciente_unidade a
		where	a.nr_atendimento			 = nr_atendimento_p
		and	a.cd_setor_atendimento = b.cd_setor_atendimento
		and	cd_classif_setor = 1
		and	a.cd_setor_atendimento = cd_setor_atendimento_w;

		select	max(ie_fechar_conta_ps_alta),
			coalesce(max(ie_forma_fechamento),'A'),
                        coalesce(max(ie_diaria_dia_ant),'N')
		into STRICT	ie_fechar_conta_ps_alta_w,
			ie_forma_fechamento_w,
                        ie_diaria_dia_ant_w
		from	parametro_faturamento
		where	cd_estabelecimento	= cd_estabelecimento_w;


		if (nr_setores_usuario_w = 0) then
			CALL Wheb_mensagem_pck.exibir_mensagem_abort(270840);
		else
			begin
				if (dt_procedimento_w > clock_timestamp()) then	 /*Edilson em 30/12/05 OS 26670*/
					dt_procedimento_w	:= clock_timestamp();
				end if;

				open	c020;
				loop
				fetch	c020 into
					dt_entrada_unidade_w,
					nr_seq_interno_w;
				EXIT WHEN NOT FOUND; /* apply on c020 */
				begin

					select	coalesce(max(dt_alta_p),dt_procedimento_w)
					into STRICT	dt_saida_setor_w
					;

					if (dt_saida_setor_w < dt_entrada_unidade_w) then
						update	atend_paciente_unidade
						set dt_saida_unidade		 = clock_timestamp(),
							nm_usuario					 = nm_usuario_p
						where nr_seq_interno			 = nr_seq_interno_w;
					else
						update	atend_paciente_unidade
						set dt_saida_unidade		 = dt_saida_setor_w,
							nm_usuario					 = nm_usuario_p
						where nr_seq_interno			 = nr_seq_interno_w;

					end if;
				end;
				end loop;
				close	c020;

				select count(*)
				into STRICT nr_setores_w
				from atend_paciente_unidade
				where nr_atendimento			 = nr_atendimento_p
				and dt_saida_unidade	 is	null;

				select count(*)
				into STRICT	 nr_setores_int_w
				from	 setor_atendimento b,
						 atend_paciente_unidade a
				where	 a.nr_atendimento			 = nr_atendimento_p
				and	a.cd_setor_atendimento = b.cd_setor_atendimento
				and	(((obter_dados_param_atend(1, 'AI') = 'S') and (b.cd_classif_setor in ('4','8'))) or
						 ((obter_dados_param_atend(1, 'AI') = 'N') and (b.cd_classif_setor in ('3','4','8'))));

				select count(*)
				into STRICT	nr_setores_ps_w
				from	setor_atendimento b,
						 atend_paciente_unidade a
				where	a.nr_atendimento			 = nr_atendimento_p
				and	a.cd_setor_atendimento = b.cd_setor_atendimento
				and	cd_classif_setor = 1;
			end;
		end if;

/* Marcus 29/12/2005 */

		ie_Atend_PS_w			:= 'N';

		if (nr_setores_ps_w > 0) and (nr_setores_int_w = 0) then
			ie_Atend_PS_w		:= 'S';
		end if;

		if (ie_usuario_ps_w = 'S') then
			nr_setores_ps_w := 0;
		end if;

		if (nr_setores_usuario_w > 0) and (nr_setores_int_w = 0) then
			begin
		/*	Edgar/Elemar 28/07/2005, OS 20383, troquei este if pelo if abaixo, para ter certeza que o paciente vai ter alta,
		evento 36 */
				if (coalesce(dt_alta_w::text, '') = '') and (nr_setores_w = 0) and (nr_setores_ps_w = 0) and (nr_setores_int_w = 0) then
					begin
					CALL Gerar_lancamento_automatico(
					nr_atendimento_p,
					cd_local_estoque_w,
					36,
					nm_usuario_p,
					null,
					null,
					null,null,null,null);
					end;
				end if;

				OPEN C010;
				LOOP
				FETCH C010 into
					nr_interno_conta_w,
					vl_conta_w;
				EXIT WHEN NOT FOUND; /* apply on C010 */
				begin
					begin
						select count(*)
						into STRICT	qt_Material_w
						from material_atend_paciente
						where nr_interno_conta		= nr_interno_conta_w
						and cd_setor_atendimento	<> cd_setor_atendimento_w;
					exception
						when others then
							qt_material_w	:= 0;
					end;

					begin
						select	count(*)
						into STRICT	qt_Procedimento_w
						from	Procedimento_paciente
						where	nr_interno_conta		= nr_interno_conta_w
						and	cd_setor_atendimento	<> cd_setor_atendimento_w;
					exception
						when others then
							qt_material_w	:= 0;
					end;

					begin
						select	count(*)			-- Edgar 23/06/2005, OS 19904, tratar procedimentos nao laudados
						into STRICT	qt_proc_sem_laudo_w
						from	procedimento_paciente a
						where	a.nr_interno_conta	= nr_interno_conta_w
						and	(a.nr_prescricao IS NOT NULL AND a.nr_prescricao::text <> '')
						and	not exists (SELECT	1
						from	laudo_paciente x
						where	x.nr_seq_proc	= a.nr_sequencia);

					exception
						when others then
							qt_proc_sem_laudo_w	:= 0;
					end;

					SELECT * FROM consiste_conta_paciente(
						nr_interno_conta_w, nr_atendimento_p, ie_fecha_atendimento_w, ie_fecha_conta_w, qt_processo_pendente_w, ds_inconsistencia_w) INTO STRICT ie_fecha_atendimento_w, ie_fecha_conta_w, qt_processo_pendente_w, ds_inconsistencia_w;

					if (ie_fecha_conta_w = 'S') and (qt_material_w = 0) and (qt_procedimento_w = 0) and (qt_proc_sem_laudo_w = 0) then
						begin
							CALL recalcular_conta_paciente(nr_interno_conta_w, nm_usuario_p);

							update conta_paciente
							set ie_status_acerto	 = 2,
							nm_usuario		= nm_usuario_p,
							dt_atualizacao	= clock_timestamp()
							where nr_interno_conta = nr_interno_conta_w;

							ds_erro_w := fechar_conta_paciente(
								nr_interno_conta_w, nr_atendimento_p, 2, nm_usuario_p, ds_erro_w);

							begin
								CALL tiss_atualizar_prot_conta(null, nr_interno_conta_w, null, null, 'N', cd_estabelecimento_w, nm_usuario_p); /* dsantos - OS138379 - 08/05/2009 */
							exception
								when others then
									null;
							end;
						end;
					end if;
				end;
				END LOOP;
				close c010;
			end;
		else
			if (ie_tipo_atendimento_w = 7) then
				CALL Wheb_mensagem_pck.exibir_mensagem_abort(270841);
			end if;
		end if;

/* Ricardo - OS95789 - Inclui o teste do usuario 'TASY', para tratar a alta automatica */

		if (nr_setores_w = 0) and
		((nr_setores_ps_w = 0) or (nm_usuario_p = 'TASY')) and (nr_setores_int_w = 0) then
			begin
				if (dt_alta_p IS NOT NULL AND dt_alta_p::text <> '') and				/* Edilson em 05/05/06 OS 32959 */
				((dt_procmat_w < dt_alta_p) or (dt_procmat_w = dt_atualizacao_w)) then
					update	atendimento_paciente
					set dt_alta		= dt_alta_p,
						cd_motivo_alta	= coalesce(cd_motivo_alta_p, cd_motivo_alta_w),
						nm_usuario	= nm_usuario_p,
						dt_atualizacao	= clock_timestamp()
					where	nr_atendimento	= nr_atendimento_p
					and	coalesce(dt_alta::text, '') = '';

		/*Inicio gerar atendimento previsto HDM*/


		/*Verifica se tem cadastros de regra na HDM - Cadastro Gerais para o tipo de atendimento */

					select	count(1)
					into STRICT	qt_regras_hdm_w
					from	mprev_atend_previsto_alta a
					where	a.ie_tipo_atendimento = ie_tipo_atendimento_w;
				/*Se existir regra para o tipo de atendimento vai chamar a procedure mprev_gerar_atend_prev_alta para
				gerar atendimento previstos para o participante da medicina preventiva conforme as regras cadastradas
				na funcao HDM - Cadastro Gerais para o tipo de atendimento.*/
					if (qt_regras_hdm_w > 0) then
						CALL mprev_gerar_atend_prev_alta(nr_atendimento_p, nm_usuario_p);
					end if;
		/*FIM gerar atendimento previsto HDM*/

                                        if (ie_diaria_dia_ant_w = 'S') then
                                                CALL calcular_diaria_atendimento(cd_estabelecimento_w, nr_atendimento_p, dt_entrada_w, dt_alta_p, nm_usuario_p, 'S', 'S', 'D', dt_alta_p);
                                        end if;
					select	count(*)
					into STRICT	qt_regra_alta_tx_diaria_w
					from	conv_regra_alta_tx_diaria;

					if (coalesce(qt_regra_alta_tx_diaria_w,0) > 0) then
						CALL gerar_regra_alta_tx_diaria(nr_atendimento_p, dt_alta_p, nm_usuario_p);
					end if;
					
					begin
					/* Mesma tratativa da Gerar_estornar_alta*/

					select	max(b.ie_tipo_convenio)
					into STRICT	ie_tipo_convenio_w
					from	convenio b,
						atend_categoria_convenio a
					where	a.cd_convenio	 	= b.cd_convenio
					and	a.nr_atendimento 		= nr_atendimento_p;
					exception
					when others then
						ie_tipo_convenio_w	:= 3;
					end;
					
					ie_gera_proc_cih_w := Obter_param_Usuario(0, 70, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_gera_proc_cih_w);
					if (ie_tipo_convenio_w <> 3) and (ie_gera_proc_cih_w = 'S') then
						CALL gerar_procedimento_cih_atend(nr_atendimento_p, nm_usuario_p);
					end if;

					if (ie_atualiza_apos_alta_w <> 'N') then
						select	count(*)
						into STRICT	qt_proc_w
						from	procedimento_paciente	 x,
								conta_paciente		y
						where	 x.nr_interno_conta = y.nr_interno_conta
						and	 y.nr_atendimento	 = nr_atendimento_p
						and	 x.dt_conta > dt_alta_p;

						select	count(*)
						into STRICT	qt_mat_w
						from	 material_atend_paciente x,
								 conta_paciente		y
						where	 x.nr_interno_conta = y.nr_interno_conta
						and	 y.nr_atendimento	 = nr_atendimento_p
						and	 x.dt_conta > dt_alta_p;

						if	((qt_proc_w + qt_mat_w) = 0) then
							if (ie_atualiza_apos_alta_w <> 'U') then

								update	conta_paciente a
								set	a.dt_periodo_final = dt_alta_p
								where	 a.nr_atendimento = nr_atendimento_p
								and	 ((ie_atualiza_apos_alta_w = 'S') or (ie_atualiza_apos_alta_w = 'P' AND a.dt_periodo_final > dt_alta_p))
								and	 a.ie_status_acerto = 1;
							else

								select	coalesce(max(nr_interno_conta),0)
								into STRICT	nr_max_interno_conta_w
								from	conta_paciente
								where	ie_status_acerto = 1
								and	nr_atendimento = nr_atendimento_p;

								update	conta_paciente a
								set	a.dt_periodo_final = dt_alta_p
								where	 a.nr_atendimento = nr_atendimento_p
								and	a.nr_interno_conta = nr_max_interno_conta_w;

							end if;
						end if;

					end if;
					

					ie_mantem_status_alta_w := obter_param_usuario(898, 11, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_mantem_status_alta_w);
					ie_realizar_alt_status_w := obter_param_usuario(821, 409, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_realizar_alt_status_w);

					open c03;
					loop
					fetch c03 into	nr_seq_agenda_w,
									ie_status_agenda_w,
									cd_tipo_agenda_w,
									ie_tipo_agenda_w;
					EXIT WHEN NOT FOUND; /* apply on c03 */
						if	(((ie_realizar_alt_status_w = 'S') and (cd_tipo_agenda_w in (3,4))) or (cd_tipo_agenda_w = 5)) then
							if (ie_status_agenda_w not in ('C','B','F','I','II','E','O')) and (ie_mantem_status_alta_w = 'S') and (cd_tipo_agenda_w in (3,4)) then
								update	agenda_consulta
								set	ie_status_agenda	= 'A'
								where	nr_sequencia		= nr_seq_agenda_w;
							elsif	((ie_status_agenda_w = 'O') or (dt_alta_p IS NOT NULL AND dt_alta_p::text <> '') or (cd_tipo_agenda_w = 5)) and (ie_status_agenda_w not in ('IT','S','C','B')) then /* Rafael em 11/06/2007 OS 41208 inclui o teste referente aos status 'C' e 'B' */
									update	agenda_consulta
									set	ie_status_agenda	= 'E'
									where	nr_sequencia		= nr_seq_agenda_w;
							end if;
						end if;

						if (ie_status_agenda_w not in ('C','B','F','I','II')) then
							CALL executar_evento_agenda_alta('AGT',ie_tipo_agenda_w,nr_seq_agenda_w,cd_estabelecimento_w,nm_usuario_p);
						end if;

					end loop;
					close c03;

					open C04;
					loop
					fetch C04 into
						nr_seq_agenda_pac_w,
						ie_status_agenda_pac_w,
						cd_tipo_agenda_pac_w,
						ie_tipo_agenda_pac_w;
					EXIT WHEN NOT FOUND; /* apply on C04 */
					begin
						CALL executar_evento_agenda_alta('AGT',ie_tipo_agenda_pac_w,nr_seq_agenda_pac_w,cd_estabelecimento_w,nm_usuario_p);
					end;
					end loop;
					close C04;

						CALL tiss_atualizar_alta(nr_atendimento_p, null, coalesce(cd_motivo_alta_p, cd_motivo_alta_w),	dt_alta_p, nm_usuario_p);
				else
					update	atendimento_paciente
					set dt_alta		= dt_procmat_w,
						cd_motivo_alta	= coalesce(cd_motivo_alta_p, cd_motivo_alta_w),
						nm_usuario	= nm_usuario_p,
						dt_atualizacao	= clock_timestamp()
					where	nr_atendimento	= nr_atendimento_p
					and	coalesce(dt_alta::text, '') = '';

		/*Inicio gerar atendimento previsto HDM*/


		/*Verifica se tem cadastros de regra na HDM - Cadastro Gerais para o tipo de atendimento */

					select	count(1)
					into STRICT	qt_regras_hdm_w
					from	mprev_atend_previsto_alta a
					where	a.ie_tipo_atendimento = ie_tipo_atendimento_w;
		/*Se existir regra para o tipo de atendimento vai chamar a procedure mprev_gerar_atend_prev_alta para
		gerar atendimento previstos para o participante da medicina preventiva conforme as regras cadastradas
		na funcao HDM - Cadastro Gerais para o tipo de atendimento.*/
					if (qt_regras_hdm_w > 0) then
						CALL mprev_gerar_atend_prev_alta(nr_atendimento_p, nm_usuario_p);
					end if;
		/*FIM gerar atendimento previsto HDM*/

                                         if (ie_diaria_dia_ant_w = 'S') then
                                                CALL calcular_diaria_atendimento(cd_estabelecimento_w, nr_atendimento_p, dt_entrada_unidade_w, dt_entrada_unidade_w, nm_usuario_p, 'S', 'S', 'D', dt_alta_p);
                                        end if;
					select	count(*)
					into STRICT	qt_regra_alta_tx_diaria_w
					from	conv_regra_alta_tx_diaria;

					if (coalesce(qt_regra_alta_tx_diaria_w,0) > 0) then
						CALL gerar_regra_alta_tx_diaria(nr_atendimento_p, dt_procmat_w, nm_usuario_p);
					end if;	
					begin
					/* Mesma tratativa da Gerar_estornar_alta*/

					select	max(b.ie_tipo_convenio)
					into STRICT	ie_tipo_convenio_w
					from	convenio b,
						atend_categoria_convenio a
					where	a.cd_convenio	 	= b.cd_convenio
					and	a.nr_atendimento 		= nr_atendimento_p;
					exception
					when others then
						ie_tipo_convenio_w	:= 3;
					end;
					ie_gera_proc_cih_w := Obter_param_Usuario(0, 70, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_gera_proc_cih_w);
					if (ie_tipo_convenio_w <> 3) and (ie_gera_proc_cih_w = 'S') then
						CALL gerar_procedimento_cih_atend(nr_atendimento_p, nm_usuario_p);
					end if;

					if (ie_atualiza_apos_alta_w <> 'N') then

						select	count(*)
						into STRICT	qt_proc_w
						from		procedimento_paciente	 x,
								conta_paciente		y
						where	 x.nr_interno_conta = y.nr_interno_conta
						and	 y.nr_atendimento	 = nr_atendimento_p
						and	 x.dt_conta > dt_procmat_w;

						select	count(*)
						into STRICT	qt_mat_w
						from		material_atend_paciente x,
								conta_paciente		y
						where	 x.nr_interno_conta = y.nr_interno_conta
						and	 y.nr_atendimento	 = nr_atendimento_p
						and	 x.dt_conta > dt_procmat_w;

						if	((qt_proc_w + qt_mat_w) = 0) then
							if (ie_atualiza_apos_alta_w <> 'U') then

								update	conta_paciente a
								set	a.dt_periodo_final = dt_procmat_w
								where	 a.nr_atendimento = nr_atendimento_p
								and	 ((ie_atualiza_apos_alta_w = 'S') or (ie_atualiza_apos_alta_w = 'P' AND a.dt_periodo_final > dt_procmat_w))
								and	 a.ie_status_acerto = 1;

							else

								select	coalesce(max(nr_interno_conta),0)
								into STRICT	nr_max_interno_conta_w
								from	conta_paciente
								where	ie_status_acerto = 1
								and	nr_atendimento = nr_atendimento_p;

								update	conta_paciente a
								set	a.dt_periodo_final = dt_procmat_w
								where	 a.nr_atendimento = nr_atendimento_p
								and	a.nr_interno_conta = nr_max_interno_conta_w;

							end if;
						end if;

					end if;

					ie_mantem_status_alta_w := obter_param_usuario(898, 11, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_mantem_status_alta_w);
					ie_realizar_alt_status_w := obter_param_usuario(821, 409, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_w, ie_realizar_alt_status_w);

					open c03;
					loop
					fetch c03 into	nr_seq_agenda_w,
									ie_status_agenda_w,
									cd_tipo_agenda_w,
									ie_tipo_agenda_w;
					EXIT WHEN NOT FOUND; /* apply on c03 */

						if	(((ie_realizar_alt_status_w = 'S') and (cd_tipo_agenda_w in (3,4))) or (cd_tipo_agenda_w = 5)) then
							if (ie_status_agenda_w not in ('C','B','F','I','II','E','O')) and (ie_mantem_status_alta_w = 'S') and (cd_tipo_agenda_w in (3,4)) then
								update	agenda_consulta
								set	ie_status_agenda	= 'A'
								where	nr_sequencia		= nr_seq_agenda_w;

							elsif	((ie_status_agenda_w = 'O') or
							((dt_alta_p IS NOT NULL AND dt_alta_p::text <> '') or (dt_procmat_w IS NOT NULL AND dt_procmat_w::text <> ''))	or (cd_tipo_agenda_w = 5)) and (ie_status_agenda_w not in ('IT','S','C','B')) then /* Rafael em 11/06/2007 OS 41208 inclui o teste referente aos status 'C' e 'B' */

								update	agenda_consulta
								set	ie_status_agenda	= 'E'
								where	nr_sequencia		= nr_seq_agenda_w;
							end if;
						end if;

						if (ie_status_agenda_w not in ('C','B','F','I','II')) then
							CALL executar_evento_agenda_alta('AGT',ie_tipo_agenda_w,nr_seq_agenda_w,cd_estabelecimento_w,nm_usuario_p);
						end if;

					end loop;
					close c03;

					open C04;
					loop
					fetch C04 into
						nr_seq_agenda_pac_w,
						ie_status_agenda_pac_w,
						cd_tipo_agenda_pac_w,
						ie_tipo_agenda_pac_w;
					EXIT WHEN NOT FOUND; /* apply on C04 */
					begin
						CALL executar_evento_agenda_alta('AGT',ie_tipo_agenda_pac_w,nr_seq_agenda_pac_w,cd_estabelecimento_w,nm_usuario_p);
					end;
					end loop;
					close C04;

					CALL tiss_atualizar_alta(nr_atendimento_p, null, coalesce(cd_motivo_alta_p, cd_motivo_alta_w),	dt_procmat_w, nm_usuario_p);

				end if;

				CALL gerar_etapa_alta_paciente(nr_atendimento_p, null, nm_usuario_p);

				if (ie_finaliza_atend_w = 'S') and
				(((ie_fechar_conta_ps_alta_w = 'N' AND ie_tipo_atendimento_w <> 3) or (ie_fechar_conta_ps_alta_w = 'S' AND ie_tipo_atendimento_w <> 1)) or (ie_fechar_conta_ps_alta_w = 'A') or
				((ie_fechar_conta_ps_alta_w = 'R') and (obter_se_finaliza_atend(nr_atendimento_p,cd_motivo_alta_p) = 'S'))) then

					if (coalesce(ie_forma_fechamento_w,'A') = 'A') then
						ds_erro_w := Finalizar_Atendimento(nr_atendimento_p, 'S', nm_usuario_p, ds_erro_w);
					elsif (coalesce(ie_forma_fechamento_w,'A') = 'C') then
						open C16;
						loop
						fetch C16 into
							nr_interno_conta_ww;
						EXIT WHEN NOT FOUND; /* apply on C16 */
						begin
							ds_erro_w := fechar_conta_paciente(nr_interno_conta_ww, nr_atendimento_p, '2', nm_usuario_p, ds_erro_w);
						end;
						end loop;
						close C16;
					end if;
				elsif (ie_fechar_conta_ps_alta_w = 'C') then
					open C16;
					loop
					fetch C16 into
						nr_interno_conta_ww;
					EXIT WHEN NOT FOUND; /* apply on C16 */
					begin
					CALL recalcular_conta_paciente(nr_interno_conta_ww,nm_usuario_p);
					end;
					end loop;
					close C16;
				end if;

				if (ie_gera_novo_atend_w = 'S') then

					select	count(*)
					into STRICT	qt_reg_w
					from	atendimento_paciente
					where	nr_atend_alta = nr_atendimento_p;

					if (qt_reg_w = 0) then
						CALL gerar_alta_administrativa(nr_atendimento_p, nm_usuario_p);
					end if;
				end if;

			end;
		end if;

	exception
			when others then
				ds_erro_ww	:= SQLERRM(SQLSTATE);

				insert into log_mov(
					dt_atualizacao,
					nm_usuario,
					cd_log,
					ds_log)
				values (	clock_timestamp(),
						'SaidaSetor',
						9,
						nr_atendimento_p || '-' || cd_setor_atendimento_p || '-' || ds_erro_ww);

				if (cd_funcao_w = 916) then
					CALL Wheb_mensagem_pck.exibir_mensagem_abort(ds_erro_ww);
				end if;
	end;

	commit;

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE saida_setor_servico (nr_atendimento_p bigint, cd_setor_atendimento_p bigint, cd_motivo_alta_p bigint, dt_alta_p timestamp, nm_usuario_p text) FROM PUBLIC;

