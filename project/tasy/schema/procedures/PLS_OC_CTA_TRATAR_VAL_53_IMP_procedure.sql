-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_53_imp (( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) is /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Aplicar a validação de duplicidade de itens
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 dados_validacao_w pls_ocor_imp_pck.dados_val_duplic_item) RETURNS varchar AS $body$
DECLARE

_ora2pg_r RECORD;
ds_result_w 			varchar(2000);
ds_observacao_w			varchar(20000);
ds_sql_w			varchar(4000);
ds_campo_sql_w			varchar(300);
ds_campo_sql_integradas_w	varchar(300);
ds_campo_sql_data_w		varchar(100);
ds_filtro_sql_w			varchar(1000);
ds_filtro_integradas_w		varchar(1000);
dt_procedimento_w		timestamp;
qt_repeticao_w			integer;

nr_seq_conta_ant_w	pls_conta.nr_sequencia%type;

tb_date_w		pls_util_cta_pck.t_date_table;
tb_origem_w		pls_util_cta_pck.t_varchar2_table_5;
tb_guia_referencia_w	pls_util_cta_pck.t_varchar2_table_20;
tb_seq_conta_w		pls_util_cta_pck.t_number_table;
tb_seq_conta_proc_w	pls_util_cta_pck.t_number_table;
tb_seq_protocolo_w	pls_util_cta_pck.t_number_table;

bind_sql_valor_w	sql_pck.t_dado_bind;
cursor_w		sql_pck.t_cursor;
BEGIN

ds_result_w := null;

ds_campo_sql_w := '';
ds_campo_sql_integradas_w := '';
case dados_validacao_p.ie_mesmo_horario
	-- mesma hora
	when 'H' then
		begin
		ds_campo_sql_w := ' trunc(dt_execucao_conv, ''hh'') ';
		ds_campo_sql_integradas_w := ' proc.dt_procedimento_real_hh ';
		end;
	-- Mesma hora e minuto
	when 'M' then
		begin
		ds_campo_sql_w := ' trunc(dt_execucao_conv, ''mi'')';
		ds_campo_sql_integradas_w := ' proc.dt_procedimento_real_min ';
		end;
	-- Mesma hora e minuto
	when 'S' then
		begin
		ds_campo_sql_w := 'dt_execucao_conv';
		ds_campo_sql_integradas_w := ' proc.dt_procedimento_real ';
		end;
	-- verifica somente se é a mesma data
	else
		begin
		ds_campo_sql_w := 'dt_execucao_trunc_conv';
		ds_campo_sql_integradas_w := ' proc.dt_procedimento_real_trunc ';
		end;
end case;


-- campo de data que será utilizado para comparação
ds_campo_sql_data_w := ds_campo_sql_w;

-- busca o valor da data que será utilizado como filtro abaixo na comparação
-- faço dentro desta rotina para centralizar o tratamento para datas
EXECUTE 'select ' || ds_campo_sql_data_w || ' from pls_conta_proc_imp proc where nr_sequencia = :nr_sequencia'
into STRICT dt_procedimento_w
using dados_proc_p.nr_sequencia;


cd_medico_atual_w := pls_obter_dados_medic_exec_imp( dados_proc_p.nr_sequencia, 'P');

-- coloca quebra de linha e vírgula
ds_campo_sql_w := ds_campo_sql_w || ',';
ds_campo_sql_w := ds_campo_sql_w || pls_util_pck.enter_w;
ds_campo_sql_integradas_w := ds_campo_sql_integradas_w ||',';
ds_campo_sql_integradas_w := ds_campo_sql_integradas_w || pls_util_pck.enter_w;

ds_filtro_sql_w := '';
ds_filtro_integradas_w := '';
/*
	ds_filtro_integradas_w refere-se aos filtros para encontrar itens dentro daquilo que já foi integrado, já que a duplicação de item não leva em consideração apenas a
	massa de dados que está sendo importada, mas também aquilo que já foi integrado
*/
if (dados_validacao_p.ie_mesmo_beneficiario = 'S' and (dados_proc_p.nr_seq_segurado IS NOT NULL AND dados_proc_p.nr_seq_segurado::text <> '')) then
	ds_filtro_sql_w		:= ds_filtro_sql_w || ' and conta.nr_seq_segurado_conv = :nr_seq_segurado ' || pls_util_pck.enter_w;
	ds_filtro_integradas_w	:= ds_filtro_integradas_w || ' and proc.nr_seq_segurado = :nr_seq_segurado ' || pls_util_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_segurado', dados_proc_p.nr_seq_segurado, bind_sql_valor_w);
end if;

if (dados_validacao_p.ie_via_acesso = 'S' and (dados_proc_p.ie_via_acesso IS NOT NULL AND dados_proc_p.ie_via_acesso::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.ie_via_acesso_conv = :ie_via_acesso ' || pls_util_pck.enter_w;
	ds_filtro_integradas_w := ds_filtro_integradas_w || ' and proc.ie_via_acesso = :ie_via_acesso ' || pls_util_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':ie_via_acesso', dados_proc_p.ie_via_acesso, bind_sql_valor_w);
end if;

if (dados_proc_p.nr_seq_prestador_exec IS NOT NULL AND dados_proc_p.nr_seq_prestador_exec::text <> '') then
	ds_filtro_sql_w := ds_filtro_sql_w || ' and conta.nr_seq_prest_exec_conv = :nr_seq_prestador_exec ' || pls_util_pck.enter_w;
	ds_filtro_integradas_w := ds_filtro_integradas_w ||' and proc.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_util_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_proc_p.nr_seq_prestador_exec, bind_sql_valor_w);
end if;
--Em caso de importação, compara o cd_guia_solic_imp com(Do procedimento ou  material que esta sendo comparado) com o
--nvl do campo cd_guia_solic_imp com o cd_guia_referencia, pois  o proc ou mat que esta sendo comparado também deve retornar no select.
--Por que é feito um group by entre os campos e quando a quantidade de registros de um agrupamento for maior que 1 é que tem registro duplicado.
if (dados_validacao_p.ie_mesma_guia = 'S' and (dados_proc_p.cd_guia_referencia IS NOT NULL AND dados_proc_p.cd_guia_referencia::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and conta.cd_guia_ok = :cd_guia_referencia_imp ' || pls_util_pck.enter_w;
	ds_filtro_integradas_w := ds_filtro_integradas_w || ' and nvl(proc.cd_guia_referencia, proc.cd_guia_solic_imp) = :cd_guia_referencia_imp ' || pls_util_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia_imp', dados_proc_p.cd_guia_referencia, bind_sql_valor_w);
end if;

-- Prestador
case dados_validacao_p.ie_profissional
	-- Profissional executor
	--A opção 'ME' neste caso é muito cara para manter no SQL, então foi delegada no loop de verificação, ganhando performance
	-- Prestador executor caso profissional não informado
	when 'PE' then

		-- Se tiver prestador exec, se não tiver, o profissional vai ser avaliado no loop, por questões de performance
		if	((dados_proc_p.nr_seq_prestador_exec IS NOT NULL AND dados_proc_p.nr_seq_prestador_exec::text <> '') and (coalesce(cd_medico_atual_w.cd_medico_executor::text, '') = '')) then

			ds_filtro_sql_w := ds_filtro_sql_w || ' and conta.nr_seq_prest_exec_conv = :nr_seq_prestador_exec ' || pls_util_pck.enter_w;
			ds_filtro_integradas_w := ds_filtro_integradas_w || ' and proc.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_util_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_proc_p.nr_seq_prestador_exec, bind_sql_valor_w);
		end if;

	-- Profissional Executor e CBO
	-- Opção 'MC'
	-- Como profissional pode estar informado nos participantes, ele será avaliado no loop abaixo,
	-- por questões de performance
	else
		null;
end case;

-- monta o select para retornar inclusive alguns dados que serão colocados na observação
--Aqui considera além de registros já integrados, o que está sendo importado no momento, sem
--esquecer que não deve contar o que está nas tabelas imp e já está integrado, pois já entrará na
--retorno das tabelas quentes.
ds_sql_w :=	'select	' || ds_campo_sql_w ||
		'	''IMP'' ie_origem, ' || pls_util_pck.enter_w ||
		'	conta.cd_guia_ok_conv cd_guia, ' || pls_util_pck.enter_w ||
		'	proc.nr_seq_conta, ' || pls_util_pck.enter_w ||
		'	proc.nr_sequencia nr_seq_conta_proc, ' || pls_util_pck.enter_w ||
		'	conta.nr_seq_protocolo ' || pls_util_pck.enter_w ||
		'from	pls_conta_proc_imp proc, ' || pls_util_pck.enter_w ||
		'	pls_conta_imp conta, ' || pls_util_pck.enter_w ||
		'	pls_protocolo_conta_imp prot ' || pls_util_pck.enter_w ||
		'where	proc.ie_origem_proced_conv = :ie_origem_proced ' || pls_util_pck.enter_w ||
		'and	proc.cd_procedimento_conv = :cd_procedimento ' || pls_util_pck.enter_w ||
		'and	proc.nr_seq_conta = conta.nr_sequencia ' || pls_util_pck.enter_w ||
		'and	prot.nr_sequencia = conta.nr_seq_protocolo ' || pls_util_pck.enter_w ||
		'and	prot.ie_situacao  not in (''T'', ''RE'') ' || pls_util_pck.enter_w ||
		ds_filtro_sql_w ||pls_util_pck.enter_w ||
		'union all ' || pls_util_pck.enter_w ||
		'select	' || ds_campo_sql_integradas_w || --Aqui as contas que já estão presentes na base
		'	''INT'' ie_origem, ' || pls_util_pck.enter_w ||
		'	proc.cd_guia_referencia cd_guia,' || pls_util_pck.enter_w ||
		'	proc.nr_seq_conta,' || pls_util_pck.enter_w ||
		'	proc.nr_sequencia nr_seq_conta_proc,' || pls_util_pck.enter_w ||
		'	proc.nr_seq_protocolo ' || pls_util_pck.enter_w ||
		'from	pls_conta_proc_ocor_v proc' || pls_util_pck.enter_w ||
		'where	proc.ie_origem_proced = :ie_origem_proced ' || pls_util_pck.enter_w ||
		'and	proc.cd_procedimento = :cd_procedimento ' || pls_util_pck.enter_w ||
		ds_filtro_integradas_w ||
		'order by nr_seq_conta';

		bind_sql_valor_w := sql_pck.bind_variable(':ie_origem_proced', dados_proc_p.ie_origem_proced, bind_sql_valor_w);
		bind_sql_valor_w := sql_pck.bind_variable(':cd_procedimento', dados_proc_p.cd_procedimento, bind_sql_valor_w);

ds_observacao_w := null;
qt_repeticao_w	:= 0;
nr_seq_conta_ant_w := null;

bind_sql_valor_w := sql_pck.executa_sql_cursor(ds_sql_w, bind_sql_valor_w);

loop
	fetch cursor_w bulk collect
	into  tb_date_w, tb_origem_w, tb_guia_referencia_w, tb_seq_conta_w, tb_seq_conta_proc_w, tb_seq_protocolo_w
	limit pls_util_cta_pck.qt_registro_transacao_w;

	exit when tb_seq_conta_w.count = 0;

	for i in tb_seq_conta_w.first..tb_seq_conta_w.last loop

		-- retorno no comando SQL todos os materiais que estão duplicados e faço a restrição por data aqui neste if.
		-- o motivo é bem simples: PERFORMANCE.
		-- se for verificado nesta rotina, existem  nvls e tratamentos de datas e o banco consegue processar muito bem isso com group by e contar as repetições
		-- então assim é feito, juntamos toda a massa e verificamos o que está duplicado e apenas consideramos neste if os que tem a mesma data
		if	((tb_date_w(i) = dt_procedimento_w) or (coalesce(tb_date_w(i)::text, '') = '' and coalesce(dt_procedimento_w::text, '') = '')) then

			ie_valido_w := 'S';
			--Tem que buscar o executor diretamente do procedimento, pois alguns tipos de guia não tem mais o executor. faço a comparação aqui para
			--o select do cursor já ter diminuído a massa de dados e ter um custo menor essa verificação de profissional executor
			if	((dados_validacao_p.ie_profissional = 'ME') or
				-- OU se for para verificar pelo profissional executor, mas o mesmo está em branco, e precisa buscar então o Prestador executor
				-- No caso, se for verificar pelo Prestador executor, ele já foi filtrado no cursor, senão, vai ter que buscar o profissional executor
				 (dados_validacao_p.ie_profissional = 'PE' AND cd_medico_atual_w.cd_medico_executor IS NOT NULL AND cd_medico_atual_w.cd_medico_executor::text <> '') or
				 -- OU se for para validar o profissional + CBO
				 (dados_validacao_p.ie_profissional = 'MC')) then

				if (tb_origem_w(i) = 'IMP') then
					cd_medico_outra_conta_w := pls_obter_dados_medic_exec_imp(tb_seq_conta_proc_w(i),'P');
				else
					cd_medico_outra_conta_w := pls_obter_dados_medico_exec(tb_seq_conta_proc_w(i),'P');
				end if;

				--quando ocorrência utilizar mesmo profissional executor, então não gera se um dos executores for nulo.
				--Em tese não deveria ocorrer um executor nulo, porém não faz sentido gerar a ocorrência mesmo nesses casos.
				-- Ainda no caso do Profissional + CBO
				if	((coalesce(cd_medico_outra_conta_w.cd_medico_executor,'X') <> coalesce(cd_medico_atual_w.cd_medico_executor, 'Z')) and (dados_validacao_p.ie_profissional != 'MC')) or
					 -- OU deve considerar mesmo profissional e mesmo CBO
					((dados_validacao_p.ie_profissional = 'MC') and
					 ((coalesce(cd_medico_outra_conta_w.cd_medico_executor,'X') <> coalesce(cd_medico_atual_w.cd_medico_executor, 'Z')) or (cd_medico_outra_conta_w.nr_seq_cbo_saude <> cd_medico_atual_w.nr_seq_cbo_saude))) then

					ie_valido_w := 'N';
				end if;

			else
				ie_valido_w := 'S';
			end if;

			--ie_valido_w somente será 'N' caso a validação for por profissional executor e  o mesmo for diferente do procedimento que esta sendo consistido.
			if (ie_valido_w = 'S') then

				-- só manda para a observação se for para uma nova conta
				if (coalesce(nr_seq_conta_ant_w::text, '') = '' or nr_seq_conta_ant_w != tb_seq_conta_w(i)) then
					-- quebra de linha
					ds_observacao_w := ds_observacao_w || pls_util_pck.enter_w;

					if ((tb_guia_referencia_w(i) IS NOT NULL AND (tb_guia_referencia_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' guia: ' || tb_guia_referencia_w(i);
					end if;

					if ((tb_seq_conta_w(i) IS NOT NULL AND (tb_seq_conta_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' conta: ' || tb_seq_conta_w(i);
					end if;

					if ((tb_seq_protocolo_w(i) IS NOT NULL AND (tb_seq_protocolo_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' protocolo: ' || tb_seq_protocolo_w(i);
					end if;

					ds_observacao_w := ds_observacao_w || ';';
				end if;

				qt_repeticao_w := qt_repeticao_w + 1;
				nr_seq_conta_ant_w := tb_seq_conta_w(i);
			end if;
		end if;

	end loop;

	-- reinicia as variáveis table
	tb_date_w.delete;
	tb_guia_referencia_w.delete;
	tb_seq_conta_w.delete;
	tb_seq_conta_proc_w.delete;
	tb_seq_protocolo_w.delete;
	tb_origem_w.delete;
end loop;
close cursor_w;

-- se teve observação e se a quantidade de repetição for maior que um, significa que tivemos itens repetidos
if ((ds_observacao_w IS NOT NULL AND ds_observacao_w::text <> '') and qt_repeticao_w > 1) then
	-- retorna somente 2000 pelo motivo que a variável table utilizada para inserção da observação aceita somente isso
	ds_result_w := 'Item com duplicidade. Os dados são:' || substr(ds_observacao_w, 0, 1850);
end if;

return ds_result_w;

end;

function obter_item_duplicado_mat(	dados_validacao_p	pls_ocor_imp_pck.dados_val_duplic_item,
					dados_mat_p		pls_ocor_imp_pck.dados_conta_mat,
					nr_seq_combinada_p	pls_oc_cta_combinada.nr_sequencia%type,
					dados_conta_p		pls_ocor_imp_pck.dados_conta
					) return varchar2 is
ds_result_w 		varchar2(2000);
ds_observacao_w		varchar2(20000);
ds_sql_w		varchar2(4000);
ds_campo_sql_w		varchar2(600);
ds_campo_integradas_w	varchar2(600);
ds_campo_sql_data_w	varchar2(600);
ds_filtro_sql_w		varchar2(1000);
ds_filtro_sql_imp_w	varchar2(1000);
dt_material_w		date;
qt_repeticao_w		pls_integer;

nr_seq_conta_ant_w	pls_conta.nr_sequencia%type;

tb_date_w		pls_util_cta_pck.t_date_table;
tb_guia_referencia_w	pls_util_cta_pck.t_varchar2_table_20;
tb_seq_conta_w		pls_util_cta_pck.t_number_table;
tb_seq_conta_mat_w	pls_util_cta_pck.t_number_table;
tb_seq_protocolo_w	pls_util_cta_pck.t_number_table;
bind_sql_valor_w	sql_pck.t_dado_bind;
cursor_w		sql_pck.t_cursor;
ds_data_w		varchar2(600);


begin

ds_result_w := null;

ds_campo_sql_w := '';
ds_campo_integradas_w := '';

case dados_validacao_p.ie_mesmo_horario
	-- mesma hora
	when 'H' then
	begin
		ds_campo_sql_w := 'trunc(dt_execucao_conv,''hh'')';
		ds_campo_integradas_w := 'trunc(dt_inicio_atend_mat, ''hh'')';
	end;
	-- Mesma hora e minuto
	when 'M' then
	begin
		ds_campo_sql_w := 'trunc(dt_execucao_conv,''mi'')';
		ds_campo_integradas_w := 'trunc(dt_inicio_atend_mat,''mi'')';
	end;
	-- Mesma hora, minuto e segundo
	when 'S' then
	begin
		ds_campo_sql_w := 'dt_execucao_conv';
		ds_campo_integradas_w := 'dt_inicio_atend_mat';
	end;
	-- verifica somente se é a mesma data
	else
	begin
		ds_campo_sql_w := 'dt_execucao_trunc_conv';
		ds_campo_integradas_w := 'trunc(dt_inicio_atend_mat,''dd'')';
	end;
end case;

-- campo de data que será utilizado para comparação
ds_campo_sql_data_w := ds_campo_sql_w;

-- busca o valor da data que será utilizado como filtro abaixo na comparação
-- faço dentro desta rotina para centralizar o tratamento para datas
EXECUTE 'select ' || ds_campo_sql_data_w || ' from pls_conta_mat_imp mat where nr_sequencia = :nr_sequencia'
into STRICT dt_material_w
using dados_mat_p.nr_sequencia;

-- coloca  vírgula
ds_campo_sql_w := ds_campo_sql_w || ',';
ds_campo_sql_w := ds_campo_sql_w || pls_util_pck.enter_w;
ds_campo_integradas_w := ds_campo_integradas_w||',';
ds_campo_integradas_w := ds_campo_integradas_w||pls_util_pck.enter_w;

ds_filtro_sql_w := '';
ds_filtro_sql_imp_w := '';

--se restringir por mesmo beneficiário
if (dados_validacao_p.ie_mesmo_beneficiario = 'S' and (dados_mat_p.nr_seq_segurado IS NOT NULL AND dados_mat_p.nr_seq_segurado::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and mat.nr_seq_segurado = :nr_seq_segurado'||pls_util_pck.enter_w;
	ds_filtro_sql_imp_w := ds_filtro_sql_imp_w ||' and conta.nr_seq_segurado_conv = :nr_seq_segurado '||pls_util_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_segurado', dados_mat_p.nr_seq_segurado, bind_sql_valor_w);
end if;

-- é feito um OR para retornar para filtrar os dois campos (busca o que está sendo importado e os que já existem na base)
-- nunca existe congênere informada para importação XML
if (dados_mat_p.nr_seq_prestador_exec IS NOT NULL AND dados_mat_p.nr_seq_prestador_exec::text <> '') then
	ds_filtro_sql_w := ds_filtro_sql_w || ' and mat.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_util_pck.enter_w;
	ds_filtro_sql_imp_w := ds_filtro_sql_imp_w||' and conta.nr_seq_prest_exec_conv = :nr_seq_prestador_exec ' || pls_util_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_mat_p.nr_seq_prestador_exec, bind_sql_valor_w);
end if;
--Em caso de importação, compara o cd_guia_solic_imp com(Do procedimento ou  material que esta sendo comparado) com o
--nvl do campo cd_guia_solic_imp com o cd_guia_referencia, pois  o proc ou mat que esta sendo comparado também deve retornar no select.
--Por que é feito um group by entre os campos e quando a quantidade de registros de um agrupamento for maior que 1 é que tem registro duplicado.
if (dados_validacao_p.ie_mesma_guia = 'S' and (dados_mat_p.cd_guia_referencia IS NOT NULL AND dados_mat_p.cd_guia_referencia::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and nvl(mat.cd_guia_referencia, mat.cd_guia_solic_imp) = :cd_guia_referencia' || pls_util_pck.enter_w;
	ds_filtro_sql_imp_w := ds_filtro_sql_imp_w||' conta.cd_guia_ok_conv = :cd_guia_referencia';
	bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia', dados_mat_p.cd_guia_referencia, bind_sql_valor_w);
end if;

-- monta o select para retornar inclusive alguns dados que serão colocados na observação
ds_sql_w :=	'select	' ||ds_campo_integradas_w||
		'	mat.cd_guia_referencia,' || pls_util_pck.enter_w ||
		'	mat.nr_seq_conta,' || pls_util_pck.enter_w ||
		'	mat.nr_sequencia nr_seq_conta_mat,' || pls_util_pck.enter_w ||
		'	mat.nr_seq_protocolo ' || pls_util_pck.enter_w ||
		'from	pls_conta_mat_ocor_v mat ' || pls_util_pck.enter_w ||
		'where	mat.nr_seq_material = :nr_seq_material' || pls_util_pck.enter_w ||
		ds_filtro_sql_w ||
		'union all' || pls_util_pck.enter_w ||
		'select	' ||ds_campo_sql_w||
		'	conta.cd_guia_ok_conv,' || pls_util_pck.enter_w ||
		'	mat.nr_seq_conta,' || pls_util_pck.enter_w ||
		'	mat.nr_sequencia nr_seq_conta_mat,' || pls_util_pck.enter_w ||
		'	conta.nr_seq_protocolo ' || pls_util_pck.enter_w ||
		'from	pls_conta_mat_imp mat, ' || pls_util_pck.enter_w ||
		'	pls_conta_imp conta '|| pls_util_pck.enter_w ||
		'where	mat.nr_sequencia = :nr_seq_material ' || pls_util_pck.enter_w ||
		'and	mat.nr_seq_conta = conta.nr_sequencia '|| pls_util_pck.enter_w ||
		ds_filtro_sql_imp_w ||
		'order by nr_seq_conta';

		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_material', dados_mat_p.nr_seq_material, bind_sql_valor_w);

ds_observacao_w := null;
qt_repeticao_w	:= 0;
nr_seq_conta_ant_w := null;
bind_sql_valor_w := sql_pck.executa_sql_cursor(ds_sql_w, bind_sql_valor_w);

loop
	fetch cursor_w bulk collect
	into  tb_date_w, tb_guia_referencia_w, tb_seq_conta_w, tb_seq_conta_mat_w, tb_seq_protocolo_w
	limit pls_util_cta_pck.qt_registro_transacao_w;

	exit when tb_seq_conta_w.count = 0;

	for i in tb_seq_conta_w.first..tb_seq_conta_w.last loop

		-- retorno no comando SQL todos os materiais que estão duplicados e faço a restrição por data aqui neste if.
		-- o motivo é bem simples: PERFORMANCE.
		-- se for verificado nesta rotina, existem  nvls e tratamentos de datas e o banco consegue processar muito bem isso com group by e contar as repetições
		-- então assim é feito, juntamos toda a massa e verificamos o que está duplicado e apenas consideramos neste if os que tem a mesma data
		if	((tb_date_w(i) = dt_material_w) or (coalesce(tb_date_w(i)::text, '') = '' and coalesce(dt_material_w::text, '') = '')) then

			-- só manda para a observação se for para uma nova conta
			if (coalesce(nr_seq_conta_ant_w::text, '') = '' or nr_seq_conta_ant_w != tb_seq_conta_w(i)) then
				-- quebra de linha
				ds_observacao_w := ds_observacao_w || pls_util_pck.enter_w;

				if ((tb_guia_referencia_w(i) IS NOT NULL AND (tb_guia_referencia_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' guia: ' || tb_guia_referencia_w(i);
				end if;

				if ((tb_seq_conta_w(i) IS NOT NULL AND (tb_seq_conta_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' conta: ' || tb_seq_conta_w(i);
				end if;

				if ((tb_seq_protocolo_w(i) IS NOT NULL AND (tb_seq_protocolo_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' protocolo: ' || tb_seq_protocolo_w(i);
				end if;

				ds_observacao_w := ds_observacao_w || ';';
			end if;

			qt_repeticao_w := qt_repeticao_w + 1;
			nr_seq_conta_ant_w := tb_seq_conta_w(i);
		end if;
	end loop;

	-- reinicia as variáveis table
	tb_date_w.delete;
	tb_guia_referencia_w.delete;
	tb_seq_conta_w.delete;
	tb_seq_conta_mat_w.delete;
	tb_seq_protocolo_w.delete;
end loop;
close cursor_w;

-- se teve observação e se a quantidade de repetição for maior que um, significa que tivemos itens repetidos
if ((ds_observacao_w IS NOT NULL AND ds_observacao_w::text <> '') and qt_repeticao_w > 1) then
	-- retorna somente 2000 pelo motivo que a variável table utilizada para inserção da observação aceita somente isso
	ds_result_w := 'Item com duplicidade. Os dados são:' || substr(ds_observacao_w, 0, 1850);
end if;

return ds_result_w;

end;

begin

ds_obs_item_duplicado_w := null;

-- Deve ter informação de uma regra válida para que seja aplicada a validação.
if (nr_seq_combinada_p IS NOT NULL AND nr_seq_combinada_p::text <> '') then

	-- Aqui irá varrer as regras cadastradas para a validação, para esta validação por enquanto só é permitida uma regra, portanto será
	-- passado apenas uma vez.
	for	r_c_regras_val_w in c_regras_val(nr_seq_combinada_p) loop

		begin

		-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
		CALL pls_ocor_imp_pck.atualiza_campo_auxiliar( 'V', 'N', nr_id_transacao_p, null, 'N');

		-- Atualizar os dados validação.
		dados_validacao_w.nr_sequencia			:= r_c_regras_val_w.nr_seq_validacao;
		dados_validacao_w.ie_mesmo_horario		:= r_c_regras_val_w.ie_mesmo_horario;
		dados_validacao_w.ie_mesma_guia			:= r_c_regras_val_w.ie_mesma_guia;
		dados_validacao_w.ie_mesma_fatura 		:= r_c_regras_val_w.ie_mesma_fatura;
		dados_validacao_w.ie_mesmo_beneficiario		:= r_c_regras_val_w.ie_mesmo_beneficiario;
		dados_validacao_w.ie_profissional_intercambio	:= r_c_regras_val_w.ie_profissional_intercambio;
		dados_validacao_w.ie_via_acesso 		:= r_c_regras_val_w.ie_via_acesso;
		dados_validacao_w.ie_considera_cons_desc	:= r_c_regras_val_w.ie_considera_cons_desc;
		dados_validacao_w.ie_profissional		:= r_c_regras_val_w.ie_profissional;

		i := 0;
		SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

		for r_C01_w in C01(nr_id_transacao_p) loop

			-- Obter os valores da linha atual do cursor.
			dados_tab_selecao_w.nr_sequencia     := r_C01_w.nr_seq_selecao;
			dados_tab_selecao_w.ie_tipo_registro := r_C01_w.ie_tipo_registro;
			dados_tab_selecao_w.nr_seq_item      := r_C01_w.nr_seq_item;

			-- alimenta as variáveis de acordo com o tipo do item (procedimento ou material)
			if (dados_tab_selecao_w.ie_tipo_registro = 'P') then
				dados_proc_w.ie_origem_proced 			:= r_C01_w.ie_origem_proced_conv;
				dados_proc_w.cd_procedimento 			:= r_C01_w.cd_procedimento_conv;
				dados_proc_w.nr_seq_prestador_exec		:= r_C01_w.nr_seq_prest_exec_conv;
				dados_proc_w.cd_guia_referencia			:= r_C01_w.cd_guia_ok_conv;
				dados_proc_w.nr_sequencia			:= r_C01_w.nr_sequencia;
				dados_proc_w.nr_seq_segurado			:= r_C01_w.nr_seq_segurado_conv;
				dados_proc_w.nr_seq_prestador_exec		:= r_C01_w.nr_seq_prest_exec_conv;
				dados_conta_w.ie_origem_conta		 	:= r_C01_w.ie_origem_conta;
				dados_proc_w.ie_via_acesso			:= r_c01_w.ie_via_acesso;
				dados_conta_w.nr_seq_cbo_saude			:= r_C01_w.nr_seq_cbo_saude;

			else
				dados_mat_w.nr_seq_material 			:= r_C01_w.nr_seq_material;
				dados_mat_w.nr_seq_prestador_exec		:= r_C01_w.nr_seq_prest_exec_conv;
				dados_mat_w.cd_guia_referencia			:= r_C01_w.cd_guia_ok_conv;
				dados_mat_w.nr_sequencia			:= r_C01_w.nr_sequencia;
				dados_mat_w.nr_seq_prestador_exec		:= r_C01_w.nr_seq_prest_exec_conv;
				dados_mat_w.nr_seq_segurado 			:= r_C01_w.nr_seq_segurado_conv;
				dados_conta_w.ie_origem_conta			:= r_C01_w.ie_origem_conta;
				dados_conta_w.nr_seq_cbo_saude			:= r_C01_w.nr_seq_cbo_saude;

			end if;

			-- faz a validação se existe item duplicado e se existir já retorna os dados para colocar na observação
			if (dados_tab_selecao_w.ie_tipo_registro = 'P') then
				ds_obs_item_duplicado_w := obter_item_duplicado_proc(	dados_validacao_w, dados_proc_w, nr_seq_combinada_p, dados_conta_w);
			else
				ds_obs_item_duplicado_w := obter_item_duplicado_mat(	dados_validacao_w, dados_mat_w, nr_seq_combinada_p, dados_conta_w);
			end if;

			-- significa que encontrou duplicidade de itens e deve gerar ocorrência para o item que está selecionado na tabela de seleção
			if (ds_obs_item_duplicado_w IS NOT NULL AND ds_obs_item_duplicado_w::text <> '') then

				dados_tb_selecao_w.nr_seq_selecao(i)	:= dados_tab_selecao_w.nr_sequencia;
				dados_tb_selecao_w.ds_observacao(i)	:= ds_obs_item_duplicado_w;
				dados_tb_selecao_w.ie_valido(i)		:= 'S';

				tb_seq_selecao_w(i):= dados_tab_selecao_w.nr_sequencia;
				tb_valido_w(i)	   := 'S';
				tb_observacao_w(i) := ds_obs_item_duplicado_w;

				-- Quando tiver atingido a quantidade máxima de registros então irá mandar para banco.
				if (i = pls_util_cta_pck.qt_registro_transacao_w) then

					-- Grava as alterações na tabela
					CALL pls_ocor_imp_pck.gerencia_selecao_validacao(tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
											nr_id_transacao_p, 'SEQ');

					-- Zera as listas e o índice para recomeçar o processo.
					SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
					i := 0;
				else
					i := i + 1;
				end if;
			end if;
		end loop;

		-- se sobrou algum registro manda para o banco
		if (dados_tb_selecao_w.nr_seq_selecao.count > 0) then
			-- Grava as alterações na tabela
			CALL pls_ocor_imp_pck.gerencia_selecao_validacao(tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
								    nr_id_transacao_p, 'SEQ');

			-- Zera as listas e o índice para recomeçar o processo.
			SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

			i := 0;
		end if;

		exception
		when others then
			-- Insere o log na tabela e aborta a operação
			CALL pls_ocor_imp_pck.trata_erro_sql_dinamico( nr_seq_combinada_p, null, sqlerrm ,  nr_id_transacao_p, wheb_usuario_pck.get_nm_usuario, 'N');
		end;

		CALL pls_ocor_imp_pck.atualiza_campo_valido('V', 'N', ie_regra_excecao_p,
							null, nr_id_transacao_p, null,
							'N');


	end loop; -- c_regras_val
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_53_imp (( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) is  dados_validacao_w pls_ocor_imp_pck.dados_val_duplic_item) FROM PUBLIC;

