-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE conta AS (nr_interno_conta 	bigint, 
		   nr_atendimento	bigint, 
		   cd_convenio	integer, 
		   cd_categoria	varchar(10), 
		   cd_estabelecimento smallint, 
		   nr_protocolo	varchar(40));


CREATE OR REPLACE PROCEDURE regeracao_pacote_conta_prot (nr_seq_protocolo_p bigint, nm_usuario_p text) AS $body$
DECLARE

 
/* 
OS 554285 
Protocolo deve estar provisório 
*/
type vetor_conta is table of conta index by integer;
				
				 
nr_interno_conta_w		bigint;
nr_atendimento_w		bigint;
qt_titulo_w			bigint;
qt_nota_w			bigint;
qt_desconto_w			bigint;
qt_item_repasse_w		bigint;
vetor_conta_w			vetor_conta;
i				integer;
k				integer;
nr_seq_w_regeracao_w		bigint;
qt_regeracao_w			bigint;
dt_fim_conta_w			timestamp;
ds_observacao_w    		varchar(255);
nr_seq_procedimento_w		bigint;
cd_convenio_w			integer;
cd_categoria_w			varchar(10);
ie_permite_gerar_pacote_w	varchar(1);
cd_estabelecimento_w		smallint;
ie_status_acerto_w		smallint;
nr_protocolo_w			varchar(40);
ie_abriu_atend_w		varchar(1);
nr_interno_conta_aux_w		bigint;
qt_atend_conv_w			bigint;	
ie_existe_pacote_w		varchar(1);
				
C01 CURSOR FOR  -- Leitura das contas do protocolo 
	SELECT	nr_interno_conta, 
		nr_atendimento, 
		cd_convenio_parametro, 
		cd_categoria_parametro, 
		cd_estabelecimento, 
		nr_protocolo 
	from	conta_paciente 
	where	nr_seq_protocolo = nr_seq_protocolo_p	 
	order by nr_interno_conta;
	
C02 CURSOR FOR 
	SELECT	nr_sequencia 
	from	w_regeracao_pac_conta_prot 
	where	nr_seq_protocolo = nr_seq_protocolo_p 
	order by nr_sequencia;	
	 
C03 CURSOR FOR 
	SELECT nr_seq_procedimento 
	from 	atendimento_pacote a 
	Where 	1 = 1 
	and 	a.nr_seq_proc_origem in (SELECT nr_sequencia 
					from 	procedimento_paciente  
					where 	nr_interno_conta = nr_interno_conta_aux_w) 
	order by nr_seq_procedimento asc;	
				    

BEGIN 
 
open C02;
loop 
fetch C02 into	 
	nr_seq_w_regeracao_w;
EXIT WHEN NOT FOUND; /* apply on C02 */
	begin 
	--Criado o cursor para deletar pela PK da Tabela. 
	delete	from w_regeracao_pac_conta_prot 
	where 	nr_sequencia = nr_seq_w_regeracao_w;	
	end;
end loop;
close C02;
 
 
i			:= 1;
qt_regeracao_w		:= 0;
ie_abriu_atend_w	:= 'N';
ie_existe_pacote_w	:= 'N';
 
open C01;
loop 
fetch C01 into	 
	nr_interno_conta_w, 
	nr_atendimento_w, 
	cd_convenio_w, 
	cd_categoria_w, 
	cd_estabelecimento_w, 
	nr_protocolo_w;
EXIT WHEN NOT FOUND; /* apply on C01 */
	begin 
	 
	select 	count(*) 
	into STRICT	qt_titulo_w 
	from 	titulo_receber 
	where 	nr_interno_conta = nr_interno_conta_w;
	 
	select 	count(*) 
	into STRICT	qt_nota_w 
	from 	nota_fiscal 
	where 	nr_interno_conta = nr_interno_conta_w;
	 
	select 	count(*) 
	into STRICT	qt_desconto_w 
	from 	conta_paciente_desconto 
	where	nr_interno_conta = nr_interno_conta_w;
	 
	select 	coalesce(sum(qt_item_repasse),0) 
	into STRICT	qt_item_repasse_w 
	from (SELECT	count(*) qt_item_repasse 
		 from	procedimento_repasse a, 
			procedimento_paciente b 
		where	a.nr_seq_procedimento = b.nr_sequencia 
		and 	b.nr_interno_conta = nr_interno_conta_w 
		
union all
 
		SELECT	count(*) qt_item_repasse 
		from  material_repasse a, 
			material_atend_paciente b 
		where	a.nr_seq_material = b.nr_sequencia 
		and 	b.nr_interno_conta = nr_interno_conta_w) alias4;
	 
	if	((qt_titulo_w > 0) or (qt_nota_w > 0) or (qt_desconto_w > 0) or (qt_item_repasse_w > 0)) then 
		qt_regeracao_w:= qt_regeracao_w + 1;
		CALL Gravar_w_regeracao_pacote(nr_interno_conta_w,  
					 nr_atendimento_w, 
					 nr_seq_protocolo_p, 
					 '1', 
					 qt_titulo_w, 
					 qt_nota_w, 
					 qt_desconto_w, 
					 qt_item_repasse_w, 
					 wheb_mensagem_pck.get_texto(298842), --'Geração cancelada', 
					 nm_usuario_p);
	else 
		--Armazenamento em vetor dinâmico 
		vetor_conta_w[i].nr_interno_conta	:= nr_interno_conta_w;
		vetor_conta_w[i].nr_atendimento		:= nr_atendimento_w;
		vetor_conta_w[i].cd_convenio		:= cd_convenio_w;
		vetor_conta_w[i].cd_categoria		:= cd_categoria_w;
		vetor_conta_w[i].cd_estabelecimento	:= cd_estabelecimento_w;
		vetor_conta_w[i].nr_protocolo		:= nr_protocolo_w;
		i:= i + 1;	
	end if;
	 
	end;
end loop;
close C01;
 
commit;
 
if (qt_regeracao_w > 0) then 
	goto final;
elsif (qt_regeracao_w = 0) then 
 
	i:= vetor_conta_w.count;
	for k in 1.. i loop 
		begin 
		 
		ie_abriu_atend_w	:= 'N';
		ie_existe_pacote_w	:= 'N';
		 
		select 	max(dt_fim_conta) 
		into STRICT	dt_fim_conta_w 
		from 	atendimento_paciente 
		where 	nr_atendimento = vetor_conta_w[k].nr_atendimento;
		 
		--Abrir o atendimento 
		if (dt_fim_conta_w IS NOT NULL AND dt_fim_conta_w::text <> '') then			 
			begin 
			CALL Abrir_Atendimento(vetor_conta_w[k].nr_atendimento, nm_usuario_p);						
			ie_abriu_atend_w:= 'S';
			exception 
			when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '2', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
			end;
		end if;		
		 
		-- Tirar a conta do protocolo 
		begin 
		update 	conta_paciente 
		set  	nr_seq_protocolo  = NULL , 
			nr_protocolo   = 0, 
			nm_usuario    = nm_usuario_p, 
			dt_atualizacao  = clock_timestamp() 
		where 	nr_interno_conta = vetor_conta_w[k].nr_interno_conta;
		exception 
			when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '3', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
		end;
		 
		 
		-- Mudar Status da conta para provisório 
		begin 
		Update 	conta_paciente 
		set 	ie_status_acerto = 1, 
			dt_atualizacao = clock_timestamp(), 
			dt_geracao_tiss  = NULL, 
			nm_usuario = nm_usuario_p 
		where 	nr_interno_conta = vetor_conta_w[k].nr_interno_conta;
		exception 
			when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '4', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
		end;
		 
		 
		-- Desfazer Pacote 
		begin 
		nr_interno_conta_aux_w:= vetor_conta_w[k].nr_interno_conta;
		open C03;
		loop 
		fetch C03 into	 
			nr_seq_procedimento_w;
		EXIT WHEN NOT FOUND; /* apply on C03 */
			begin 
			ie_existe_pacote_w:= 'S';
			CALL desfazer_pacote(nr_seq_procedimento_w, 'N', nm_usuario_p);
			end;
		end loop;
		close C03;
		commit;
		CALL recalcular_conta_paciente(vetor_conta_w[k].nr_interno_conta, nm_usuario_p);
		exception 
			when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '5', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
		end;
		 
		 
		--Gerar pacote simplificado 
		if (ie_existe_pacote_w = 'S') then 
			select 	coalesce(max(ie_permite_gerar_pacote),'S') 
			into STRICT	ie_permite_gerar_pacote_w 
			from  	categoria_convenio 
			where 	cd_convenio = vetor_conta_w[k].cd_convenio 
			and   cd_categoria = vetor_conta_w[k].cd_categoria;		
			 
			if (ie_permite_gerar_pacote_w = 'N') then	 
				ds_observacao_w:= wheb_mensagem_pck.get_texto(180009); --'Esta categoria não permite geração de pacotes'; 
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,
								 vetor_conta_w[k].nr_atendimento, 
								 nr_seq_protocolo_p, 
								 '6', 
								 0, 
								 0, 
								 0, 
								 0, 
								 ds_observacao_w, 
								 nm_usuario_p);			
			else			 
				begin 
				CALL calcular_pacote(vetor_conta_w[k].nr_atendimento, 
						vetor_conta_w[k].nr_interno_conta, 
						vetor_conta_w[k].cd_convenio, 
						vetor_conta_w[k].cd_categoria, 
						nm_usuario_p, 
						'S', 
						'S', 
						'S', 
						'S', 
						'N');					
				exception 
				when others then 
					ds_observacao_w:= substr(sqlerrm,1,255);
					CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
								 vetor_conta_w[k].nr_atendimento, 
								 nr_seq_protocolo_p, 
								 '6', 
								 0, 
								 0, 
								 0, 
								 0, 
								 ds_observacao_w, 
								 nm_usuario_p);
					goto proximo;
				end;
			end if;
		end if;
		 
		 
		--Fechar a conta do paciente 
		begin 
		ds_observacao_w := fechar_conta_paciente(vetor_conta_w[k].nr_interno_conta, vetor_conta_w[k].nr_atendimento, 2, nm_usuario_p, ds_observacao_w);
		 
		select 	coalesce(max(ie_status_acerto),1) 
		into STRICT	ie_status_acerto_w 
		from 	conta_paciente 
		where 	nr_interno_conta = vetor_conta_w[k].nr_interno_conta;
		 
		if (ie_status_acerto_w = 2) then		 
			begin 
			CALL tiss_atualizar_conta_paciente(vetor_conta_w[k].nr_interno_conta,null,'S',vetor_conta_w[k].cd_estabelecimento,nm_usuario_p,null,null);
			exception 
				when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '7', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
			end;
		 
		else 
		 
			CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '7', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
			goto proximo;
		end if;
		 
		exception 
			when others then 
			ds_observacao_w:= substr(sqlerrm,1,255);
			CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
						 vetor_conta_w[k].nr_atendimento, 
						 nr_seq_protocolo_p, 
						 '7', 
						 0, 
						 0, 
						 0, 
						 0, 
						 ds_observacao_w, 
						 nm_usuario_p);
			goto proximo;
		end;		
		 
			 
		-- Inserir a conta no protocolo 
		begin 
		update 	conta_paciente 
		set  	nr_seq_protocolo = nr_seq_protocolo_p , 
			nr_protocolo   = vetor_conta_w[k].nr_protocolo, 
			nm_usuario    = nm_usuario_p, 
			dt_atualizacao  = clock_timestamp() 
		where 	nr_interno_conta = vetor_conta_w[k].nr_interno_conta;
		exception 
			when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '8', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
		end;
		 
		 
		-- Fechar Arendimento 
		if (ie_abriu_atend_w = 'S') then 
			begin 
			ds_observacao_w := Finalizar_Atendimento(vetor_conta_w[k].nr_atendimento, 'S', nm_usuario_p, ds_observacao_w);
			exception 
				when others then 
				ds_observacao_w:= substr(sqlerrm,1,255);
				CALL Gravar_w_regeracao_pacote(vetor_conta_w[k].nr_interno_conta,  
							 vetor_conta_w[k].nr_atendimento, 
							 nr_seq_protocolo_p, 
							 '9', 
							 0, 
							 0, 
							 0, 
							 0, 
							 ds_observacao_w, 
							 nm_usuario_p);
				goto proximo;
			end;
		end if;
		 
		 
		commit;
		 
		<<proximo>> 
			if (qt_regeracao_w = 0) then 
				/*Foi criado para setar o goto, sem esse if ele dá erro de compilação*/
 
				ds_observacao_w := '';
			end if;
		 
		end;
	end loop;
 
	commit;
end if;
 
<<final>> 
	 
if (qt_regeracao_w > 0) then 
	/*Foi criado para setar o goto, sem esse if ele dá erro de compilação*/
 
	qt_regeracao_w := 0;
end if;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE regeracao_pacote_conta_prot (nr_seq_protocolo_p bigint, nm_usuario_p text) FROM PUBLIC;

