-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_arq_monit_ans_utf ( nr_seq_lote_p pls_monitor_tiss_lote.nr_sequencia%type, nm_usuario_p text, nr_seq_arquivo_p pls_monitor_tiss_arquivo.nr_sequencia%type default null) AS $body$
DECLARE


nr_seq_log_w			tasy_xml_banco.nr_sequencia%type;
ds_parametros_w			varchar(255);
ds_local_w			varchar(255) := null;
ds_erro_w			varchar(255);
arq_texto_w			utl_file.file_type;
----------------------------------------------------------------------------------------------------------
ds_xml_clob_w			text := '';
ds_xml_clob_aux_w		text;
texto_w				varchar(32767);

ds_xml_raw_w			bytea;
limit_raw_w 			constant integer := 32767;
nr_seq_projeto_w		bigint;
ds_xml_blob_w			bytea;
limit_w            		integer	:= 32767;
warning_w			integer;
lang_context_w			integer := dbms_lob.default_lang_ctx;
blob_offset_w			integer := 1;
offset_w			integer := 1;
ds_hash_w			varchar(32);
ds_sql_w			varchar(255);
jobno				bigint;
nm_arquivo_w			pls_monitor_tiss_arquivo.nm_arquivo%type;
ds_stack_w			varchar(4000);

file_exist_w			boolean;
size_w				bigint;
block_size_w			bigint;
cd_versao_tiss_w		varchar(255);

--Cursor dos arquivos a serem gerados
C01 CURSOR(	nr_seq_lote_pc		pls_monitor_tiss_lote.nr_sequencia%type) FOR
	SELECT	nr_sequencia
	from	pls_monitor_tiss_arquivo
	where	nr_seq_lote_monitor = nr_seq_lote_pc;

--Cursor do conteúdo do XML
C02 CURSOR(nr_seq_log_pc	tasy_xml_banco.nr_sequencia%type) FOR
	SELECT	ds_xml
	from	tasy_xml_banco
	where	nr_sequencia = nr_seq_log_pc
	order by nr_seq_geracao;

--Curso do conteúdo de valores do XML
C03 CURSOR(nr_seq_log_pc	tasy_valor_xml_banco.nr_sequencia%type) FOR
	SELECT	ds_valor_xml ds_xml
	from	tasy_valor_xml_banco
	where	nr_sequencia = nr_seq_log_pc
	order by nr_seq_geracao;
BEGIN

CALL gravar_processo_longo('Gerar arquivos de Monitoramento ANS' ,'PLS_GERAR_ARQ_MONIT_ANS_UTF',0);

-- se for para gerar todos os arquivos irá disparar uma JOB para cada arquivo ao invez de processar todos juntos
if (coalesce(nr_seq_arquivo_p::text, '') = '') then

	for r_c01_w in C01(nr_seq_lote_p) loop

		dbms_job.submit(jobno,
				'PLS_GERAR_ARQ_MONIT_ANS_UTF(' || nr_seq_lote_p || ',' || pls_util_pck.aspas_w || nm_usuario_p || pls_util_pck.aspas_w || ',' || r_c01_w.nr_sequencia || ');',
				clock_timestamp() + interval '216000 seconds' * (1/24/60/60));
		commit;
	end loop;
else
	-- verifica se existe o registro, só vai processar caso o nome do arquivo exista
	select	max(nm_arquivo)
	into STRICT	nm_arquivo_w
	from	pls_monitor_tiss_arquivo
	where	nr_seq_lote_monitor = nr_seq_lote_p
	and	nr_sequencia = nr_seq_arquivo_p;

	if (nm_arquivo_w IS NOT NULL AND nm_arquivo_w::text <> '') then
		begin
			-- atualiza o registro para Gerando e limpa o campo erro
			update	pls_monitor_tiss_arquivo
			set	ie_status = 'G',
				ds_erro	 = NULL,
				dt_atualizacao = clock_timestamp(),
				nm_usuario = nm_usuario_p
			where	nr_sequencia = nr_seq_arquivo_p;
			commit;

			CALL gravar_processo_longo('Arquivo - ' || nm_arquivo_w,'PLS_GERAR_ARQ_MONIT_ANS_UTF',-1);

			SELECT * FROM obter_evento_utl_file(13, null, ds_local_w, ds_erro_w) INTO STRICT ds_local_w, ds_erro_w;

			--Obtém os dados do arquivo no diretório
			utl_file.fgetattr(ds_local_w, nm_arquivo_w, file_exist_w, size_w, block_size_w);

			--Caso existir, remove ele para não criar registros no arquivo já criado
			if (file_exist_w) then
				utl_file.fremove(ds_local_w, nm_arquivo_w);
			end if;

			--Cria a instância do arquivo do UTL_FILE
			begin
			arq_texto_w := utl_file.fopen(ds_local_w, nm_arquivo_w, 'WB');
			exception
			when others then
				if (SQLSTATE = -29289) then
					--O acesso ao arquivo foi negado pelo sistema operacional (access_denied).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302935);
				elsif (SQLSTATE = -29298) then
					--O arquivo foi aberto usando FOPEN_NCHAR,  mas efetuaram-se operações de I/O usando funções nonchar comos PUTF ou GET_LINE (charsetmismatch).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302936);
				elsif (SQLSTATE = -29291) then
					--Não foi possível apagar o arquivo (delete_failed).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302937);
				elsif (SQLSTATE = -29286) then
					--Erro interno desconhecido no package UTL_FILE (internal_error).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302938);
				elsif (SQLSTATE = -29282) then
					--O handle do arquivo não existe (invalid_filehandle).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302939);
				elsif (SQLSTATE = -29288) then
					--O arquivo com o nome especificado não foi encontrado neste local (invalid_filename).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302940);
				elsif (SQLSTATE = -29287) then
					--O valor de MAX_LINESIZE para FOPEN() é inválido; deveria estar na faixa de 1 a 32767 (invalid_maxlinesize).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302942);
				elsif (SQLSTATE = -29281) then
					--O parâmetro open_mode na chamda FOPEN é inválido (invalid_mode).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302943);
				elsif (SQLSTATE = -29290) then
					--O parâmetro ABSOLUTE_OFFSET para a chamada FSEEK() é inválido; deveria ser maior do que 0 e menor do que o número total de bytes do arquivo (invalid_offset).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302944);
				elsif (SQLSTATE = -29283) then
					--O arquivo não pôde ser aberto ou operado da forma desejada - ou o caminho não foi encontrado (invalid_operation).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302945);
				elsif (SQLSTATE = -29280) then
					--O caminho especificado não existe ou não está visível ao Oracle (invalid_path).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302946);
				elsif (SQLSTATE = -29284) then
					--Não é possível efetuar a leitura do arquivo (read_error).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302947);
				elsif (SQLSTATE = -29292) then
					--Não é possível renomear o arquivo.
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302948);
				elsif (SQLSTATE = -29285) then
					--Não foi possível gravar no arquivo (write_error).
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302950);
				else
					--Erro desconhecido no package UTL_FILE.
					CALL wheb_mensagem_pck.exibir_mensagem_abort(302951);
				end if;
			end;

			--Cria o LOG do XML, esse varíavel será usada para buscar os dados do arquivo XML nas tabelas  TASY_XML_BANCO e TASY_VALOR_XML_BANCO
			select 	nextval('tasy_xml_banco_seq')
			into STRICT 	nr_seq_log_w
			;

			ds_parametros_w	:= 'NR_SEQUENCIA=' || nr_seq_lote_p || ';NR_SEQ_ARQUIVO=' || nr_seq_arquivo_p|| ';';

			--aldellandrea os846044
			--pego a versão do tiss para tratar o projeto xml
			select	max(cd_versao_tiss)
			into STRICT	cd_versao_tiss_w
			from	pls_monitor_tiss_lote
			where	nr_sequencia = nr_seq_lote_p;

			nr_seq_projeto_w := pls_obter_projeto_xml_monit(cd_versao_tiss_w);

			--Monta os dados do arquivo XML
			CALL wheb_exportar_xml(nr_seq_projeto_w, nr_seq_log_w, 'MANS', ds_parametros_w);

			--Instância um BLOB
			dbms_lob.createtemporary(ds_xml_blob_w, true, dbms_lob.session);
			--Instância um CLOB para o conteúdo do XML
			dbms_lob.createtemporary(ds_xml_clob_w, true, dbms_lob.session);
			dbms_lob.open(ds_xml_clob_w, dbms_lob.lob_readwrite);

			--Abre o cursor e armazena o conteúdo no CLOB
			for r_c02_w in C02(nr_seq_log_w) loop
				begin
				texto_w	:= r_c02_w.ds_xml;

				dbms_lob.append(ds_xml_clob_w, texto_w);

				end;
			end loop;

			--Instância um CLOB para o conteúdo de valores XML
			dbms_lob.createtemporary(ds_xml_clob_aux_w, true, dbms_lob.session);
			dbms_lob.open(ds_xml_clob_aux_w, dbms_lob.lob_readwrite);

			--Abre o cursor e armazena o conteúdo no CLOB
			for r_c03_w in C03(nr_seq_log_w) loop
				begin
				texto_w	:= r_c03_w.ds_xml;

				dbms_lob.append(ds_xml_clob_aux_w, texto_w);

				end;
			end loop;

			--Nessa linha faz o cálculo HASH com os dados de valor do XML
			if (ds_xml_clob_aux_w IS NOT NULL AND ds_xml_clob_aux_w::text <> '') then
				--Utiliza o DBMS_CRYPTO para calcular o HASH, dbms_obfuscation_toolkit não calcula corretamente
				ds_sql_w :=	'begin ' ||
						':ie_hash_w := lower(RAWTOHEX(DBMS_CRYPTO.hash(:ds_xml_clob_aux, dbms_crypto.hash_md5))); ' ||
						'end;';

				EXECUTE ds_sql_w using out ds_hash_w, ds_xml_clob_aux_w;

				dbms_lob.close(ds_xml_clob_aux_w);
				dbms_lob.freetemporary(ds_xml_clob_aux_w);

				--Coloca o HASH no CLOB do conteúdo do ARQUIVO XML
				ds_xml_clob_w := replace(ds_xml_clob_w, 'GERAR_HASH_MD5', ds_hash_w);
			end if;

			--Faz a conversão de dados do CLOB para o BLOB, faz isso por abaixo tem que ser trabalhado com BLOB
			dbms_lob.converttoblob(ds_xml_blob_w,ds_xml_clob_w,dbms_lob.lobmaxsize,blob_offset_w,blob_offset_w,dbms_lob.default_csid,lang_context_w,warning_w);

			--Aqui copia os dados para um RAW a cada 32767, então abre um LOOP quebrando o BLOB
			loop
				begin
					limit_w := limit_raw_w;
					--Aqui ele quebra o BLOB conforme o OFFSET
					dbms_lob.read(ds_xml_blob_w,limit_w,offset_w,ds_xml_raw_w);
					--Manda para o arquivo a instância do RAW quebrado
					utl_file.put_raw(arq_texto_w, ds_xml_raw_w);
					utl_file.fflush(arq_texto_w);
				exit when limit_w < limit_raw_w;
					--Aumenta o OFFSET a cada passagem, ou seja, começa com 1 e depois vai aumentando para 32767 a cada passagem
					offset_w := offset_w + limit_raw_w;
				exception
				    when no_data_found
				    then
					exit;
				end;
			end loop;

			--Fecha o CLOB caso estiver aperto
			if (dbms_lob.isopen(ds_xml_clob_w) > 0) then
				dbms_lob.close(ds_xml_clob_w);
			end if;

			--Libera na memória o CLOB e BLOB
			dbms_lob.freetemporary(ds_xml_clob_w);
			dbms_lob.freetemporary(ds_xml_blob_w);
			--Fecha e libera o arquivo do UTL_FILE
			utl_file.fclose(arq_texto_w);

			--Copia o conteúdo do XML para o banco
			CALL pls_gravar_xml_monitor_tiss(nr_seq_log_w, nr_seq_arquivo_p, nm_usuario_p);

			--Inicializa as variáveis de offset
			offset_w	:= 1;
			blob_offset_w	:= 1;
			lang_context_w	:= dbms_lob.default_lang_ctx;

			-- atualiza o registro para Arquivo gerado
			update	pls_monitor_tiss_arquivo
			set	ie_status = 'S',
				dt_atualizacao = clock_timestamp(),
				nm_usuario = nm_usuario_p
			where	nr_sequencia = nr_seq_arquivo_p;
		exception
			when others then
				rollback;
				ds_stack_w := 	substr(sqlerrm || pls_util_pck.enter_w ||
						dbms_utility.format_call_stack || pls_util_pck.enter_w ||
						dbms_utility.format_error_backtrace, 1, 4000);

			update	pls_monitor_tiss_arquivo
			set	ie_status = 'E',
				ds_erro = ds_stack_w,
				dt_atualizacao = clock_timestamp(),
				nm_usuario = nm_usuario_p
			where	nr_sequencia = nr_seq_arquivo_p;
			commit;
		end;
	end if;
end if;
commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_arq_monit_ans_utf ( nr_seq_lote_p pls_monitor_tiss_lote.nr_sequencia%type, nm_usuario_p text, nr_seq_arquivo_p pls_monitor_tiss_arquivo.nr_sequencia%type default null) FROM PUBLIC;

