-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE consistir_reserva_leito ( cd_agenda_p bigint, dt_agenda_p timestamp, ie_reserva_leito_p text, qt_diaria_prev_p bigint, nr_sequencia_p bigint, cd_medico_p bigint default null, ds_erro_p INOUT text DEFAULT NULL) AS $body$
DECLARE


qt_regra_w			bigint;
qt_reserva_leito_w		bigint;
qt_agenda_w			bigint;
ie_consistir_regra_w		varchar(3);
ds_reserva_leito_w		varchar(254);
ds_reserva_leito_age_w		varchar(254);
ie_considerar_diarias_w		varchar(1):= 'N';
cd_agenda_w			bigint;
hr_inicio_w			timestamp;
hr_fim_w			timestamp;
hr_inicio_anterior_w		timestamp;
hr_inicio_atual_w		timestamp;	
hr_fim_anterior_w		timestamp;
hr_fim_atual_w			timestamp;
ie_primeiro_registro_w 		varchar(1);
qt_diaria_prev_w		smallint;
ie_dia_semana_w			smallint;
cd_especialidade_w		bigint;
ie_dia_agenda_w			smallint := pkg_date_utils.get_weekday(dt_agenda_p);
ds_especialidades_w		varchar(4000);
qt_match_w				bigint;

C01 CURSOR FOR
	SELECT	hr_inicio,
	--	OS282923 - Luciano - Conversado com Darlene, o processo de consistencia deve considerar o dia atual com um dia de reserva ate as 23:59:59, o proximo dia, ja sera considerado o segundo dia de reserva
	establishment_timezone_utils.endOfDay(hr_inicio)+ coalesce(qt_diaria_prev,1) -1
	from	agenda_paciente
	where	((hr_inicio between hr_inicio_w and hr_fim_w) or (establishment_timezone_utils.endOfDay(hr_inicio)+ coalesce(qt_diaria_prev,1) -1 between hr_inicio_w and hr_fim_w) or
		((hr_inicio < hr_inicio_w) and (establishment_timezone_utils.endOfDay(hr_inicio)+ coalesce(qt_diaria_prev,1) -1 > hr_fim_w)))
	and	ie_status_agenda not in ('C','L','B','F','I','LF')
	and	ie_reserva_leito	= ie_reserva_leito_p
	and	((coalesce(cd_agenda_w::text, '') = '') or (cd_agenda = cd_agenda_w))
	and	obter_tipo_agenda(cd_agenda) = 1
	and	nr_sequencia <> nr_sequencia_p
	order by 1,2;
	
c02 CURSOR FOR
	SELECT	a.qt_reserva_leito,
		a.ie_consistir_regra,
		substr(obter_valor_dominio(1545, a.ie_reserva_leito),1,254),
		coalesce(ie_considerar_diarias,'N'),
		cd_agenda,
		a.ie_dia_semana,
		a.cd_especialidade
	from	agenda_reserva_leito a
	where	coalesce(a.cd_agenda,cd_agenda_p) 	= cd_agenda_p
	and	a.ie_reserva_leito		= ie_reserva_leito_p
	order by coalesce(cd_agenda,0);
		


BEGIN
qt_diaria_prev_w := 1;
if (qt_diaria_prev_p > 0) then
	qt_diaria_prev_w := qt_diaria_prev_p;
end if;	

ds_erro_p := null;

if (cd_agenda_p IS NOT NULL AND cd_agenda_p::text <> '') and (dt_agenda_p IS NOT NULL AND dt_agenda_p::text <> '') and (ie_reserva_leito_p IS NOT NULL AND ie_reserva_leito_p::text <> '') then
	begin
	/* Obter a quantidade de regras para o tipo de reserva leito informado no agendamento */

	select	count(*)
	into STRICT	qt_regra_w
	from	agenda_reserva_leito a
	where	((coalesce(a.cd_agenda::text, '') = '') or (a.cd_agenda = cd_agenda_p))
	and	a.ie_reserva_leito = ie_reserva_leito_p;
	
	/* Obter a descricao da reserva leito */

	select	substr(obter_valor_dominio(1545, ie_reserva_leito_p),1,254)
	into STRICT	ds_reserva_leito_age_w
	;

	/* Se possuir apenas uma regra definida para o tipo de reserva leito realiza a verificacao da consistencia */

	if (qt_regra_w = 1) then

		/* Obter as informacoes da regra para o tipo de reserva leito */

		select	a.qt_reserva_leito,
			a.ie_consistir_regra,
			substr(obter_valor_dominio(1545, a.ie_reserva_leito),1,254),
			max(coalesce(ie_considerar_diarias,'N')),
			cd_agenda,
			ie_dia_semana,
			cd_especialidade
		into STRICT	qt_reserva_leito_w,
			ie_consistir_regra_w,
			ds_reserva_leito_w,
			ie_considerar_diarias_w,
			cd_agenda_w,
			ie_dia_semana_w,
			cd_especialidade_w
		from	agenda_reserva_leito a
		where	((coalesce(a.cd_agenda::text, '') = '') or (a.cd_agenda = cd_agenda_p))
		and	a.ie_reserva_leito	= ie_reserva_leito_p
		group	by 	a.qt_reserva_leito,
				a.ie_consistir_regra,
				substr(obter_valor_dominio(1545, a.ie_reserva_leito),1,254),
				cd_agenda,
				ie_dia_semana,
				cd_especialidade;
	else
		open C02;
		loop
		fetch C02 into	
			qt_reserva_leito_w,
			ie_consistir_regra_w,
			ds_reserva_leito_w,
			ie_considerar_diarias_w,
			cd_agenda_w,
			ie_dia_semana_w,
			cd_especialidade_w;
		EXIT WHEN NOT FOUND; /* apply on C02 */
			begin
			qt_reserva_leito_w	:= qt_reserva_leito_w;
			ie_consistir_regra_w	:= ie_consistir_regra_w;	
			ds_reserva_leito_w	:= ds_reserva_leito_w;
			ie_considerar_diarias_w := ie_considerar_diarias_w;
			cd_agenda_w		:= cd_agenda_w;
			ie_dia_semana_w := ie_dia_semana_w;
			cd_especialidade_w := cd_especialidade_w;
			end;
		end loop;
		close C02;
	end if;	
	
	if (ie_considerar_diarias_w = 'N') then
		begin
		/* Obter a quantidade de agendamentos com o tipo de reserva leito para a agenda e para o dia*/

		if (coalesce(cd_agenda_w, 0) > 0) then
			select	count(*)
			into STRICT	qt_agenda_w
			from	agenda_paciente a
			where (cd_agenda = cd_agenda_w)
			and a.dt_agenda between ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_agenda_p) and ESTABLISHMENT_TIMEZONE_UTILS.endOfDay(dt_agenda_p)
			and	a.ie_status_agenda not in ('C','L','B','F','I','LF')
			and	a.ie_reserva_leito		= ie_reserva_leito_p
			and	obter_tipo_agenda(a.cd_agenda) = 1
         and	nr_sequencia <> nr_sequencia_p;
		else
			select	count(*)
			into STRICT	qt_agenda_w
			from	agenda_paciente a
			where	a.dt_agenda between ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_agenda_p) and ESTABLISHMENT_TIMEZONE_UTILS.endOfDay(dt_agenda_p) 
			and	a.ie_status_agenda not in ('C','L','B','F','I','LF')
			and	a.ie_reserva_leito		= ie_reserva_leito_p
			and	obter_tipo_agenda(a.cd_agenda) = 1
         and	nr_sequencia <> nr_sequencia_p;
		end if;
		end;
	else	
		begin
		/* Obter a quantidade de agendamentos com o tipo de reserva leito para a agenda verificando por diarias previstas*/

		hr_inicio_w 	:= dt_agenda_p;
		hr_fim_w	:= (establishment_timezone_utils.endOfDay(dt_agenda_p) + qt_diaria_prev_w) -1;
		ie_primeiro_registro_w 	:= 'S';
		
		


		open C01;
		loop
		fetch C01 into
			hr_inicio_atual_w,
			hr_fim_atual_w;
		EXIT WHEN NOT FOUND; /* apply on C01 */
			if (ie_primeiro_registro_w = 'S') then
				hr_inicio_anterior_w 	:= hr_inicio_atual_w;
				hr_fim_anterior_w	:= hr_fim_atual_w;
				qt_agenda_w		:= 1;
				ie_primeiro_registro_w 	:= 'N';
			else

				if (hr_inicio_atual_w < hr_fim_anterior_w) then
					qt_agenda_w	:= qt_agenda_w + 1;

				end if;
			end if;
		end loop;
		close C01;
		end;
	end if;	
	
	ds_especialidades_w := ',' || obter_especialidade_medico_cod(cd_medico_p) || ','; -- para padronizar que todos os valores fiquem entre virgulas
	qt_match_w := coalesce(position(',' || cd_especialidade_w || ',' in ds_especialidades_w),0); -- se > 0 , significa que houve match na posicao citada pela variavel.
		
	/* Se a quantidade de agendamentos para a agenda no dia for igual a quantidade maxima na regra de reserva leito, o sistema ira realizar a consistencia */

	if (qt_reserva_leito_w > 0) and (qt_agenda_w > 0) and (qt_reserva_leito_w <= qt_agenda_w) and
		((ie_dia_semana_w < 8 and ie_dia_semana_w = ie_dia_agenda_w) or  --Checagens com relacao ao dia da semana
			(ie_dia_semana_w = 9 and ie_dia_agenda_w between 2 and 6) or (coalesce(ie_dia_semana_w::text, '') = '')) and
		((coalesce(cd_especialidade_w::text, '') = '') or -- checagens com relacao a especialidade.
			(qt_match_w > 0)) then
		begin
		if (ie_consistir_regra_w = 'CS') then
			/* Se a regra esta definida como consistir e salvar */

			ds_erro_p	:= substr(wheb_mensagem_pck.get_texto(278019, 'DS_RESERVA_LEITO_P=' || ds_reserva_leito_w),1,255);
		elsif (ie_consistir_regra_w = 'CB') then
			/* Se a regra esta definida como consistir e bloquear */


			--A quantidade maxima de agendamentos com o tipo de reserva leito: ' || ds_reserva_leito_w || ', permitidos por dia para esta agenda, ' || chr(13) || chr(10) || 'ja foi alcancada.' || '#@#@'
			CALL Wheb_mensagem_pck.exibir_mensagem_abort(263560,'DS_RESERVA_LEITO_W=' || ds_reserva_leito_w);


		end if;
		end;



	end if;	
	end;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE consistir_reserva_leito ( cd_agenda_p bigint, dt_agenda_p timestamp, ie_reserva_leito_p text, qt_diaria_prev_p bigint, nr_sequencia_p bigint, cd_medico_p bigint default null, ds_erro_p INOUT text DEFAULT NULL) FROM PUBLIC;

