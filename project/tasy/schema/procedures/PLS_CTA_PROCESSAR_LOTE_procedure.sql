-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_cta_processar_lote ( nr_seq_lote_p pls_cta_lote_processo.nr_sequencia%type, ds_lista_processo_p text, nr_seq_ocorrencia_p pls_ocorrencia.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) AS $body$
DECLARE

 
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
Finalidade: Processar o lote conforme as opções selecionadas pelo usuário 
------------------------------------------------------------------------------------------------------------------- 
Locais de chamada direta: 
[ ] Objetos do dicionário [X ] Tasy (Delphi/Java) [ ] Portal [ ] Relatórios [ ] Outros: 
 ------------------------------------------------------------------------------------------------------------------ 
Pontos de atenção: 
 
ie_contar_qtd_p - Criado para retornar ao Delphi primeiro, para tratar barra de progresso 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 
 
nr_seq_processo_exec_w 	pls_cta_lote_proc_exec.nr_sequencia%type;
nr_seq_processo_item_w 	pls_cta_lote_prc_exec_item.nr_sequencia%type;
qt_contas_w  			integer := 0;
qt_proc_w  			integer := 0;
qt_mat_w  			integer := 0;
ds_log_w  			pls_oc_cta_log_erro.ds_log%type;
ds_stack_w  			varchar(4000);
nm_id_sid_w			pls_cta_lote_processo.nm_id_sid%type;
nm_id_serial_w			pls_cta_lote_processo.nm_id_serial%type;
dt_geracao_lote_w		pls_cta_lote_processo.dt_geracao_lote%type;
dt_geracao_pos_w		timestamp;
nr_seq_analise_pos_w		pls_analise_conta.nr_sequencia%type;
ie_status_pos_estab_w		pls_analise_conta.ie_status%type;
qt_analise_w			integer;
nr_seq_analise_ref_w		pls_analise_conta.nr_seq_analise_ref%type;

c_contas CURSOR(	nr_seq_lote_pc pls_cta_lote_processo.nr_sequencia%type) FOR 
 SELECT	a.nr_seq_conta, 
		(SELECT	count(1) 
		from	pls_conta_proc x 
		where	x.nr_seq_conta = a.nr_seq_conta) qt_proc, 
		(select	count(1) 
		from	pls_conta_mat x 
		where	x.nr_seq_conta = a.nr_seq_conta) qt_mat, 
		b.ie_status, 
		b.ie_status_analise 
 from	pls_cta_lote_proc_conta a, 
	pls_conta_v  		b 
 where a.nr_seq_lote_processo = nr_seq_lote_pc 
 and 	b.nr_sequencia  	= a.nr_seq_conta;

c_pos CURSOR(	nr_seq_lote_pc pls_cta_lote_processo.nr_sequencia%type) FOR 
	SELECT	pos.nr_seq_analise 
	from	pls_cta_lote_proc_conta a, 
		pls_conta_v  		b, 
		pls_conta_pos_estabelecido	pos 
	where 	a.nr_seq_lote_processo = nr_seq_lote_pc 
	and 	b.nr_sequencia  	= a.nr_seq_conta 
	and	pos.nr_seq_conta	= b.nr_sequencia 
	and	((pos.ie_situacao	= 'A') or (coalesce(pos.ie_situacao::text, '') = '')) 
	group by pos.nr_seq_analise;
	
C_pos_conta CURSOR(nr_seq_analise_pc	pls_conta_pos_estabelecido.nr_seq_analise%type)FOR 
	SELECT	distinct c.nr_sequencia nr_seq_conta 
 
	from	pls_analise_conta	pos, 
			pls_analise_conta	pag, 
			pls_conta			c 
	where	pos.nr_sequencia = nr_seq_analise_pc 
 
	and		pos.nr_seq_analise_ref = pag.nr_sequencia 
	and		pag.nr_sequencia	= c.nr_seq_analise;
	
c_processos CURSOR( ds_processos_pc text) FOR 
	SELECT	a.nr_sequencia, 
		a.cd_processo, 
		a.nm_processo 
	from	pls_cta_tipo_processo a 
	where	a.cd_processo in (	SELECT	x.nr_valor_number 
					from	table(pls_util_pck.converter_lista_valores(ds_processos_pc, ',')) x) 
	order by a.cd_processo;
	
c_analise CURSOR(nr_seq_lote_pc	pls_cta_lote_processo.nr_sequencia%type) FOR 
	SELECT	distinct b.nr_sequencia 
	from	pls_cta_lote_proc_conta a, 
		pls_conta_v  		b 
	where 	b.nr_sequencia  	= a.nr_seq_conta 
	and	a.nr_seq_lote_processo = nr_seq_lote_pc 
	and	(b.nr_seq_segurado IS NOT NULL AND b.nr_seq_segurado::text <> '') 
	and 	not exists (	SELECT 1 
				from 	pls_conta_pos_estabelecido 	x, 
					pls_conta			c					 
				where 	c.nr_seq_analise = b.nr_seq_analise  
				and	c.nr_sequencia	 = x.nr_seq_conta 
				and 	(x.nr_seq_analise IS NOT NULL AND x.nr_seq_analise::text <> '') 
				and	((x.ie_situacao	 = 'A') or (coalesce(x.ie_situacao::text, '') = '')));

procedure grava_log_erro(	ds_stack_p  	text) is 
;
BEGIN
-- controle para rodar ou não a procedure pls_analise_cta_pck.pls_atualizar_agrup_proc 
pls_analise_cta_pck.ie_atu_nr_seq_agrup_analise := 'N';
pls_util_cta_pck.ie_grava_log_w := 'S';
  
-- coloca com status de processado com erros. 
update 	pls_cta_lote_processo 
set 	ie_status 	= '4', 
	nm_usuario 	= nm_usuario_p, 
	dt_atualizacao 	= clock_timestamp() 
where	nr_sequencia 	= nr_seq_lote_p;
commit;
  
-- Obter o log a ser gravado 
ds_log_w := substr('Erro: ' || sqlerrm || pls_util_pck.enter_w || 
		  'Stack: ' || pls_util_pck.enter_w || ds_stack_p, 1, 4000);
  
insert into pls_cta_lote_prc_exec_erro(nr_sequencia, 
	 nm_usuario, 
	 dt_atualizacao, 
	 nr_seq_processo_exec, 
	 ds_erro) 
values (nextval('pls_cta_lote_prc_exec_erro_seq'), 
	 nm_usuario_p, 
	 clock_timestamp(), 
	 nr_seq_processo_exec_w, 
	 ds_log_w);
commit;
 
CALL wheb_mensagem_pck.exibir_mensagem_abort(241019, 'ERRO=' || sqlerrm, -20012);
 
end;
 
procedure inserir_contas_itens_pendentes( tb_seq_contas_p pls_util_cta_pck.t_number_table) is 
 
begin 
	if (tb_seq_contas_p.count > 0) then 
		forall i in tb_seq_contas_p.first..tb_seq_contas_p.last 
			insert into pls_cta_lote_proc_pend( 	dt_atualizacao, dt_atualizacao_nrec, nm_usuario, 
								nm_usuario_nrec, nr_seq_conta, nr_seq_lote_processo, 
								nr_sequencia) 
							values ( clock_timestamp(), clock_timestamp(), nm_usuario_p, 
								nm_usuario_p, tb_seq_contas_p(i), nr_seq_lote_p, 
								nextval('pls_cta_lote_proc_pend_seq'));
		commit;
	end if;
 
end;
 
procedure insere_contas_itens_pendentes( nr_seq_lote_p pls_cta_lote_processo.nr_sequencia%type) is 
 
tb_seq_contas_w	pls_util_cta_pck.t_number_table;
nr_index_w	pls_integer;
 
C01 CURSOR FOR 
	SELECT	nr_seq_conta 
	from	pls_cta_lote_proc_conta a 
	where	nr_seq_lote_processo = nr_seq_lote_p 
	and	exists ( SELECT 	1 
			from  	pls_conta_proc_v c, 
				pls_analise_conta b 
			where 	c.nr_seq_conta = a.nr_seq_conta 
			and  	c.ie_status = 'P' 
			and	c.nr_seq_analise = b.nr_sequencia 
			and	b.ie_status 	= 'T' 
		) 
	
union
 
	select	nr_seq_conta 
	from	pls_cta_lote_proc_conta a 
	where	nr_seq_lote_processo = nr_seq_lote_p 
	and	exists ( select 1 
			from  	pls_conta_mat_v 	c, 
				pls_analise_conta	b 
			where 	c.nr_seq_conta = a.nr_seq_conta 
			and  	c.ie_status = 'P' 
			and	c.nr_seq_analise = b.nr_sequencia 
			and	b.ie_status	= 'T' 
	);
	 
begin 
 
nr_index_w := 0;
tb_seq_contas_w.delete;
 
for r_C01_w in C01 loop 
 
	nr_index_w := nr_index_w + 1;
	tb_seq_contas_w(nr_index_w) := r_c01_w.nr_seq_conta;
	if (nr_index_w > pls_util_pck.qt_registro_transacao_w) then 
		inserir_contas_itens_pendentes(tb_seq_contas_w);
		nr_index_w:= 0;
		tb_seq_contas_w.delete;
	end if;
end loop;
 
inserir_contas_itens_pendentes(tb_seq_contas_w);
 
end;
 
begin 
-- essa tabela foi criada como alternativa de performance para processamento de lotes 
CALL gera_cta_temp_lote_processo(nr_seq_lote_p);
 
-- controle para rodar ou não a procedure pls_analise_cta_pck.pls_atualizar_agrup_proc 
pls_analise_cta_pck.ie_atu_nr_seq_agrup_analise := 'N';
pls_util_cta_pck.ie_grava_log_w := 'N';
CALL wheb_usuario_pck.set_nm_usuario(nm_usuario_p);
 
select	sid, 
	serial# 
into STRICT	nm_id_sid_w, 
	nm_id_serial_w 
from	v$session 
where 	audsid = userenv('SESSIONID');
 
-- coloca com status em processamento. 
update	pls_cta_lote_processo 
set	ie_status 	= '2', 
	nm_id_sid 	= nm_id_sid_w, 
	nm_id_serial 	= nm_id_serial_w, 
	nm_usuario 	= nm_usuario_p, 
	dt_atualizacao 	= clock_timestamp() 
where	nr_sequencia 	= nr_seq_lote_p;
 
commit;
 
select	a.dt_geracao_lote 
into STRICT	dt_geracao_lote_w 
from	pls_cta_lote_processo a 
where	a.nr_sequencia	= nr_seq_lote_p;
	 
select	max(coalesce(item.dt_inicio, item.dt_termino)) 
into STRICT	dt_geracao_pos_w 
from	pls_cta_lote_proc_exec		lote, 
	pls_cta_lote_prc_exec_item 	item 
where	item.nr_seq_processo_exec	= lote.nr_sequencia 
and	item.nr_seq_tipo_processo	= 14 
and	lote.nr_sequencia		=(SELECT	max(x.nr_sequencia) 
					 from		pls_cta_lote_proc_exec	x 
					 where		x.nr_seq_lote_processo	= nr_seq_lote_p 
					 and 		not exists (	select 	1 
										from	pls_cta_lote_prc_exec_erro er 
										where 	nr_seq_processo_exec	= x.nr_sequencia));
	 
select	nextval('pls_cta_lote_proc_exec_seq') 
into STRICT	nr_seq_processo_exec_w
;
 
delete 	from pls_cta_lote_proc_pend 
where 	nr_seq_lote_processo = nr_seq_lote_p;
 
insert into pls_cta_lote_proc_exec(nr_sequencia, 
	 nm_usuario, 
	 dt_atualizacao, 
	 nm_usuario_nrec, 
	 dt_atualizacao_nrec, 
	 nr_seq_lote_processo, 
	 dt_inicio) 
values (nr_seq_processo_exec_w, 
	 nm_usuario_p, 
	 clock_timestamp(), 
	 nm_usuario_p, 
	 clock_timestamp(), 
	 nr_seq_lote_p, 
	 clock_timestamp());
commit;
begin 
	if (dt_geracao_lote_w < dt_geracao_pos_w) then 
		CALL wheb_mensagem_pck.exibir_mensagem_abort(317011);
	end if;
exception 
when others then 
	-- obter o callstack 
	ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
		   dbms_utility.format_error_backtrace;
	CALL grava_log_erro(	ds_stack_w);
end;
 
--Apenas varre a lista de processos que executará para validar se poderá executar de fato. 
--Até o mesmo, apenas verifica se esta tentando rodar as etapas de Atualização de cobrança ou 
--Geração de pós-estabelecido em lote gerado como pagamento. Alertará o usuário antes de rodar 
--qualquer uma das etapas 
for rw_processo_w in c_processos(ds_lista_processo_p) loop 
 
	begin 
 
	--Então o lote foi gerado como pagamento e nesse caso não deixa executar os processos 9 e 11 
	if ((dt_geracao_lote_w IS NOT NULL AND dt_geracao_lote_w::text <> '') and rw_processo_w.cd_processo in (9,11)) then 
	 
		-- obter o callstack 
	 
		begin 
			CALL wheb_mensagem_pck.exibir_mensagem_abort(356874);
		exception 
		when others then 
			-- obter o callstack 
			ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
				   dbms_utility.format_error_backtrace;
			CALL grava_log_erro(	ds_stack_w);
		end;
	 
	end if;
	 
	--Então o lote foi gerado como faturamento e nesse caso não deixa executar os demais processos () 
	if (coalesce(dt_geracao_lote_w::text, '') = '' and rw_processo_w.cd_processo not in (9,11)) then 
		begin 
		 
			CALL wheb_mensagem_pck.exibir_mensagem_abort(357816);
			--wheb_mensagem_pck.exibir_mensagem_abort('Na geração de lote de faturamento, são permitidas apenas executar as --apenas para o depois da 1655 
			--							etapas Atualização de Cobrança e Geração de Pós-Estabelecido.'); 
		exception 
		when others then 
			-- obter o callstack 
			ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
				   dbms_utility.format_error_backtrace;
			CALL grava_log_erro(	ds_stack_w);
		end;
	 
	end if;
	 
	end;
end loop;
 
--Esse loop pega cada uma das etapas que vieram no parâmetro, separadas por virgula e traz os dados necessários. 
for rw_processo_w in c_processos(ds_lista_processo_p) loop 
 
	if (rw_processo_w.cd_processo > 0) then 
   
		select	nextval('pls_cta_lote_prc_exec_item_seq') 
		into STRICT	nr_seq_processo_item_w 
		;
    
		insert into pls_cta_lote_prc_exec_item(nr_sequencia, 
			 nm_usuario, 
			 dt_atualizacao, 
			 nm_usuario_nrec, 
			 dt_atualizacao_nrec, 
			 nr_seq_processo_exec, 
			 nr_seq_tipo_processo, 
			 dt_inicio) 
		values (nr_seq_processo_item_w, 
			 nm_usuario_p, 
			 clock_timestamp(), 
			 nm_usuario_p, 
			 clock_timestamp(), 
			 nr_seq_processo_exec_w, 
			 rw_processo_w.nr_sequencia, 
			 clock_timestamp());
		commit;
    
		-- tratamento para processos que são autônomos, ou seja, eles recebem o lote de parâmetro e resolvem tudo o que for do lote 
		if (rw_processo_w.cd_processo not in (9, 11)) then 
     
			case(rw_processo_w.cd_processo) 
				-- Consistir 
				when 2 then 
					begin 
						CALL pls_cta_consistir_pck.gerencia_pre_requisitos_gerais( 	null, null, nr_seq_lote_p, 
													null, null, null, nm_usuario_p, 
													cd_estabelecimento_p);
						-- essa tabela foi criada como alternativa de performance para processamento de lotes 
						-- chamada aqui novamente porque pode nascer contas novas neste processo (honorário individual) 
						CALL gera_cta_temp_lote_processo(nr_seq_lote_p);
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
				-- Valorização 
				when 3 then 
					begin 
						CALL pls_cta_consistir_pck.gera_valorizacao(	null, null, nr_seq_lote_p, null, 
											null, null, nm_usuario_p, cd_estabelecimento_p);
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
				-- Glosas 
				when 4 then 
					begin 
						CALL pls_cta_consistir_pck.verifica_glosa( 	null, null, nr_seq_lote_p, null, 
											null, nm_usuario_p, cd_estabelecimento_p);
						pls_analise_cta_pck.ie_atu_nr_seq_agrup_analise := 'S';
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
				-- Ocorrências antigas 
				when 5 then 
					CALL pls_cta_consistir_pck.verifica_ocorrencia( 	null, null, nr_seq_lote_p, null, 
											null, null, nm_usuario_p, 
											cd_estabelecimento_p);
					-- seta a variável que é utilizada para controlar se a procedure pls_analise_cta_pck.pls_atualizar_agrup_proc precisará ser rodada ou se a mesma já foi 
					pls_analise_cta_pck.ie_atu_nr_seq_agrup_analise := 'S';
				-- Ocorrências combinadas - 
				when 6 then 
					begin 
						CALL pls_cta_consistir_pck.verifica_ocorrencia_combinada( 	null, null, nr_seq_lote_p, null, 
													null, null, nr_seq_ocorrencia_p, 
													nm_usuario_p, cd_estabelecimento_p);
						pls_analise_cta_pck.ie_atu_nr_seq_agrup_analise := 'S';
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
				-- Liberações automáticas 
				when 7 then 
					begin 
						CALL pls_cta_consistir_pck.gerencia_liberacao_automatica( 	null, null, nr_seq_lote_p, null, 
													null, null, nm_usuario_p, 
													cd_estabelecimento_p);
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
				-- Atualização de Pagamento e Cobrança 
				when 8 then 
					begin 
						CALL pls_cta_consistir_pck.atualizar_pagamento( 	null, null, nr_seq_lote_p, null, 
												'L', nm_usuario_p, cd_estabelecimento_p);
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
		 
				-- Geração da análise 
				when 10 then 
					begin 
						pls_analise_cta_pck.gerar_analise( 	null, null, nr_seq_lote_p, null, 
											nm_usuario_p, cd_estabelecimento_p, 'N', 'N', 
											'S');
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);
					end;
				--Liberação automática da análise	 
				when 12 then 
					begin 
						CALL pls_cta_consistir_pck.liberar_automatic_analise(	null, null, nr_seq_lote_p, null, 
													nm_usuario_p, cd_estabelecimento_p);
					exception 
					when others then 
						-- obter o callstack 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);	
					end;
				else 
					null;
			end case;
		else 
			-- tratamento para processos que são feitos a nível de conta 
			-- existe uma tendência para que tudo vire um processo autônomo, ou seja, que esses tratamentos a nível de conta sejam feitos a nível de lote de processo 
			-- para fins de performance e simplificação, o tratamento de exceção foi feito para o bloco inteiro 
			begin 
				case(rw_processo_w.cd_processo) 
				 
				--Atualizar cobrança 
				when 9 then 
					begin 
					 
						CALL pls_cta_consistir_pck.atualizar_cobranca( 	null, null, nr_seq_lote_p, null, 
												'L', nm_usuario_p, cd_estabelecimento_p);
						 
					exception 
					when others then 
						ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							   dbms_utility.format_error_backtrace;
						CALL grava_log_erro(	ds_stack_w);	
					end;
						 
				-- Geração de pós-estabelecido 
				when 11 then 
					begin 
					 
					--Gera o lote de processo para as contas de pós-estabelecido 
					CALL pls_cta_gerar_lote_processo(	nr_seq_lote_p, nm_usuario_p,'S');
					 
					update 	pls_conta_proc c 
					set	nr_seq_regra_conv	 = NULL 
					where	nr_seq_conta 		in (	SELECT 	a.nr_seq_conta 
										from	pls_cta_lote_proc_conta a 
 										where 	a.nr_seq_lote_processo = nr_seq_lote_p) 
					and	ie_status	!= 'M';
										 
					for r_c_pos_w in c_pos(nr_seq_lote_p) loop 
						begin 
 
						if (r_c_pos_w.nr_seq_analise IS NOT NULL AND r_c_pos_w.nr_seq_analise::text <> '') then 
					 
							-- abertura de pacotes do faturamento 
							select	max(nr_seq_analise_ref) 
							into STRICT	nr_seq_analise_ref_w 
							from	pls_analise_conta 
							where	nr_sequencia = r_c_pos_w.nr_seq_analise;
							 
							CALL pls_tratar_abertura_pct_fat(	null, null, nr_seq_analise_ref_w, 
											null, cd_estabelecimento_p, nm_usuario_p);
							for r_c_pos_conta_w in c_pos_conta(r_c_pos_w.nr_seq_analise) loop 
								begin 
								CALL pls_lancar_item_proc_pos(r_c_pos_conta_w.nr_seq_conta, nm_usuario_p);
								end;
							end loop;
 
							--Necessário setar o status para o inicio para caso seja gerado ocorrência, a análise ficar pendente 
							update	pls_analise_conta 
							set	ie_status	= 'S' 
							where 	nr_sequencia 	= r_c_pos_w.nr_seq_analise;
 
							CALL pls_consistir_analise_pos(r_c_pos_w.nr_seq_analise, null, cd_estabelecimento_p,nm_usuario_p, 'S', 'S', 'N');
							 
							 
						end if;
						 
						end;
					end loop;
					 
					for r_c_analise_w in c_analise(nr_seq_lote_p) loop 
						begin 
						CALL pls_lancar_item_proc_pos(r_c_analise_w.nr_sequencia, nm_usuario_p);
						CALL pls_gerar_valor_pos_estab(r_c_analise_w.nr_sequencia, nm_usuario_p, 'C', 
											null, null, 'C');
						end;
					end loop;
					 
					 
					for r_c_contas_w in c_contas(nr_seq_lote_p) loop 
						-- Gerar os valores de pós-estabelecido somente se a conta que estiver fechada 
						if (r_c_contas_w.ie_status = 'F') then 
							select 	count(1) 
							into STRICT	qt_analise_w 
							from	pls_analise_conta 
							where	ie_status	not in ('T','C') 
							and	nr_sequencia 	in (	SELECT 	nr_seq_analise 
											from	pls_conta_pos_estabelecido	a 
											where	a.nr_seq_conta		= r_c_contas_w.nr_seq_conta		 
											and	((ie_situacao		= 'A') or (coalesce(ie_situacao::text, '') = '')));	
											 
							if (coalesce(r_c_contas_w.ie_status_analise::text, '') = '' or r_c_contas_w.ie_status_analise = 'T') and (qt_analise_w = 0) then 
								update	pls_conta 
								set	ie_status_fat	= 'L' 
								where	nr_sequencia	= r_c_contas_w.nr_seq_conta;
							end if;
							--ajusta o status dos itens para liberado para faturamento caso estes estejam setados para permite faturamento 
							 
							 
							--Além da conta fechada, é preciso verificar se a análise esta como atendimento encerrado			 
							select max(nr_seq_analise) 
							into STRICT	nr_seq_analise_pos_w 
							from  pls_conta_pos_estabelecido 
							where  nr_seq_conta = r_c_contas_w.nr_seq_conta  LIMIT 1;
							 
							select	max(ie_status) 
							into STRICT	ie_status_pos_estab_w 
							from	pls_analise_conta 
							where	nr_sequencia = nr_seq_analise_pos_w;
							 
							if (coalesce(ie_status_pos_estab_w::text, '') = '' or ie_status_pos_estab_w = 'T') then 
								update	pls_conta_pos_estabelecido 
								set	ie_status_faturamento 	= 'L', 
									dt_atualizacao		= clock_timestamp(), 
									nm_usuario		= nm_usuario_p 
								where	nr_seq_conta 		= r_c_contas_w.nr_seq_conta 
								and	ie_status_faturamento 	= 'P' 
								and	((ie_situacao		= 'A') or (coalesce(ie_situacao::text, '') = ''));	
							end if;
							commit;
						end if;
					end loop;
					 
					end;
					 
					for r_c_pos_w in c_pos(nr_seq_lote_p) loop 
 
 
						if (r_c_pos_w.nr_seq_analise IS NOT NULL AND r_c_pos_w.nr_seq_analise::text <> '') then 
 
							select	max(nr_seq_analise_ref) 
							into STRICT	nr_seq_analise_ref_w 
							from	pls_analise_conta 
							where	nr_sequencia = r_c_pos_w.nr_seq_analise;
 
							--Caso não exista grupo auditor vinculado a análise encerra ela novamente 
							CALL pls_gerar_auditoria_pos(nr_seq_analise_ref_w, null, 'N', cd_estabelecimento_p, nm_usuario_p);
						end if;
 
					end loop;
					 
				else 
					null;
				end case;
     
				 
			exception 
			when others then 
				-- obter o callstack 
				ds_stack_w := dbms_utility.format_call_stack||pls_util_pck.enter_w|| 
							 dbms_utility.format_error_backtrace;
				CALL grava_log_erro(	ds_stack_w);
			end;
		end if;
    
		update	pls_cta_lote_prc_exec_item 
		set 	dt_termino = clock_timestamp() 
		where	nr_sequencia = nr_seq_processo_item_w;
		commit;
    
	end if;
end loop;
 
--Insere as contas que possuem itens pendentes 
insere_contas_itens_pendentes(nr_seq_lote_p);
 
-- para alimentar os totais 
select count(1) qt_conta, 
	sum((select count(1) 
	   from pls_conta_proc x 
	   where x.nr_seq_conta = a.nr_seq_conta)) qt_proc, 
	sum((select count(1) 
	   from pls_conta_mat x 
	   where x.nr_seq_conta = a.nr_seq_conta)) qt_mat 
into STRICT  qt_contas_w, 
	qt_proc_w, 
	qt_mat_w 
from	pls_cta_lote_proc_conta a 
where	a.nr_seq_lote_processo = nr_seq_lote_p;
 
update	pls_cta_lote_proc_exec 
set	dt_termino 		= clock_timestamp(), 
	qt_total_contas 	= qt_contas_w, 
	qt_total_procedimento 	= qt_proc_w, 
	qt_total_material 	= qt_mat_w 
where	nr_sequencia 		= nr_seq_processo_exec_w;
 
commit;
  
-- coloca com status processsado. 
update	pls_cta_lote_processo 
set	ie_status 	= '3', 
	nm_id_job 	 = NULL, 
	nm_id_sid 	 = NULL, 
	nm_id_serial 	 = NULL, 
	nm_usuario 	= nm_usuario_p, 
	dt_atualizacao 	= clock_timestamp() 
where	nr_sequencia 	= nr_seq_lote_p;
commit;
 
pls_analise_cta_pck.ie_atu_nr_seq_agrup_analise := 'N';
pls_util_cta_pck.ie_grava_log_w := 'S';
  
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_cta_processar_lote ( nr_seq_lote_p pls_cta_lote_processo.nr_sequencia%type, ds_lista_processo_p text, nr_seq_ocorrencia_p pls_ocorrencia.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;

