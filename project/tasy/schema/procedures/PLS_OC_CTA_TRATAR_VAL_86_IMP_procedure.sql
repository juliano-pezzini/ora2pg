-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_86_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) is ie_valido_w varchar(1) RETURNS bigint AS $body$
DECLARE


_ora2pg_r RECORD;
ie_retorno_w	smallint;
BEGIN
	ie_retorno_w := 0;
	if (coalesce(nr_seq_prestador_p::text, '') = '') then
		ie_retorno_w	:= 1;

	--Somente para importação de xml
	else
		select 	count(1)
		into STRICT	qt_prest_w
		from	pls_prestador a
		where	a.nr_sequencia = nr_seq_prestador_p;

		if (qt_prest_w = 0) then
			ie_retorno_w	:= 2;
		end if;

	end if;

return ie_retorno_w;

end;

function valida_cnes_prestador(	nr_seq_prestador_p	pls_prestador.nr_sequencia%type,
				cd_cnes_p		pls_conta.cd_cnes%type,
				ie_tipo_validacao_p	pls_oc_cta_val_dado_pres.ie_valida_cnes%type)
				return			number is

ie_retorno_w	number(1); --1 para válido e 0 para não válido
begin

	ie_retorno_w := 0;
	if (coalesce(cd_cnes_p::text, '') = '') then
		if (ie_tipo_validacao_p <> 'S') then
			ie_retorno_w := 1;
		end if;
	else
		select 	coalesce(substr(pls_obter_cnes_prestador(a.nr_sequencia),1,40),'X')
		into STRICT	cd_cnes_prest_w
		from 	pls_prestador a
		where 	a.nr_sequencia = nr_seq_prestador_p;

		if	(cd_cnes_p <> cd_cnes_prest_w AND cd_cnes_p <> '9999999') then
			ie_retorno_w := 1;
		end if;
	end if;

return ie_retorno_w;
end;

function valida_cpf_cnpj( 	cd_cpf_p	pls_conta.cd_cpf_executor_imp%type,
				cd_cnpj_p	pls_conta.cd_cgc_executor_imp%type)
				return		number is

ie_retorno_w	number(1);
begin

	ie_retorno_w := 0;
	if (cd_cpf_p IS NOT NULL AND cd_cpf_p::text <> '') then
		if (length(cd_cpf_p) <> 11) then
			ie_retorno_w := 1;
		end if;

	end if;

	if (cd_cnpj_p IS NOT NULL AND cd_cnpj_p::text <> '') then
		if (length(cd_cnpj_p) <> 14) then
			ie_retorno_w := 2;
		end if;
	end if;

return ie_retorno_w;
end;

begin

-- Deve exisitr informação da regra para executar a validação
if (nr_seq_combinada_p IS NOT NULL AND nr_seq_combinada_p::text <> '')  then

	-- Buscar a parametrização da validação conforme cadastrado pelos usuarios.
	for r_C01_w in C01(nr_seq_combinada_p) loop

		-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
		CALL pls_ocor_imp_pck.atualiza_campo_auxiliar( 'V', 'N', nr_id_transacao_p, null);

		SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

		--Se prestador executor
		if (r_C01_w.ie_tipo_prestador = '1') then

			for r_C02_w in C02(nr_id_transacao_p) loop

				tb_observacao_w(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C02_w.nr_seq_prestador_exec);

					if (ie_retorno_prest_w = 1) then
						tb_observacao_w(nr_idx_w):= ' Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						tb_observacao_w(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Se ie_retorno_w for diferente de 0 então que dizer que já caiu lá em cima, então não precisa mais verificar
				if (r_c01_w.ie_valida_cnes in ('S', 'V')  and ie_retorno_prest_w = 0) then

					ie_retorno_prest_w := valida_cnes_prestador(r_C02_w.nr_seq_prestador_exec, r_C02_w.cd_cnes, r_c01_w.ie_valida_cnes);


					if (ie_retorno_prest_w = 1) then
						tb_observacao_w(nr_idx_w):=  'CNES do prestador executor não é válido.';

					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S' AND ie_retorno_prest_w = 0) then

					if ((r_C02_w.cd_cpf_prest_exec_conv IS NOT NULL AND r_C02_w.cd_cpf_prest_exec_conv::text <> '') or (r_c02_w.cd_cgc_prest_exec_conv IS NOT NULL AND r_c02_w.cd_cgc_prest_exec_conv::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C02_w.cd_cpf_prest_exec_conv, r_c02_w.cd_cgc_prest_exec_conv);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						tb_observacao_w(nr_idx_w) := wheb_mensagem_pck.get_texto('CPF informado inválido.');
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						tb_observacao_w(nr_idx_w) := wheb_mensagem_pck.get_texto('CNPJ informado inválido.');
					end if;

				end if;

				tb_seq_selecao_w(nr_idx_w):=	r_C02_w.nr_seq_selecao;
				if ((tb_observacao_w(nr_idx_w) IS NOT NULL AND (tb_observacao_w(nr_idx_w))::text <> '')) then
					tb_valido_w(nr_idx_w) := 'S';
				else
					tb_valido_w(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
											nr_id_transacao_p, 'SEQ');

					nr_idx_w := 0;
					SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;

		--Se prestador atendimento
		elsif (r_C01_w.ie_tipo_prestador = '2') then
			for r_C02_w in C02(nr_id_transacao_p) loop

				tb_observacao_w(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C02_w.nr_seq_prestador_atend);

					if (ie_retorno_prest_w = 1) then
						tb_observacao_w(nr_idx_w):= 'Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						tb_observacao_w(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S') and (ie_retorno_prest_w = 0)then

					if ((r_C02_w.cd_cpf_prest_atend IS NOT NULL AND r_C02_w.cd_cpf_prest_atend::text <> '') or (r_c02_w.cd_cgc_prest_atend IS NOT NULL AND r_c02_w.cd_cgc_prest_atend::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C02_w.cd_cpf_prest_atend, r_c02_w.cd_cgc_prest_atend);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						tb_observacao_w(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						tb_observacao_w(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  tb_observacao_w, de modo  que uma condição da regra
				--não se sobreponha às outras.
				tb_seq_selecao_w(nr_idx_w):=	r_C02_w.nr_seq_selecao;
				if ((tb_observacao_w(nr_idx_w) IS NOT NULL AND (tb_observacao_w(nr_idx_w))::text <> '')) then
					tb_valido_w(nr_idx_w) := 'S';
				else
					tb_valido_w(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
											nr_id_transacao_p, 'SEQ');

					nr_idx_w := 0;
					SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;
		--Se prestador solicitante
		elsif (r_C01_w.ie_tipo_prestador = '3') then
			for r_C02_w in C02(nr_id_transacao_p) loop

				tb_observacao_w(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C02_w.nr_seq_prestador_solic);

					if (ie_retorno_prest_w = 1) then
						tb_observacao_w(nr_idx_w):= 'Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						tb_observacao_w(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML
				if (r_C01_w.ie_valida_cpf_cpnj = 'S') and (ie_retorno_prest_w = 0)then

					if ((r_C02_w.cd_cpf_prest_solic IS NOT NULL AND r_C02_w.cd_cpf_prest_solic::text <> '') or (r_c02_w.cd_cgc_prest_solic IS NOT NULL AND r_c02_w.cd_cgc_prest_solic::text <> '')) then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C02_w.cd_cpf_prest_solic, r_c02_w.cd_cgc_prest_solic);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						tb_observacao_w(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						tb_observacao_w(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  tb_observacao_w, de modo  que uma condição da regra
				--não se sobreponha às outras.
				tb_seq_selecao_w(nr_idx_w):=	r_C02_w.nr_seq_selecao;
				if ((tb_observacao_w(nr_idx_w) IS NOT NULL AND (tb_observacao_w(nr_idx_w))::text <> '')) then
					tb_valido_w(nr_idx_w) := 'S';
				else
					tb_valido_w(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
											nr_id_transacao_p, 'SEQ');

					nr_idx_w := 0;
					SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;

		--Se prestador participante
		elsif (r_C01_w.ie_tipo_prestador = '4') then
			for r_C03_w in C03(nr_id_transacao_p) loop

				tb_observacao_w(nr_idx_w):= null;

				if (r_c01_w.ie_prestador_existe = 'S') then
					ie_retorno_prest_w := valida_prestador_informado(r_C03_w.nr_seq_prestador_exec);

					if (ie_retorno_prest_w = 1) then
						tb_observacao_w(nr_idx_w):= 'Prestador não informado.';
					elsif (ie_retorno_prest_w = 2) then
						tb_observacao_w(nr_idx_w):= ' Prestador não localizado. ';
					end if;
				end if;

				--Só validará CPF e CNPJ em importação de XML - Para participante, o prestador sempre será um Pessoa física.
				if (r_C01_w.ie_valida_cpf_cpnj = 'S') and (ie_retorno_prest_w = 0)then

					if (r_C03_w.cd_cpf_executor IS NOT NULL AND r_C03_w.cd_cpf_executor::text <> '') then

						ie_retorno_prest_w := valida_cpf_cnpj(r_C03_w.cd_cpf_executor, null);
					end if;

					if (ie_retorno_prest_w = 1) then --CPF inválido
						tb_observacao_w(nr_idx_w) := 'CPF informado inválido';
					elsif (ie_retorno_prest_w = 2) then --CNPJ inválido
						tb_observacao_w(nr_idx_w) := 'CNPJ informado inválido';
					end if;

				end if;

				--Aqui verifica se realmente o registro da tabela de seleção é válido em relação às condições da regra e em caso afirmativo, irá
				--atualizar  com 'S' o ie_válido_temp para posterior atualização do ie_valido.  Novas restrições na regra devem ser inseridas antes
				--desse ponto e efetuado o controle de geração ou não via  tb_observacao_w, de modo  que uma condição da regra
				--não se sobreponha às outras.
				tb_seq_selecao_w(nr_idx_w):=	r_C03_w.nr_seq_selecao;
				if ((tb_observacao_w(nr_idx_w) IS NOT NULL AND (tb_observacao_w(nr_idx_w))::text <> '')) then
					tb_valido_w(nr_idx_w) := 'S';
				else
					tb_valido_w(nr_idx_w) := 'N';
				end if;

				if (nr_idx_w = pls_util_cta_pck.qt_registro_transacao_w) then
					CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
											nr_id_transacao_p, 'SEQ');

					nr_idx_w := 0;
					SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
				else
					nr_idx_w := nr_idx_w + 1;
				end if;

			end loop;
		end if;
	end loop;

	if (nr_idx_w > 0) then

		CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w,
											nr_id_transacao_p, 'SEQ');
	end if;

	-- seta os registros que serão válidos ou inválidos após o processamento
	CALL pls_ocor_imp_pck.atualiza_campo_valido('V', 'N', ie_regra_excecao_p,
							null, nr_id_transacao_p, null);
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_86_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) is ie_valido_w varchar(1) FROM PUBLIC;

