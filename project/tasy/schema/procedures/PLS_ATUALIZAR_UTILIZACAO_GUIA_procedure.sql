-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_atualizar_utilizacao_guia ( nr_seq_conta_p pls_conta.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, ie_analise_p text default 'N') AS $body$
DECLARE


nr_seq_analise_w		pls_analise_conta.nr_sequencia%type;
ie_status_w			pls_guia_plano_proc.ie_utilizado%type;
qt_tot_utilizado_w		integer;
qt_tot_autorizado_w		integer;
ie_dados_atualizar_util_w	pls_param_autorizacao.ie_dados_atualizar_utilizacao%type;

-- feito com union all para tratar as duas formas de chamada a esta função
c00 CURSOR(	nr_seq_analise_pc	pls_analise_conta.nr_sequencia%type,
		nr_seq_conta_pc		pls_conta.nr_sequencia%type) FOR
	-- todas as guias da análise
	SELECT	distinct b.nr_sequencia nr_seq_guia
	from	pls_conta_v a,
		pls_guia_plano b
	where	a.nr_seq_analise = nr_seq_analise_pc
	and	b.cd_guia = a.cd_guia_referencia
	and	b.nr_seq_segurado = a.nr_seq_segurado
	
union all

	-- ou a guia da conta
	SELECT	distinct b.nr_sequencia nr_seq_guia
	from	pls_conta_v a,
		pls_guia_plano b
	where	a.nr_sequencia = nr_seq_conta_pc
	and	coalesce(nr_seq_analise_pc::text, '') = ''
	and	b.cd_guia = a.cd_guia_referencia
	and	b.nr_seq_segurado = a.nr_seq_segurado;

c01 CURSOR(	nr_seq_guia_pc		pls_guia_plano.nr_sequencia%type,
		cd_estabelecimento_pc	estabelecimento.cd_estabelecimento%type) FOR
	SELECT	a.nr_sequencia,
		a.cd_procedimento,
		a.ie_origem_proced,
		coalesce(sum(b.qt_saldo), 0) qt_saldo,
		coalesce(sum(b.qt_utilizada), 0) qt_utilizada,
		coalesce(sum(b.qt_autorizada), 0) qt_autorizada
	from	pls_guia_plano_proc a,
		table(pls_conta_autor_pck.obter_dados(nr_seq_guia_pc, 'P', cd_estabelecimento_pc, a.ie_origem_proced, a.cd_procedimento)) b
	where	a.nr_seq_guia = nr_seq_guia_pc
	group by a.nr_sequencia,
		a.cd_procedimento,
		a.ie_origem_proced;

c02 CURSOR(	nr_seq_guia_pc		pls_guia_plano.nr_sequencia%type,
		cd_estabelecimento_pc	estabelecimento.cd_estabelecimento%type) FOR
	SELECT	a.nr_sequencia,
		a.nr_seq_material,
		coalesce(sum(b.qt_saldo), 0) qt_saldo,
		coalesce(sum(b.qt_utilizada), 0) qt_utilizada,
		coalesce(sum(b.qt_autorizada), 0) qt_autorizada
	from	pls_guia_plano_mat a,
		table(pls_conta_autor_pck.obter_dados(nr_seq_guia_pc, 'M', cd_estabelecimento_pc, null, null, a.nr_seq_material)) b
	where	a.nr_seq_guia = nr_seq_guia_pc
	group by a.nr_sequencia,
		a.nr_seq_material;
BEGIN
-- alimenta a análise somente quando esta função for chamada pelo processo de reconsistir análise
if (ie_analise_p = 'S') then
	select	max(nr_seq_analise)
	into STRICT	nr_seq_analise_w
	from	pls_conta
	where 	nr_sequencia = nr_seq_conta_p;
else
	nr_seq_analise_w := null;
end if;

select	max(coalesce(ie_dados_atualizar_utilizacao,'A'))
into STRICT	ie_dados_atualizar_util_w
from	pls_param_autorizacao
where	cd_estabelecimento	= cd_estabelecimento_p;

-- retorna todas as guias que necessitam ser atualizadas
for r_c00_w in c00(nr_seq_analise_w, nr_seq_conta_p) loop

	qt_tot_utilizado_w := 0;
	qt_tot_autorizado_w := 0;

	for r_c01_w in c01(r_c00_w.nr_seq_guia, cd_estabelecimento_p) loop

		if (r_c01_w.qt_saldo <= 0) then
			ie_status_w	:= 'U';
		elsif (r_c01_w.qt_saldo = r_c01_w.qt_autorizada) then
			ie_status_w	:= 'N';
		else
			ie_status_w	:= 'P';
		end if;

		update	pls_guia_plano_proc
		set	ie_utilizado	= ie_status_w,
			qt_utilizado	= r_c01_w.qt_utilizada,
			dt_atualizacao	= CASE WHEN ie_dados_atualizar_util_w='N' THEN dt_atualizacao  ELSE clock_timestamp() END ,
			nm_usuario	= CASE WHEN ie_dados_atualizar_util_w='M' THEN nm_usuario_p  ELSE nm_usuario END
		where	nr_sequencia	= r_c01_w.nr_sequencia;

		qt_tot_utilizado_w := qt_tot_utilizado_w + r_c01_w.qt_utilizada;
		qt_tot_autorizado_w := qt_tot_autorizado_w + r_c01_w.qt_autorizada;
	end loop;
	commit;

	for r_c02_w in c02(r_c00_w.nr_seq_guia, cd_estabelecimento_p) loop

		if (r_c02_w.qt_saldo <= 0) then
			ie_status_w	:= 'U';
		elsif (r_c02_w.qt_saldo = r_c02_w.qt_autorizada) then
			ie_status_w	:= 'N';
		else
			ie_status_w	:= 'P';
		end if;

		update	pls_guia_plano_mat
		set	ie_utilizado	= ie_status_w,
			qt_utilizado	= r_c02_w.qt_utilizada,
			dt_atualizacao	= CASE WHEN ie_dados_atualizar_util_w='N' THEN dt_atualizacao  ELSE clock_timestamp() END ,
			nm_usuario	= CASE WHEN ie_dados_atualizar_util_w='M' THEN nm_usuario_p  ELSE nm_usuario END
		where	nr_sequencia	= r_c02_w.nr_sequencia;

		qt_tot_utilizado_w := qt_tot_utilizado_w + r_c02_w.qt_utilizada;
		qt_tot_autorizado_w := qt_tot_autorizado_w + r_c02_w.qt_autorizada;
	end loop;
	commit;

	if (qt_tot_utilizado_w = 0) then
		ie_status_w	:= 'N';
	elsif (qt_tot_utilizado_w >= qt_tot_autorizado_w) then
		ie_status_w	:= 'U';
	else
		ie_status_w	:= 'P';
	end if;

	update	pls_guia_plano
	set	ie_utilizado	= ie_status_w,
		dt_atualizacao	= CASE WHEN ie_dados_atualizar_util_w='N' THEN dt_atualizacao  ELSE clock_timestamp() END ,
		nm_usuario	= CASE WHEN ie_dados_atualizar_util_w='M' THEN nm_usuario_p  ELSE nm_usuario END
	where	nr_sequencia	= r_c00_w.nr_seq_guia;

	commit;
end loop;

-- se for chamada em um processo de consistência da análise só precisa rodar uma vez.
-- por isso é que esse if é feito alimentando a variável de controle
if (ie_analise_p = 'S') then
	pls_util_cta_pck.ie_atualiza_util_guia_w := 'N';
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_atualizar_utilizacao_guia ( nr_seq_conta_p pls_conta.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, ie_analise_p text default 'N') FROM PUBLIC;

