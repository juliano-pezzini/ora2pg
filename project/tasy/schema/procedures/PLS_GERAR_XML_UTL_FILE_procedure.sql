-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_xml_utl_file ( nr_seq_projeto_p bigint, ds_parametros_p text, nm_arquivo_p text, cd_evento_p bigint) AS $body$
DECLARE


nr_seq_log_w        tasy_xml_banco.nr_sequencia%type;
ds_parametros_w     varchar(255);
ds_local_w          varchar(255) := null;
ds_erro_w           varchar(255);
arq_texto_w         utl_file.file_type;
----------------------------------------------------------------------------------------------------------
ds_xml_clob_w       text := '';
ds_xml_clob_aux_w   text;
texto_w             varchar(32767);

ds_xml_raw_w        bytea;
limit_raw_w         constant integer := 32767;
nr_seq_projeto_w    bigint;
ds_xml_blob_w       bytea;
limit_w             integer := 32767;
warning_w           integer;
lang_context_w      integer := dbms_lob.default_lang_ctx;
blob_offset_w       integer := 1;
offset_w            integer := 1;
ds_hash_w           varchar(32);
ds_sql_w            varchar(255);

file_exist_w        boolean;
size_w              bigint;
block_size_w        bigint;
cd_versao_tiss_w    varchar(255);


--Cursor do conteudo do XML
C02 CURSOR(nr_seq_log_pc   tasy_xml_banco.nr_sequencia%type) FOR
    SELECT  ds_xml
    from    tasy_xml_banco
    where   nr_sequencia = nr_seq_log_pc
    order by nr_seq_geracao;

--Curso do conteudo de valores do XML
C03 CURSOR(nr_seq_log_pc   tasy_valor_xml_banco.nr_sequencia%type) FOR
    SELECT  ds_valor_xml ds_xml
    from    tasy_valor_xml_banco
    where   nr_sequencia = nr_seq_log_pc
    order by nr_seq_geracao;
BEGIN

SELECT * FROM obter_evento_utl_file(cd_evento_p, null, ds_local_w, ds_erro_w) INTO STRICT ds_local_w, ds_erro_w;

--Obtem os dados do arquivo no diretorio
utl_file.fgetattr(ds_local_w,nm_arquivo_p,file_exist_w,size_w,block_size_w);

--Caso existir, remove ele para nao criar registros no arquivo ja criado
if (file_exist_w) then
    utl_file.fremove(ds_local_w,nm_arquivo_p);
end if;

--Cria a instancia do arquivo do UTL_FILE
begin
arq_texto_w := utl_file.fopen(ds_local_w,nm_arquivo_p,'WB');
exception
when others then
    if (SQLSTATE = -29289) then
        --O acesso ao arquivo foi negado pelo sistema operacional (access_denied).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302935);
    elsif (SQLSTATE = -29298) then
        --O arquivo foi aberto usando FOPEN_NCHAR,  mas efetuaram-se operacoes de I/O usando funcoes nonchar comos PUTF ou GET_LINE (charsetmismatch).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302936);
    elsif (SQLSTATE = -29291) then
        --Nao foi possivel apagar o arquivo (delete_failed).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302937);
    elsif (SQLSTATE = -29286) then
        --Erro interno desconhecido no package UTL_FILE (internal_error).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302938);
    elsif (SQLSTATE = -29282) then
        --O handle do arquivo nao existe (invalid_filehandle).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302939);
    elsif (SQLSTATE = -29288) then
        --O arquivo com o nome especificado nao foi encontrado neste local (invalid_filename).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302940);
    elsif (SQLSTATE = -29287) then
        --O valor de MAX_LINESIZE para FOPEN() e invalido; deveria estar na faixa de 1 a 32767 (invalid_maxlinesize).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302942);
    elsif (SQLSTATE = -29281) then
        --O parametro open_mode na chamda FOPEN e invalido (invalid_mode).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302943);
    elsif (SQLSTATE = -29290) then
        --O parametro ABSOLUTE_OFFSET para a chamada FSEEK() e invalido; deveria ser maior do que 0 e menor do que o numero total de bytes do arquivo (invalid_offset).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302944);
    elsif (SQLSTATE = -29283) then
        --O arquivo nao pode ser aberto ou operado da forma desejada - ou o caminho nao foi encontrado (invalid_operation).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302945);
    elsif (SQLSTATE = -29280) then
        --O caminho especificado nao existe ou nao esta visivel ao Oracle (invalid_path).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302946);
    elsif (SQLSTATE = -29284) then
        --Nao e possivel efetuar a leitura do arquivo (read_error).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302947);
    elsif (SQLSTATE = -29292) then
        --Nao e possivel renomear o arquivo.
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302948);
    elsif (SQLSTATE = -29285) then
        --Nao foi possivel gravar no arquivo (write_error).
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302950);
    else
        --Erro desconhecido no package UTL_FILE.
        CALL wheb_mensagem_pck.exibir_mensagem_abort(302951);
    end if;
end;

--Cria o LOG do XML, esse variavel sera usada para buscar os dados do arquivo XML nas tabelas  TASY_XML_BANCO e TASY_VALOR_XML_BANCO
select  nextval('tasy_xml_banco_seq')
into STRICT    nr_seq_log_w
;

--Monta os dados do arquivo XML
CALL wheb_exportar_xml(nr_seq_projeto_p,nr_seq_log_w,'MANS',ds_parametros_p);

--Instancia um BLOB
dbms_lob.createtemporary(ds_xml_blob_w, true, dbms_lob.session);
--Instancia um CLOB para o conteudo do XML
dbms_lob.createtemporary(ds_xml_clob_w, true, dbms_lob.session);
dbms_lob.open(ds_xml_clob_w, dbms_lob.lob_readwrite);

--Abre o cursor e armazena o conteudo no CLOB
for r_c02_w in C02(nr_seq_log_w) loop
    begin
    texto_w := r_c02_w.ds_xml;

    dbms_lob.append(ds_xml_clob_w, texto_w);

    end;
end loop;

--Instancia um CLOB para o conteudo de valores XML
dbms_lob.createtemporary(ds_xml_clob_aux_w, true, dbms_lob.session);
dbms_lob.open(ds_xml_clob_aux_w, dbms_lob.lob_readwrite);

--Abre o cursor e armazena o conteudo no CLOB
for r_c03_w in C03(nr_seq_log_w) loop
    begin
    texto_w := r_c03_w.ds_xml;

    dbms_lob.append(ds_xml_clob_aux_w, texto_w);

    end;
end loop;

--Nessa linha faz o calculo HASH com os dados de valor do XML
if (ds_xml_clob_aux_w IS NOT NULL AND ds_xml_clob_aux_w::text <> '') then
    --Utiliza o DBMS_CRYPTO para calcular o HASH, dbms_obfuscation_toolkit nao calcula corretamente
    ds_sql_w := 'begin ' ||
            ':ie_hash_w := lower(RAWTOHEX(DBMS_CRYPTO.hash(:ds_xml_clob_aux, dbms_crypto.hash_md5))); ' ||
            'end;';

    EXECUTE ds_sql_w using out ds_hash_w, ds_xml_clob_aux_w;

    dbms_lob.close(ds_xml_clob_aux_w);
    dbms_lob.freetemporary(ds_xml_clob_aux_w);

    --Coloca o HASH no CLOB do conteudo do ARQUIVO XML
    ds_xml_clob_w := replace(ds_xml_clob_w, 'GERAR_HASH_MD5', ds_hash_w);
end if;

--Faz a conversao de dados do CLOB para o BLOB, faz isso por abaixo tem que ser trabalhado com BLOB
dbms_lob.converttoblob(ds_xml_blob_w,ds_xml_clob_w,dbms_lob.lobmaxsize,blob_offset_w,blob_offset_w,dbms_lob.default_csid,lang_context_w,warning_w);

--Aqui copia os dados para um RAW a cada 32767, entao abre um LOOP quebrando o BLOB
loop
begin
    limit_w := limit_raw_w;
    --Aqui ele quebra o BLOB conforme o OFFSET
    dbms_lob.read(ds_xml_blob_w,limit_w,offset_w,ds_xml_raw_w);
    --Manda para o arquivo a instancia do RAW quebrado
    utl_file.put_raw(arq_texto_w, ds_xml_raw_w);
    utl_file.fflush(arq_texto_w);
exit when limit_w < limit_raw_w;
    --Aumenta o OFFSET a cada passagem, ou seja, comeca com 1 e depois vai aumentando para 32767 a cada passagem
    offset_w := offset_w + limit_raw_w;
exception
    when no_data_found
    then
    exit;
end;
end loop;

--Fecha o CLOB caso estiver aperto
if (dbms_lob.isopen(ds_xml_clob_w) > 0) then
    dbms_lob.close(ds_xml_clob_w);
end if;

--Libera na memoria o CLOB e BLOB
dbms_lob.freetemporary(ds_xml_clob_w);
dbms_lob.freetemporary(ds_xml_blob_w);
--Fecha e libera o arquivo do UTL_FILE
utl_file.fclose(arq_texto_w);

--Inicializa as variaveis de offset
offset_w    := 1;
blob_offset_w   := 1;
lang_context_w  := dbms_lob.default_lang_ctx;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_xml_utl_file ( nr_seq_projeto_p bigint, ds_parametros_p text, nm_arquivo_p text, cd_evento_p bigint) FROM PUBLIC;

