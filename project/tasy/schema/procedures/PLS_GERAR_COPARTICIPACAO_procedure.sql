-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_coparticipacao (( nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_segurado_p pls_segurado.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type, nr_seq_plano_p pls_plano.nr_sequencia%type, nr_seq_contrato_p pls_contrato.nr_sequencia%type, nr_seq_intercambio_p bigint, dt_contratacao_p timestamp, qt_idade_p bigint, ie_titularidade_p text, param_1_p text, nr_seq_disc_mat_p pls_discussao_mat.nr_sequencia%type, nr_seq_disc_proc_p pls_discussao_proc.nr_sequencia%type, nr_seq_conta_rec_p pls_rec_glosa_conta.nr_sequencia%type, ie_recurso_glosa_p text default 'N') is cd_procedimento_w bigint) RETURNS varchar AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Verifica se sera utilizado o valor de regra de preco ou pagamento do prestador,
	com base no tipo de valor
	
	Essa informacao e armazenada na coparticipacao oriunda da producao medica,
	para ser consumida de forma mais facil na geracao de coparticipacao para
	recurso de glosa.
	
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[  ]  Objetos do dicionario [ X] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
------------------------------------------------------------------------------------------------------------------

Pontos de atencao: 
Alteracaes:
------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
					
ds_retorno_w	pls_conta_pos_estabelecido.ie_vl_pag_prestador%type;

BEGIN
-- Verifica se a coparticipacao devera ter o valor calculado com base na regra de preco, ou entao com o valor de pagamento

-- e grava em uma coluna, para facilitar a geracao de coparticipacao de recurso de glosa.


-- Valor padrao anterior a alteracao
ds_retorno_w := 'S';
-- [1] - Regra de preco

-- [2] - Valor apresentado pelo prestador

-- [4] - Valor apresentado, caso Regra de preco seja 0

-- [6] - Regra de preco coparticipacao			
if (ie_tipo_valor_p in ('1', '2', '4', '6')) then
	
	ds_retorno_w := 'N';
-- [3] - Valor a ser pago ao prestador	
elsif (ie_tipo_valor_p = '3') then

	ds_retorno_w := 'S';

-- [5] - Valor a ser pago ao prestador, caso Regra de preco seja 0
elsif (ie_tipo_valor_p = '5') then

	-- se nao tiver regra de preco, vai ser usado o valor pago ao prestador
	if (coalesce(vl_proc_copartic_p,0) = 0) then
	
		ds_retorno_w := 'S';
	else
		ds_retorno_w := 'N';
	end if;

end if;

return ds_retorno_w;

end;


function retorna_vl_unit_copart_rec(	ie_tipo_valor_p		in pls_regra_preco_pos_estab.ie_tipo_valor%type,
					vl_padrao_p		in number,
					vl_proc_copartic_p	in number,
					vl_apresentado_p	in number,
					vl_liberado_p		in number) return number is
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Apura qual o tipo de valor sera utilizado conforme a regra
	
	Essa function nao teve a declaracao de parametros utilizando o % type, pois
	ela e consumida em proc e mat, onde os campos seriam diferentes
	
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[  ]  Objetos do dicionario [ X] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
------------------------------------------------------------------------------------------------------------------

Pontos de atencao: 
Alteracoes:
------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
	
ds_retorno_w	number(15,2);
begin

ds_retorno_w := vl_padrao_p;

-- [2] - Valor apresentado pelo prestador
if (ie_tipo_valor_p = '2') then

	ds_retorno_w	:= vl_apresentado_p;
-- [3] - Valor a ser pago ao prestador
elsif (ie_tipo_valor_p = '3') then

	ds_retorno_w	:= vl_liberado_p;
-- [4] - Valor apresentado, caso Regra de preco seja 0
elsif (ie_tipo_valor_p = '4') then

	if (vl_proc_copartic_p = 0) then
		ds_retorno_w	:= vl_apresentado_p;
	else
		ds_retorno_w	:= vl_proc_copartic_p;
	end if;
-- [5] - Valor a ser pago ao prestador, caso Regra de preco seja 0
elsif (ie_tipo_valor_p = '5') then

	if (vl_proc_copartic_p = 0) then
		ds_retorno_w	:= vl_liberado_p;
	else
		ds_retorno_w	:= vl_proc_copartic_p;
	end if;
-- [6] - Regra de preco coparticipacao
elsif (ie_tipo_valor_p = '6') then

	ds_retorno_w	:= vl_proc_copartic_p;
end if;

return ds_retorno_w;

end;
					

begin
/* Obter parametros da conta medica */

ie_restringe_estab_w	:= pls_obter_se_controle_estab('CO');

select	coalesce(max(ie_calculo_coparticipacao),'P'),
	coalesce(max(ie_gerar_copartic_zerado),'N'),
	coalesce(max(ie_data_base_coparticipacao),'C'),
	coalesce(max(ie_regra_contrato_copart),'N'),
	coalesce(max(ie_copartic_intercambio),'N')
into STRICT	ie_calculo_coparticipacao_w,
	ie_gerar_copartic_zerado_w,
	ie_data_base_coparticipacao_w,
	ie_regra_contrato_copart_w,
	ie_gerar_copart_int_w
from	pls_parametros
where	((ie_restringe_estab_w	= 'S' AND cd_estabelecimento	= cd_estabelecimento_p)
or (ie_restringe_estab_w	= 'N'));

ie_dependencia_w	:= pls_obter_garu_dependencia_seg(nr_seq_segurado_p,'C');

if (ie_dependencia_w = 'T') then
	ie_dependencia_w	:= '';
elsif (ie_dependencia_w = 'DL') then
	ie_dependencia_w	:= '1';
elsif (ie_dependencia_w = 'DA') then
	ie_dependencia_w	:= '2';
end if;

select	max(c.nr_seq_grau_partic)
into STRICT	nr_seq_grau_partic_w
from	pls_conta_proc b,
	pls_proc_participante c
where	c.nr_seq_conta_proc = b.nr_sequencia
and	b.nr_sequencia = nr_seq_conta_proc_p;
-- Obtem os dados da guia da conta
select	a.cd_guia,
	a.cd_guia_referencia,
	a.ie_tipo_guia,
	trunc(coalesce(a.dt_atendimento_referencia, coalesce(b.dt_mes_competencia,clock_timestamp())),'dd'),
	coalesce(a.nr_seq_clinica,0),
	a.nr_seq_prestador_exec,
	b.nr_seq_prestador,
	a.ie_origem_conta,
	coalesce(a.nr_seq_saida_int,0),
	a.nr_seq_guia,
	trunc(b.dt_mes_competencia,'Month'),
	a.ie_tipo_faturamento,
	coalesce(nr_seq_grau_partic_w,a.nr_seq_grau_partic),
	coalesce(b.ie_tipo_protocolo,'C'),
	b.nr_sequencia,
	a.nr_seq_conta_princ,
	a.nr_seq_prestador_solic_ref,
	a.cd_guia_ok,
	a.nr_seq_tipo_atendimento,
	a.ie_tipo_segurado,
	a.ie_carater_internacao,
	b.ie_apresentacao,
	a.dt_fechamento_conta,
	a.ie_regime_atendimento,
	a.ie_saude_ocupacional
into STRICT	cd_guia_w,
	cd_guia_referencia_w,
	ie_tipo_guia_w,
	dt_autorizacao_w,
	nr_seq_clinica_w,
	nr_seq_prestador_exec_w,
	nr_seq_prestador_w,
	ie_origem_conta_w,
	nr_seq_saida_int_w,
	nr_seq_guia_w,
	dt_mes_competencia_w,
	ie_tipo_faturamento_w,
	nr_seq_grau_partic_w,
	ie_tipo_protocolo_w,
	nr_seq_protocolo_w,
	nr_seq_conta_prin_w,
	nr_seq_prestador_solic_w,
	cd_guia_ok_w,
	nr_seq_tipo_atendimento_w,
	ie_tipo_segurado_w,
	ie_carater_internacao_w,
	ie_apresentacao_w,
	dt_fechamento_conta_w,
	ie_regime_atendimento_w,
	ie_saude_ocupacional_w
from	pls_protocolo_conta	b,
	pls_conta		a
where	a.nr_seq_protocolo	= b.nr_sequencia
and	a.nr_sequencia		= nr_seq_conta_p;

if (coalesce(ie_tipo_segurado_w::text, '') = '') then
	select	max(ie_tipo_segurado)
	into STRICT	ie_tipo_segurado_w
	from	pls_segurado
	where	nr_sequencia	= nr_seq_segurado_p;
end if;

select	max(nr_seq_tipo_prestador)
into STRICT	nr_seq_tipo_prestador_w
from	pls_prestador
where	nr_sequencia	= nr_seq_prestador_w;

begin
	select	CASE WHEN coalesce(cd_cgc::text, '') = '' THEN 'PF'  ELSE 'PJ' END
	into STRICT	ie_tipo_prestador_atend_w
	from	pls_prestador
	where	nr_sequencia	= nr_seq_prestador_w;
exception
when others then
	ie_tipo_prestador_atend_w	:= null;
end;

begin
	select	CASE WHEN coalesce(cd_cgc::text, '') = '' THEN 'PF'  ELSE 'PJ' END
	into STRICT	ie_tipo_prestador_exec_w
	from	pls_prestador
	where	nr_sequencia	= nr_seq_prestador_exec_w;
exception
when others then
	ie_tipo_prestador_exec_w	:= null;
end;

select	count(1)
into STRICT	qt_prestador_cooperado_w
from	pls_congenere	b,
	pls_prestador	a
where	a.cd_cgc	= b.cd_cgc
and	a.nr_sequencia	= nr_seq_prestador_exec_w  LIMIT 1;

if (nr_seq_conta_proc_p IS NOT NULL AND nr_seq_conta_proc_p::text <> '') then
	if (coalesce(ie_recurso_glosa_p,'N') = 'N') then
		-- Pega os valores liberados do procedimento
		select	cd_procedimento,
			ie_origem_proced,
			coalesce(vl_liberado,0),
			coalesce(qt_procedimento,0),
			coalesce(vl_unitario,0),
			coalesce(dt_procedimento_referencia,dt_autorizacao_w),
			coalesce(vl_proc_copartic,0),
			coalesce(vl_procedimento_imp,0),
			coalesce(qt_procedimento_imp,0),
			coalesce(nr_seq_regra,0),
			coalesce(vl_procedimento,0),
			coalesce(ie_tipo_despesa,'0'),
			coalesce(tx_intercambio,0),
			coalesce(nr_seq_regra_copartic,0),
			ie_status,
			ie_glosa,
			coalesce(ie_cobranca_prevista, 'N'),
			cd_grau_partic_imp,
			ie_ato_cooperado,
			dt_procedimento
		into STRICT	cd_procedimento_w,
			ie_origem_w,
			vl_liberado_w,
			qt_liberada_w,
			vl_unitario_w,
			dt_procedimento_w,
			vl_proc_copartic_w,
			vl_apresentado_w,
			qt_apresentada_liberada_w,
			nr_seq_regra_w,
			vl_item_w,
			ie_tipo_despesa_w,
			tx_intercambio_w,
			nr_seq_regra_copartic_ww,
			ie_status_w,
			ie_glosa_w,
			ie_cobranca_prevista_w,
			cd_ptu_w,
			ie_ato_cooperado_w,
			dt_base_item_w
		from	pls_conta_proc
		where	nr_sequencia	= nr_seq_conta_proc_p;
	elsif (ie_recurso_glosa_p = 'S') then
	
		select	max(nr_sequencia)
		into STRICT	nr_seq_rec_glosa_proc_w
		from	pls_rec_glosa_proc
		where	nr_seq_conta_proc	= nr_seq_conta_proc_p
		and	nr_seq_conta_rec	= nr_seq_conta_rec_p;	
	
		select	a.cd_procedimento,
			a.ie_origem_proced,
			coalesce(b.vl_acatado,0),
			coalesce(a.qt_procedimento,0),
			coalesce(a.vl_unitario,0),
			coalesce(a.dt_procedimento_referencia,dt_autorizacao_w),
			coalesce(a.vl_proc_copartic,0),
			coalesce(b.vl_recursado,0),
			coalesce(a.qt_procedimento_imp,0),
			coalesce(a.nr_seq_regra,0),
			coalesce(a.vl_procedimento,0),
			coalesce(a.ie_tipo_despesa,'0'),
			coalesce(a.tx_intercambio,0),
			coalesce(a.nr_seq_regra_copartic,0),
			a.ie_status,
			a.ie_glosa,
			coalesce(a.ie_cobranca_prevista, 'N'),
			a.cd_grau_partic_imp,
			a.ie_ato_cooperado,
			b.nr_sequencia,
			a.dt_procedimento,
			(coalesce(a.qt_procedimento_imp,0) - coalesce(a.qt_procedimento,0)) qt_saldo
		into STRICT	cd_procedimento_w,
			ie_origem_w,
			vl_liberado_w,
			qt_liberada_w,
			vl_unitario_w,
			dt_procedimento_w,
			vl_proc_copartic_w,
			vl_apresentado_w,
			qt_apresentada_liberada_w,
			nr_seq_regra_w,
			vl_item_w,
			ie_tipo_despesa_w,
			tx_intercambio_w,
			nr_seq_regra_copartic_ww,
			ie_status_w,
			ie_glosa_w,
			ie_cobranca_prevista_w,
			cd_ptu_w,
			ie_ato_cooperado_w,
			nr_seq_conta_proc_w,
			dt_base_item_w,
			qt_saldo_proc_rec_w
		from	pls_conta_proc a,
			pls_rec_glosa_proc b
		where	b.nr_sequencia		= nr_seq_rec_glosa_proc_w
		and	a.nr_sequencia 		= b.nr_seq_conta_proc
		and	b.nr_seq_conta_rec	= nr_seq_conta_rec_p;	
	end if;
	
	if (nr_seq_disc_proc_p IS NOT NULL AND nr_seq_disc_proc_p::text <> '') then
	
		select	coalesce(qt_reconh_orig,0),
			coalesce(qt_aceita,0)
		into STRICT	qt_reconh_orig_w,
			qt_aceita_w
		from	pls_discussao_proc
		where	nr_sequencia = nr_seq_disc_proc_p;
		
		qt_liberada_w	:= qt_aceita_w - qt_reconh_orig_w;
		
		if (qt_liberada_w	< 0) then
			qt_liberada_w	:= 0;
		end if;
	end if;
	
	if (ie_data_base_coparticipacao_w = 'I') then
		dt_autorizacao_w	:= coalesce(dt_procedimento_w, clock_timestamp());
	end if;
	
	if (cd_ptu_w IS NOT NULL AND cd_ptu_w::text <> '') then
		select	coalesce(max(nr_sequencia),nr_seq_grau_partic_w)
		into STRICT	nr_seq_grau_partic_w
		from	pls_grau_participacao
		where	cd_ptu = cd_ptu_w;
	end if;
	
	dt_coparticipacao_w	:= coalesce(dt_autorizacao_w,pls_obter_data_preco_item(nr_seq_conta_proc_p, 'P'));	
	
	if (ie_recurso_glosa_p = 'S') then
		qt_liberada_w := qt_apresentada_liberada_w - qt_liberada_w;
		
		if (qt_liberada_w <= 0) then
			qt_liberada_w := 1;
		end if;
	end if;
	
	if (ie_calculo_coparticipacao_w	= 'R') then
		if (qt_liberada_w = 0) then
			qt_liberada_w := qt_apresentada_liberada_w;
		end if;
		
		if (ie_recurso_glosa_p = 'S') then
		
			vl_unitario_w := vl_liberado_w;
			
			select	max(nr_seq_regra_preco_copart),
				coalesce(max(ie_vl_pag_prestador), 'S')
			into STRICT	nr_seq_regra_copartic_w,
				ie_vl_pag_prestador_w
			from	pls_conta_coparticipacao
			where	nr_seq_conta_proc = nr_seq_conta_proc_p
			and	coalesce(nr_seq_conta_rec::text, '') = '';
			
			-- Para o recurso de glosa, ainda e avaliado se sera necessario gerar a coparticipacao.

			-- Inicialmente sera levantado se a coparticipacao original foi gerada utilizando a tabela de preco propria ou o valor de fato pago ao prestador.

			-- Se for utilizado a tabela de preco, e verificado se o saldo (quantidade apresentada - quantidade liberada) for menor ou igual a zero, nao devera gerar a coparticipaco, 

			-- entendendo que o recurso foi sobre o valor de um procedimento, e a coparticipacao por tabela de preco ja cobrou tudo o que deveria.

			-- Se o saldo for igual ou superior a 1, sera entendido que a quantidade foi glosada e recursada, portanto devera gerar a coparticipacao

			-- Quando for identificado que foi utilizado o pagamento ao prestador, entao devera gerar a coparticipacao
			
			if	((ie_vl_pag_prestador_w = 'S') or
				 ((ie_vl_pag_prestador_w = 'N') and (coalesce(qt_saldo_proc_rec_w, 0) > 0))) then
				
				-- se for pagamento sobre o valor, ou entao tabela de preco onde teve saldo, indicando glosa de quantidade, entao marca para gerar
				ie_gerar_copart_rec_w := 'S';
			else
				
				ie_gerar_copart_rec_w := 'N';
			end if;
			
			
			if (coalesce(nr_seq_regra_copartic_w::text, '') = '') then
				if (vl_liberado_w > 0) then
					ie_glosa_w := 'N';
				end if;
				
				SELECT * FROM pls_obter_tipo_valor_copartic(	nr_seq_segurado_p, dt_procedimento_w, nm_usuario_p, ie_tipo_despesa_w, ie_origem_conta_w, ie_glosa_w, ie_tipo_protocolo_w, nr_seq_conta_p, nr_seq_prestador_exec_w, nr_seq_prestador_solic_w, nr_seq_clinica_w, ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w) INTO STRICT ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w;
			
			-- se ja existe uma regra vinculada a coparticipacao anterior, vai buscar o ie_tipo_valor_w dela
			else			
			
				select	max(a.ie_tipo_valor)
				into STRICT	ie_tipo_valor_w
				from	pls_regra_preco_copartic	a
				where	a.nr_sequencia			= nr_seq_regra_copartic_w;
			
			end if;
			
			-- Apenas aplica o calculo do valor unitario, se identificou que deve gerar a coparticipacao ou nao.
			if (ie_gerar_copart_rec_w = 'S') then
			
				vl_unitario_w := retorna_vl_unit_copart_rec(	ie_tipo_valor_w,
										vl_liberado_w,
										vl_proc_copartic_w,
										vl_apresentado_w,
										vl_liberado_w);
				
				-- Como no recurso de glosa, o TISS nao possui a informacao de quantidade glosada, apenas o valor,

				-- entao e presumido que sera recursado a quantidade 1, portanto o vl_liberado recebe o unitario ja tratado
				vl_liberado_w := vl_unitario_w;
				
			end if;
			
			
		else
			SELECT * FROM pls_obter_tipo_valor_copartic(	nr_seq_segurado_p, dt_procedimento_w, nm_usuario_p, ie_tipo_despesa_w, ie_origem_conta_w, ie_glosa_w, ie_tipo_protocolo_w, nr_seq_conta_p, nr_seq_prestador_exec_w, nr_seq_prestador_solic_w, nr_seq_clinica_w, ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w) INTO STRICT ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w;
			
			-- Levanta se sera utilizado o valor de regra de preco ou valor pago ao prestador, com base no tipo de valor

			-- foi criado uma function porque e a mesma regra para os materiais, evitando duplicidade de codigo
			ie_vl_pag_prestador_w := ie_vl_pag_prest(ie_tipo_valor_w, vl_proc_copartic_w);
			
			
			if (ie_tipo_valor_w = '2') then
				vl_unitario_w	:= dividir(vl_apresentado_w,qt_apresentada_liberada_w);
				vl_liberado_w	:= vl_apresentado_w;
			elsif (ie_tipo_valor_w = '3') then
				if (vl_liberado_w > 0) then
					vl_unitario_w	:= dividir(vl_liberado_w,qt_liberada_w);
					vl_liberado_w	:= vl_liberado_w;
				else
					vl_unitario_w	:= dividir( vl_item_w ,qt_liberada_w);
					vl_liberado_w	:= vl_item_w;
				end if;
			elsif (ie_tipo_valor_w = '4') and (vl_proc_copartic_w = 0) then
				vl_unitario_w	:= dividir(vl_apresentado_w,qt_apresentada_liberada_w);
				vl_liberado_w	:= vl_apresentado_w;
			elsif (ie_tipo_valor_w = '4') and (vl_proc_copartic_w <> 0) then
			
				if (ie_tipo_despesa_w in (2,3)) then
					vl_unitario_w	:= dividir(vl_proc_copartic_w, qt_liberada_w);
					vl_liberado_w	:= vl_proc_copartic_w;
				else
					vl_unitario_w	:= vl_proc_copartic_w;
					vl_liberado_w	:= vl_proc_copartic_w * qt_liberada_w;
				end if;
				
			elsif (ie_tipo_valor_w = '5') and (vl_proc_copartic_w = 0) then
				if (vl_liberado_w > 0) then
					vl_unitario_w	:= dividir(vl_liberado_w,qt_liberada_w);
					vl_liberado_w	:= vl_liberado_w;
				else
					vl_unitario_w	:= dividir(vl_item_w,qt_liberada_w);
					vl_liberado_w	:= vl_item_w;
				end if;
			elsif (ie_tipo_valor_w = '5') and (vl_proc_copartic_w <> 0) then
			
				if (ie_tipo_despesa_w in (2,3)) then
					vl_unitario_w	:= dividir(vl_proc_copartic_w, qt_liberada_w);
					vl_liberado_w	:= vl_proc_copartic_w;
				else
					vl_unitario_w	:= vl_proc_copartic_w;
					vl_liberado_w	:= vl_proc_copartic_w * qt_liberada_w;
				end if;
				
			elsif (ie_tipo_valor_w = '6') then
				if (ie_tipo_despesa_w in (2,3)) then
					vl_unitario_w	:= dividir(vl_proc_copartic_w, qt_liberada_w);
					vl_liberado_w	:= vl_proc_copartic_w;
				else
					vl_unitario_w	:= vl_proc_copartic_w;
					vl_liberado_w	:= vl_proc_copartic_w * qt_liberada_w;
				end if;
			end if;
		end if;
		
	elsif (ie_calculo_coparticipacao_w = 'O') then
	
		ie_vl_pag_prestador_w := 'N';
		
		if (ie_recurso_glosa_p = 'S') then
			vl_liberado_w := vl_liberado_w;
			vl_unitario_w := vl_liberado_w;
		else
			--Se for servico, entao o vl_proc_copartic da pls_conta_proc e multiplicado pela quantidade(Atualiza_valor_servico))
			if (ie_tipo_despesa_w in (2,3) ) then
				vl_unitario_w	:= dividir(vl_proc_copartic_w, qt_liberada_w);
				vl_liberado_w	:= vl_proc_copartic_w;
			else
				vl_unitario_w	:= vl_proc_copartic_w;
				vl_liberado_w	:= vl_proc_copartic_w * qt_liberada_w;
			end if;
		end if;
		
	elsif (ie_calculo_coparticipacao_w = 'P') then
	
		ie_vl_pag_prestador_w := 'S';
		
		if (coalesce(ie_recurso_glosa_p, 'N') = 'S') then
		
			vl_unitario_w := vl_liberado_w;
		end if;
	end if;
	
	-- Retrorna o cd_area, cd_especialidade, cd_grupo, ie_origem do proceimento 
	SELECT * FROM pls_obter_estrut_proc(cd_procedimento_w, ie_origem_w, cd_area_w, cd_especialidade_w, cd_grupo_w, ie_origem_proced_w) INTO STRICT cd_area_w, cd_especialidade_w, cd_grupo_w, ie_origem_proced_w;
elsif (nr_seq_conta_mat_p <> 0) then
	if (coalesce(ie_recurso_glosa_p,'N') = 'N') then
		select	nr_seq_material,
			coalesce(vl_liberado,0),
			coalesce(qt_material,0),
			coalesce(vl_unitario,0),
			coalesce(dt_atendimento_referencia,dt_autorizacao_w),
			coalesce(vl_mat_copartic,0),
			coalesce(vl_material_imp,0),
			coalesce(qt_material_imp,0),
			coalesce(nr_seq_regra,0),
			coalesce(vl_material,0),
			coalesce(tx_intercambio,0),
			coalesce(nr_seq_regra_copartic,0),
			ie_status,
			ie_glosa,
			coalesce(ie_cobranca_previa_servico, 'N'),
			ie_ato_cooperado,
			dt_atendimento
		into STRICT	nr_seq_material_w,
			vl_liberado_w,
			qt_liberada_w,
			vl_unitario_w,
			dt_atendimento_w,
			vl_mat_copartic_w,
			vl_apresentado_w,
			qt_apresentada_liberada_w,
			nr_seq_regra_w,
			vl_item_w,
			tx_intercambio_w,
			nr_seq_regra_copartic_ww,
			ie_status_w,
			ie_glosa_w,
			ie_cobranca_prevista_w,
			ie_ato_cooperado_w,
			dt_base_item_w
		from	pls_conta_mat
		where	nr_sequencia	= nr_seq_conta_mat_p;
	elsif (ie_recurso_glosa_p = 'S') then
	
		select	max(nr_sequencia)
		into STRICT	nr_seq_rec_glosa_mat_w
		from	pls_rec_glosa_mat
		where	nr_seq_conta_mat	= nr_seq_conta_mat_p
		and	nr_seq_conta_rec	= nr_seq_conta_rec_p;
	
		select	a.nr_seq_material,
			coalesce(b.vl_acatado,0),
			coalesce(a.qt_material,0),
			coalesce(a.vl_unitario,0),
			coalesce(a.dt_atendimento_referencia,dt_autorizacao_w),
			coalesce(a.vl_mat_copartic,0),
			coalesce(a.vl_material_imp,0),
			coalesce(a.qt_material_imp,0),
			coalesce(a.nr_seq_regra,0),
			coalesce(a.vl_material,0),
			coalesce(a.tx_intercambio,0),
			coalesce(a.nr_seq_regra_copartic,0),
			a.ie_status,
			a.ie_glosa,
			coalesce(a.ie_cobranca_previa_servico, 'N'),
			a.ie_ato_cooperado,
			b.nr_sequencia,
			a.dt_atendimento,
			(coalesce(qt_material_imp, 0) - coalesce(qt_material,0)) qt_saldo
		into STRICT	nr_seq_material_w,
			vl_liberado_w,
			qt_liberada_w,
			vl_unitario_w,
			dt_atendimento_w,
			vl_mat_copartic_w,
			vl_apresentado_w,
			qt_apresentada_liberada_w,
			nr_seq_regra_w,
			vl_item_w,
			tx_intercambio_w,
			nr_seq_regra_copartic_ww,
			ie_status_w,
			ie_glosa_w,
			ie_cobranca_prevista_w,
			ie_ato_cooperado_w,
			nr_seq_conta_mat_w,
			dt_base_item_w,
			qt_saldo_mat_rec_w
		from	pls_conta_mat a,
			pls_rec_glosa_mat b
		where	b.nr_sequencia		= nr_seq_rec_glosa_mat_w
		and	a.nr_sequencia 		= b.nr_seq_conta_mat
		and	b.nr_seq_conta_rec	= nr_seq_conta_rec_p;
	end if;
	
	if (ie_data_base_coparticipacao_w = 'I') then
		dt_autorizacao_w := coalesce(dt_atendimento_w,clock_timestamp());
	end if;
	
	dt_coparticipacao_w	:= coalesce(dt_autorizacao_w,coalesce(dt_atendimento_w, clock_timestamp()));
	
	if (nr_seq_disc_mat_p IS NOT NULL AND nr_seq_disc_mat_p::text <> '') then
	
		select	coalesce(qt_reconh_orig,0),
			coalesce(qt_aceita,0)
		into STRICT	qt_reconh_orig_w,
			qt_aceita_w
		from	pls_discussao_mat
		where	nr_sequencia = nr_seq_disc_mat_p;
		
		qt_liberada_w	:= qt_aceita_w - qt_reconh_orig_w;
		
		if (qt_liberada_w	< 0) then
			qt_liberada_w	:= 0;
		end if;
	end if;
	
	if (qt_liberada_w = 0) and (coalesce(ie_glosa_w,'N') = 'N')then
		qt_liberada_w	:= qt_apresentada_liberada_w;
	end if;
	
	if (ie_recurso_glosa_p = 'S') then
		qt_liberada_w := qt_apresentada_liberada_w - qt_liberada_w;
		
		if (qt_liberada_w <= 0) then
			qt_liberada_w := 1;
		end if;
	end if;
	
	if ( ie_calculo_coparticipacao_w	= 'R') then
		if (qt_liberada_w = 0) then
			qt_liberada_w := qt_apresentada_liberada_w;
		end if;
		
		if (ie_recurso_glosa_p = 'S') then
			vl_unitario_w := vl_liberado_w;
			
			select	max(nr_seq_regra_preco_copart),
				coalesce(max(ie_vl_pag_prestador),'S')
			into STRICT	nr_seq_regra_copartic_w,
				ie_vl_pag_prestador_w
			from	pls_conta_coparticipacao
			where	nr_seq_conta_mat = nr_seq_conta_mat_p
			and	coalesce(nr_seq_conta_rec::text, '') = '';
			
			-- Para o recurso de glosa, ainda e avaliado se sera necessario gerar a coparticipacao.

			-- Inicialmente sera levantado se a coparticipacao original foi gerada utilizando a tabela de preco propria ou o valor de fato pago ao prestador.

			-- Se for utilizado a tabela de preco, e verificado se o saldo (quantidade apresentada - quantidade liberada) for menor ou igual a zero, nao devera gerar a coparticipacao, 

			-- entendendo que o recurso foi sobre o valor de um procedimento, e a coparticipacao por tabela de preco ja cobrou tudo o que deveria.

			-- Se o saldo for igual ou superior a 1, sera entendido que a quantidade foi glosada e recursada, portanto devera gerar a coparticipacao

			-- Quando for identificado que foi utilizado o pagamento ao prestador, entao devera gerar a coparticipacao
			
			if	((ie_vl_pag_prestador_w = 'S') or
				 ((ie_vl_pag_prestador_w = 'N') and (coalesce(qt_saldo_mat_rec_w, 0) > 0))) then
				
				-- se for pagamento sobre o valor, ou entao tabela de preco onde teve saldo, indicando glosa de quantidade, entao marca para gerar
				ie_gerar_copart_rec_w := 'S';
			else
				
				ie_gerar_copart_rec_w := 'N';
			end if;
			
			if (coalesce(nr_seq_regra_copartic_w::text, '') = '') then
				if (vl_liberado_w > 0) then
					ie_glosa_w := 'N';
				end if;
				
				SELECT * FROM pls_obter_tipo_valor_copartic(	nr_seq_segurado_p, dt_coparticipacao_w, nm_usuario_p, '0', ie_origem_conta_w, ie_glosa_w, ie_tipo_protocolo_w, nr_seq_conta_p, nr_seq_prestador_exec_w, nr_seq_prestador_solic_w, nr_seq_clinica_w, ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w) INTO STRICT ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w;
			-- se ja possui uma regra, busca o ie_tipo_valor_w dela
			else
			
				select	max(a.ie_tipo_valor)
				into STRICT	ie_tipo_valor_w
				from	pls_regra_preco_copartic	a
				where	a.nr_sequencia			= nr_seq_regra_copartic_w;			
			end if;
			
			
			
			-- Apenas aplica o calculo do valor unitario, se identificou que deve gerar a coparticipaco ou nao.
			if (ie_gerar_copart_rec_w = 'S') then
			
				vl_unitario_w := retorna_vl_unit_copart_rec(	ie_tipo_valor_w,
										vl_liberado_w,
										vl_proc_copartic_w,
										vl_apresentado_w,
										vl_liberado_w);
										
				-- Como no recurso de glosa, o TISS nao possui a informacao de quantidade glosada, apenas o valor,

				-- entao e presumido que sera recursado a quantidade 1, portanto o vl_liberado recebe o unitario ja tratado
				vl_liberado_w := vl_unitario_w;
				
			end if;
		else
			SELECT * FROM pls_obter_tipo_valor_copartic(	nr_seq_segurado_p, dt_coparticipacao_w, nm_usuario_p, '0', ie_origem_conta_w, ie_glosa_w, ie_tipo_protocolo_w, nr_seq_conta_p, nr_seq_prestador_exec_w, nr_seq_prestador_solic_w, nr_seq_clinica_w, ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w) INTO STRICT ie_tipo_valor_w, nr_seq_regra_copartic_w, ie_multi_internacao_w;
							
			-- Levanta se sera utilizado o valor de regra de preco ou valor pago ao prestador, com base no tipo de valor

			-- foi criado uma function porque e a mesma regra para os procedimentos, evitando duplicidade de codigo
			ie_vl_pag_prestador_w := ie_vl_pag_prest(ie_tipo_valor_w, vl_proc_copartic_w);
			
			if (ie_tipo_valor_w = '2') then
				vl_unitario_w	:= dividir(vl_apresentado_w ,qt_apresentada_liberada_w);
				vl_liberado_w	:= vl_apresentado_w;
			elsif (ie_tipo_valor_w = '3') then
				if (vl_liberado_w > 0) then
					vl_unitario_w	:= dividir(vl_liberado_w,qt_liberada_w);
					vl_liberado_w	:= vl_liberado_w;
				else
					vl_unitario_w	:= dividir(vl_item_w,qt_liberada_w);
					vl_liberado_w	:= vl_item_w;
				end if;
			elsif (ie_tipo_valor_w = '4') and (nr_seq_regra_copartic_ww = 0) then
				vl_unitario_w	:= dividir(vl_apresentado_w,qt_apresentada_liberada_w);
				vl_liberado_w	:= vl_apresentado_w;
			elsif (ie_tipo_valor_w = '4') and (nr_seq_regra_copartic_ww <> 0) then
				vl_unitario_w	:= vl_mat_copartic_w;
				vl_liberado_w	:= vl_mat_copartic_w * qt_liberada_w;
			elsif (ie_tipo_valor_w = '5') and (nr_seq_regra_copartic_ww = 0) then
				if (vl_liberado_w > 0) then
					vl_unitario_w	:= dividir(vl_liberado_w,qt_liberada_w);
					vl_liberado_w	:= vl_liberado_w;
				else
					vl_unitario_w	:= dividir(vl_item_w,qt_liberada_w);
					vl_liberado_w	:= vl_item_w;
				end if;
			elsif (ie_tipo_valor_w = '5') and (nr_seq_regra_copartic_ww <> 0) then
				vl_unitario_w	:= vl_mat_copartic_w;
				vl_liberado_w	:= vl_mat_copartic_w * qt_liberada_w;
			elsif (ie_tipo_valor_w = '6') then
				vl_unitario_w	:= vl_mat_copartic_w;
				vl_liberado_w	:= vl_mat_copartic_w * qt_liberada_w;
			end if;
		end if;
	elsif (ie_calculo_coparticipacao_w = 'O') then
	
		ie_vl_pag_prestador_w := 'N';
		
		if (ie_recurso_glosa_p = 'S') then
			vl_liberado_w := vl_liberado_w;
			vl_unitario_w := vl_liberado_w;
		else
			vl_unitario_w	:= vl_mat_copartic_w;
			vl_liberado_w	:= vl_mat_copartic_w * qt_liberada_w;
		end if;
		
	elsif (ie_calculo_coparticipacao_w = 'P') then
	
		ie_vl_pag_prestador_w := 'S';
		
		if (coalesce(ie_recurso_glosa_p, 'N') = 'S') then
		
			vl_unitario_w := vl_liberado_w;
		end if;
	end if;
	
	select	max(nr_seq_estrut_mat),
		max(ie_tipo_despesa)
	into STRICT	nr_seq_estrutura_mat_w,
		ie_tipo_despesa_w
	from	pls_material
	where	nr_sequencia = nr_seq_material_w;
end if;

select	max(b.ie_cobrar_copartic)
into STRICT	ie_cobrar_copartic_w
from	pls_execucao_req_item	a,
	pls_requisicao		b
where	a.nr_seq_requisicao	= b.nr_sequencia
and	a.nr_seq_guia		= nr_seq_guia_w;

SELECT * FROM pls_consis_item_copart_liminar(nr_seq_conta_proc_p, nr_seq_conta_mat_p, nr_seq_segurado_p, dt_coparticipacao_w, ie_valor_zerado_w, nr_seq_processo_copartic_w) INTO STRICT ie_valor_zerado_w, nr_seq_processo_copartic_w;

if (coalesce(ie_cobrar_copartic_w,'S') = 'N') or (coalesce(ie_valor_zerado_w, 'N') = 'S') or (coalesce(ie_cobranca_prevista_w, 'N') = 'S') then
	ie_status_coparticipacao_w	:= 'N';
	ie_status_mensalidade_w		:= 'C'; --Quando na requisicao estiver definido que nao deve cobrar a coparticipacao, o status deve ser "Cobranca cancelada"
else
	select	max(ie_controle_coparticipacao)
	into STRICT	ie_controle_coparticipacao_w
	from	pls_parametros
	where	cd_estabelecimento	= cd_estabelecimento_p;
	ie_controle_coparticipacao_w	:= coalesce(ie_controle_coparticipacao_w,'N');
	
	if (ie_controle_coparticipacao_w = 'S') then
		ie_status_mensalidade_w := 'P'; -- Caso o parametro seja 'S', somente pode mudar o status para "L" na funcao OPS - Controle de Coparticipacaes
	else
		if (ie_status_w in ('L','S','M')) then
			ie_status_mensalidade_w := 'L';
		else
			ie_status_mensalidade_w := 'P';
		end if;
	end if;
end if;

/*aaschlote 31/05/2012 - Tratar essa rotina aqui pois vera dos materiais e dos servicaos*/

select	max(b.ie_utilizar_fecham_conta)
into STRICT	ie_utilizar_fecham_conta_w
from	pls_segurado		a,
	pls_contrato		b
where	a.nr_seq_contrato	= b.nr_sequencia
and	a.nr_sequencia		= nr_seq_segurado_p;

-- prioriza o fechamento da conta;
if (coalesce(ie_utilizar_fecham_conta_w, 'N') = 'S') then

	ie_cobrar_pos_estab_w := pls_obter_se_pos_estab(nr_seq_segurado_p, cd_estabelecimento_p, coalesce(dt_fechamento_conta_w, coalesce(dt_base_item_w, dt_coparticipacao_w)));
else

	ie_cobrar_pos_estab_w := pls_obter_se_pos_estab(nr_seq_segurado_p, cd_estabelecimento_p, coalesce(dt_base_item_w, dt_coparticipacao_w));
end if;

--Parametro Aplicar taxa de intercambio sobre coparticipacao da OPS - Gestao de Operadoras\Parametros da OPS\Contas medicas

--OS 792956
select	max(ie_cobra_tx_inter_copartic)
into STRICT	ie_cobra_tx_inter_copartic_w
from	table(pls_parametros_pck.f_retorna_param(cd_estabelecimento_p));

if (coalesce(ie_cobra_tx_inter_copartic_w::text, '') = '' or ie_cobra_tx_inter_copartic_w = 'S') then

	/*aaschlote 23/05/2012 OS - 441778 - Caso possuir taxa de intercambio entao incrementa no valor de cooparticipacao*/

	if (coalesce(tx_intercambio_w,0) <> 0) and
		not((ie_calculo_coparticipacao_w	= 'R') and
		    ((ie_tipo_valor_w = '3') or
		    (ie_tipo_valor_w = '5' AND nr_seq_regra_copartic_ww = 0)))then
		vl_unitario_w	:= vl_unitario_w + ((coalesce(vl_unitario_w,0) * tx_intercambio_w) / 100);
		vl_liberado_w	:= vl_liberado_w + ((coalesce(vl_liberado_w,0) * tx_intercambio_w) / 100);
	end if;
end if;

-- Pega o plano e contrato do segurado que e parametro
nr_seq_plano_w		:= nr_seq_plano_p;
nr_seq_contrato_w	:= nr_seq_contrato_p;
nr_seq_intercambio_w	:= nr_seq_intercambio_p;
dt_contratacao_w	:= dt_contratacao_p;
qt_idade_w		:= qt_idade_p;
ie_titularidade_w	:= ie_titularidade_p;

if (coalesce(nr_seq_plano_w, 0) = 0) and (coalesce(qt_idade_w, 0) = 0) then
	begin
	--select	nr_seq_plano,
	select	pls_obter_produto_benef(nr_sequencia,dt_contratacao_p),
		nr_seq_contrato,
		nr_seq_intercambio,
		dt_contratacao,
		obter_idade_pf(cd_pessoa_fisica,clock_timestamp(),'A'),
		CASE WHEN coalesce(nr_seq_titular::text, '') = '' THEN 'T'  ELSE 'D' END
	into STRICT	nr_seq_plano_w,
		nr_seq_contrato_w,
		nr_seq_intercambio_w,
		dt_contratacao_w,
		qt_idade_w,
		ie_titularidade_w
	from	pls_segurado
	where	nr_sequencia	= nr_seq_segurado_p;
	exception
	when others then
		nr_seq_contrato_w	:= 0;
		nr_seq_intercambio_w	:= 0;
		nr_seq_plano_w		:= 0;
	end;
end if;

if (coalesce(qt_idade_w::text, '') = '') then
	qt_idade_w	:= 0;
end if;

-- Verifica se e migracao de contrato
select	count(1)
into STRICT	qt_historicos_w
from	pls_segurado_historico
where	nr_seq_segurado		= nr_seq_segurado_p
and	ie_tipo_historico	= '5' -- Migracao entre contratos
  LIMIT 1;

-- Pega a data de contratacao do contrato passado como parametro
select	max(dt_contrato),
	max(dt_reajuste)
into STRICT	dt_contratos_w,
	dt_reajuste_w
from	pls_contrato
where	nr_sequencia	= nr_seq_contrato_w;

-- Pega a data de contratacao do contrato de intercambio passado como parametro
select	max(dt_inclusao)
into STRICT	dt_intercambio_w
from	pls_intercambio
where	nr_sequencia	= nr_seq_intercambio_w;

dt_contrato_w	:= coalesce(dt_contratos_w,dt_intercambio_w);
dt_reajuste_w	:= coalesce(dt_reajuste_w,dt_contrato_w);

-- Caso for migracao entre contratos
if (qt_historicos_w <> 0) then
	-- caso o procedimento se realizou antes da data de contratacao
	if (dt_procedimento_w < dt_contrato_w) then
		select	coalesce(max(nr_sequencia),0)
		into STRICT	nr_seq_historico_w
		from	pls_segurado_historico
		where	nr_seq_segurado	= nr_seq_segurado_p
		and	dt_historico =	(SELECT	max(dt_historico)
					from	pls_segurado_historico
					where	dt_procedimento_w	<= dt_historico
					and	nr_seq_segurado	= nr_seq_segurado_p);
		
		-- Seleciona os dados do contrato anterior caso este exista
		if (nr_seq_historico_w > 0) then
			select	coalesce(nr_seq_plano_ant,0),
				coalesce(nr_seq_contrato_ant,0)
			into STRICT	nr_seq_plano_ant_w,
				nr_seq_contrato_ant_w
			from	pls_segurado_historico
			where	nr_sequencia	= nr_seq_historico_w;
		end if;
		
		if (nr_seq_contrato_ant_w > 0) then
			select	trunc(dt_contrato,'dd')
			into STRICT	dt_contrato_ant_w
			from	pls_contrato
			where	nr_sequencia = nr_seq_contrato_ant_w;
			
			begin
			select	trunc(dt_inclusao,'dd')
			into STRICT	dt_contrato_ant_interc_w
			from	pls_intercambio
			where	nr_sequencia = nr_seq_contrato_ant_w;
			exception
			when others then
				dt_contrato_ant_interc_w	:= clock_timestamp();
			end;
			
			if (dt_contrato_ant_w <= dt_procedimento_w) then
				nr_seq_contrato_w := nr_seq_contrato_ant_w;
				if (nr_seq_plano_ant_w > 0) then
					nr_seq_plano_w := nr_seq_plano_ant_w;
				end if;
			elsif (dt_contrato_ant_interc_w <= dt_procedimento_w) then
				nr_seq_intercambio_w := nr_seq_contrato_ant_w;
				if (nr_seq_plano_ant_w > 0) then
					nr_seq_plano_w := nr_seq_plano_ant_w;
				end if;
			end if;
		end if;
	end if;
end if;

select	max(ie_preco)
into STRICT	ie_preco_w
from	pls_plano
where	nr_sequencia	= nr_seq_plano_w;



if (ie_tipo_protocolo_w	= 'C') and (ie_multi_internacao_w = 'N') then
	ie_gerar_copartic_w :=	pls_obter_se_copartic(cd_guia_ok_w, nr_seq_segurado_p, nr_seq_conta_proc_p, nr_seq_conta_mat_p);
else
	ie_gerar_copartic_w	:= 'N';
end if;	

-- Caso a geracao de coparticipacao seja por regra e nao encontrou regra valida

-- nao permite continuar, pois em alguns casos, devido a regras de valor fixo

-- estava gerando coparticipacao para itens glosados.

-- atribuimos o valor 'S' e variavel ie_gerar_copartic_w pq era a logica ja utilizada

-- Utilizado o nvl pois caso nao encontra regra, a variavel recebe 0
if (ie_calculo_coparticipacao_w = 'R') and (coalesce(nr_seq_regra_copartic_w,0) = 0) then
	ie_gerar_copartic_w := 'S';
end if;


if (ie_gerar_copartic_w = 'N') and (ie_cobrar_pos_estab_w = 'N') then
	
	if (cd_guia_ok_w IS NOT NULL AND cd_guia_ok_w::text <> '') then
	
		select	max(nr_sequencia)
		into STRICT	nr_seq_guia_referencia_w
		from	pls_conta
		where	cd_guia	= cd_guia_ok_w
		and ie_tipo_guia = 5;
		
		if (coalesce(nr_seq_guia_referencia_w::text, '') = '') then
			select	max(nr_sequencia)
			into STRICT	nr_seq_guia_referencia_w
			from	pls_conta
			where	cd_guia	= cd_guia_ok_w;
		end if;
		
		if (nr_seq_guia_referencia_w IS NOT NULL AND nr_seq_guia_referencia_w::text <> '') then
			select	max(ie_tipo_guia)
			into STRICT	ie_tipo_guia_w
			from	pls_conta
			where	nr_sequencia	= nr_seq_guia_referencia_w;
		end if;
	end if;
	
	if	( (cd_guia_referencia_w IS NOT NULL AND cd_guia_referencia_w::text <> '') and (coalesce(nr_seq_guia_referencia_w::text, '') = '')) then
		select	max(nr_sequencia)
		into STRICT	nr_seq_guia_referencia_w
		from	pls_conta
		where	cd_guia	= cd_guia_referencia_w
		and ie_tipo_guia = 5;
		
		if (coalesce(nr_seq_guia_referencia_w::text, '') = '') then
			select	max(nr_sequencia)
			into STRICT	nr_seq_guia_referencia_w
			from	pls_conta
			where	cd_guia	= cd_guia_referencia_w;
		end if;
		
		if (coalesce(nr_seq_guia_referencia_w,0) > 0) then
			select	max(ie_tipo_guia)
			into STRICT	ie_tipo_guia_w
			from	pls_conta
			where	nr_sequencia	= nr_seq_guia_referencia_w;
		end if;
		
	end if;
	
	-- o correto e verificar se a conta principal e de internacao
	ie_tipo_atend_w	:= pls_obter_se_internado(coalesce(nr_seq_conta_prin_w,nr_seq_conta_p), 'C');
	
	if (ie_tipo_atend_w = 'S') then
		ie_tipo_atend_w	:= 'I';
	else
		ie_tipo_atend_w	:= 'E';
	end if;
	
	/* Lepinski - 01/11/2010 - Regra por quantidade de ocorrencia */

	if (nr_seq_conta_proc_p IS NOT NULL AND nr_seq_conta_proc_p::text <> '') then
		select	max(a.ie_tipo_despesa)
		into STRICT	ie_tipo_despesa_ww
		from	pls_conta_proc	a,
			pls_conta	b,
			pls_segurado	c
		where	a.nr_seq_conta		= b.nr_sequencia
		and	b.nr_seq_segurado	= c.nr_sequencia
		and	a.nr_sequencia		= nr_seq_conta_proc_p;
	end if;
	
	begin
	select	cd_tiss
	into STRICT	cd_tiss_internacao_w
	from	pls_clinica
	where	nr_sequencia	= nr_seq_clinica_w;
	exception
	when others then
		cd_tiss_internacao_w	:= null;
	end;

	
	open C01;
	loop
	fetch C01 into	-- Dados do tipo de coparticipacao do plano ou contrato
		nr_seq_coparticipacao_w,
		nr_seq_tipo_coparticipacao_w,
		tx_coparticipacao_w,
		vl_maximo_w,
		ie_tipo_atendimento_w,
		vl_copartic_w,
		qt_eventos_minimo_w,
		qt_meses_intervalo_w,
		qt_ocorrencias_w,
		ie_tipo_ocorrencia_w,
		ie_tipo_data_consistencia_w,
		qt_diaria_inicial_w,
		qt_diaria_final_w,
		ie_origem_regra_w,
		ie_incidencia_valor_maximo_w,
		ie_forma_cobr_internacao_w,
		ie_periodo_valor_maximo_w,
		ie_incidencia_proc_mat_w,
		nr_seq_tipo_prestador_copart_w,
		ie_incidencia_valor_fixo_w,
		ie_incide_vl_fixo_cta_w,
		ie_inc_demais_itens_w,
		vl_base_max_w,
		vl_base_min_w,
		ie_incidencia_psiquiatria_w,
		dt_inicio_vig_regra_w,
		nr_seq_prestador_atend_w;
	EXIT WHEN NOT FOUND; /* apply on c01 */
		begin
		
		ie_gerar_w := 'S';
								
		if (ie_gerar_copart_int_w = 'S' and ie_origem_conta_w = 'A') then
		
			--Se retornar, entao ja tem coparticipacao gerada para procedimento com mesmo codigo e origem e participacao diferente
			select 	CASE WHEN count(1)=0 THEN  'S'  ELSE 'N' END
			into STRICT	ie_gerar_w
			from	pls_conta_coparticipacao a,
					pls_conta_proc b,
					pls_proc_participante c,
					pls_conta x
			where 	x.cd_guia_ok = cd_guia_ok_w
			and 	x.nr_seq_segurado = nr_seq_segurado_p
			and 	x.nr_sequencia = a.nr_seq_conta
			and		a.nr_seq_conta_proc = b.nr_sequencia
			and		b.nr_sequencia =  c.nr_seq_conta_proc
			and		c.nr_seq_grau_partic != nr_seq_grau_partic_w
			and		b.cd_procedimento = cd_procedimento_w
			and		b.ie_origem_proced = ie_origem_w
			and		coalesce(a.dt_estorno::text, '') = '';
			
			--Se nao localizar pelo cd_guia_ok(as vezes acontece de nao vir guia referencia no A500, entao acaba nao localizando dessa forma), entao busca pelo nr_seq_guia
			if (ie_gerar_w = 'S')then
				
				--Se retornar, entao ja tem coparticipacao gerada para procedimento com mesmo codigo e origem e participacao diferente
				select 	CASE WHEN count(1)=0 THEN  'S'  ELSE 'N' END
				into STRICT	ie_gerar_w
				from	pls_conta_coparticipacao a,
						pls_conta_proc b,
						pls_proc_participante c,
						pls_conta x
				where 	x.nr_seq_guia = nr_seq_guia_w
				and 	x.nr_seq_segurado = nr_seq_segurado_p
				and 	x.nr_sequencia = a.nr_seq_conta
				and		a.nr_seq_conta_proc = b.nr_sequencia
				and		b.nr_sequencia =  c.nr_seq_conta_proc
				and		c.nr_seq_grau_partic != nr_seq_grau_partic_w
				and		b.cd_procedimento = cd_procedimento_w
				and		b.ie_origem_proced = ie_origem_w
				and		coalesce(a.dt_estorno::text, '') = '';
				
			end if;
		
		end if;
						
		if ( vl_unitario_w > vl_base_max_w and (vl_base_max_w IS NOT NULL AND vl_base_max_w::text <> '') )  then
		
			ie_gerar_w := 'N';
			
		elsif (vl_unitario_w < vl_base_min_w and (vl_base_min_w IS NOT NULL AND vl_base_min_w::text <> '') ) then
			
			ie_gerar_w := 'N';
		
		end if;
									
		if ( ie_gerar_w = 'S') then
		
			if (coalesce(qt_meses_intervalo_w,1) < 1) then
				qt_meses_intervalo_w :=1;
			end if;
					
			--Se a regra de coparticipacao tiver uma excecao valida, entao desconsidera a mesma e prossegue no loop
			if (ie_tipo_guia_w in (4,6) and (nr_seq_conta_prin_w IS NOT NULL AND nr_seq_conta_prin_w::text <> '')) then
				
				select	max(nr_seq_saida_int),
						max(nr_seq_tipo_atendimento),
						max(ie_regime_atendimento),
						max(ie_saude_ocupacional)
				into STRICT	nr_seq_saida_internacao_w,
						nr_seq_tipo_atendimento_w,
						ie_regime_atendimento_w,
						ie_saude_ocupacional_w
				from	pls_conta
				where	nr_sequencia = nr_seq_conta_prin_w;
				
			else
				nr_seq_saida_internacao_w := nr_seq_saida_int_w;
			end if;
			
			if (cd_guia_w IS NOT NULL AND cd_guia_w::text <> '') then
				select	max(ie_tipo_atend_tiss)
				into STRICT	ie_tipo_atend_tiss_w
				from	pls_guia_plano
				where	cd_guia = cd_guia_w;
			end if;
							
			if ( coalesce(pls_obter_excecao_copartic(	nr_seq_coparticipacao_w, nr_seq_prestador_w, 	nr_seq_grupo_servico_w,
								nr_seq_saida_int_w, 	 nr_seq_saida_internacao_w, ie_tipo_guia_w, 	
								dt_autorizacao_w, 	nr_seq_conta_proc_p, 	 ie_tipo_protocolo_w,
								nr_seq_tipo_atendimento_w, ie_tipo_atend_tiss_w, ie_apresentacao_w,
								ie_regime_atendimento_w, ie_saude_ocupacional_w)::text, '') = '') then
					
				ie_status_mensalidade_item_w	:= ie_status_mensalidade_w;
				
				ie_diaria_w		:= 'S';
				
				
				qt_copart_cobrar_w	:= 0;
											
				nr_seq_regra_exclusao_w	:= pls_obter_copartic_exclusao(	nr_seq_tipo_coparticipacao_w, nr_seq_prestador_w, nr_seq_prestador_exec_w,
											dt_coparticipacao_w, nr_seq_conta_prin_w, ie_tipo_guia_w, 
											nr_seq_saida_int_w, ie_tipo_faturamento_w,nr_seq_grau_partic_w, 
											nr_seq_contrato_w, nr_seq_tipo_prestador_w,cd_procedimento_w, 
											nr_seq_prestador_solic_w, nr_seq_segurado_p, cd_guia_ok_w, ie_origem_conta_w,
											nr_seq_tipo_atendimento_w, ie_carater_internacao_w, ie_apresentacao_w, nr_seq_plano_w,
											ie_regime_atendimento_w, ie_saude_ocupacional_w);
				
				if (nr_seq_regra_exclusao_w <> 0) then
					ie_status_mensalidade_item_w	:= 'C'; -- Se existir regra de exclusao, o item sera gerado com o valor 0, e a coparticipacacao nao deve ser gerada na funcao de controle de coparticipacao
				end if;
													
				if (nr_seq_conta_proc_p <> 0) then
					ie_cobrar_copart_w := pls_consist_cobr_prest_copart(nr_seq_coparticipacao_w, nr_seq_conta_p, cd_procedimento_w, ie_origem_w, nr_seq_prestador_exec_w, dt_coparticipacao_w, ie_cobrar_copart_w);
				end if;
				
				if (ie_cobrar_copart_w = 'N') then
					goto final;
				end if;
				
				if (ie_tipo_data_consistencia_w = 'N') then /* Nenhum */
					dt_inicio_w	:= null;
					dt_final_w	:= null;

                                elsif (ie_tipo_data_consistencia_w = 'I') and (ie_tipo_atend_w = 'I') then
				
					select	trunc(min(t.dt_item), 'dd'),
						fim_dia(max(t.dt_item))
					into STRICT	dt_inicio_w,
						dt_final_w
					from (	SELECT	a.dt_procedimento_referencia dt_item
							from	pls_conta_proc	a,
								pls_conta	b
							where	b.nr_sequencia		= a.nr_seq_conta
							and	b.nr_seq_segurado	= nr_seq_segurado_p
							and	b.cd_guia_ok		= cd_guia_ok_w
							and	b.ie_status		!= 'C'
							
union all

							SELECT	a.dt_atendimento_referencia dt_item
							from	pls_conta_mat	a,
								pls_conta	b
							where	b.nr_sequencia		= a.nr_seq_conta
							and	b.nr_seq_segurado	= nr_seq_segurado_p
							and	b.cd_guia_ok		= cd_guia_ok_w
							and	b.ie_status		!= 'C') t;

				elsif (ie_tipo_data_consistencia_w in ('A','C','R','V')) then
				
					--Jogando a data de adesao do beneficiario para um campo temporario

					
					/* Data de adesao */

					if (ie_tipo_data_consistencia_w = 'A') then
						dt_w	:= dt_contratacao_w;
					/* Data contrato */

					elsif (ie_tipo_data_consistencia_w = 'C') then
						dt_w	:= dt_contrato_w;
					/*Data reajuste*/

					elsif (ie_tipo_data_consistencia_w = 'R') then
						dt_w	:= dt_reajuste_w;
					elsif (ie_tipo_data_consistencia_w = 'V') then
						dt_w	:= dt_inicio_vig_regra_w;
					end if;
				
				--Verificando se a data de coopartiticpacao e maior que a data da consistencia
					if (dt_coparticipacao_w	>= dt_w) then
					--Verificando se a data de adesao se encaixa na data de cooparticipacao
						if	NOT(dt_coparticipacao_w between dt_w and add_months(dt_w,qt_meses_intervalo_w))then
							ie_psiquiatricia_w	:= 'N';
							--Caso nao encaixe, o sistema ira incrementando os intervalos para aas data, ate encontrar uma data valida
							while(ie_psiquiatricia_w	= 'N') loop
								dt_w	:= add_months(dt_w,qt_meses_intervalo_w);
								dt_inicio_w		:= dt_w;
								dt_final_w		:= add_months(dt_w,qt_meses_intervalo_w);
								if	NOT(dt_coparticipacao_w between dt_inicio_w and dt_final_w) then
									ie_psiquiatricia_w	:= 'N';
								else
									ie_psiquiatricia_w	:= 'S';
								end if;
							end loop;
						else
							dt_inicio_w	:= dt_w;
							dt_final_w	:= add_months(dt_w,qt_meses_intervalo_w);
						end if;
					end if;
				elsif (ie_tipo_data_consistencia_w = 'L') then /* Ano calendario */
					dt_inicio_w	:= trunc(to_date('01/01/'||to_char(dt_coparticipacao_w,'yyyy')),'dd');
					dt_final_w	:= fim_dia(to_date('31/12/'||to_char(dt_coparticipacao_w,'yyyy')));
				end if;
						
				if (ie_tipo_despesa_ww = '3') then
					if (ie_tipo_ocorrencia_w = 'D') then
						
						/* Se for psiquiatrica */

						if (cd_tiss_internacao_w = '5') and (coalesce(qt_ocorrencias_w,0) <> 0) then
							select	sum(a.qt_procedimento),
								sum(e.qt_liberada_copartic)
							into STRICT	qt_diarias_w,
								qt_diarias_cobradas_w
							FROM pls_clinica d, pls_segurado c, pls_conta b, pls_conta_proc a
LEFT OUTER JOIN pls_conta_coparticipacao e ON (a.nr_sequencia = e.nr_seq_conta_proc)
WHERE a.nr_seq_conta		= b.nr_sequencia and b.nr_seq_segurado	= c.nr_sequencia  and c.nr_sequencia		= nr_seq_segurado_p and b.ie_status		= 'F' and a.nr_sequencia		<> nr_seq_conta_proc_p and a.ie_tipo_despesa	= '3' and b.nr_seq_clinica	= d.nr_sequencia and d.cd_tiss		= '5' and pls_obter_data_preco_item(a.nr_sequencia, 'P') between coalesce(dt_inicio_w,pls_obter_data_preco_item(a.nr_sequencia, 'P')) and coalesce(dt_final_w,pls_obter_data_preco_item(a.nr_sequencia, 'P'));
							
							qt_total_diarias_w  := coalesce(qt_liberada_w,0);
								qt_copart_cobrar_w  := coalesce(qt_ocorrencias_w,0) - qt_total_diarias_w - coalesce(qt_diarias_cobradas_w,0);
							
							if (qt_copart_cobrar_w > 0) then
								ie_diaria_w		:= 'P';								
							else
								ie_diaria_w		:= 'N';								
							end if;
							
						elsif (qt_diaria_inicial_w IS NOT NULL AND qt_diaria_inicial_w::text <> '') and (qt_diaria_final_w IS NOT NULL AND qt_diaria_final_w::text <> '') then
							
							if (ie_tipo_data_consistencia_w <> 'N') then
							
								-- carrega a quantidade de diarias ja existentes
								SELECT * FROM pls_obter_qt_diarias(nr_seq_conta_p, nr_seq_conta_proc_p, nr_seq_segurado_p, dt_procedimento_w, dt_inicio_w, dt_final_w, ie_incidencia_psiquiatria_w, ie_recurso_glosa_p, qt_diarias_w, qt_diarias_cobradas_w) INTO STRICT qt_diarias_w, qt_diarias_cobradas_w;
								
								
								qt_copart_cobrar_w := 0;
								qt_saldo_cobrar_w :=  ( qt_diaria_final_w - qt_diaria_inicial_w + 1) - coalesce(qt_diarias_cobradas_w,0);
								qt_saldo_menos_lib_w	:= qt_saldo_cobrar_w - qt_liberada_w;
								qt_diarias_w := coalesce(qt_diarias_w,0);
								qt_diarias_cobradas_w := qt_diarias_cobradas_w + coalesce(qt_diarias_cobradas_w,0);
								
								ie_limite_inferior_ok_w := 'N';
								if ( (qt_diarias_w + qt_liberada_w) >= qt_diaria_inicial_w) then
									ie_limite_inferior_ok_w := 'S';								
								end if;

														
								--Considera o limite superior menos o limite inferir e subtrai o que ja foi cobrado
								if (qt_saldo_cobrar_w > 0 and qt_liberada_w = 1 and ie_limite_inferior_ok_w = 'S') then
								
									qt_copart_cobrar_w := qt_liberada_w;
								
								elsif (qt_saldo_cobrar_w > 0 AND ie_limite_inferior_ok_w = 'S') then --se qt_liberada > 1 faz verificacoes
																						
									if (qt_saldo_cobrar_w >= qt_liberada_w AND qt_diarias_w >= qt_diaria_inicial_w) then
										
										qt_copart_cobrar_w := qt_liberada_w;
										
									elsif ( qt_saldo_cobrar_w >= qt_liberada_w ) then
										
										qt_copart_cobrar_w := 1 + qt_liberada_w - ( qt_diaria_inicial_w - qt_diarias_w);
										
										
									elsif (qt_saldo_cobrar_w < qt_liberada_w AND qt_diarias_w >= qt_diaria_inicial_w) then
									
										qt_copart_cobrar_w := qt_saldo_cobrar_w;
										
									else
										if ((qt_diarias_w + qt_liberada_w - qt_diaria_inicial_w) > qt_saldo_cobrar_w) then
											qt_copart_cobrar_w := qt_saldo_cobrar_w;
										else
											qt_copart_cobrar_w := qt_liberada_w + qt_diarias_w - qt_diaria_inicial_w;
										end if;
									end if;
									
								end if;
								
								if (qt_copart_cobrar_w < 0 ) then
									qt_copart_cobrar_w := 0;
								end if;
								
								
								if ( qt_copart_cobrar_w > 0) then
									ie_diaria_w		:= 'P';									
								else
									ie_diaria_w		:= 'N';									
								end if;
							else
								if (qt_liberada_w > qt_diaria_final_w) then
									qt_copart_cobrar_w	:= qt_diaria_final_w;
									ie_diaria_w		:= 'P';									
								else
									qt_copart_cobrar_w	:= qt_liberada_w;
									ie_diaria_w		:= 'S';									
								end if;
							end if;
						else
							ie_diaria_w	:= 'S';							
						end if;
					elsif (ie_tipo_ocorrencia_w = 'DC') then
					
						--aaschlote 04/05/2015 864842
						if (qt_diaria_inicial_w IS NOT NULL AND qt_diaria_inicial_w::text <> '') and (qt_diaria_final_w IS NOT NULL AND qt_diaria_final_w::text <> '') then	
							
							select	sum(coalesce(qt_procedimento,0))
							into STRICT	qt_liberada_w
							from	pls_conta_proc
							where	nr_seq_conta	= nr_seq_conta_p
							and	ie_tipo_despesa	= '3';
							
							--Se a quantidade libera estiver conforme a quantidade inicial e final
							if	((qt_liberada_w >= qt_diaria_inicial_w) or (qt_diaria_final_w <= qt_liberada_w)) then
							
								--Verifica se a quantidade libera e maior que a final
								if (qt_liberada_w > qt_diaria_final_w) then
									qt_copart_cobrar_w	:= qt_diaria_final_w;
								else
									qt_copart_cobrar_w	:= qt_liberada_w;
								end if;
								
								if (qt_copart_cobrar_w > 0) then
									ie_diaria_w		:= 'P';									
								else
									ie_diaria_w		:= 'N';									
								end if;
							end if;
						end if;
					end if;
				elsif (ie_tipo_despesa_ww <> '3') and (coalesce(qt_ocorrencias_w,0) <> 0) and (ie_inc_demais_itens_w = 'N') then
					ie_diaria_w := 'N';					
				elsif (ie_inc_demais_itens_w	= 'S') and (coalesce(qt_ocorrencias_w,0) <> 0) then
					ie_lib_item_w	:= pls_obter_se_data_limite(	qt_ocorrencias_w,  nr_seq_segurado_p,  dt_base_item_w,
											cd_tiss_internacao_w,dt_inicio_w, dt_final_w);
					if (ie_lib_item_w	= 'S') then
						ie_diaria_w := 'P';						
					else
						ie_diaria_w := 'N';						
					end if;
				end if;			
				
				/*Se cobrar a internacao, nao ira verificar outro tipo de cobranca de coparticipacao*/

				if ( ie_diaria_w	<> 'P') then
					if (ie_tipo_data_consistencia_w = 'N') then /* Nenhum */
						dt_inicio_contrato_w	:= null;
						dt_fim_contrato_w	:= null;
					elsif (ie_tipo_data_consistencia_w in ('A','C','R','V')) then
						/* Data de adesao */

						if (ie_tipo_data_consistencia_w = 'A') then
							dt_ww	:= dt_contratacao_w;
						/* Data contratacao */

						elsif (ie_tipo_data_consistencia_w = 'C') then
							dt_ww	:= dt_contrato_w;
						/*Data reajuste*/

						elsif (ie_tipo_data_consistencia_w = 'R') then
							dt_ww	:= dt_reajuste_w;
						elsif (ie_tipo_data_consistencia_w = 'V') then
							dt_ww	:= dt_inicio_vig_regra_w;
						end if;
						
						if (dt_autorizacao_w	>= dt_ww) then
							if	NOT(dt_autorizacao_w between dt_ww and add_months(dt_ww,qt_meses_intervalo_w))then
								ie_eventos_min_w	:= 'N';
								while(ie_eventos_min_w	= 'N') loop
									dt_ww	:= add_months(dt_ww,qt_meses_intervalo_w);
									dt_inicio_contrato_w		:= dt_ww;
									dt_fim_contrato_w		:= add_months(dt_ww,qt_meses_intervalo_w);
									if	NOT(dt_autorizacao_w between dt_inicio_contrato_w and dt_fim_contrato_w) then
										ie_eventos_min_w	:= 'N';
									else
										ie_eventos_min_w	:= 'S';
									end if;
								end loop;
							else
								dt_inicio_contrato_w	:= dt_ww;
								dt_fim_contrato_w	:= add_months(dt_ww,qt_meses_intervalo_w);
							end if;
							
						end if;
					elsif (ie_tipo_data_consistencia_w = 'L') then /* Ano calendario */
						dt_inicio_contrato_w		:= trunc(to_date('01/01/'||to_char(dt_autorizacao_w,'yyyy')),'dd');
						dt_fim_contrato_w		:= fim_dia(to_date('31/12/'||to_char(dt_autorizacao_w,'yyyy')));
					end if;
					
					ie_gerar_copart_min_w	:= 'N';
					qt_conta_w		:= 0;
					if (qt_eventos_minimo_w		<> 0) then
					
						qt_conta_w
									 := pls_minimo_coparticipacao(nr_seq_tipo_coparticipacao_w, qt_liberada_w, qt_eventos_minimo_w, nr_seq_segurado_p, nr_seq_conta_proc_p, dt_inicio_contrato_w, dt_fim_contrato_w, nr_seq_coparticipacao_w, cd_estabelecimento_p, nr_seq_conta_mat_p, ie_incidencia_proc_mat_w, nr_seq_prestador_atend_w, qt_conta_w
									);

					end if;
					
					if (qt_conta_w > 0) then
						ie_gerar_copart_min_w	:= 'S';
						qt_copart_cobrar_w	:= qt_conta_w;
					else
						ie_gerar_copart_min_w	:= 'N';
					end if;
					ie_outras_ocorrencias_w	:= 'S';
					
					/*aaschlote 29/03/22011 OS - Gerar a regra de outras ocorrencias da coparticipacao*/

					if	((qt_eventos_minimo_w = 0) or (ie_gerar_copart_min_w = 'S')) then
						begin
						SELECT * FROM pls_gerar_outras_ocorr_copar(nr_seq_coparticipacao_w, nr_seq_conta_proc_p, nr_seq_segurado_p, ie_outras_ocorrencias_w, qt_outras_ocorrencias_w) INTO STRICT ie_outras_ocorrencias_w, qt_outras_ocorrencias_w;
						exception
						when others then
							ie_outras_ocorrencias_w	:= 'S';
							qt_outras_ocorrencias_w	:= 0;
						end;
						if (qt_outras_ocorrencias_w <> 0) then
							qt_copart_cobrar_w := qt_outras_ocorrencias_w;
						end if;
					end if;
				end if;
				
				-- "or" do ie_diaria_w = P necessario para os casos aonde tem varias regras que se encaixam, e o ie_gerar_copart_min_w acabava como N, e nao era limpo.

				-- assim nao interfere nas tratativas dos valores, e deixa entrar no if caso for diaria com qt de ocorrencias minimas
				if	((qt_eventos_minimo_w = 0) or (ie_gerar_copart_min_w = 'S' or ie_diaria_w = 'P')) and (ie_diaria_w <> 'N') and (ie_outras_ocorrencias_w = 'S') then
																						
					if (ie_tipo_atendimento_w = ie_tipo_atend_w) or (ie_tipo_atendimento_w = 'A')then
						cont_w			:= 0;
						nr_seq_copartic_w	:= null;
						ie_liberado_w		:= 'N';
																
						if (coalesce(qt_copart_cobrar_w,0) = 0) then
							qt_copart_cobrar_w	:= qt_liberada_w;
						elsif (coalesce(qt_copart_cobrar_w,0) > qt_liberada_w) and (qt_liberada_w > 0 ) then
							qt_copart_cobrar_w	:= qt_liberada_w; --1
						end if;
						
						-- tratamento especifico para pisciquiatria
						if (ie_diaria_w = 'P') then

							-- restringe esse tratamento a somente quando for usar a qt diarias pisciquiatricas
							if (qt_ocorrencias_w > 0) then
							
								select	sum(e.qt_liberada_copartic)
								into STRICT	qt_copartic_ja_cobradas_w
								FROM pls_clinica d, pls_segurado c, pls_conta b, pls_conta_proc a
LEFT OUTER JOIN pls_conta_coparticipacao e ON (a.nr_sequencia = e.nr_seq_conta_proc)
WHERE a.nr_seq_conta		= b.nr_sequencia and b.nr_seq_segurado	= c.nr_sequencia  and b.nr_seq_clinica	= d.nr_sequencia and c.nr_sequencia		= nr_seq_segurado_p and b.ie_status		= 'F' and a.nr_sequencia		<> nr_seq_conta_proc_p and a.ie_tipo_despesa	= '3' and d.cd_tiss		= '5' and pls_obter_data_preco_item(a.nr_sequencia, 'P') between coalesce(dt_inicio_w,pls_obter_data_preco_item(a.nr_sequencia, 'P')) and coalesce(dt_final_w,pls_obter_data_preco_item(a.nr_sequencia, 'P')) and coalesce(e.dt_estorno::text, '') = '';
								
								
							
								if (qt_ocorrencias_w <= qt_copartic_ja_cobradas_w) then
									qt_copart_cobrar_w := 0;
								end if;
							end if;
							
							
							
						else
						
							select count(1)
							into STRICT	qt_copartic_ja_cobradas_w
							from	pls_conta_coparticipacao a,
									pls_conta_proc b
							where	a.nr_seq_conta = nr_seq_conta_p
							and		a.nr_seq_conta_proc = b.nr_sequencia
							and		a.nr_seq_regra = nr_seq_coparticipacao_w
							and		b.ie_tipo_despesa = 3
							and		coalesce(a.dt_estorno::text, '') = '';
							--Se ja gerou a quantidade a ser cobrada. Verificacao feita para que nao ocorra cobranca de qtde maior que o limite apontado na regra(Diarias)
							



							if (qt_copart_cobrar_w <= qt_copartic_ja_cobradas_w) then
								qt_copart_cobrar_w := 0;
							end if;
						
						end if;
							
						
						--aaschlote 19/02/2016 OS 1001909 - Realizado tratamento para quantidade a ser cobrada de coparticipacao nao ser maior que a quantidade apresentada (caso houver)
						if (coalesce(qt_apresentada_liberada_w,0) > 0) and (coalesce(qt_copart_cobrar_w,0) > coalesce(qt_apresentada_liberada_w,0)) then
							qt_copart_cobrar_w	:= qt_apresentada_liberada_w;
						end if;
											
						if (coalesce(vl_copartic_w,0) > 0) then
							if (nr_seq_conta_proc_p <> 0) then						
								if	((nr_seq_clinica_w <> 0) or (nr_seq_saida_int_w <> 0)) and (ie_tipo_atend_w <> 'I') then /*Verifica se tem regra de tipo de atendimento cadastrado*/
									
									select	count(1)
									into STRICT	cont_w
									from	pls_tipo_coparticipacao a,
										pls_coparticipacao_proc b
									where	a.nr_sequencia	 = b.nr_seq_tipo_coparticipacao
									and	a.nr_sequencia				= nr_seq_tipo_coparticipacao_w
									and	coalesce(b.nr_seq_clinica, nr_seq_clinica_w)	= nr_seq_clinica_w
									and (b.nr_seq_saida_int = nr_seq_saida_int_w or (coalesce(b.nr_seq_saida_int::text, '') = '' and
										  not exists (	SELECT	1
												from	pls_coparticipacao_proc	x
												where	x.nr_seq_tipo_coparticipacao = a.nr_sequencia
												and	x.nr_seq_saida_int = nr_seq_saida_int_w)))
									and	coalesce(ie_liberado, 'S') = 'S'
									and	a.ie_situacao	= 'A';	
								elsif (nr_seq_conta_mat_p = 0) then
									open c02;
									loop
									fetch c02 into
										nr_seq_copartic_w,
										ie_lib_regra_w,
										nr_seq_grupo_servico_w;
									EXIT WHEN NOT FOUND; /* apply on c02 */
										begin
										ie_grupo_lib_w	:= 'S';
										
										if (nr_seq_grupo_servico_w IS NOT NULL AND nr_seq_grupo_servico_w::text <> '') then
											ie_grupo_lib_w	:= pls_se_grupo_preco_servico_lib(nr_seq_grupo_servico_w, cd_procedimento_w, ie_origem_proced_w);
										end if;
										
										if (ie_grupo_lib_w	= 'S') then
											ie_liberado_w	:= ie_lib_regra_w;
										end if;
										end;
									end loop;
									close c02;
									
									/*aaschlote 07/11/2013 - Caso o item estiver liberado entao cobra o item*/

									if (ie_liberado_w = 'S') then
										cont_w	:= 1;
									end if;
								elsif (nr_seq_conta_mat_p <> 0) then
									select	count(1)
									into STRICT	cont_w
									from	pls_tipo_coparticipacao a,
										pls_coparticipacao_mat b
									where	a.nr_sequencia	= b.nr_seq_tipo_coparticipacao
									and	a.nr_sequencia	= nr_seq_tipo_coparticipacao_w
									and	a.ie_situacao	= 'A';
								end if;
							end if;
						end if;
																													
						if (cont_w > 0) then /*Se entra no if para o valor de coparticipacao fixo*/
							vl_coparticipacao_w	:= 0;
												
							if (nr_seq_conta_proc_p <> 0) and (coalesce(nr_seq_copartic_w::text, '') = '') then
								open c02;
								loop
								fetch c02 into
									nr_seq_copartic_w,
									ie_lib_regra_w,
									nr_seq_grupo_servico_w;
								EXIT WHEN NOT FOUND; /* apply on c02 */
									begin
									ie_grupo_lib_w	:= 'S';
									
									if (nr_seq_grupo_servico_w IS NOT NULL AND nr_seq_grupo_servico_w::text <> '') then
										ie_grupo_lib_w	:= pls_se_grupo_preco_servico_lib(nr_seq_grupo_servico_w, cd_procedimento_w, ie_origem_proced_w);
									end if;
									
									if (ie_grupo_lib_w	= 'S') then
										ie_liberado_w	:= ie_lib_regra_w;
									end if;
									end;
								end loop;
								close c02;
							elsif (nr_seq_conta_mat_p <> 0) and (coalesce(nr_seq_copartic_w::text, '') = '') then
								open c03;
								loop
								fetch c03 into
									nr_seq_copartic_w,
									ie_lib_regra_w,
									nr_seq_estrut_regra_w;
								EXIT WHEN NOT FOUND; /* apply on c03 */
									begin
									ie_estrut_mat_w	:= 'S';
									if (nr_seq_estrut_regra_w IS NOT NULL AND nr_seq_estrut_regra_w::text <> '') then
										ie_estrut_mat_w	:= pls_obter_se_mat_estrutura(nr_seq_material_w, nr_seq_estrut_regra_w);
									end if;
									
									if (ie_estrut_mat_w = 'S') then
										ie_liberado_w	:= ie_lib_regra_w;
									end if;
									end;
								end loop;
								close c03;
							end if;
							
							-- Se verifica caso seja internao	
							if (ie_tipo_atend_w = 'I') then

								/*aaschlote 06/12/2013 OS 672733*/

								if (ie_forma_cobr_internacao_w = 'C') then
								
									-- Verifica o tipo da aplicacao do valor fixo para a internacao 

									-- I - Itens, deve seguir conforme o padrao anterior a alteracao

									-- C - Conta, deve ser verificado apenas a conta atual
									if (ie_incide_vl_fixo_cta_w = 'I') then
									
										select	count(1)
										into STRICT	qt_coparticipacao_w
										from	pls_conta_coparticipacao	a,
											pls_conta			b,
											pls_conta_proc			c
										where	a.nr_seq_conta	= b.nr_sequencia
										and	c.nr_sequencia	= a.nr_seq_conta_proc
										and	c.nr_sequencia = nr_seq_conta_proc_p
										and	b.nr_sequencia	= nr_seq_conta_p
										and	coalesce(a.dt_estorno::text, '') = '';
									--tratamento alterado em conversa com o analista Paulo Rosa, para geracao de fixo para cada item existente na conta Dgkorz 17/02/2014	
										if (qt_coparticipacao_w = 0) then
											select	count(1)
											into STRICT	qt_coparticipacao_w
											from	pls_conta_coparticipacao	a,
												pls_conta			b,
												pls_conta_mat			c
											where	a.nr_seq_conta	= b.nr_sequencia
											and	c.nr_sequencia	= a.nr_seq_conta_mat
											and	c.nr_seq_material = nr_seq_material_w
											and	b.nr_sequencia	= nr_seq_conta_p
											and	coalesce(a.dt_estorno::text, '') = '';
									
										end if;
										
									-- Quando e aplicacao em conta
									elsif (ie_incide_vl_fixo_cta_w = 'C') then
																		
										select	count(1)
										into STRICT	qt_coparticipacao_w
										from	pls_conta_coparticipacao	a,
											pls_conta			b
										where	a.nr_seq_conta	= b.nr_sequencia
										and	b.nr_sequencia	= nr_seq_conta_p
										and	coalesce(a.dt_estorno::text, '') = '';
										
									end if;
								-- Quando a incidencia da internacao e guia, a aplicacao  
								elsif (ie_forma_cobr_internacao_w = 'G') then
								
									select	count(1)
									into STRICT	qt_coparticipacao_w
									from	pls_conta_coparticipacao	a,
										pls_conta			b
									where	a.nr_seq_conta	= b.nr_sequencia
									and	b.nr_seq_conta_princ	= nr_seq_conta_prin_w
									and	coalesce(a.dt_estorno::text, '') = '';
								end if;
							else
								-- Se a aplicacao for a nivel de item, segue com o comportamento padrao anterior a alteracao
								if (ie_incide_vl_fixo_cta_w = 'I') then
								
									qt_coparticipacao_w := 0;
									
								-- se for a nivel de  conta, entao levanta a quantidade de coparticipacao existentes
								elsif (ie_incide_vl_fixo_cta_w = 'C') then
								
									select	count(1)
									into STRICT	qt_coparticipacao_w
									from	pls_conta_coparticipacao	a,
										pls_conta			b
									where	a.nr_seq_conta			= b.nr_sequencia
									and	b.nr_sequencia			= nr_seq_conta_p
									and	coalesce(a.dt_estorno::text, '') = '';
								end if;
								
							end if;																										
							
							if (coalesce(ie_liberado_w,'N') = 'S') and (qt_coparticipacao_w = 0) and (qt_copart_cobrar_w > 0) then --OS 935726 17/09/2015 - Quantidade cobrada deve ser maior que zero
								/* Tratado para sempre calcular o valor da coparticipacao com base na quantidade de procedimentos - ebcabral - 25/07/2014 - OS 760585 */


								
								--Se na regra estiver definido que devera aplicar o valor fixo a  cada unidade do item, entao multiplica pela quantidade

								--para obtencao do valor total da coparticipacao para o item.
								if ( ie_incidencia_valor_fixo_w = 'U') then
								
									vl_coparticipacao_w	:= vl_copartic_w * qt_copart_cobrar_w;
								else
									vl_coparticipacao_w	:= vl_copartic_w;
								end if;
								
								if (coalesce(nr_seq_coparticipacao_w,0) > 0) then
									select	cd_procedimento_internacao,
										ie_origem_proced_internacao
									into STRICT	cd_procedimento_internacao_w,
										ie_origem_proced_internacao_w
									from	pls_tipo_coparticipacao
									where	nr_sequencia = nr_seq_tipo_coparticipacao_w;
								end if;
								
								if (nr_seq_conta_proc_p <> 0) then
									if (nr_seq_regra_exclusao_w <> 0) then
										vl_coparticipacao_w	:= 0;
									else
										nr_seq_regra_exclusao_w	:= null;
									end if;
									
									--Nao calcula taxa de coparticipacao aqui pois so entrara aqui com valor fixo
									vl_base_calculo_maximo_w	:= 0;
									vl_cobrado_copar_evento_max_w	:= 0;
																
									if (ie_incidencia_valor_maximo_w	= 'U') then
										vl_base_calculo_maximo_w	:= vl_coparticipacao_w;
									elsif (ie_incidencia_valor_maximo_w	= 'T') then
										vl_base_calculo_maximo_w	:= vl_coparticipacao_w;
									elsif (ie_incidencia_valor_maximo_w	= 'M') then
																
										SELECT * FROM pls_consist_vl_max_copar_event(	nr_seq_conta_p, nr_seq_segurado_p, nr_seq_coparticipacao_w, dt_mes_competencia_w, ie_periodo_valor_maximo_w, vl_coparticipacao_w, vl_cobrado_copar_evento_max_w, vl_base_calculo_maximo_w) INTO STRICT vl_cobrado_copar_evento_max_w, vl_base_calculo_maximo_w;			
									end if;
									
									if (ie_recurso_glosa_p = 'S') then
										select	coalesce(sum(vl_coparticipacao),0),
											coalesce(sum(qt_liberada_copartic),0)
										into STRICT	vl_copart_orignal_w,
											qt_liberado_original_w
										from	pls_conta_coparticipacao
										where	nr_seq_conta_proc = nr_seq_conta_proc_p;
										
										vl_base_calculo_maximo_w := vl_base_calculo_maximo_w + vl_copart_orignal_w;
									end if;
									
									if (vl_maximo_w > 0) and (vl_base_calculo_maximo_w > vl_maximo_w) then
										
										if (ie_recurso_glosa_p = 'N') then
											if (ie_incidencia_valor_maximo_w	= 'U') then
												vl_coparticipacao_w		:= (vl_maximo_w * qt_liberada_w);
											elsif (ie_incidencia_valor_maximo_w	= 'T') then
												vl_coparticipacao_w		:= vl_maximo_w;
											elsif (ie_incidencia_valor_maximo_w	= 'M') then
												if (vl_maximo_w > vl_cobrado_copar_evento_max_w) then
													vl_coparticipacao_w		:= vl_maximo_w - vl_cobrado_copar_evento_max_w;
												else
													vl_coparticipacao_w		:= 0;
												end if;
											end if;
											
											vl_copartic_unit_w	:= vl_maximo_w;
										else
											vl_coparticipacao_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
											
											if (ie_incidencia_valor_maximo_w = 'U') then
												vl_maximo_rec_w := (vl_maximo_w * (qt_liberada_w + qt_liberado_original_w));
											elsif (ie_incidencia_valor_maximo_w = 'T') then	
												vl_maximo_rec_w := vl_maximo_w;
											elsif (ie_incidencia_valor_maximo_w = 'M') then
												vl_maximo_rec_w := vl_maximo_w - vl_cobrado_copar_evento_max_w;
											end if;
																															
											if	((vl_coparticipacao_w + vl_copart_orignal_w) > vl_maximo_rec_w) then
												vl_coparticipacao_w := vl_maximo_rec_w - vl_copart_orignal_w;
											end if;
										end if;
									end if;
																								
									--Se valor da coparticipacao for diferente de zero ou entao se for zerado mas estiver parametrizado para gerar mesmo assim, entao gera
									if (vl_coparticipacao_w <> 0 or ie_gerar_copartic_zerado_w = 'S') then
									
										-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
										if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
											 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
											
											insert	into	pls_conta_coparticipacao(	nr_sequencia, dt_atualizacao, nm_usuario,
													nr_seq_conta, nr_seq_conta_proc, tx_coparticipacao,
													vl_coparticipacao, nr_seq_regra, nr_seq_regra_exclusao,
													ie_calculo_coparticipacao, vl_base_copartic, nr_seq_conta_mat,
													qt_liberada_copartic, vl_coparticipacao_unit, vl_provisao,
													ie_origem_copartic, ie_status_mensalidade, nm_usuario_nrec,
													dt_atualizacao_nrec, ie_origem_regra, ie_status_coparticipacao,
													cd_procedimento_internacao, ie_origem_proced_internacao, nr_seq_processo_copartic,
													nr_seq_disc_mat, nr_seq_disc_proc, ie_ato_cooperado, nr_seq_prestador_atend,
													nr_seq_prestador_exec, ie_tipo_prestador_atend, ie_tipo_prestador_exec,
													ie_tipo_guia, dt_mes_competencia, ie_tipo_segurado, ie_tipo_protocolo,
													nr_seq_protocolo, nr_seq_segurado, ie_preco,
													nr_seq_proc_rec, nr_seq_conta_rec, nr_seq_regra_preco_copart, ie_vl_pag_prestador)
												values (	nextval('pls_conta_coparticipacao_seq'), clock_timestamp(), nm_usuario_p,
													nr_seq_conta_p, nr_seq_conta_proc_p, 0,
													vl_coparticipacao_w, nr_seq_coparticipacao_w, nr_seq_regra_exclusao_w,
													ie_calculo_coparticipacao_w, vl_unitario_w, null,
													qt_copart_cobrar_w, vl_copartic_w, vl_coparticipacao_w,
													null, ie_status_mensalidade_item_w, nm_usuario_p,
													clock_timestamp(), ie_origem_regra_w, ie_status_coparticipacao_w,
													cd_procedimento_internacao_w, ie_origem_proced_internacao_w, nr_seq_processo_copartic_w,
													nr_seq_disc_mat_p, nr_seq_disc_proc_p, ie_ato_cooperado_w, nr_seq_prestador_w,
													nr_seq_prestador_exec_w, ie_tipo_prestador_atend_w, ie_tipo_prestador_exec_w,
													ie_tipo_guia_w, dt_mes_competencia_w, ie_tipo_segurado_w, ie_tipo_protocolo_w,
													nr_seq_protocolo_w, nr_seq_segurado_p, ie_preco_w,
													nr_seq_conta_proc_w, nr_seq_conta_rec_p, nr_seq_regra_copartic_w, ie_vl_pag_prestador_w);
										end if;
									end if;
									
									-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
									if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
										 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
										
										update	pls_conta_proc
										set	vl_coparticipacao	= coalesce(vl_coparticipacao_w,0),
											ie_coparticipacao	= ie_liberado_w
										where	nr_sequencia		= nr_seq_conta_proc_p;
										
										vl_tot_copartic_w	:= coalesce(vl_tot_copartic_w,0) + coalesce(vl_coparticipacao_w,0);
									end if;
									
								elsif (nr_seq_conta_mat_p <> 0) then
									if (nr_seq_regra_exclusao_w <> 0) then
										vl_coparticipacao_w	:= 0;
									else
										nr_seq_regra_exclusao_w	:= null;
									end if;
									
									--Nao calcula taxa de coparticipacao aqui pois so entrara aqui com valor fixo
									vl_base_calculo_maximo_w	:= 0;
									vl_cobrado_copar_evento_max_w	:= 0;
																
									if (ie_incidencia_valor_maximo_w	= 'U') then
										vl_base_calculo_maximo_w	:= vl_coparticipacao_w;
									elsif (ie_incidencia_valor_maximo_w	= 'T') then
										vl_base_calculo_maximo_w	:= vl_coparticipacao_w;
									elsif (ie_incidencia_valor_maximo_w	= 'M') then
																
										SELECT * FROM pls_consist_vl_max_copar_event(	nr_seq_conta_p, nr_seq_segurado_p, nr_seq_coparticipacao_w, dt_mes_competencia_w, ie_periodo_valor_maximo_w, vl_coparticipacao_w, vl_cobrado_copar_evento_max_w, vl_base_calculo_maximo_w) INTO STRICT vl_cobrado_copar_evento_max_w, vl_base_calculo_maximo_w;
														
									end if;
									
									if (ie_recurso_glosa_p = 'S') then
										select	coalesce(sum(vl_coparticipacao),0),
											coalesce(sum(qt_liberada_copartic),0)
										into STRICT	vl_copart_orignal_w,
											qt_liberado_original_w
										from	pls_conta_coparticipacao
										where	nr_seq_conta_mat = nr_seq_conta_mat_p;
										
										vl_base_calculo_maximo_w := vl_base_calculo_maximo_w + vl_copart_orignal_w;
									end if;
									
									if (vl_maximo_w > 0) and (vl_base_calculo_maximo_w > vl_maximo_w) then
										
										if (ie_recurso_glosa_p = 'N') then
											if (ie_incidencia_valor_maximo_w	= 'U') then
												vl_coparticipacao_w		:= (vl_maximo_w * qt_liberada_w);
											elsif (ie_incidencia_valor_maximo_w	= 'T') then
												vl_coparticipacao_w		:= vl_maximo_w;
											elsif (ie_incidencia_valor_maximo_w	= 'M') then
												if (vl_maximo_w > vl_cobrado_copar_evento_max_w) then
													vl_coparticipacao_w		:= vl_maximo_w - vl_cobrado_copar_evento_max_w;
												else
													vl_coparticipacao_w		:= 0;
												end if;
											end if;
											
											vl_copartic_unit_w	:= vl_maximo_w;
										else
											vl_coparticipacao_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
											
											if (ie_incidencia_valor_maximo_w = 'U') then
												vl_maximo_rec_w := (vl_maximo_w * (qt_liberada_w + qt_liberado_original_w));
											elsif (ie_incidencia_valor_maximo_w = 'T') then	
												vl_maximo_rec_w := vl_maximo_w;
											elsif (ie_incidencia_valor_maximo_w = 'M') then
												vl_maximo_rec_w := vl_maximo_w - vl_cobrado_copar_evento_max_w;
											end if;
																															
											if	((vl_coparticipacao_w + vl_copart_orignal_w) > vl_maximo_rec_w) then
												vl_coparticipacao_w := vl_maximo_rec_w - vl_copart_orignal_w;
											end if;
											
											if (vl_coparticipacao_w < 0) then
												vl_coparticipacao_w := 0;
											end if;
										end if;
									end if;
																	
									--Se valor da coparticipacao for diferente de zero ou entao se for zerado mas estiver parametrizado para gerar mesmo assim, entao gera
									if (vl_coparticipacao_w <> 0 or ie_gerar_copartic_zerado_w = 'S') then
									
										-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
										if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
											 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
											
											insert	into	pls_conta_coparticipacao(	nr_sequencia, dt_atualizacao, nm_usuario,
													nr_seq_conta, nr_seq_conta_mat, tx_coparticipacao,
													vl_coparticipacao, nr_seq_regra, nr_seq_regra_exclusao,
													ie_calculo_coparticipacao, vl_base_copartic, nr_seq_conta_proc,
													qt_liberada_copartic, vl_coparticipacao_unit, vl_provisao,
													ie_origem_copartic, ie_status_mensalidade, nm_usuario_nrec,
													dt_atualizacao_nrec, ie_origem_regra, ie_status_coparticipacao,
													cd_procedimento_internacao, ie_origem_proced_internacao, nr_seq_processo_copartic,
													nr_seq_disc_mat, nr_seq_disc_proc, ie_ato_cooperado, nr_seq_prestador_atend,
													nr_seq_prestador_exec, ie_tipo_prestador_atend, ie_tipo_prestador_exec,
													ie_tipo_guia, dt_mes_competencia, ie_tipo_segurado, ie_tipo_protocolo,
													nr_seq_protocolo, nr_seq_segurado, ie_preco,
													nr_seq_mat_rec, nr_seq_conta_rec, nr_seq_regra_preco_copart, ie_vl_pag_prestador)
												values (	nextval('pls_conta_coparticipacao_seq'), clock_timestamp(), nm_usuario_p,
													nr_seq_conta_p, nr_seq_conta_mat_p, 0,
													vl_coparticipacao_w, nr_seq_coparticipacao_w, nr_seq_regra_exclusao_w,
													ie_calculo_coparticipacao_w, vl_unitario_w, null,
													qt_copart_cobrar_w, vl_copartic_w, vl_coparticipacao_w,
													null, ie_status_mensalidade_item_w, nm_usuario_p,
													clock_timestamp(), ie_origem_regra_w, ie_status_coparticipacao_w,
													cd_procedimento_internacao_w, ie_origem_proced_internacao_w, nr_seq_processo_copartic_w,
													nr_seq_disc_mat_p, nr_seq_disc_proc_p, ie_ato_cooperado_w, nr_seq_prestador_w,
													nr_seq_prestador_exec_w, ie_tipo_prestador_atend_w, ie_tipo_prestador_exec_w,
													ie_tipo_guia_w, dt_mes_competencia_w, ie_tipo_segurado_w, ie_tipo_protocolo_w,
													nr_seq_protocolo_w, nr_seq_segurado_p, ie_preco_w,
													nr_seq_conta_mat_w, nr_seq_conta_rec_p, nr_seq_regra_copartic_w, ie_vl_pag_prestador_w);
										end if;
									end if;
									
									-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
									if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
										 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
										
										update	pls_conta_mat
										set	vl_participacao		= coalesce(vl_coparticipacao_w,0),
											ie_coparticipacao	= ie_liberado_w
										where	nr_sequencia		= nr_seq_conta_mat_p;
										
										vl_tot_copartic_w	:= coalesce(vl_tot_copartic_w,0) + coalesce(vl_coparticipacao_w,0);
									end if;
								end if;
							end if;
						end if;
						
						/*aaschlote 24/09/2012  OS - 499150*/

						ie_liberado_w	:= 'N';
						
						
						
						if (nr_seq_conta_proc_p <> 0) then
							open c02;
							loop
							fetch c02 into
								nr_seq_copartic_w,
								ie_lib_regra_w,
								nr_seq_grupo_servico_w;
							EXIT WHEN NOT FOUND; /* apply on c02 */
								begin
								ie_grupo_lib_w	:= 'S';
								
								if (nr_seq_grupo_servico_w IS NOT NULL AND nr_seq_grupo_servico_w::text <> '') then
									ie_grupo_lib_w	:= pls_se_grupo_preco_servico_lib(nr_seq_grupo_servico_w, cd_procedimento_w, ie_origem_proced_w);
								end if;
								
								if (ie_grupo_lib_w	= 'S') then
									ie_liberado_w	:= ie_lib_regra_w;
								end if;
								end;
							end loop;
							close c02;
						elsif (nr_seq_conta_mat_p <> 0) then
							open c03;
							loop
							fetch c03 into
								nr_seq_copartic_w,
								ie_lib_regra_w,
								nr_seq_estrut_regra_w;
							EXIT WHEN NOT FOUND; /* apply on c03 */
								begin
								ie_estrut_mat_w	:= 'S';
								if (nr_seq_estrut_regra_w IS NOT NULL AND nr_seq_estrut_regra_w::text <> '') then
									ie_estrut_mat_w	:= pls_obter_se_mat_estrutura(nr_seq_material_w, nr_seq_estrut_regra_w);
								end if;
								
								if (ie_estrut_mat_w = 'S') then
									ie_liberado_w	:= ie_lib_regra_w;
								end if;
								end;
							end loop;
							close c03;
						end if;
						
						vl_coparticipacao_w	:= 0;
											
						if (coalesce(ie_liberado_w,'N') = 'S') then
							if (nr_seq_conta_proc_p <> 0) then
								select	count(1)
								into STRICT	qt_registros_w
								from	pls_conta_coparticipacao
								where	nr_seq_conta_proc	= nr_seq_conta_proc_p
								and	vl_coparticipacao	> 0;
								
								-- Alterado para buscar a quantidade liberada e nao a paresentada, pois

								-- caso houvesse alguma glosa de quantidade no item e duas regras de coaprticipacao

								-- iria gerar coparticipacao duplicada. OS 1161345
								select	a.qt_procedimento,
									(select sum(qt_liberada_copartic)
									from pls_conta_coparticipacao b
									where a.nr_sequencia = b.nr_seq_conta_proc
									and b.ie_status_coparticipacao <> 'N'
									group by b.nr_seq_conta_proc) liberada
								into STRICT	qt_origem_conta_w,
									qt_liberada_conta_w
								from	pls_conta_proc a
								where	a.nr_sequencia	= nr_seq_conta_proc_p;							
							elsif (nr_seq_conta_mat_p <> 0) then
								select	count(1)
								into STRICT	qt_registros_w
								from	pls_conta_coparticipacao
								where	nr_seq_conta_mat	= nr_seq_conta_mat_p
								and	vl_coparticipacao	> 0;
								
								select	a.qt_material,
									(select sum(qt_liberada_copartic)
									from 	pls_conta_coparticipacao b
									where 	a.nr_sequencia = b.nr_seq_conta_mat
									and	b.ie_status_coparticipacao <> 'N'
									group by b.nr_seq_conta_mat) liberada
								into STRICT	qt_origem_conta_w,
									qt_liberada_conta_w
								from	pls_conta_mat a
								where	a.nr_sequencia	= nr_seq_conta_mat_p;
							end if;
							
							if (coalesce(ie_gerar_copartic_zerado_w,'N') = 'N') then
								if (qt_registros_w = 0) or (coalesce(param_1_p,'X') = 'R') or (qt_origem_conta_w > coalesce(qt_liberada_conta_w,0)) or (ie_recurso_glosa_p = 'S') then
									
									--Relizado calculo aqui para contemplar os casos onde libera valor sem valor calculado e apresentado, pois nesse caso, nao popula o unitario liberado no item
									vl_lib_w	:= dividir_sem_round(vl_liberado_w,qt_liberada_w);								
									vl_copartic_unit_w	:= ((coalesce(vl_lib_w,0) * tx_coparticipacao_w) / 100); -- Paulo OS 95779 - 06/06/2008
									
									vl_base_calculo_maximo_w	:= 0;
									vl_cobrado_copar_evento_max_w	:= 0;
									
									if (ie_incidencia_valor_maximo_w	= 'U') then
										vl_base_calculo_maximo_w	:= vl_copartic_unit_w;
									elsif (ie_incidencia_valor_maximo_w	= 'T') then
										vl_base_calculo_maximo_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
									elsif (ie_incidencia_valor_maximo_w	= 'M') then
										pls_consist_vl_max_copar_event(	nr_seq_conta_p,nr_seq_segurado_p,nr_seq_coparticipacao_w,
														dt_mes_competencia_w,ie_periodo_valor_maximo_w,
														((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100),
														vl_cobrado_copar_evento_max_w,vl_base_calculo_maximo_w);
									end if;
									
									if (ie_recurso_glosa_p = 'S') then
										if (nr_seq_conta_proc_p <> 0) then
											select	coalesce(sum(vl_coparticipacao),0),
												coalesce(sum(qt_liberada_copartic),0)
											into STRICT	vl_copart_orignal_w,
												qt_liberado_original_w
											from	pls_conta_coparticipacao
											where	nr_seq_conta_proc = nr_seq_conta_proc_p;
											
											select	coalesce(qt_procedimento_imp,0)
											into STRICT	qt_origem_conta_ww
											from	pls_conta_proc a
											where	a.nr_sequencia	= nr_seq_conta_proc_p;
											
											if (qt_liberada_w = qt_origem_conta_ww) then
												qt_liberado_original_w := 0;
											end if;
										elsif (nr_seq_conta_mat_p <> 0) then
											select	coalesce(sum(vl_coparticipacao),0),
												coalesce(sum(qt_liberada_copartic),0)
											into STRICT	vl_copart_orignal_w,
												qt_liberado_original_w
											from	pls_conta_coparticipacao
											where	nr_seq_conta_mat = nr_seq_conta_mat_p;
											
											select	coalesce(qt_material_imp,0)
											into STRICT	qt_origem_conta_ww
											from	pls_conta_mat
											where	nr_sequencia = nr_seq_conta_mat_p;
											
											if (qt_liberada_w = qt_origem_conta_ww) then
												qt_liberado_original_w := 0;
											end if;
										end if;
										
										vl_base_calculo_maximo_w := vl_base_calculo_maximo_w + vl_copart_orignal_w;
									end if;
																									
									if (vl_maximo_w > 0) and (vl_base_calculo_maximo_w > vl_maximo_w) then
										
										if (ie_recurso_glosa_p = 'N') then
											if (ie_incidencia_valor_maximo_w	= 'U') then
												vl_coparticipacao_w		:= (vl_maximo_w * qt_liberada_w);
											elsif (ie_incidencia_valor_maximo_w	= 'T') then
												vl_coparticipacao_w		:= vl_maximo_w;
											elsif (ie_incidencia_valor_maximo_w	= 'M') then
												if (vl_maximo_w > vl_cobrado_copar_evento_max_w) then
													vl_coparticipacao_w		:= vl_maximo_w - vl_cobrado_copar_evento_max_w;
												else
													vl_coparticipacao_w		:= 0;
												end if;
											end if;
																			
											vl_copartic_unit_w	:= vl_maximo_w;
										else
											vl_coparticipacao_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
											
											if (ie_incidencia_valor_maximo_w = 'U') then
												vl_maximo_rec_w := (vl_maximo_w * (qt_liberada_w + qt_liberado_original_w));
											elsif (ie_incidencia_valor_maximo_w = 'T') then	
												vl_maximo_rec_w := vl_maximo_w;
											elsif (ie_incidencia_valor_maximo_w = 'M') then
												vl_maximo_rec_w := vl_maximo_w - vl_cobrado_copar_evento_max_w;
											end if;
											
											if	((vl_coparticipacao_w + vl_copart_orignal_w) > vl_maximo_rec_w) then
												vl_coparticipacao_w := vl_maximo_rec_w - vl_copart_orignal_w;
											end if;
										end if;
									else
										vl_coparticipacao_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
									end if;
									
									if (ie_diaria_w = 'P') then
										vl_coparticipacao_w	:= vl_copartic_unit_w * qt_copart_cobrar_w;
									end if;
									
									if (ie_gerar_copart_min_w = 'S') then
										vl_coparticipacao_w	:= vl_copartic_unit_w * qt_copart_cobrar_w;
									end if;
																	
									if (nr_seq_conta_proc_p <> 0) then
									
										if (nr_seq_regra_exclusao_w <> 0) then
											vl_coparticipacao_w	:= 0;
											vl_copartic_unit_w	:= 0;
										else
											nr_seq_regra_exclusao_w	:= null;
										end if;
										
										if (coalesce(vl_coparticipacao_w,0) > 0) then
																					
											-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
											if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
												 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
												 
												insert	into	pls_conta_coparticipacao(	nr_sequencia, dt_atualizacao, nm_usuario,
														nr_seq_conta, nr_seq_conta_proc, tx_coparticipacao,
														vl_coparticipacao, nr_seq_regra, vl_coparticipacao_unit,
														nr_seq_regra_exclusao, ie_calculo_coparticipacao, vl_base_copartic,
														qt_liberada_copartic, vl_provisao, ie_origem_copartic,
														ie_status_mensalidade, nm_usuario_nrec, dt_atualizacao_nrec,
														ie_origem_regra, ie_status_coparticipacao, nr_seq_processo_copartic,
														nr_seq_disc_mat, nr_seq_disc_proc, ie_ato_cooperado, nr_seq_prestador_atend,
														nr_seq_prestador_exec, ie_tipo_prestador_atend, ie_tipo_prestador_exec,
														ie_tipo_guia, dt_mes_competencia, ie_tipo_segurado, ie_tipo_protocolo,
														nr_seq_protocolo, nr_seq_segurado, ie_preco,
														nr_seq_proc_rec, nr_seq_conta_rec, nr_seq_regra_preco_copart, ie_vl_pag_prestador)
													values (	nextval('pls_conta_coparticipacao_seq'), clock_timestamp(), nm_usuario_p,
														nr_seq_conta_p, nr_seq_conta_proc_p, tx_coparticipacao_w,
														vl_coparticipacao_w, nr_seq_coparticipacao_w, vl_copartic_unit_w,
														nr_seq_regra_exclusao_w, ie_calculo_coparticipacao_w, vl_unitario_w,
														qt_copart_cobrar_w, vl_coparticipacao_w, null,
														ie_status_mensalidade_item_w, nm_usuario_p, clock_timestamp(),
														ie_origem_regra_w, ie_status_coparticipacao_w, nr_seq_processo_copartic_w,
														nr_seq_disc_mat_p, nr_seq_disc_proc_p, ie_ato_cooperado_w, nr_seq_prestador_w,
														nr_seq_prestador_exec_w, ie_tipo_prestador_atend_w, ie_tipo_prestador_exec_w,
														ie_tipo_guia_w, dt_mes_competencia_w, ie_tipo_segurado_w, ie_tipo_protocolo_w,
														nr_seq_protocolo_w, nr_seq_segurado_p, ie_preco_w,
														nr_seq_conta_proc_w, nr_seq_conta_rec_p, nr_seq_regra_copartic_w, ie_vl_pag_prestador_w);
												
												update	pls_conta_proc
												set	vl_coparticipacao	= coalesce(vl_coparticipacao_w,0),
													ie_coparticipacao	= ie_liberado_w
												where	nr_sequencia		= nr_seq_conta_proc_p;
												
												vl_tot_copartic_w	:= coalesce(vl_tot_copartic_w,0) + coalesce(vl_coparticipacao_w,0);
											end if;
										end if;
									elsif (nr_seq_conta_mat_p <> 0) then
									
										if (nr_seq_regra_exclusao_w <> 0) then
											vl_coparticipacao_w	:= 0;
											vl_copartic_unit_w	:= 0;
										else
											nr_seq_regra_exclusao_w	:= null;
										end if;
									
										if (coalesce(vl_coparticipacao_w,0) > 0) then
											
											-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
											if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
												 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
											
												insert	into	pls_conta_coparticipacao(	nr_sequencia, dt_atualizacao, nm_usuario,
														nr_seq_conta, nr_seq_conta_mat, tx_coparticipacao,
														vl_coparticipacao, nr_seq_regra, vl_coparticipacao_unit,
														nr_seq_regra_exclusao, ie_calculo_coparticipacao, vl_base_copartic,
														qt_liberada_copartic, vl_provisao, ie_origem_copartic,
														ie_status_mensalidade, nm_usuario_nrec, dt_atualizacao_nrec,
														ie_origem_regra, ie_status_coparticipacao, nr_seq_processo_copartic,
														nr_seq_disc_mat, nr_seq_disc_proc, ie_ato_cooperado, nr_seq_prestador_atend,
														nr_seq_prestador_exec, ie_tipo_prestador_atend, ie_tipo_prestador_exec,
														ie_tipo_guia, dt_mes_competencia, ie_tipo_segurado, ie_tipo_protocolo,
														nr_seq_protocolo, nr_seq_segurado, ie_preco,
														nr_seq_mat_rec, nr_seq_conta_rec, nr_seq_regra_preco_copart, ie_vl_pag_prestador)
													values (	nextval('pls_conta_coparticipacao_seq'), clock_timestamp(), nm_usuario_p,
														nr_seq_conta_p, nr_seq_conta_mat_p, tx_coparticipacao_w,
														vl_coparticipacao_w, nr_seq_coparticipacao_w, vl_copartic_unit_w,
														nr_seq_regra_exclusao_w, ie_calculo_coparticipacao_w, vl_unitario_w,
														qt_copart_cobrar_w, vl_coparticipacao_w, null,
														ie_status_mensalidade_item_w, nm_usuario_p, clock_timestamp(),
														ie_origem_regra_w, ie_status_coparticipacao_w, nr_seq_processo_copartic_w,
														nr_seq_disc_mat_p, nr_seq_disc_proc_p, ie_ato_cooperado_w, nr_seq_prestador_w,
														nr_seq_prestador_exec_w, ie_tipo_prestador_atend_w, ie_tipo_prestador_exec_w,
														ie_tipo_guia_w, dt_mes_competencia_w, ie_tipo_segurado_w, ie_tipo_protocolo_w,
														nr_seq_protocolo_w, nr_seq_segurado_p, ie_preco_w,
														nr_seq_conta_mat_w, nr_seq_conta_rec_p, nr_seq_regra_copartic_w,ie_vl_pag_prestador_w);
												
												update	pls_conta_mat
												set	vl_participacao		= coalesce(vl_coparticipacao_w,0),
													ie_coparticipacao	= ie_liberado_w
												where	nr_sequencia		= nr_seq_conta_mat_p;
												vl_tot_copartic_w	:= coalesce(vl_tot_copartic_w,0) + coalesce(vl_coparticipacao_w,0);
											
											end if;
										end if;
									end if;
								end if;
							elsif (ie_gerar_copartic_zerado_w = 'S') then
								if (nr_seq_conta_proc_p <> 0) then
									select	count(1)
									into STRICT	qt_registros_w
									from	pls_conta_coparticipacao
									where	nr_seq_conta_proc	= nr_seq_conta_proc_p;
									
									select	a.qt_procedimento_imp,
										(select sum(qt_liberada_copartic)
										from pls_conta_coparticipacao b
										where a.nr_sequencia = b.nr_seq_conta_proc
										and b.ie_status_coparticipacao <> 'N'
										group by b.nr_seq_conta_proc) liberada
									into STRICT	qt_origem_conta_w,
										qt_liberada_conta_w
									from	pls_conta_proc a
									where	a.nr_sequencia	= nr_seq_conta_proc_p;
								elsif (nr_seq_conta_mat_p <> 0) then
									select	count(1)
									into STRICT	qt_registros_w
									from	pls_conta_coparticipacao
									where	nr_seq_conta_mat	= nr_seq_conta_mat_p;
									
									select	a.qt_material_imp,
										(select sum(qt_liberada_copartic)
										from 	pls_conta_coparticipacao b
										where 	a.nr_sequencia = b.nr_seq_conta_mat
										and	b.ie_status_coparticipacao <> 'N'
										group by b.nr_seq_conta_mat) liberada
									into STRICT	qt_origem_conta_w,
										qt_liberada_conta_w
									from	pls_conta_mat a
									where	a.nr_sequencia	= nr_seq_conta_mat_p;
								end if;
								
								--Relizado calculo aqui para contemplar os casos onde libera valor sem valor calculado e apresentado, pois nesse caso, nao popula o unitario liberado no item
								vl_lib_w	:= dividir_sem_round(vl_liberado_w,qt_liberada_w);
								if (qt_registros_w = 0) or (coalesce(param_1_p,'X') = 'R') or (qt_origem_conta_w > coalesce(qt_liberada_conta_w,0)) then
									vl_copartic_unit_w	:= ((coalesce( vl_lib_w,0) * tx_coparticipacao_w) / 100); -- Paulo OS 95779 - 06/06/2008
									vl_base_calculo_maximo_w	:= 0;
									vl_cobrado_copar_evento_max_w	:= 0;
									
									
									if (ie_incidencia_valor_maximo_w	= 'U') then
										vl_base_calculo_maximo_w	:= vl_copartic_unit_w;
									elsif (ie_incidencia_valor_maximo_w	= 'T') then
										vl_base_calculo_maximo_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
									elsif (ie_incidencia_valor_maximo_w	= 'M') then
										pls_consist_vl_max_copar_event(	nr_seq_conta_p,nr_seq_segurado_p,nr_seq_coparticipacao_w,
														dt_mes_competencia_w,ie_periodo_valor_maximo_w,
														((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100),
														vl_cobrado_copar_evento_max_w,vl_base_calculo_maximo_w);
									end if;
									
									
									if (vl_maximo_w > 0) and (vl_base_calculo_maximo_w > vl_maximo_w) then
										
										if (ie_incidencia_valor_maximo_w	= 'U') then
											vl_coparticipacao_w	:= (vl_maximo_w * qt_liberada_w);
										elsif (ie_incidencia_valor_maximo_w	= 'T') then
											vl_coparticipacao_w	:= vl_maximo_w;
										elsif (ie_incidencia_valor_maximo_w	= 'M') then
											if (vl_maximo_w > vl_cobrado_copar_evento_max_w) then
												vl_coparticipacao_w		:= vl_maximo_w - vl_cobrado_copar_evento_max_w;
											else
												vl_coparticipacao_w		:= 0;
											end if;
										end if;
										
										vl_copartic_unit_w	:= vl_maximo_w;
									else
										vl_coparticipacao_w	:= ((coalesce(vl_liberado_w,0) * tx_coparticipacao_w) / 100);
									end if;
									
									
									if (ie_diaria_w = 'P') then
										vl_coparticipacao_w	:= vl_copartic_unit_w * qt_copart_cobrar_w;
									end if;
									
									if (ie_gerar_copart_min_w = 'S') then
										vl_coparticipacao_w	:= vl_copartic_unit_w * qt_copart_cobrar_w;
									end if;
									
									if (nr_seq_conta_proc_p <> 0) then
										--if	(nvl(vl_coparticipacao_w,0) > 0) then 
											if (nr_seq_regra_exclusao_w <> 0) then
												vl_coparticipacao_w	:= 0;
												vl_copartic_unit_w	:= 0;
											else
												nr_seq_regra_exclusao_w	:= null;
											end if;
											
											-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
											if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
												 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
												
												insert	into	pls_conta_coparticipacao(	nr_sequencia, dt_atualizacao, nm_usuario,
														nr_seq_conta, nr_seq_conta_proc, tx_coparticipacao,
														vl_coparticipacao, nr_seq_regra, vl_coparticipacao_unit,
														nr_seq_regra_exclusao, ie_calculo_coparticipacao, vl_base_copartic,
														qt_liberada_copartic, vl_provisao, ie_origem_copartic,
														ie_status_mensalidade, nm_usuario_nrec, dt_atualizacao_nrec,
														ie_origem_regra, ie_status_coparticipacao, nr_seq_processo_copartic,
														nr_seq_disc_mat, nr_seq_disc_proc, ie_ato_cooperado, nr_seq_prestador_atend,
														nr_seq_prestador_exec, ie_tipo_prestador_atend, ie_tipo_prestador_exec,
														ie_tipo_guia, dt_mes_competencia, ie_tipo_segurado, ie_tipo_protocolo,
														nr_seq_protocolo, nr_seq_segurado, ie_preco,
														nr_seq_proc_rec, nr_seq_conta_rec, nr_seq_regra_preco_copart, ie_vl_pag_prestador)
													values (	nextval('pls_conta_coparticipacao_seq'), clock_timestamp(), nm_usuario_p,
														nr_seq_conta_p, nr_seq_conta_proc_p, tx_coparticipacao_w,
														vl_coparticipacao_w, nr_seq_coparticipacao_w, vl_copartic_unit_w,
														nr_seq_regra_exclusao_w, ie_calculo_coparticipacao_w, vl_unitario_w,
														qt_copart_cobrar_w, vl_coparticipacao_w, null,
														ie_status_mensalidade_item_w, nm_usuario_p, clock_timestamp(),
														ie_origem_regra_w, ie_status_coparticipacao_w, nr_seq_processo_copartic_w,
														nr_seq_disc_mat_p, nr_seq_disc_proc_p, ie_ato_cooperado_w, nr_seq_prestador_w,
														nr_seq_prestador_exec_w, ie_tipo_prestador_atend_w, ie_tipo_prestador_exec_w,
														ie_tipo_guia_w, dt_mes_competencia_w, ie_tipo_segurado_w, ie_tipo_protocolo_w,
														nr_seq_protocolo_w, nr_seq_segurado_p, ie_preco_w,
														nr_seq_conta_proc_w, nr_seq_conta_rec_p, nr_seq_regra_copartic_w, ie_vl_pag_prestador_w);
												
												update	pls_conta_proc
												set	vl_coparticipacao	= coalesce(vl_coparticipacao_w,0),
													ie_coparticipacao	= ie_liberado_w
												where	nr_sequencia		= nr_seq_conta_proc_p;
												
												vl_tot_copartic_w	:= coalesce(vl_tot_copartic_w,0) + coalesce(vl_coparticipacao_w,0);
											end if;
										--end if;
									elsif (nr_seq_conta_mat_p <> 0) then
										--if	(nvl(vl_coparticipacao_w,0) > 0) then
											if (nr_seq_regra_exclusao_w <> 0) then
												vl_coparticipacao_w	:= 0;
												vl_copartic_unit_w	:= 0;
											else
												nr_seq_regra_exclusao_w	:= null;
											end if;
											
											-- agora verifica se for copartcipacao de recurso, se for vai ainda validar se deve, conforme regras baseadas no tipo de valor que compoem a coparticipacao original
											if	((coalesce(ie_recurso_glosa_p, 'N') = 'N') or
												 ((coalesce(ie_recurso_glosa_p, 'N') = 'S') and (coalesce(ie_gerar_copart_rec_w, 'S') = 'S'))) then
												
												insert	into	pls_conta_coparticipacao(nr_sequencia, dt_atualizacao, nm_usuario,
														nr_seq_conta, nr_seq_conta_mat, tx_coparticipacao,
														vl_coparticipacao, nr_seq_regra, vl_coparticipacao_unit,
														nr_seq_regra_exclusao, ie_calculo_coparticipacao, vl_base_copartic,
														qt_liberada_copartic, vl_provisao, ie_origem_copartic,
														ie_status_mensalidade, nm_usuario_nrec, dt_atualizacao_nrec,
														ie_origem_regra, ie_status_coparticipacao, nr_seq_processo_copartic,
														nr_seq_disc_mat, nr_seq_disc_proc, ie_ato_cooperado, nr_seq_prestador_atend,
														nr_seq_prestador_exec, ie_tipo_prestador_atend, ie_tipo_prestador_exec,
														ie_tipo_guia, dt_mes_competencia, ie_tipo_segurado, ie_tipo_protocolo,
														nr_seq_protocolo, nr_seq_segurado, ie_preco,
														nr_seq_mat_rec, nr_seq_conta_rec, nr_seq_regra_preco_copart, ie_vl_pag_prestador)
													values (	nextval('pls_conta_coparticipacao_seq'), clock_timestamp(), nm_usuario_p,
														nr_seq_conta_p, nr_seq_conta_mat_p, tx_coparticipacao_w,
														vl_coparticipacao_w, nr_seq_coparticipacao_w, vl_copartic_unit_w,
														nr_seq_regra_exclusao_w, ie_calculo_coparticipacao_w, vl_unitario_w,
														qt_copart_cobrar_w, vl_coparticipacao_w, null,
														ie_status_mensalidade_item_w, nm_usuario_p, clock_timestamp(),
														ie_origem_regra_w, ie_status_coparticipacao_w, nr_seq_processo_copartic_w,
														nr_seq_disc_mat_p, nr_seq_disc_proc_p, ie_ato_cooperado_w, nr_seq_prestador_w,
														nr_seq_prestador_exec_w, ie_tipo_prestador_atend_w, ie_tipo_prestador_exec_w,
														ie_tipo_guia_w, dt_mes_competencia_w, ie_tipo_segurado_w, ie_tipo_protocolo_w,
														nr_seq_protocolo_w, nr_seq_segurado_p, ie_preco_w,
														nr_seq_conta_mat_w, nr_seq_conta_rec_p, nr_seq_regra_copartic_w, ie_vl_pag_prestador_w);
												
												update	pls_conta_mat
												set	vl_participacao		= coalesce(vl_coparticipacao_w,0),
													ie_coparticipacao	= ie_liberado_w
												where	nr_sequencia		= nr_seq_conta_mat_p;
												vl_tot_copartic_w	:= coalesce(vl_tot_copartic_w,0) + coalesce(vl_coparticipacao_w,0);
											end if;
										--end if;
									end if;
								end if;
							end if;
						end if;
					end if;
				end if;
				<<final>>
				nr_seq_coparticipacao_w	:= nr_seq_coparticipacao_w;
			
			end if;--Fim do if da regra de excecao
			
		end if; --
			
		end;
	end loop;
	close c01;
	
	if (ie_tipo_protocolo_w = 'R') then
		if (nr_seq_conta_proc_p <> 0) and (vl_tot_copartic_w > 0) then
				update	pls_conta_proc
				set	vl_coparticipacao	= vl_tot_copartic_w
				where	nr_sequencia		= nr_seq_conta_proc_p;
		elsif (nr_seq_conta_mat_p <> 0) and (vl_tot_copartic_w > 0) then
				update	pls_conta_mat
				set	vl_participacao		= vl_tot_copartic_w
				where	nr_sequencia		= nr_seq_conta_mat_p;
		end if;
	end if;
end if;

if (ie_tipo_protocolo_w = 'R') then
	if (nr_seq_conta_proc_p <> 0) then
		select 	coalesce(sum(vl_coparticipacao),0)
		into STRICT	vl_tot_coparticipacao_w
		from	pls_conta_proc
		where	nr_seq_conta	= nr_seq_conta_p;
	elsif (nr_seq_conta_mat_p <> 0) then
		select 	coalesce(sum(vl_participacao),0)
		into STRICT	vl_tot_coparticipacao_w
		from	pls_conta_mat
		where	nr_seq_conta	= nr_seq_conta_p;
	end if;
else
	select	coalesce(sum(vl_coparticipacao),0)
	into STRICT	vl_tot_coparticipacao_w
	from	pls_conta_coparticipacao
	where	nr_seq_conta	= nr_seq_conta_p;
end if;

update	pls_conta
set	vl_coparticipacao	= coalesce(vl_tot_coparticipacao_w,0)
where	nr_sequencia		= nr_seq_conta_p;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_coparticipacao (( nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_segurado_p pls_segurado.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type, nr_seq_plano_p pls_plano.nr_sequencia%type, nr_seq_contrato_p pls_contrato.nr_sequencia%type, nr_seq_intercambio_p bigint, dt_contratacao_p timestamp, qt_idade_p bigint, ie_titularidade_p text, param_1_p text, nr_seq_disc_mat_p pls_discussao_mat.nr_sequencia%type, nr_seq_disc_proc_p pls_discussao_proc.nr_sequencia%type, nr_seq_conta_rec_p pls_rec_glosa_conta.nr_sequencia%type, ie_recurso_glosa_p text default 'N') is cd_procedimento_w bigint) FROM PUBLIC;

