-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE sus_verifica_min_aih_prot ( nr_seq_protocolo_p protocolo_convenio.nr_seq_protocolo%type, nm_usuario_p usuario.nm_usuario%type, ds_mensagem_p INOUT text) AS $body$
DECLARE

				
ds_retorno_w			varchar(255) 	:= '';
qt_regra_w			bigint 	:= 0;
qt_proc_regra_w			bigint 	:= 0;
cd_estabelecimento_w		protocolo_convenio.cd_estabelecimento%type;
cd_procedimento_w		sus_regra_min_aih_prot.cd_procedimento%type;
ie_origem_proced_w		sus_regra_min_aih_prot.ie_origem_proced%type;
ie_complexidade_w		sus_regra_min_aih_prot.ie_complexidade%type;
ie_tipo_financiamento_w		sus_regra_min_aih_prot.ie_tipo_financiamento%type;
nr_seq_forma_org_w		sus_regra_min_aih_prot.nr_seq_forma_org%type;
nr_seq_grupo_w			sus_regra_min_aih_prot.nr_seq_grupo%type;
nr_seq_subgrupo_w		sus_regra_min_aih_prot.nr_seq_subgrupo%type;
nr_sequencia_w			sus_regra_min_aih_prot.nr_sequencia%type;
qt_minima_aih_w			sus_regra_min_aih_prot.qt_minima_aih%type;
cd_procedimento_princ_w		procedimento_paciente.cd_procedimento%type;
cd_proced_princ_conta_w		procedimento_paciente.cd_procedimento%type;
nr_interno_conta_w		conta_paciente.nr_interno_conta%type;
ds_regra_w			varchar(255) := '';
dt_periodo_inicial_w		conta_paciente.dt_periodo_inicial%type;

C01 CURSOR FOR
	SELECT	nr_sequencia,
		coalesce(cd_procedimento,0) cd_procedimento,
		coalesce(ie_origem_proced,0) ie_origem_proced,
		coalesce(ie_complexidade,0) ie_complexidade,
		coalesce(ie_tipo_financiamento,0) ie_tipo_financiamento,
		coalesce(nr_seq_forma_org,0) nr_seq_forma_org,
		coalesce(nr_seq_subgrupo,0) nr_seq_subgrupo,
		coalesce(nr_seq_grupo,0) nr_seq_grupo,
		coalesce(qt_minima_aih,0) qt_minima_aih
	from	sus_regra_min_aih_prot
	where	cd_estabelecimento = cd_estabelecimento_w
	and	ie_situacao = 'A'
	and	qt_minima_aih > 0
	order by	cd_procedimento,
		nr_seq_forma_org,
		nr_seq_subgrupo,
		nr_seq_grupo,
		ie_complexidade,
		ie_tipo_financiamento;
		
type 		fetch_array is table of c01%rowtype;
s_array 	fetch_array;
i		integer := 1;
type vetor is table of fetch_array index by integer;
vetor_c01_w			vetor;
		
C02 CURSOR FOR
	SELECT	coalesce(Sus_Obter_Proc_Aih_Unif(nr_interno_conta,2,'C'),0) cd_procedimento_princ,
		nr_interno_conta,
		dt_periodo_inicial
	from	conta_paciente
	where	nr_seq_protocolo = nr_seq_protocolo_p;
	
type 		fetch_array2 is table of c02%rowtype;
s_array2 	fetch_array2;
j		integer := 1;
type vetor2 is table of fetch_array2 index by integer;
vetor_c02_w			vetor2;

C03 CURSOR FOR
	SELECT	cd_procedimento
	from	procedimento_paciente
	where	nr_interno_conta = nr_interno_conta_w
	and	sus_obter_tiporeg_proc(cd_procedimento,ie_origem_proced,'C',2) = 3
	order by sus_obter_seq_ordem(nr_sequencia) desc;
				
BEGIN

delete from w_sus_proc_aih_prot
where nr_seq_protocolo = nr_seq_protocolo_p;

begin
select	cd_estabelecimento
into STRICT	cd_estabelecimento_w
from	protocolo_convenio
where	nr_seq_protocolo = nr_seq_protocolo_p;
exception
when others then
	cd_estabelecimento_w := 0;
end;

begin
select	count(1)
into STRICT	qt_regra_w
from	sus_regra_min_aih_prot
where	cd_estabelecimento = cd_estabelecimento_w
and	ie_situacao = 'A'
and	qt_minima_aih > 0  LIMIT 1;
exception
when others then
	qt_regra_w := 0;
end;

if (qt_regra_w > 0) then
	begin
	
	open c02;
	loop
	fetch c02 bulk collect into s_array2 limit 1000;
		vetor_c02_w(j) := s_array2;
		j := j + 1;
	EXIT WHEN NOT FOUND; /* apply on c02 */
	end loop;
	close c02;
	
	for j in 1..vetor_c02_w.count loop
		begin
		s_array2 := vetor_c02_w(j);
		for x in 1..s_array2.count loop
			begin			
			cd_procedimento_princ_w := s_array2[x].cd_procedimento_princ;
			nr_interno_conta_w	:= s_array2[x].nr_interno_conta;
			dt_periodo_inicial_w	:=  s_array2[x].dt_periodo_inicial;
			
			if (sus_validar_regra(nr_seq_regra_p => 11,cd_procedimento_p => cd_procedimento_princ_w,ie_origem_proced_p => 7,dt_competencia_p => dt_periodo_inicial_w) = 0) then
				begin

				insert into w_sus_proc_aih_prot(	
					nr_sequencia,
					dt_atualizacao,
					nm_usuario,
					dt_atualizacao_nrec,
					nm_usuario_nrec,
					nr_interno_conta,
					nr_seq_protocolo,
					cd_procedimento,
					ie_origem_proced)
				values (	nextval('w_sus_proc_aih_prot_seq'),
					clock_timestamp(),
					nm_usuario_p,
					clock_timestamp(),
					nm_usuario_p,
					nr_interno_conta_w,
					nr_seq_protocolo_p,
					cd_procedimento_princ_w,
					7);				
				
				end;
			else
				begin				
				
				open C03;
				loop
				fetch C03 into	
					cd_proced_princ_conta_w;
				EXIT WHEN NOT FOUND; /* apply on C03 */
				end loop;
				close C03;		
				
				insert into w_sus_proc_aih_prot(	
					nr_sequencia,
					dt_atualizacao,
					nm_usuario,
					dt_atualizacao_nrec,
					nm_usuario_nrec,
					nr_interno_conta,
					nr_seq_protocolo,
					cd_procedimento,
					ie_origem_proced)
				values (	nextval('w_sus_proc_aih_prot_seq'),
					clock_timestamp(),
					nm_usuario_p,
					clock_timestamp(),
					nm_usuario_p,
					nr_interno_conta_w,
					nr_seq_protocolo_p,
					cd_proced_princ_conta_w,
					7);
				
				end;
				
			end if;
			end;
		end loop;
		end;
	end loop;	
	
	commit;
	
	open c01;
	loop
	fetch c01 bulk collect into s_array limit 1000;
		vetor_c01_w(i) := s_array;
		i := i + 1;
	EXIT WHEN NOT FOUND; /* apply on c01 */
	end loop;
	close c01;
	
	for i in 1..vetor_c01_w.count loop
		begin
		s_array := vetor_c01_w(i);
		for z in 1..s_array.count loop
			begin
			
			nr_sequencia_w			:= s_array[z].nr_sequencia;
			cd_procedimento_w		:= s_array[z].cd_procedimento;
			ie_origem_proced_w		:= s_array[z].ie_origem_proced;
			ie_complexidade_w		:= s_array[z].ie_complexidade;
			ie_tipo_financiamento_w		:= s_array[z].ie_tipo_financiamento;
			nr_seq_forma_org_w		:= s_array[z].nr_seq_forma_org;
			nr_seq_subgrupo_w		:= s_array[z].nr_seq_subgrupo;
			nr_seq_grupo_w			:= s_array[z].nr_seq_grupo;
			qt_minima_aih_w			:= s_array[z].qt_minima_aih;
			
			select	count(1)
			into STRICT	qt_proc_regra_w
			from	w_sus_proc_aih_prot a,
				sus_procedimento c,
				sus_forma_organizacao d,
				sus_subgrupo e,
				sus_grupo f
			where	a.nr_seq_protocolo	= nr_seq_protocolo_p
			and 	a.cd_procedimento	= c.cd_procedimento
			and	a.ie_origem_proced	= c.ie_origem_proced
			and	c.nr_seq_forma_org	= d.nr_sequencia
			and	d.nr_seq_subgrupo	= e.nr_sequencia
			and	e.nr_seq_grupo		= f.nr_sequencia
			and	((cd_procedimento_w = 0) or (a.cd_procedimento = cd_procedimento_w))
			and	((ie_origem_proced_w = 0) or (a.ie_origem_proced = ie_origem_proced_w))
			and	((ie_complexidade_w = 0) or (c.ie_complexidade = ie_complexidade_w))
			and	((ie_tipo_financiamento_w = 0) or (c.ie_tipo_financiamento = ie_tipo_financiamento_w))
			and	((nr_seq_forma_org_w = 0) or (d.nr_sequencia = nr_seq_forma_org_w))
			and	((nr_seq_subgrupo_w = 0) or (e.nr_sequencia = nr_seq_subgrupo_w))
			and	((nr_seq_grupo_w = 0) or (f.nr_sequencia = nr_seq_grupo_w));
			
			if (qt_minima_aih_w > qt_proc_regra_w) then
				begin
				ds_regra_w := substr(ds_regra_w || nr_sequencia_w || ',',1,255);
				end;
			end if;
			
			end;
		end loop;
		end;
	end loop;
	
	if (coalesce(ds_regra_w,'X') <> 'X') then
		begin
		ds_mensagem_p := wheb_mensagem_pck.get_texto(328853,'NR_SEQ_REGRA='||substr(ds_regra_w,1,length(ds_regra_w)-1));		
		end;
	end if;
	
	end;
else
	ds_mensagem_p	:= '';
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE sus_verifica_min_aih_prot ( nr_seq_protocolo_p protocolo_convenio.nr_seq_protocolo%type, nm_usuario_p usuario.nm_usuario%type, ds_mensagem_p INOUT text) FROM PUBLIC;

