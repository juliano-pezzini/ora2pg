-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pfcs_calc_available_device ( nr_seq_indicator_p bigint, cd_estabelecimento_p text, nm_usuario_p text) AS $body$
DECLARE


	qt_total_device					bigint := 0;
	nr_seq_operational_level_w  	pfcs_operational_level.nr_sequencia%type;
	pfcs_panel_detail_seq_w			pfcs_panel_detail.nr_sequencia%type;
	nr_seq_panel_w					pfcs_panel_detail.nr_seq_panel%type;
	pfcs_flag_settings          	bigint := 0;

	ie_started_status 				varchar(5) :='S';
	ie_finished_status 				varchar(5) :='F';
    ie_matching_status				varchar(5) := 'S';
	
	ds_dev_unknown_status			varchar(15) := 'UNKNOWN';
	ds_dev_inactive_status			varchar(15) := 'INACTIVE';
  	ds_tl_dev_type 					varchar(10) := 'TL';
	ds_monitor_dev_type 			varchar(10) := 'Monitor';

	c01_from_pfcs CURSOR FOR
		SELECT dev.id_device cd_equipamento,
			dev.ds_device_name ds_equipamento
		from pfcs_device dev
		where 
			dev.si_status in (ds_dev_unknown_status, ds_dev_inactive_status)
			and dev.ds_device_type = ds_monitor_dev_type 
			and dev.nr_seq_organization = (cd_estabelecimento_p)::numeric;

	c01_from_tasy CURSOR FOR
		SELECT eq.cd_equipamento cd_equipamento,
			eq.ds_equipamento ds_equipamento
		from equipamento eq
		where eq.ie_tipo_equipamento = ds_tl_dev_type
			and eq.cd_estabelecimento = (cd_estabelecimento_p)::numeric
			and eq.cd_equipamento not in (
				SELECT distinct uae.cd_equipamento
				from
					unidade_atend_equip uae,
					equipamento eq,
					setor_atendimento sa,
					atend_paciente_unidade apu,
					cpoe_recomendacao cr,
					tipo_recomendacao tr,
					atendimento_paciente ap
				where uae.cd_equipamento = eq.cd_equipamento
					and eq.cd_estabelecimento = (cd_estabelecimento_p)::numeric 
					and uae.cd_setor_atendimento = sa.cd_setor_atendimento
					and apu.nr_atendimento         = apu.nr_atendimento
					and apu.cd_unidade_basica    = uae.cd_unidade_basica
					and apu.cd_setor_atendimento = uae.cd_setor_atendimento
					and apu.cd_unidade_compl     = uae.cd_unidade_compl
					and apu.nr_atendimento         = cr.nr_atendimento
					and cr.cd_recomendacao = tr.cd_tipo_recomendacao
					and apu.nr_atendimento =  ap.nr_atendimento
					and coalesce(ap.dt_alta_medico::text, '') = ''
					and apu.dt_saida_unidade is  null
					and (
						pfcs_get_recommendation_status(cr.nr_sequencia) = ie_started_status
						or pfcs_get_recommendation_status(cr.nr_sequencia) = ie_finished_status)
					and tr.ie_telemetria = ie_matching_status);

	
BEGIN

	nr_seq_operational_level_w := pfcs_get_structure_level(
										cd_establishment_p => cd_estabelecimento_p,
										ie_level_p => 'O',
										ie_info_p => 'C');

	select ie_table_origin into STRICT pfcs_flag_settings
	from pfcs_general_rule;

	if (pfcs_flag_settings = 0 or pfcs_flag_settings = 2)
	then
		qt_total_device := pfcs_get_tele_total_device(ds_tl_dev_type, 'A', cd_estabelecimento_p);

		for r_c01 in c01_from_tasy loop
			select 	nextval('pfcs_panel_detail_seq') into STRICT pfcs_panel_detail_seq_w
			;

			insert into pfcs_panel_detail(
				nr_sequencia,
				nm_usuario,
				dt_atualizacao,
				nm_usuario_nrec,
				dt_atualizacao_nrec,
				ie_situation,
				nr_seq_indicator,
				nr_seq_operational_level)
			values (
				pfcs_panel_detail_seq_w,
				nm_usuario_p,
				clock_timestamp(),
				nm_usuario_p,
				clock_timestamp(),
				'T',
				nr_seq_indicator_p,
				nr_seq_operational_level_w);

			insert into pfcs_detail_device(
				nr_sequencia,
				dt_atualizacao,
				nm_usuario,
				dt_atualizacao_nrec,
				nm_usuario_nrec,
				cd_equipamento,
				ds_device,
				nr_seq_detail)
			values (
				nextval('pfcs_detail_device_seq'),
				clock_timestamp(),
				nm_usuario_p,
				clock_timestamp(),
				nm_usuario_p,
				r_c01.cd_equipamento,
				r_c01.ds_equipamento,
				pfcs_panel_detail_seq_w);

		end loop;
		 := pfcs_pck.pfcs_generate_results(
			vl_indicator_p => qt_total_device, ds_reference_value_p => '', nr_seq_indicator_p => nr_seq_indicator_p, nr_seq_operational_level_p => nr_seq_operational_level_w, nm_usuario_p => nm_usuario_p, nr_seq_panel_p => nr_seq_panel_w);

		CALL pfcs_pck.pfcs_update_detail(
			nr_seq_indicator_p => nr_seq_indicator_p,
			nr_seq_panel_p => nr_seq_panel_w,
			nr_seq_operational_level_p => nr_seq_operational_level_w,
			nm_usuario_p => nm_usuario_p);
	end if;

	if (pfcs_flag_settings = 1 or pfcs_flag_settings = 2)
	then

		qt_total_device := pfcs_get_tele_device_from_intg(ds_monitor_dev_type, 'A', cd_estabelecimento_p);

		for r_c01 in c01_from_tasy loop
			select 	nextval('pfcs_panel_detail_seq') into STRICT pfcs_panel_detail_seq_w
			;

			insert into pfcs_panel_detail(
				nr_sequencia,
				nm_usuario,
				dt_atualizacao,
				nm_usuario_nrec,
				dt_atualizacao_nrec,
				ie_situation,
				nr_seq_indicator,
				nr_seq_operational_level)
			values (
				pfcs_panel_detail_seq_w,
				nm_usuario_p,
				clock_timestamp(),
				nm_usuario_p,
				clock_timestamp(),
				'T',
				nr_seq_indicator_p,
				nr_seq_operational_level_w);

			insert into pfcs_detail_device(
				nr_sequencia,
				dt_atualizacao,
				nm_usuario,
				dt_atualizacao_nrec,
				nm_usuario_nrec,
				cd_equipamento,
				ds_device,
				nr_seq_detail)
			values (
				nextval('pfcs_detail_device_seq'),
				clock_timestamp(),
				nm_usuario_p,
				clock_timestamp(),
				nm_usuario_p,
				r_c01.cd_equipamento,
				r_c01.ds_equipamento,
				pfcs_panel_detail_seq_w);

		end loop;
		 := pfcs_pck.pfcs_generate_results(
			vl_indicator_p => qt_total_device, ds_reference_value_p => '', nr_seq_indicator_p => nr_seq_indicator_p, nr_seq_operational_level_p => nr_seq_operational_level_w, nm_usuario_p => nm_usuario_p, nr_seq_panel_p => nr_seq_panel_w);

		CALL pfcs_pck.pfcs_update_detail(
			nr_seq_indicator_p => nr_seq_indicator_p,
			nr_seq_panel_p => nr_seq_panel_w,
			nr_seq_operational_level_p => nr_seq_operational_level_w,
			nm_usuario_p => nm_usuario_p);
	end if;
	commit;

	CALL pfcs_pck.pfcs_activate_records(
		nr_seq_indicator_p => nr_seq_indicator_p,
		nr_seq_operational_level_p => nr_seq_operational_level_w,
		nm_usuario_p => nm_usuario_p);

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pfcs_calc_available_device ( nr_seq_indicator_p bigint, cd_estabelecimento_p text, nm_usuario_p text) FROM PUBLIC;

