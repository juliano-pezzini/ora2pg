-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE gerar_eis_saldo_estoque ( dt_parametro_p timestamp, cd_estabelecimento_p bigint, nm_usuario_p text) AS $body$
DECLARE


cd_local_estoque_w			smallint;
cd_grupo_material_w			smallint;
cd_subgrupo_material_w			smallint;
cd_classe_material_w			integer;
cd_material_w				integer;
dt_mes_ref_w				timestamp;
dt_referencia_w				timestamp;
qt_consumo_w				double precision;
qt_estoque_w				double precision;
qt_estoque_medio_w			double precision;
vl_custo_medio_w				double precision;
vl_giro_w					double precision;
vl_estoque_w				double precision;
vl_consumo_w				double precision;
vl_estoque_medio_W			double precision;
ie_padronizado_w				varchar(1);
ie_ressuprimento_w				varchar(1);
ie_curva_abc_w				varchar(1);
qt_maximo_w				    double precision;
qt_estoque_maximo_ww  			  double precision;
vl_estoque_maximo_w			double precision;
vl_excedente_w				double precision := 0;
vl_estoque_calc_max_w			double precision := 0;
qt_estoque_geral_w			double precision := 0;
vl_estoque_geral_w				double precision := 0;
qt_existe_w				bigint;
nr_sequencia_w				bigint;
cd_estabelecimento_w			estabelecimento.cd_estabelecimento%type;

/*Materiais com estoque*/

C01 CURSOR FOR
SELECT	distinct
	cd_material
from	saldo_estoque
where	cd_estabelecimento	= cd_estabelecimento_w
and	dt_mesano_referencia	= dt_mes_ref_w
order by cd_material;

/*Locais de estoque e o saldo*/

C02 CURSOR FOR
SELECT	distinct
	cd_local_estoque,
	coalesce(qt_estoque_medio,0),
	coalesce(qt_estoque,0),
	coalesce(vl_estoque,0)
from	saldo_estoque
where	cd_estabelecimento	= cd_estabelecimento_w
and	dt_mesano_referencia	= dt_mes_ref_w
and	cd_material		= cd_material_w;

C00 CURSOR FOR
SELECT	PKG_DATE_UTILS.start_of(dt_parametro_p,'MONTH', 0) dt_mes


union all

select	PKG_DATE_UTILS.ADD_MONTH(PKG_DATE_UTILS.start_of(dt_parametro_p,'MONTH', 0),-1,0) dt_mes

where (upper(nm_usuario_p) = 'TASY')
and (PKG_DATE_UTILS.start_of(dt_parametro_p,'dd', 0) = PKG_DATE_UTILS.start_of(clock_timestamp(),'MONTH', 0)) /* Atualizar o mes anterior se for pela job e primeiro dia do mes*/
order by dt_mes asc;

C03 CURSOR FOR
SELECT	cd_estabelecimento
from	estabelecimento
where	cd_estabelecimento = cd_estabelecimento_p

union all

select	a.cd_estabelecimento
from	estabelecimento a
where	a.ie_situacao = 'A'
and	cd_estabelecimento_p = 0
and	exists (select 	1
		from	parametro_estoque x
		where	x.cd_estabelecimento = a.cd_estabelecimento
		and	x.ie_situacao = 'A');



BEGIN

--insert into log_xxxtasy values (sysdate, nm_usuario_p, 601, 'SaldoEstoque');
nr_sequencia_w := Gravar_Log_Indicador(549, wheb_mensagem_pck.get_texto(305702), clock_timestamp(), PKG_DATE_UTILS.start_of(dt_parametro_p,'dd', 0), nm_usuario_p, nr_sequencia_w);

open C03;
loop
fetch C03 into
	cd_estabelecimento_w;
EXIT WHEN NOT FOUND; /* apply on C03 */

	open C00;
	loop
	fetch C00 into
		dt_mes_ref_w;
	EXIT WHEN NOT FOUND; /* apply on C00 */
		begin
		delete	FROM eis_saldo_estoque
		where	cd_estabelecimento	= cd_estabelecimento_w
		and	dt_referencia		= dt_mes_ref_w
		and	ie_periodo		= 'M';

		open C01;
		loop
		fetch C01 into
			cd_material_w;
		EXIT WHEN NOT FOUND; /* apply on C01 */
			begin
			select	cd_grupo_material,
				cd_subgrupo_material,
				cd_classe_material
			into STRICT	cd_grupo_material_w,
				cd_subgrupo_material_w,
				cd_classe_material_w
			from	estrutura_material_v
			where	cd_material = cd_material_w;

			select	substr(obter_se_material_padronizado(cd_estabelecimento_w, cd_material_w),1,1),
				substr(obter_se_mat_ressuprimento(cd_estabelecimento_w, cd_material_w),1,1),
				substr(obter_curva_abc_estab(cd_estabelecimento_w, cd_material_w, null, dt_mes_ref_w),1,1),
				coalesce(obter_mat_estabelecimento(cd_estabelecimento_w, cd_estabelecimento_w, cd_material_w, 'MA'),0)
			into STRICT	ie_padronizado_w,
				ie_ressuprimento_w,
				ie_curva_abc_w,
				qt_maximo_w
			;

				open C02;
				loop
				fetch C02 into
					cd_local_estoque_w,
					qt_estoque_medio_w,
					qt_estoque_w,
					vl_estoque_w;
				EXIT WHEN NOT FOUND; /* apply on C02 */
					begin

					select	round((obter_custo_medio_material(cd_estabelecimento_w, dt_mes_ref_w, cd_material_w))::numeric,4)
					into STRICT	vl_custo_medio_w
					;

					vl_estoque_medio_w		:= round((qt_estoque_medio_w * vl_custo_medio_w)::numeric, 2);
					vl_estoque_maximo_w		:= 0;
					vl_estoque_calc_max_w		:= 0;

					select	sum(qt_estoque),
						sum(vl_estoque)
					into STRICT	qt_estoque_geral_w,
						vl_estoque_geral_w
					from	saldo_estoque
					where	cd_estabelecimento	= cd_estabelecimento_w
					and	dt_mesano_referencia	= dt_mes_ref_w
					and	cd_material		= cd_material_w;

				      begin
					qt_estoque_maximo_ww :=	qt_estoque_w / 	qt_estoque_geral_w * qt_maximo_w;
				      exception
				      when others then
					qt_estoque_maximo_ww	:= 0;
				      end;

					vl_estoque_maximo_w 	:= round((qt_estoque_maximo_ww * vl_custo_medio_w)::numeric,4);

					if (coalesce(qt_estoque_geral_w,0) > coalesce(qt_estoque_maximo_ww,0)) and	/*Se o estoque é maior que o maximo*/
						(coalesce(qt_estoque_maximo_ww,0) > 0) and			/*Se o qt_maximo_ressup maior zero*/
						(ie_padronizado_w = 'S') and			/*Se o material é padronizado*/
						(ie_ressuprimento_w = 'S') then		/*Se o material é de ressuprimento*/
						vl_estoque_calc_max_w	:= vl_estoque_w - vl_estoque_maximo_w;
					end if;


					select	sum(qt_consumo),
						sum(vl_consumo)
					into STRICT	qt_consumo_w,
						vl_consumo_w
					from	movto_estoque_operacao_v
					where	dt_mesano_referencia = dt_mes_ref_w
					and	cd_estabelecimento = cd_estabelecimento_w
					and	cd_material = cd_material_w
					and	cd_local_estoque = cd_local_estoque_w;

					select	count(*)
					into STRICT	qt_existe_w
					from	eis_saldo_estoque
					where	cd_estabelecimento	= cd_estabelecimento_w
					and	dt_referencia		= dt_mes_ref_w

					and	cd_material		= cd_material_w
					and	cd_local_estoque = cd_local_estoque_w;

					if (qt_existe_w > 0) then
						vl_estoque_calc_max_w	:= 0;
					end if;

					insert into eis_saldo_estoque(
						nr_sequencia,
						dt_atualizacao,
						nm_usuario,
						cd_estabelecimento,
						dt_referencia,
						cd_local_estoque,
						ie_periodo,
						qt_estoque,
						vl_estoque,
						vl_estoque_calc_max,
						vl_estoque_medio,
						vl_consumo,
						cd_subgrupo_material,
						cd_grupo_material,
						cd_classe_material,
						cd_material,
						ie_padronizado,
						ie_curva_abc,
						vl_estoque_maximo)
					values (	nextval('eis_estoque_seq'),
						clock_timestamp(),
						nm_usuario_p,
						cd_estabelecimento_w,
						dt_mes_ref_w,
						cd_local_estoque_w,
						'M',
						qt_estoque_w,
						vl_estoque_w,
						vl_estoque_calc_max_w,
						vl_estoque_medio_w,
						vl_consumo_w,
						cd_subgrupo_material_w,
						cd_grupo_material_w,
						cd_classe_material_w,
						cd_material_w,
						coalesce(ie_padronizado_w,'N'),
						ie_curva_abc_w,
						round((vl_estoque_maximo_w)::numeric,2));
					end;
				end loop;
				close C02;
		end;
		end loop;
		close C01;
		end;
	end loop;
	close C00;

	CALL gerar_estoque_excedente(PKG_DATE_UTILS.start_of(dt_parametro_p,'MONTH', 0),cd_estabelecimento_w,nm_usuario_p);
	CALL Atualizar_Log_Indicador(clock_timestamp(), nr_sequencia_w);

	commit;

end loop;
close C03;

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE gerar_eis_saldo_estoque ( dt_parametro_p timestamp, cd_estabelecimento_p bigint, nm_usuario_p text) FROM PUBLIC;

