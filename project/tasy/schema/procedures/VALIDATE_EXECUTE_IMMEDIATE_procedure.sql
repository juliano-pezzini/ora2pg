-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE validate_execute_immediate ( ds_object_p text) AS $body$
DECLARE


/*
Esta procedure pode ser usada para validar outras procedures que usem a get_procedure_call junto com execute immediate.
Para fazer isso, ela usa principalmente instr, substr e replaces, portanto ela pode não conseguir validar as sintaxes mais criativas.
*/
object_body 	text := ds_object_p;
object_header	varchar(32000);
object_name		varchar(32000);
base_index		bigint := 1;
end_index		bigint := 1;
full_stm		varchar(32000);
variables		varchar(32000);
name_start		bigint;
has_params		boolean;

max_loops		bigint := 100;
i				bigint := 0;
proc_call		varchar(32000);
proc_params		varchar(32000);
result_call		varchar(32000);

c01 CURSOR FOR
	SELECT	text
	from	user_errors
	where	name = object_name
	order by sequence;

error_line	c01%rowtype;
error_text	varchar(32000) := '';


BEGIN
--Isola o cabeçalho da procedure sendo validada
object_header := substr(object_body, 1, position('begin' in object_body) - 1);
has_params := position('(' in object_header) > 0;

--Isolar o nome da procedure sendo validada
if (has_params) then
	object_name := substr(object_body, position('procedure ' in object_header), position('(' in object_header));
else
	object_name := substr(object_body, position('procedure ' in object_header) + 10, instr(object_header, ' ', position('procedure ' in object_header) + 10) - (position('procedure ' in object_header) + 10));
end if;

--Define o nome da cópia de validação
object_name := upper(substr('VALIDATE_' || object_name, 1, 30));
object_body := replace(object_body, object_name, object_name);

--Itera sobre todas as ocorrências de 'execute immediate get_procedure_call'
while instr(object_body, 'execute immediate get_procedure_call', base_index) > 0 loop
	begin
	--Isola a primeira ocorrência encontrada
	base_index := instr(object_body, 'execute immediate get_procedure_call', base_index);
	end_index := instr(object_body, ';', base_index) + 1;
	full_stm := substr(object_body, base_index, end_index - base_index);

	--Isola somente a chamada da get_procedure_call
	proc_call := substr(full_stm, position('get_procedure_call' in full_stm), position(')' in full_stm) - position('get_procedure_call' in full_stm) + 1);

	--Executa  a chamada e armazena o reusltado na result_call
	EXECUTE 'begin :result_call := ' || proc_call || '; end;' using out result_call;

	--Se tiver parâmetros de entrada, isola eles também
	if (position('using ' in full_stm) > 0) then
		variables := substr(full_stm, position('using ' in full_stm) + 6, end_index - position('using ' in full_stm));
		variables := trim(both ';' from variables);
	end if;

	--Se o retoron for vazio, ao invés de uma chamada de procedure, ele vai conter uma variável 'dummy' . Nesse caso, não faz nada
	if (position('dummy' in result_call) <= 0) then
		result_call := regexp_replace(result_call, '\(.*\)', '(' || variables || ')');
		object_body := replace(object_body, full_stm, result_call);
	end if;

	--Faz um safeguard anti loop infinito
	i := i + 1;
	if (i >= max_loops) then
		exit;
	end if;
	end;
end loop;

begin
	--Compila o novo objeto na base
	EXECUTE to_char(object_body);
exception when others then
	--Obtém os erros, se houver
	open c01;
	loop
	fetch c01 into
		error_line;
	EXIT WHEN NOT FOUND; /* apply on c01 */
		begin
		error_text := error_text || error_line.text;
		end;
	end loop;
	close c01;

	--Dropa a cópia de validação
	EXECUTE 'drop procedure ' || object_name;

	--Exibe os erros para o usuário, através de um ra*ise
	CALL wheb_mensagem_pck.exibir_mensagem_abort('Validation error: ' || chr(13) || chr(10) || error_text);
end;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE validate_execute_immediate ( ds_object_p text) FROM PUBLIC;

