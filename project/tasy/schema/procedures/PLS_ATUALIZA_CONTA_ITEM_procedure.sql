-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_atualiza_conta_item ( nr_seq_item_p bigint, ie_tipo_item_p text, nr_seq_motivo_glosa_p bigint, vl_unitario_p bigint, vl_liberado_p INOUT bigint, vl_glosa_p bigint, vl_saldo_p bigint, vl_prestador_p bigint, qt_liberada_p bigint, ds_observacao_p text, ie_origem_p text, cd_estabelecimento_p bigint, nm_usuario_p text, ie_commit_p text, vl_pag_medico_conta_p bigint, ie_conta_inteira_p text, ie_tipo_liberacao_p text, ie_gerar_analise_aud_p text, vl_lib_hi_p bigint, vl_lib_material_p bigint, vl_lib_co_p bigint, vl_lib_taxa_hi_p bigint, vl_lib_taxa_mat_p bigint, vl_lib_taxa_co_p bigint) AS $body$
DECLARE


/*
ie_tipo_item_p
	'M' - Mat/Med/OPM/Gases
	'P' - Proc/Taxa/Diaria
	'R' - Participante
*/


/*
ie_origem_p
	'C' - Contas medicas
	'A' - Analise de contas medicas
*/


/*ie_tipo_liberacao_p
	'A' - Apresentado
	'C' - Calculado
	* por default este valor sera como calculado o mesmo serve para na hora da geracao dos pagamentos verificar a origem da liberacao e ajustar o valor que sera pago ao prestador
*/

/*Criado para que ao atualizar o status de pagamento pela analise nao seja atribuido  o status liberado pelo usuario ao item Diogo*/

ds_observacao_w			varchar(4000);
dt_inicio_proc_w		varchar(255);
cd_guia_referencia_w		varchar(20);
cd_motivo_tiss_w		varchar(10);
ie_valor_informado_w		varchar(10);
ie_tipo_conta_w			varchar(10);
ie_via_acesso_inf_w		varchar(5);
ie_via_acesso_w			varchar(5);
ie_status_pagamento_w		varchar(5);
ie_cobranca_pos_w		varchar(3);
ie_tipo_liberacao_p_w		varchar(3);
ie_analise_cm_nova_w		varchar(3);
ie_glosa_w			varchar(3);
ie_excluir_fat_w		varchar(3)	:= 'S';
ie_status_w			varchar(2);
ie_repassa_medico_w		varchar(2);
ie_gerar_analise_audit_w	varchar(2) := 	'N';
ie_calcula_preco_benef_w	varchar(1);
ie_preco_co_operadora_w		varchar(1);
ie_cobranca_prevista_inter_w	varchar(1);
ie_atualiza_apresentado_w	varchar(1);
ie_via_acesso_regra_w		varchar(1);
ie_via_acesso_imp_w		varchar(1);
ie_origem_conta_w		varchar(1);
ie_vl_calculado_glosa_w		varchar(1);
ie_valor_base_w			varchar(1);
qt_apresentada_w		double precision;
vl_glosa_w			double precision	:= 0;
tx_ajuste_benef_lib_w		double precision;
vl_prestador_w			double precision;
vl_taxa_co_imp_w		double precision;
vl_taxa_material_imp_w		double precision;
vl_taxa_servico_imp_w		double precision;
qt_liberada_p_w			double precision;
vl_apresentado_w		double precision;
vl_beneficiario_w		double precision	:= 0;
vl_calculado_w			double precision;
vl_pag_medico_conta_w		double precision;
vl_liberado_w			double precision;
vl_original_medico_w		double precision;
vl_diferenca_w			double precision;
vl_participante_w		double precision;
vl_calculado_ww			double precision;
vl_total_partic_w		double precision;
vl_custo_operacional_w		double precision;
vl_filme_w			double precision;
vl_procedimento_w		double precision;
vl_apresentado_proc_w		double precision;
vl_lib_w			double precision;
vl_unitario_p_w			pls_conta_proc.vl_unitario%type;
vl_liberado_p_w			double precision;
vl_glosa_p_w			double precision;
vl_saldo_p_w			double precision;
vl_pag_medico_conta_p_w		double precision;
vl_taxa_servico_w		double precision;
vl_taxa_material_w		double precision;
vl_taxa_co_w			double precision;
vl_taxa_intercambio_imp_w	double precision;
vl_taxa_intercambio_w		double precision;
vl_liberado_hi_w		double precision;
vl_liberado_co_w		double precision;
vl_liberado_material_w		double precision;
vl_glosa_hi_w			double precision;
vl_glosa_co_w			double precision;
vl_glosa_material_w		double precision;
vl_calc_hi_util_w		double precision;
vl_calc_co_util_w		double precision;
vl_calc_mat_util_w		double precision;
vl_total_lib_partic_w		double precision;
vl_total_glosa_partic_w		double precision;
vl_medico_original_w		double precision;
vl_procedimento_imp_w		double precision;
vl_unitario_imp_w		double precision;
vl_unitario_calc_w		double precision;
vl_unitario_w			double precision;
vl_base_w			double precision;
vl_diferenca_apres_w		double precision;
vl_apresentado_ww		double precision;
qt_procedimento_imp_w		double precision;
nr_seq_conta_w			bigint;
nr_seq_protocolo_w		bigint;
nr_seq_prestador_w		bigint;
nr_seq_regra_pos_estab_w	bigint;
nr_seq_segurado_w		bigint;
nr_seq_contrato_w		bigint;
nr_seq_intercambio_w		bigint;
nr_seq_lote_sip_w		bigint;
nr_seq_lote_w			bigint;
qt_glosa_inter_taxa_w		bigint;
nr_seq_pos_stab_w		bigint;
nr_seq_conta_proc_w		bigint;
nr_seq_prestador_ww		bigint;
nr_seq_analise_w		bigint;
nr_seq_honorario_w		bigint;
qt_procedimento_w		bigint;
nr_seq_conta_proc_aux_w		bigint;
cd_procedimento_w		bigint;
nr_seq_regra_via_acesso_w	bigint;
nr_seq_conta_aux_w		bigint;
ie_origem_proced_w		integer;
qt_part_glosado_w		integer;
qt_part_liberado_w		integer;
qt_part_parcial_w		integer;
dt_procedimento_w		timestamp;
vl_base_hi_w			double precision;
vl_base_mat_w			double precision;
vl_base_co_w			double precision;
vl_procedimento_ptu_imp_w	double precision;
vl_co_ptu_imp_w			double precision;
vl_material_ptu_imp_w		double precision;
ie_via_acesso_gerada_w		varchar(255)	:= 'N';
vl_dif_w			double precision	:= 0;
vl_lib_taxa_servico_w		double precision;
vl_lib_taxa_material_w		double precision;
vl_lib_taxa_co_w		double precision;
vl_glosa_taxa_servico_w		double precision	:= 0;
vl_glosa_taxa_material_w	double precision	:= 0;
vl_glosa_taxa_co_w		double precision 	:= 0;
vl_tot_partic_w			double precision	:= 0;
ie_atualiza_via_acesso_w	varchar(2);
ie_permite_maior_apres_w	varchar(2);
qt_via_acesso_w			integer;
vl_exame_coleta_w		pls_conta_proc.vl_exame_coleta%type;
nr_seq_exame_coleta_w		pls_conta_proc.nr_seq_exame_coleta%type;
ie_via_acesso_manual_w		pls_conta_proc.ie_via_acesso_manual%type;
qt_partic_param_w		integer;
dados_intercambio_w		pls_cta_alt_valor_pck.dados_vl_tx_libe;
qt_grupos_audit_w		integer;
ie_tipo_protocolo_w		pls_protocolo_conta.ie_tipo_protocolo%type;
nr_seq_regra_acao_reemb_w	bigint;
nr_seq_conta_mat_w		pls_conta_mat.nr_sequencia%type;
tx_intercambio_imp_w		pls_conta_proc.tx_intercambio_imp%type;
tx_intercambio_w		pls_conta_proc.tx_intercambio%type;
vl_glosa_final_w		pls_conta_proc.vl_glosa%type;
vl_total_apres_w		pls_conta_proc.vl_procedimento_imp%type;
vl_total_lib_partic_ww		double precision;
ie_tipo_despesa_w		pls_conta_proc.ie_tipo_despesa%type;

C01 CURSOR FOR
	SELECT	a.nr_sequencia,
		a.ie_via_acesso,
		a.ie_via_acesso_imp,
		a.nr_seq_regra_via_acesso,
		a.ie_via_acesso_manual
	from	pls_conta_proc	a,
		pls_conta	b
	where	b.nr_sequencia	= a.nr_seq_conta
	and	((b.cd_guia_referencia			= cd_guia_referencia_w)
	or (b.cd_guia				= cd_guia_referencia_w))
	and	b.nr_seq_segurado			= nr_seq_segurado_w
	and	to_char(a.dt_inicio_proc,'hh24:mi:ss')	= dt_inicio_proc_w
	and	trunc(dt_procedimento,'dd')		= dt_procedimento_w
	and	b.ie_status				not in ('F')
	and	coalesce(b.nr_seq_analise,0)			= coalesce(nr_seq_analise_w,0);

C02 CURSOR FOR
	SELECT	nr_sequencia
	from	pls_conta
	where	((nr_seq_analise = nr_seq_analise_w) or (nr_sequencia = nr_seq_conta_w ))
	order by 1;
	

BEGIN
select	coalesce(ie_calculo_base_glosa, 'N'),
	coalesce(ie_via_acesso_regra, 'N'),
	coalesce(ie_atualiza_via_acesso,'N')
into STRICT	ie_vl_calculado_glosa_w,
	ie_via_acesso_regra_w,
	ie_atualiza_via_acesso_w
from	pls_parametros
where	cd_estabelecimento = cd_estabelecimento_p;

ds_observacao_w		:= coalesce(ds_observacao_p,'');

select	count(1)
into STRICT	qt_via_acesso_w
from	pls_tipo_via_acesso;

begin
ie_gerar_analise_audit_w	:= coalesce(ie_gerar_analise_aud_p, 'N');
	select	cd_motivo_tiss
	into STRICT	cd_motivo_tiss_w
	from	tiss_motivo_glosa
	where	nr_sequencia	= nr_seq_motivo_glosa_p;
exception
when others then
	cd_motivo_tiss_w	:= 0;
end;

select	coalesce(max(ie_analise_cm_nova), 'N')
into STRICT	ie_analise_cm_nova_w
from	pls_parametros
where	cd_estabelecimento	= cd_estabelecimento_p;

/* Francisco - OS 530164 - 13/12/2012 */

if (ie_analise_cm_nova_w = 'S') and (ie_origem_p = 'A') then
	ie_excluir_fat_w	:= 'N';
end if;

ie_permite_maior_apres_w	:= obter_parametro_funcao(1365,21, nm_usuario_p);

ie_status_pagamento_w	:= null;
if (coalesce(nr_seq_item_p,0) <> 0) and (ie_tipo_item_p = 'P') then
	nr_seq_pos_stab_w	:= 0;
	vl_prestador_w		:= 0;
	
	select	coalesce(vl_procedimento_imp,0),
		coalesce(qt_procedimento_imp,0),
		coalesce(vl_procedimento,0),
		coalesce(vl_taxa_servico_imp,0),
		coalesce(vl_taxa_servico,0),
		coalesce(vl_taxa_material_imp,0),
		coalesce(vl_taxa_material,0),
		coalesce(vl_taxa_co_imp,0),
		coalesce(vl_taxa_co,0),
		coalesce(vl_calc_hi_util,0),
		coalesce(vl_calc_co_util,0),
		coalesce(vl_calc_mat_util,0),
		coalesce(vl_medico_original,0),
		nr_seq_conta,
		coalesce(vl_beneficiario,0),
		coalesce(nr_seq_regra_pos_estab,0),
		ie_valor_informado,
		ie_status,
		to_char(dt_inicio_proc,'hh24:mi:ss'),
		trunc(dt_procedimento,'dd'),
		cd_procedimento,
		ie_origem_proced,
		coalesce(vl_procedimento_ptu_imp,0),
		coalesce(vl_co_ptu_imp,0),
		coalesce(vl_material_ptu_imp,0),
		coalesce(vl_exame_coleta,0),
		nr_seq_exame_coleta
	into STRICT	vl_apresentado_w,
		qt_apresentada_w,
		vl_calculado_w,
		vl_taxa_servico_imp_w,
		vl_taxa_servico_w,
		vl_taxa_material_imp_w,
		vl_taxa_material_w,
		vl_taxa_co_imp_w,
		vl_taxa_co_w,
		vl_calc_hi_util_w,
		vl_calc_co_util_w,
		vl_calc_mat_util_w,
		vl_medico_original_w,
		nr_seq_conta_w,
		vl_beneficiario_w,
		nr_seq_regra_pos_estab_w,
		ie_valor_informado_w,
		ie_status_w,
		dt_inicio_proc_w,
		dt_procedimento_w,
		cd_procedimento_w,
		ie_origem_proced_w,
		vl_procedimento_ptu_imp_w,
		vl_co_ptu_imp_w,
		vl_material_ptu_imp_w,
		vl_exame_coleta_w,
		nr_seq_exame_coleta_w
	from	pls_conta_proc
	where	nr_sequencia	= nr_seq_item_p;
	
	select	coalesce(max(ie_calculo_pos_estab), 'O')
	into STRICT	ie_cobranca_pos_w
	from	pls_parametros
	where	cd_estabelecimento	= cd_estabelecimento_p;
	
	select	nr_seq_protocolo,
		nr_seq_segurado,
		ie_tipo_conta,
		coalesce(cd_guia,cd_guia_referencia),
		ie_origem_conta,
		nr_seq_analise
	into STRICT	nr_seq_protocolo_w,
		nr_seq_segurado_w,
		ie_tipo_conta_w,
		cd_guia_referencia_w,
		ie_origem_conta_w,
		nr_seq_analise_w
	from	pls_conta
	where	nr_sequencia	= nr_seq_conta_w;
	
	ie_gerar_analise_audit_w	:= pls_obter_conta_item_auditoria(nr_seq_conta_w);
	
	--OS758314

	--Esse if e devido a possibilidade de serem inseridos grupos de auditoria manualmente

	--Quando  a glosa nao estava vinculada a uma ocorrencia(O que faz com que  nao fosse gerada

	--auditoria e grupos auditores eram inseridos manualmente e algum deles mantivesse uma glosa, 

	--o fechamnto da conta nao se tornava possivel, devido ao valor de glosa nao ser propagado para as 

	--tabelas pls_conta_proc e pls_conta_mat)
	if (ie_gerar_analise_audit_w = 'N') then
	
		select	count(1)
		into STRICT	qt_grupos_audit_w
		from	pls_auditoria_conta_grupo a
		where 	a.nr_seq_analise = nr_seq_analise_w;
		
		if (qt_grupos_audit_w > 0) then
			ie_gerar_analise_audit_w := 'S';
		end if;
	
	end if;

	select	nr_seq_prestador,
		ie_tipo_protocolo
	into STRICT	nr_seq_prestador_w,
		ie_tipo_protocolo_w
	from	pls_protocolo_conta
	where	nr_sequencia	= nr_seq_protocolo_w;

	select	max(nr_seq_contrato),
		max(nr_seq_intercambio)
	into STRICT	nr_seq_contrato_w,
		nr_seq_intercambio_w
	from	pls_segurado
	where	nr_sequencia	= nr_seq_segurado_w;
	if (nr_seq_contrato_w IS NOT NULL AND nr_seq_contrato_w::text <> '') then
		/* Obter dados do contrato */

		select	max(ie_preco_co_operadora)
		into STRICT	ie_preco_co_operadora_w
		from	pls_contrato
		where	nr_sequencia	= nr_seq_contrato_w;
	elsif (nr_seq_intercambio_w IS NOT NULL AND nr_seq_intercambio_w::text <> '') then
		/*Obter dados contrato de intercambio*/

		select  max(ie_preco_co_operadora)
		into STRICT	ie_cobranca_prevista_inter_w
		from 	pls_intercambio
		where	nr_sequencia 	= nr_seq_intercambio_w;
	end if;

	/* Felipe OS 195231 - Alterei para N, pois para os precos reprocessados pela tabela da operadora NAO pode ser alterado o valor do beneficiario */

	ie_calcula_preco_benef_w	:= pls_obter_dados_conta(nr_seq_conta_w, 'CPO');
	if (ie_tipo_conta_w not in ('I', 'C')) then
		if	((ie_calcula_preco_benef_w = 'S') and
			((ie_preco_co_operadora_w = 'N') or (ie_cobranca_prevista_inter_w = 'N')) and (ie_cobranca_pos_w in ('C', 'P', 'O')))then
			vl_beneficiario_w	:= coalesce(vl_liberado_p,0);
		end if;
	end if;

	vl_taxa_intercambio_imp_w	:= vl_taxa_servico_imp_w + vl_taxa_material_imp_w + vl_taxa_co_imp_w;
	vl_taxa_intercambio_w		:= vl_taxa_servico_w + vl_taxa_material_w + vl_taxa_co_w;

	/*Quando o item for liberado na conta medica as glosa e ocorrencias devem ser inativadas OS 498506*/

	if (coalesce(ie_origem_p, 'C') = 'C') and
		((coalesce(ie_analise_cm_nova_w, 'N') = 'N') or (coalesce(nr_seq_analise_w::text, '') = ''))then
		
		if (cd_motivo_tiss_w <> 0) then
		
			update 	pls_conta_glosa
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
			where	nr_seq_conta_proc	= nr_seq_item_p;
			
			update 	pls_ocorrencia_benef
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
			where	nr_seq_conta_proc	= nr_seq_item_p;
			
			-- Alterada as glosas geradas por essa rotina para SCE, pois quando as  nao sao executadas na OPS  a rotina nao as gravava na consitencia da conta 
			CALL pls_gravar_conta_glosa(cd_motivo_tiss_w, null, nr_seq_item_p,
						null, 'S', ds_observacao_p,
						nm_usuario_p,'A','SCE',
						nr_seq_prestador_w, cd_estabelecimento_p,'',null);
						
		elsif (vl_liberado_p < vl_apresentado_w) then
			
			update 	pls_conta_glosa
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta_proc	= nr_seq_item_p;
			
			update 	pls_ocorrencia_benef
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta_proc	= nr_seq_item_p;
			
		elsif (vl_liberado_p >= vl_apresentado_w) then
		
			update 	pls_conta_glosa
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
			where	nr_seq_conta_proc	= nr_seq_item_p;
			
			update 	pls_ocorrencia_benef
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
			where	nr_seq_conta_proc	= nr_seq_item_p;
			
		end if;
		
	elsif (coalesce(ie_origem_p,'C') = 'C') and (coalesce(ie_analise_cm_nova_w,'N') = 'S') and (nr_seq_analise_w IS NOT NULL AND nr_seq_analise_w::text <> '') then
		
		if (vl_liberado_p >= vl_apresentado_w) then
			update 	pls_conta_glosa	a
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
			where	nr_seq_conta_proc	= nr_seq_item_p
			and	exists (SELECT	1
					from	tiss_motivo_glosa	x
					where	x.nr_sequencia	= a.nr_seq_motivo_glosa
					and	x.cd_motivo_tiss in ('1705','9919'));
			
			update	pls_ocorrencia_benef	a
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END 
			where	a.nr_seq_conta_proc	= nr_seq_item_p
			and	exists (SELECT	1
					from	pls_conta_glosa	x,
						tiss_motivo_glosa	y
					where	y.nr_sequencia		= x.nr_seq_motivo_glosa
					and	x.nr_seq_conta_proc	= nr_seq_item_p
					and	a.nr_seq_glosa		= x.nr_sequencia
					and	y.cd_motivo_tiss in ('1705','9919'));
			
		end if;
	end if;

	select	coalesce(ie_atualizar_valor_apresent, 'N')
	into STRICT	ie_atualiza_apresentado_w
	from 	pls_parametros
	where	cd_estabelecimento	= cd_estabelecimento_p;
	
	/*377170	- Robson da Silva - caso fique o mesmovalor do prestador pode ser o valor calculado, e nesta situacao ira pegar quando tiver glosa e tera que aceitar um valor o valor deve mudar para o valor correspondente */


	/*desccontado o valor do pagamento ao medico*/

	vl_prestador_w	:= coalesce(vl_prestador_p,0);
	
	if (coalesce(vl_prestador_p,0)	<> coalesce(vl_liberado_p,0)) then
		vl_prestador_w	:= vl_liberado_p;
	end if;
	
	if (coalesce(vl_prestador_w,0) = 0 ) and (coalesce(vl_calculado_w,0) > 0)then
		vl_prestador_w	:= vl_calculado_w;
	end if;
	
	if (ie_origem_p = 'C') or (coalesce(ie_analise_cm_nova_w, 'N') = 'S') then
		ie_status_w	:= 'L';
	else
		ie_status_w 	:= ie_status_w;
	end if;

	/*Os 335736 - Adicionado o "vl_prestador = nvl(vl_liberado_p,0)," pra aque ao ser aceito valor em um item que nao possue valor calculado o prestador receba totalmente pelo procedimento*/

	
	if	((coalesce(ie_gerar_analise_audit_w, 'N') = 'S') and (ie_origem_p <> 'C')) or
		((ie_origem_p = 'C') or (coalesce(ie_analise_cm_nova_w, 'N') = 'S')) then
		vl_unitario_p_w		:= coalesce(vl_unitario_p, 0);
		vl_liberado_p_w		:= coalesce(vl_liberado_p, 0);
		vl_glosa_p_w		:= coalesce(vl_glosa_p, 0);
		vl_saldo_p_w		:= coalesce(vl_saldo_p, 0);
		qt_liberada_p_w		:= coalesce(qt_liberada_p, 0);
		ie_tipo_liberacao_p_w	:= coalesce(ie_tipo_liberacao_p, 'C');
		
		if (coalesce(vl_pag_medico_conta_p, 0) = 0) then
			vl_pag_medico_conta_p_w	:= dividir_sem_round(vl_liberado_p,vl_calculado_w) * vl_medico_original_w;
		else
			vl_pag_medico_conta_p_w	:= coalesce(vl_pag_medico_conta_p, 0);
		end if;
		
		if (vl_lib_hi_p > 0) or (vl_lib_material_p > 0) or (vl_lib_co_p > 0) then
			if (vl_procedimento_ptu_imp_w > 0) then
				vl_base_hi_w	:= vl_procedimento_ptu_imp_w;
			else
				vl_base_hi_w	:= vl_calc_hi_util_w;
			end if;
			
			if (vl_co_ptu_imp_w > 0) then
				vl_base_co_w	:= vl_co_ptu_imp_w;
			else
				vl_base_co_w	:= vl_calc_co_util_w;
			end if;
			
			if (vl_material_ptu_imp_w > 0) then
				vl_base_mat_w	:= vl_material_ptu_imp_w;
			else
				vl_base_mat_w	:= vl_calc_mat_util_w;
			end if;
			
			vl_liberado_hi_w		:= coalesce(vl_lib_hi_p,0);
			vl_liberado_co_w		:= coalesce(vl_lib_co_p,0);
			vl_liberado_material_w		:= coalesce(vl_lib_material_p,0);
			
			if (coalesce(vl_lib_taxa_hi_p::text, '') = '') or (coalesce(vl_lib_taxa_mat_p::text, '') = '') or (coalesce(vl_lib_taxa_co_p::text, '') = '') then
				vl_lib_taxa_servico_w		:= vl_taxa_servico_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
				vl_lib_taxa_material_w		:= vl_taxa_material_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
				vl_lib_taxa_co_w		:= vl_taxa_co_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
			else
				vl_lib_taxa_servico_w		:= vl_lib_taxa_hi_p;
				vl_lib_taxa_material_w		:= vl_lib_taxa_mat_p;
				vl_lib_taxa_co_w		:= vl_lib_taxa_co_p;
			end if;
			
				
		else
			select	vl_procedimento,
				vl_procedimento_imp,
				qt_procedimento_imp,
				ie_valor_base,
				vl_unitario_imp,
				tx_intercambio_imp,
				tx_intercambio
			into STRICT	vl_procedimento_w,
				vl_procedimento_imp_w,
				qt_procedimento_imp_w,
				ie_valor_base_w,
				vl_unitario_imp_w,
				tx_intercambio_imp_w,
				tx_intercambio_w
			from	pls_conta_proc
			where	nr_sequencia	= nr_seq_item_p;
				
			if	(((ie_valor_base_w = '1') and (coalesce(ie_tipo_liberacao_p::text, '') = '')) or (ie_tipo_liberacao_p	= 'A') or (coalesce(vl_calc_hi_util_w,0) = 0 and
				coalesce(vl_calc_mat_util_w,0) = 0 and
				coalesce(vl_calc_co_util_w,0) = 0 and
				coalesce(vl_taxa_servico_w,0) = 0 and
				coalesce(vl_taxa_material_w,0) = 0 and
				coalesce(vl_taxa_co_w,0) = 0)) and (ie_tipo_conta_w 	= 'I') then
				vl_liberado_hi_w		:= vl_liberado_p_w * dividir_sem_round(vl_procedimento_ptu_imp_w,vl_procedimento_imp_w);
				vl_liberado_co_w		:= vl_liberado_p_w * dividir_sem_round(vl_co_ptu_imp_w,vl_procedimento_imp_w);
				vl_liberado_material_w		:= vl_liberado_p_w * dividir_sem_round(vl_material_ptu_imp_w,vl_procedimento_imp_w);
				vl_lib_taxa_servico_w		:= vl_taxa_servico_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
				vl_lib_taxa_material_w		:= vl_taxa_material_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
				vl_lib_taxa_co_w		:= vl_taxa_co_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
			elsif (ie_valor_base_w = '4') and (ie_tipo_conta_w = 'I') then
				--Quanto da regra ser aceitar o valor apresentado e glosa a taxa de intercambio
				vl_liberado_hi_w	:= vl_liberado_p_w * dividir_sem_round(vl_procedimento_ptu_imp_w,vl_procedimento_imp_w);
				vl_liberado_co_w	:= vl_liberado_p_w * dividir_sem_round(vl_co_ptu_imp_w,vl_procedimento_imp_w);
				vl_liberado_material_w	:= vl_liberado_p_w * dividir_sem_round(vl_material_ptu_imp_w,vl_procedimento_imp_w);
				vl_lib_taxa_servico_w	:= 0;
				vl_lib_taxa_material_w	:= 0;
				vl_lib_taxa_co_w	:= 0;
				
				vl_liberado_p_w		:= coalesce(vl_liberado_hi_w,0) + coalesce(vl_liberado_co_w,0) + coalesce(vl_liberado_material_w,0);
				
			else
			--Necessario realizar o tratamento abaixo para contas de intercambio, devido a nao ser possivel liberar um valor superior ao valor apresentado OS 703323 tratado em conexao com o consultor Valmir
				if (ie_tipo_conta_w	= 'I') then
					dados_intercambio_w := pls_cta_alt_valor_pck.pls_calc_vl_lib_vl_calc( coalesce(vl_procedimento_ptu_imp_w,0), coalesce(vl_material_ptu_imp_w,0),
											coalesce(vl_co_ptu_imp_w,0), coalesce(vl_taxa_servico_imp_w,0), coalesce(vl_taxa_material_imp_w,0),
											coalesce(vl_taxa_co_imp_w,0), coalesce(vl_calc_hi_util_w,0), coalesce(vl_calc_mat_util_w,0),
											coalesce(vl_calc_co_util_w,0), coalesce(vl_taxa_servico_w,0), coalesce(vl_taxa_material_w,0),
											coalesce(vl_taxa_co_w,0), tx_intercambio_imp_w, tx_intercambio_w);
					-- calculo das glosas

					-- se der valor negativo, a glosa e sempre zero
					
					vl_liberado_co_w	:= dados_intercambio_w.vl_liberado_co;
					vl_liberado_hi_w	:= dados_intercambio_w.vl_liberado_hi;
					vl_liberado_material_w	:= dados_intercambio_w.vl_liberado_mat;
					vl_lib_taxa_co_w	:= dados_intercambio_w.vl_lib_taxa_co;
					vl_lib_taxa_servico_w	:= dados_intercambio_w.vl_lib_taxa_hi;
					vl_lib_taxa_material_w	:= dados_intercambio_w.vl_lib_taxa_mat;
						
					if (coalesce(vl_liberado_hi_w,0) > 0) then	
						vl_liberado_hi_w		:= dividir((vl_liberado_p_w * vl_liberado_hi_w),vl_procedimento_w);
					end if;

				
					if (coalesce(vl_liberado_co_w,0) > 0)then
						vl_liberado_co_w		:= dividir((vl_liberado_p_w * vl_liberado_co_w),vl_procedimento_w);
					end if;
					
					if (coalesce(vl_liberado_material_w,0) > 0) then
						vl_liberado_material_w		:= dividir((vl_liberado_p_w * vl_liberado_material_w),vl_procedimento_w);
					end if;
					
					if (coalesce(vl_lib_taxa_servico_w,0) > 0) then
						vl_lib_taxa_servico_w	:= dividir((vl_liberado_p_w * vl_lib_taxa_servico_w ),vl_procedimento_w);
					end if;
				
					if (coalesce(vl_lib_taxa_material_w,0) > 0) then
						vl_lib_taxa_material_w	:= dividir((vl_liberado_p_w * vl_lib_taxa_material_w ),vl_procedimento_w);
							
					end if;
					
					if (coalesce(vl_lib_taxa_co_w,0) > 0) then
						vl_lib_taxa_co_w :=  dividir((vl_liberado_p_w * vl_lib_taxa_co_w ),vl_procedimento_w);
				
					end if;	
					
				else	
					if (vl_calc_hi_util_w > vl_procedimento_ptu_imp_w) and (coalesce(vl_procedimento_ptu_imp_w,0) > 0) then	
						vl_liberado_hi_w		:= vl_liberado_p_w * dividir_sem_round(vl_procedimento_ptu_imp_w,vl_procedimento_imp_w);
					else
						vl_liberado_hi_w		:= coalesce(vl_lib_hi_p, vl_liberado_p_w) * dividir_sem_round(vl_calc_hi_util_w,vl_calculado_w);
					end if;
				
					if (vl_calc_co_util_w > vl_co_ptu_imp_w) and (coalesce(vl_co_ptu_imp_w,0) > 0)then
						vl_liberado_co_w		:= vl_liberado_p_w * dividir_sem_round(vl_co_ptu_imp_w,vl_procedimento_imp_w);
					else
						vl_liberado_co_w		:= vl_liberado_p_w * dividir_sem_round(vl_calc_co_util_w,vl_calculado_w);
					end if;
					
					if (vl_calc_mat_util_w > vl_material_ptu_imp_w) and (coalesce(vl_material_ptu_imp_w,0) > 0) then
						vl_liberado_material_w		:= vl_liberado_p_w * dividir_sem_round(vl_material_ptu_imp_w,vl_procedimento_imp_w);
					else
						vl_liberado_material_w		:= vl_liberado_p_w * dividir_sem_round(vl_calc_mat_util_w,vl_calculado_w);
					end if;
					
					if (vl_taxa_servico_w > vl_taxa_servico_imp_w) and (coalesce(vl_taxa_servico_imp_w,0) > 0) then
						vl_lib_taxa_servico_w	:= vl_taxa_servico_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
					else
						vl_lib_taxa_servico_w	:= vl_taxa_servico_w * dividir_sem_round(vl_liberado_p_w,vl_calculado_w);
					end if;
					
					if (vl_taxa_material_w > vl_taxa_material_imp_w) and (coalesce(vl_taxa_material_imp_w,0) > 0) then
						vl_lib_taxa_material_w	:= vl_taxa_material_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
					else
						vl_lib_taxa_material_w	:= vl_taxa_material_w * dividir_sem_round(vl_liberado_p_w,vl_calculado_w);
					end if;
					
					if (vl_taxa_co_w > vl_taxa_co_imp_w) and (coalesce(vl_taxa_co_imp_w,0) > 0) then
						vl_lib_taxa_co_w := vl_taxa_co_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
				
					else
						vl_lib_taxa_co_w := vl_taxa_co_w * dividir_sem_round(vl_liberado_p_w,vl_calculado_w);
				
					end if;
				end if;
			end if;
		end if;
		
		vl_dif_w := 	(coalesce(vl_lib_taxa_servico_w,0) + coalesce(vl_lib_taxa_material_w,0) + coalesce(vl_lib_taxa_co_w,0) +
				coalesce(vl_liberado_hi_w,0) + coalesce(vl_liberado_material_w,0) + coalesce(vl_liberado_co_w,0)) - coalesce(vl_liberado_p_w,0);
					
		if (vl_dif_w > 0) then
			if (coalesce(vl_liberado_hi_w,0) > vl_dif_w) then
				vl_liberado_hi_w	:= vl_liberado_hi_w - vl_dif_w;
			elsif (coalesce(vl_liberado_co_w,0) > vl_dif_w) then
				vl_liberado_co_w	:= vl_liberado_co_w - vl_dif_w;
			elsif (coalesce(vl_liberado_material_w,0) > vl_dif_w) then
				vl_liberado_material_w	:= vl_liberado_material_w - vl_dif_w;
			end if;
		elsif (vl_dif_w < 0) then
			vl_dif_w := vl_dif_w * -1; --Criado esse tratamento para tornar a diferenca positiva, caso contrario vai subtrair quando deveria somar
		
			if (coalesce(vl_liberado_hi_w,0) > 0) then
				vl_liberado_hi_w	:= vl_liberado_hi_w + vl_dif_w;
			elsif (coalesce(vl_liberado_co_w,0) > 0) then
				vl_liberado_co_w	:= vl_liberado_co_w + vl_dif_w;
			elsif (coalesce(vl_liberado_material_w,0) > 0) then
				vl_liberado_material_w	:= vl_liberado_material_w + vl_dif_w;
			end if;
		end if;
		
		/*Glosas sempre sao pelo valor apresentado, nao precisa ter valor base */

		if (vl_procedimento_ptu_imp_w > 0) or (vl_co_ptu_imp_w > 0) or (vl_material_ptu_imp_w > 0) then
			vl_glosa_hi_w			:= vl_procedimento_ptu_imp_w - coalesce(vl_liberado_hi_w,0);
			
			vl_glosa_co_w			:= vl_co_ptu_imp_w - coalesce(vl_liberado_co_w,0);
			vl_glosa_material_w		:= vl_material_ptu_imp_w - coalesce(vl_liberado_material_w,0);
		else
			vl_glosa_hi_w			:= vl_glosa_p_w * dividir_sem_round(vl_calc_hi_util_w,vl_calculado_w);
			
			vl_glosa_co_w			:= vl_glosa_p_w * dividir_sem_round(vl_calc_co_util_w,vl_calculado_w);
			vl_glosa_material_w		:= vl_glosa_p_w * dividir_sem_round(vl_calc_mat_util_w,vl_calculado_w);
		end if;
		
		if (vl_glosa_hi_w < 0) then
			vl_glosa_hi_w	:= 0;
		end if;
		
		if (vl_glosa_co_w < 0) then
			vl_glosa_co_w	:= 0;
		end if;
		
		if (vl_glosa_material_w < 0) then
			vl_glosa_material_w	:= 0;
		end if;
		
		if (ie_origem_p = 'A') then
			ie_glosa_w	:= 'N';
			
			if (vl_liberado_p_w = 0) and (vl_glosa_p_w > 0) then
				ie_glosa_w	:= 'S';
			end if;
			
			if (vl_calculado_w = 0) and (vl_apresentado_w = 0) then
				ie_glosa_w	:= 'S';
			elsif (vl_calculado_w > 0) and (vl_liberado_p_w = 0) and (vl_apresentado_w = 0) then
				ie_glosa_w	:= 'S';
			end if;
				
			/* Atualizar status de pagamento */

			if (ie_glosa_w = 'S') then
				ie_status_pagamento_w	:= 'G';
			else
				if (vl_liberado_p_w > 0) and (vl_glosa_p_w = 0) then
					ie_status_pagamento_w	:= 'L';
				else
					ie_status_pagamento_w	:= 'P';
				end if;
			end if;
		end if;
		
		if	((ie_origem_p = 'A') and (ie_tipo_liberacao_p <> 'A') and (coalesce(ie_analise_cm_nova_w, 'N') = 'S')) then
			
			update	pls_conta_proc
			set	ie_glosa = ie_glosa_w
			where	nr_sequencia = nr_seq_item_p;
			
			if (ie_atualiza_via_acesso_w = 'S') and (qt_via_acesso_w > 0) then
				/*Conforme tratado em reuniao com o Sr. Decio e o Sr. Adriano, foi recriado o tratamento para que a via de acesso seja atualziado automaticamente quando o item sofrer alguma acao
				para isto o parametro devera estar como 'S' e devera haver ao menos uma regra de via de acesso cadastrada Dgkorz*/
				
				open C01;
				loop
				fetch C01 into	
					nr_seq_conta_proc_aux_w,
					ie_via_acesso_w,
					ie_via_acesso_imp_w,
					nr_seq_regra_via_acesso_w,
					ie_via_acesso_manual_w;
				EXIT WHEN NOT FOUND; /* apply on C01 */
					begin
					ie_via_acesso_gerada_w	:= 'S';
					ie_via_acesso_inf_w	:= 'S';
					
					if (coalesce(ie_origem_conta_w, 'D') = 'E') and (ie_via_acesso_regra_w = 'S') then
						if (coalesce(ie_via_acesso_w, 'X') = coalesce(ie_via_acesso_imp_w, 'X')) and (not ie_via_acesso_manual_w	= 'S')then
							ie_via_acesso_inf_w	:= 'N';
						end if;
					end if;
					if (ie_via_acesso_inf_w = 'N') or (coalesce(nr_seq_regra_via_acesso_w,0) > 0 )then
						update	pls_conta_proc
						set	ie_via_acesso		 = NULL,
							nr_seq_regra_via_acesso	 = NULL,
							tx_item			= 100,
							nr_seq_proc_ref		 = NULL
						where	nr_sequencia		= nr_seq_conta_proc_aux_w;
					end if;
					end;
				end loop;
				close C01;
				
				/*
				ATENCAO!! NAO TIRAR ESSE COMENTARIO!!
				Esse rotina e chamada a cada vez que glosa um item na analise, para internacao e inviavel
				Adriano peidu para falar com ele caso seja necessario alterar, e nunca sera nesse processo, sera no fechar conta.
				*/
				open C02;
				loop
				fetch C02 into	
					nr_seq_conta_aux_w;
				EXIT WHEN NOT FOUND; /* apply on C02 */
					begin
					CALL pls_consiste_procedimento(nr_seq_conta_aux_w, 'CC', nm_usuario_p, cd_estabelecimento_p);
					CALL pls_atualizar_via_acesso_conta(nr_seq_conta_aux_w, nm_usuario_p);
					CALL pls_recalcular_conta(nr_seq_conta_aux_w, nm_usuario_p, 'G', 'S','N',null,null);
					end;
				end loop;
				close C02;
			end if;
			
			select	coalesce(vl_procedimento,0),
				coalesce(vl_procedimento_imp,0),
				qt_procedimento_imp,
				ie_valor_base,
				vl_unitario_imp
			into STRICT	vl_procedimento_w,
				vl_procedimento_imp_w,
				qt_procedimento_imp_w,
				ie_valor_base_w,
				vl_unitario_imp_w
			from	pls_conta_proc
			where	nr_sequencia	= nr_seq_item_p;
			
			vl_unitario_calc_w	:= dividir_sem_round(vl_procedimento_w, qt_procedimento_imp_w);
			
			if (ie_valor_base_w = '1') then
				--vl_base_w		:= vl_procedimento_imp_w;
				vl_unitario_w		:= vl_unitario_imp_w;
			else
				--vl_base_w		:= vl_procedimento_w;
				vl_unitario_w		:= vl_unitario_calc_w;
			end if;
			
			if (vl_procedimento_imp_w > 0) then
				vl_base_w	:= vl_procedimento_imp_w;
			else
				vl_base_w	:= vl_procedimento_w;
			end if;
	
			if (coalesce(ie_glosa_w,'L') <> 'S') then
				if (coalesce(ie_analise_cm_nova_w,'N') = 'S') and (ie_origem_p = 'A') then
					vl_unitario_w	:= vl_unitario_p_w;
				end if;
			--Retirei o tratamento abaixo devido a estar gerando divergencias quando da acao de aceitar o valor apresentado dgkorz OS 715119	

			--	if	(ie_tipo_liberacao_p != 'AV') then

			--		vl_liberado_p_w	:= nvl(qt_liberada_p,0) * vl_unitario_w;

			--	end if;

				
				/*verifica no parametro se permite  aceitar o valor maior que o apresentado  drquadros O.S. 643116 */

				if (coalesce(ie_permite_maior_apres_w,'N') <> 'S')	then
					if (ie_valor_base_w = 1) and (coalesce(vl_liberado_p_w,0) <> coalesce(vl_procedimento_imp_w,0)) and (coalesce(vl_procedimento_imp_w,0) > 0) and (coalesce(vl_liberado_p_w,0) > coalesce(vl_procedimento_imp_w,0))then
						vl_liberado_p_w	:= vl_procedimento_imp_w;
					end if;
				end if;
					
				vl_glosa_p_w	:= vl_base_w - vl_liberado_p_w;
			else
				if (vl_procedimento_imp_w = 0 ) and (ie_vl_calculado_glosa_w = 'S') then
					vl_glosa_p_w	:= vl_procedimento_w - vl_liberado_p_w;					
				else
					vl_glosa_p_w	:= vl_procedimento_imp_w - vl_liberado_p_w;
				end if;
				
			end if;
			
			if (vl_glosa_p_w < 0) then
				vl_glosa_p_w	:= 0;
			end if;
		end if;


	--	if	(ie_origem_p = 'C') then
			vl_dif_w := 0;
			update	pls_proc_participante		
			set	vl_participante		= dividir((vl_liberado_p_w * vl_calculado),vl_calculado_w),
				vl_glosa		= CASE WHEN vl_glosa_p_w=0 THEN 0  ELSE 1 END  * vl_calculado,
				qt_liberada		= coalesce(qt_liberada_p,0),
				ie_status		= ie_status_w,
				ie_glosa		= CASE WHEN ie_glosa_w = NULL THEN ie_glosa  ELSE ie_glosa_w END ,
				ie_status_pagamento	= coalesce(ie_status_pagamento_w,ie_status_pagamento)
			where	nr_seq_conta_proc	= nr_seq_item_p
			and (coalesce(ie_gerada_cta_honorario::text, '') = '' or ie_gerada_cta_honorario = 'N')
			and (coalesce(ie_status::text, '') = '' or ie_status <> 'C');
			
			begin
				select	sum(vl_participante)
				into STRICT	vl_tot_partic_w
				from	pls_proc_participante
				where	nr_seq_conta_proc	= nr_seq_item_p
				and (coalesce(ie_gerada_cta_honorario::text, '') = '' or ie_gerada_cta_honorario = 'N')
				and (coalesce(ie_status::text, '') = '' or ie_status <> 'C');
			exception
			when others then
				vl_tot_partic_w := 0;
			end;
			
			if (vl_tot_partic_w > vl_liberado_p_w) and (vl_liberado_p_w > 0) then
				vl_dif_w := vl_tot_partic_w - vl_liberado_p_w;
				
				update	pls_proc_participante		
				set	vl_participante		= (vl_participante - vl_dif_w)
				where	nr_seq_conta_proc	= nr_seq_item_p
				and (coalesce(ie_gerada_cta_honorario::text, '') = '' or ie_gerada_cta_honorario = 'N')
				and (coalesce(ie_status::text, '') = '' or ie_status <> 'C')
				and	nr_sequencia = (SELECT 	max(nr_sequencia)
							from	pls_proc_participante
							where	nr_seq_conta_proc	= nr_seq_item_p
							and (coalesce(ie_gerada_cta_honorario::text, '') = '' or ie_gerada_cta_honorario = 'N')
							and (coalesce(ie_status::text, '') = '' or ie_status <> 'C')
							and	vl_participante > vl_dif_w);
			end if;

		
		ie_glosa_w	:= null;

		/* Francisco - 16/04/2013 - Unifiquei o IF das analises e tirei o tratamento de via de acesso
		pois nao atualizava o IE_GLOSA em alguns casos */
		if (ie_origem_p = 'A') then
			ie_glosa_w	:= 'N';
			
			if (vl_liberado_p_w = 0) and (vl_glosa_p_w > 0) then
				ie_glosa_w	:= 'S';
			end if;
			
			if (vl_calculado_w = 0) and (vl_apresentado_w = 0) then
				ie_glosa_w	:= 'S';
			end if;
			
			if (vl_calculado_w > 0) and (vl_apresentado_w = 0) and (qt_liberada_p_w = 0) then
				ie_glosa_w	:= 'S';
			end if;
			/* Atualizar status de pagamento */

			if (ie_glosa_w = 'S') then
				ie_status_pagamento_w	:= 'G';
			else
				if (vl_liberado_p_w > 0) and (vl_glosa_p_w = 0) then
					ie_status_pagamento_w	:= 'L';
				elsif (vl_liberado_p_w = 0) and (vl_glosa_p_w = 0) then
					ie_status_pagamento_w	:= 'G';
				else
					ie_status_pagamento_w	:= 'P';
				end if;
			end if;
		end if;
		
		if (vl_glosa_p_w < 0) then
			vl_glosa_p_w := 0;
		end if;
		
		if (ie_glosa_w		= 'S') and (vl_exame_coleta_w	> 0)   then
			nr_seq_exame_coleta_w	:= null;
			vl_exame_coleta_w	:= 0;
		end if;
		--Retirado o vl provisao e o ie_origem_provisao na OS 696733 conforme tratado com Paulo Rosa apos a geracao do mesmo o valor do mesmo deve ser mantido dgkorz
		update	pls_conta_proc		
		set	dt_atualizacao		= clock_timestamp(),
			nm_usuario		= nm_usuario_p,
			vl_unitario		= vl_unitario_p_w,
			vl_liberado		= vl_liberado_p_w,
			vl_prestador		= vl_liberado_p_w,
			vl_glosa		= vl_glosa_p_w,
			vl_saldo		= vl_saldo_p_w,
			vl_beneficiario		= vl_beneficiario_w,
			vl_pag_medico_conta	= vl_pag_medico_conta_p_w,
			qt_procedimento		= qt_liberada_p_w,
			ie_status		= ie_status_w,
			ie_tipo_liberacao	= ie_tipo_liberacao_p_w,
			dt_liberacao		= clock_timestamp(),
			nm_usuario_liberacao	= nm_usuario_p,
			ds_log			= 'pls_atualiza_conta_item',		
			vl_liberado_hi		= vl_liberado_hi_w,
			vl_liberado_co		= vl_liberado_co_w,
			vl_liberado_material	= vl_liberado_material_w,
			vl_glosa_hi		= vl_glosa_hi_w,
			vl_glosa_co		= vl_glosa_co_w,
			vl_glosa_material	= vl_glosa_material_w,
			ie_glosa		=  CASE WHEN ie_glosa_w = NULL THEN ie_glosa  ELSE ie_glosa_w END ,
			ie_status_pagamento	= coalesce(ie_status_pagamento_w,ie_status_pagamento),
			nr_seq_exame_coleta	= nr_seq_exame_coleta_w,
			vl_exame_coleta		= vl_exame_coleta_w
		where	nr_sequencia		= nr_seq_item_p
		and	ie_status		<> 'D';
		
		if ( vl_liberado_p_w 	> 0) and ( vl_glosa_p_w 		> 0) and ( ie_tipo_liberacao_p	= 'C' )then
			/*Tratamento criato para ativar a glosa 1705 caso o valor liberado for menor que o apresentado OS 548630*/

			update 	pls_conta_glosa	a
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta_proc	= nr_seq_item_p
			and	exists (SELECT	1
					from	tiss_motivo_glosa	x
					where	x.nr_sequencia	= a.nr_seq_motivo_glosa
					and	x.cd_motivo_tiss = '1705' );
			
			update	pls_ocorrencia_benef	a
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	a.nr_seq_conta_proc	= nr_seq_item_p
			and	exists (SELECT	1
					from	pls_conta_glosa	x,
						tiss_motivo_glosa	y
					where	y.nr_sequencia		= x.nr_seq_motivo_glosa
					and	x.nr_seq_conta_proc	= nr_seq_item_p
					and	a.nr_seq_glosa		= x.nr_sequencia
					and	y.cd_motivo_tiss = '1705');
		end if;
		/* Felipe - OS 254016 - Se nao for valor informado e o valor apresentado for 0, entao atualiza com o valor liberado */

		if (coalesce(ie_atualiza_apresentado_w,'S') <> 'N') then	
			if (coalesce(ie_valor_informado_w,'S')	= 'N') and (coalesce(vl_apresentado_w,0) = 0) then
				CALL pls_atualiza_valor_apresentado( null, null, null,
								null, nr_seq_item_p,
								cd_estabelecimento_p, nm_usuario_p);
				
			end if;
		end if;
		
		if	((ie_origem_p = 'A') and (coalesce(ie_analise_cm_nova_w,'N') = 'S')) and (ie_atualiza_via_acesso_w = 'S') and (qt_via_acesso_w > 0) then	
			open C02;
			loop
			fetch C02 into	
				nr_seq_conta_aux_w;
			EXIT WHEN NOT FOUND; /* apply on C02 */
				begin
				CALL pls_atualiza_lib_conta(nr_seq_conta_aux_w,'A',nm_usuario_p);
				end;
			end loop;
			close C02;
		end if;
		
		/* Se for intercambio */

		if (coalesce(ie_tipo_conta_w,'O') = 'I') then
			if (vl_lib_taxa_hi_p IS NOT NULL AND vl_lib_taxa_hi_p::text <> '') or (vl_lib_taxa_mat_p IS NOT NULL AND vl_lib_taxa_mat_p::text <> '') or (vl_lib_taxa_co_p IS NOT NULL AND vl_lib_taxa_co_p::text <> '') then
				update	pls_conta_proc
				set	vl_lib_taxa_servico	= coalesce(vl_lib_taxa_hi_p,0),
					vl_lib_taxa_material	= coalesce(vl_lib_taxa_mat_p,0),
					vl_lib_taxa_co		= coalesce(vl_lib_taxa_co_p,0),
					vl_glosa_taxa_servico	= coalesce(vl_taxa_servico_imp_w,0) - coalesce(vl_lib_taxa_hi_p,0),
					vl_glosa_taxa_material	= coalesce(vl_taxa_material_imp_w,0) - coalesce(vl_lib_taxa_mat_p,0),
					vl_glosa_taxa_co	= coalesce(vl_taxa_co_imp_w,0) - coalesce(vl_lib_taxa_co_p,0)
				where	nr_sequencia		= nr_seq_item_p
				and	ie_status		<> 'D';
				
				/* Francisco - 05/02/2013 - OS 548622 - Quando ajusta o valor nao pode passar aqui 
				Porque o sistema ja soma as taxas no valor liberado */
				if (ie_tipo_liberacao_p <> 'A') and (coalesce(vl_lib_taxa_hi_p,0) = 0) and (coalesce(vl_lib_taxa_co_p,0) = 0) and (coalesce(vl_lib_taxa_mat_p,0) = 0) then
					update	pls_conta_proc
					set	vl_liberado	= vl_liberado + vl_lib_taxa_servico + vl_lib_taxa_material + vl_lib_taxa_co
					where	nr_sequencia	= nr_seq_item_p
					and	ie_status	<> 'D';
				end if;
				
				update	pls_conta_proc
				set	vl_glosa	= vl_procedimento_imp - vl_liberado
				where	nr_sequencia	= nr_seq_item_p
				and	vl_procedimento_imp	> vl_liberado
				and	ie_status	<> 'D';
			else
				if (ie_valor_base_w = '1')	then
					update	pls_conta_proc
					set	vl_lib_taxa_servico	= vl_taxa_servico_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w),
						vl_lib_taxa_material	= vl_taxa_material_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w),
						vl_lib_taxa_co		= vl_taxa_co_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w)
					where	nr_sequencia		= nr_seq_item_p
					and	ie_status		<> 'D';
				else
					if (coalesce(vl_lib_taxa_servico_w::text, '') = '') and (coalesce(vl_lib_taxa_material_w::text, '') = '') and (coalesce(vl_lib_taxa_co_w::text, '') = '') then
						if (vl_taxa_servico_w > vl_taxa_servico_imp_w) then
							vl_lib_taxa_servico_w	:= vl_taxa_servico_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
						else
							vl_lib_taxa_servico_w	:= vl_taxa_servico_w * dividir_sem_round(vl_liberado_p_w,vl_calculado_w);
						end if;
						
						if (vl_taxa_material_w > vl_taxa_material_imp_w) then
							vl_lib_taxa_material_w	:= vl_taxa_material_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
						else
							vl_lib_taxa_material_w	:= vl_taxa_material_w * dividir_sem_round(vl_liberado_p_w,vl_calculado_w);
						end if;
						
						if (vl_taxa_co_w > vl_taxa_co_imp_w) then
							vl_lib_taxa_co_w := vl_taxa_co_imp_w * dividir_sem_round(vl_liberado_p_w,vl_apresentado_w);
						else
							vl_lib_taxa_co_w := vl_taxa_co_w * dividir_sem_round(vl_liberado_p_w,vl_calculado_w);
							
					
						end if;
					end if;
					
					update	pls_conta_proc
					set	vl_lib_taxa_servico	= vl_lib_taxa_servico_w,
						vl_lib_taxa_material	= vl_lib_taxa_material_w,
						vl_lib_taxa_co		= vl_lib_taxa_co_w
					where 	nr_sequencia		= nr_seq_item_p
					and	ie_status		<> 'D';
				end if;
				/*Atualiza valor de glosa pois o mesmo sempre sera calculado dessa forma*/

				update	pls_conta_proc
				set	vl_glosa_taxa_servico	= vl_taxa_servico_imp_w - vl_lib_taxa_servico,
					vl_glosa_taxa_material	= vl_taxa_material_imp_w - vl_lib_taxa_material,
					vl_glosa_taxa_co	= vl_taxa_co_imp_w -vl_lib_taxa_co
				where	nr_sequencia 		= nr_seq_item_p
				and	ie_status		<> 'D';
			end if;
		end if;
	end if;
	
	begin
		select	coalesce(vl_glosa_taxa_servico,0),
			coalesce(vl_glosa_taxa_material,0),
			coalesce(vl_glosa_taxa_co,0)
		into STRICT	vl_glosa_taxa_servico_w,
			vl_glosa_taxa_material_w,
			vl_glosa_taxa_co_w
		from	pls_conta_proc
		where	nr_sequencia 		= nr_seq_item_p;
	exception
	when others then
		vl_glosa_taxa_servico_w		:= 0;
		vl_glosa_taxa_material_w	:= 0;
		vl_glosa_taxa_co_w		:= 0;
	end;
	
	if ( vl_glosa_taxa_servico_w 	< 0) then
		vl_glosa_taxa_servico_w := 0;
	elsif ( vl_glosa_taxa_material_w 	< 0) then
		vl_glosa_taxa_material_w := 0;
	elsif ( vl_glosa_taxa_co_w 		< 0) then
		vl_glosa_taxa_co_w  := 0;
	end if;
	
	update	pls_conta_proc
	set	vl_glosa_taxa_servico 	= vl_glosa_taxa_servico_w,
		vl_glosa_taxa_material	= vl_glosa_taxa_material_w,
		vl_glosa_taxa_co	= vl_glosa_taxa_co_w
	where	nr_sequencia 	= nr_seq_item_p
	and	ie_status	<> 'D';
	
	begin
	select	nr_sequencia
	into STRICT	nr_seq_pos_stab_w
	from 	pls_conta_pos_estabelecido
	where 	nr_seq_conta_proc	= nr_seq_item_p
	and	((ie_situacao		= 'A')or (coalesce(ie_situacao::text, '') = ''));
	exception
	when others then
		nr_seq_pos_stab_w	:= 0;
	end;

	if (coalesce(nr_seq_pos_stab_w,0) > 0) then
		update	pls_conta_pos_estabelecido
		set	ie_status_faturamento	= 'P',
			dt_atualizacao		= clock_timestamp(),
			nm_usuario		= nm_usuario_p
		where	nr_sequencia		= nr_seq_pos_stab_w
		and	vl_beneficiario		> 0;
	end if;
	
	if ( ie_tipo_protocolo_w <> 'R') then --nao deve ser chamada a rotina para protocolos de reembolso
		CALL pls_atualiza_conta_resumo_item(	nr_seq_item_p, 'P', nm_usuario_p, ie_conta_inteira_p);
	end if;					
	
	CALL pls_atualiza_conta_proc_fat(	nr_seq_item_p,
					nm_usuario_p,
					cd_estabelecimento_p,
					ie_excluir_fat_w);
elsif (coalesce(nr_seq_item_p,0) <> 0) and (ie_tipo_item_p = 'M') then
	select	nr_seq_conta,
		coalesce(vl_beneficiario,0),
		coalesce(nr_seq_regra_pos_estab,0),
		ie_status,
		coalesce(vl_material_imp,0),
		coalesce(vl_material,0),
		coalesce(vl_taxa_material_imp,0),
		coalesce(vl_taxa_material,0)
	into STRICT	nr_seq_conta_w,
		vl_beneficiario_w,
		nr_seq_regra_pos_estab_w,
		ie_status_w,
		vl_apresentado_w,
		vl_calculado_w,
		vl_taxa_material_imp_w,
		vl_taxa_material_w
	from	pls_conta_mat
	where	nr_sequencia	= nr_seq_item_p;
	
	if (nr_seq_regra_pos_estab_w > 0) then
		select	coalesce(tx_ajuste_benef_lib,1)
		into STRICT	tx_ajuste_benef_lib_w
		from	pls_regra_preco_mat
		where	nr_sequencia	= nr_seq_regra_pos_estab_w;
	end if;
	
	select	coalesce(max(ie_calculo_pos_estab), 'O')
	into STRICT	ie_cobranca_pos_w
	from	pls_parametros
	where	cd_estabelecimento	= cd_estabelecimento_p;
	
	select	nr_seq_protocolo,
		nr_seq_segurado,
		ie_tipo_conta,
		nr_seq_analise
	into STRICT	nr_seq_protocolo_w,
		nr_seq_segurado_w,
		ie_tipo_conta_w,
		nr_seq_analise_w
	from	pls_conta
	where	nr_sequencia	= nr_seq_conta_w;

	select	nr_seq_prestador,
		ie_tipo_protocolo
	into STRICT	nr_seq_prestador_w,
		ie_tipo_protocolo_w
	from	pls_protocolo_conta
	where	nr_sequencia	= nr_seq_protocolo_w;
	
	begin
	select	nr_seq_contrato,
		nr_seq_intercambio
	into STRICT	nr_seq_contrato_w,
		nr_seq_intercambio_w
	from	pls_segurado
	where	nr_sequencia	= nr_seq_segurado_w;
	exception
	when others then
		nr_seq_contrato_w	:= null;
		nr_seq_intercambio_w	:= null;
	end;
	
	/* Felipe OS 195231 - Alterei para N, pois para os precos reprocessados pela tabela da operadora NAO pode ser alterado o valor do beneficiario */


	/* Felipe OS   220682             - Retirado e colocado os calculos valor beneficiario  procedure  de calculo de preco de material*/


	/* Felipe e Robson OS - Inserido o teste IE_PRECO_CO_OPERADORA_W pois deve atualizar o VL_BENEFICIARIO  somente se sera cobrado algo do beneficiario e nao for com base na tabela da operadora */

	
	if (nr_seq_contrato_w IS NOT NULL AND nr_seq_contrato_w::text <> '') then
		/* Obter dados do contrato */

		begin
		select	ie_preco_co_operadora
		into STRICT	ie_preco_co_operadora_w
		from	pls_contrato
		where	nr_sequencia	= nr_seq_contrato_w;
		exception
		when others then
			ie_preco_co_operadora_w	:= null;
		end;
	elsif (nr_seq_intercambio_w IS NOT NULL AND nr_seq_intercambio_w::text <> '') then
	/*Obter dados contrato de intercambio*/

		select  max(ie_preco_co_operadora)
		into STRICT	ie_cobranca_prevista_inter_w
		from 	pls_intercambio
		where	nr_sequencia 	= nr_seq_intercambio_w;
	end if;

	ie_calcula_preco_benef_w	:= pls_obter_dados_conta(nr_seq_conta_w, 'CP');
	
	if (ie_tipo_conta_w not in ('I', 'C')) then
		if (ie_calcula_preco_benef_w = 'S') and
			((ie_preco_co_operadora_w = 'N') or (ie_cobranca_prevista_inter_w = 'N') and (ie_cobranca_pos_w in ('C', 'P', 'O'))) then
			vl_beneficiario_w	:= coalesce(vl_liberado_p,0);
		end if;
	end if;
		
	if (coalesce(ie_origem_p, 'C') = 'C') then
		update 	pls_conta_glosa
		set	ie_situacao		= 'I',
			ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
		where	nr_seq_conta_mat	= nr_seq_item_p;
		
		update 	pls_ocorrencia_benef
		set	ie_situacao		= 'I',
			ie_forma_inativacao	= CASE WHEN ie_forma_inativacao='S' THEN 'US' WHEN ie_forma_inativacao='US' THEN 'US'  ELSE 'U' END
		where	nr_seq_conta_mat	= nr_seq_item_p;
	end if;
	
	/* Francisco - 28/11/2012 - OS 523066 - Tem fazre isso so quando atualizando pela Gestao
	Pela analise o usuario pode escolher o que vai ativar/inativar */
	if (coalesce(ie_origem_p,'C') = 'C') or
		((coalesce(ie_analise_cm_nova_w, 'N') = 'N') or (coalesce(nr_seq_analise_w::text, '') = '' )) then
		if (cd_motivo_tiss_w <> 0) then
			/*Alterada as glosas geradas por essa rotina para SCE, pois quando as  nao sao executadas na OPS  a rotina nao as gravava na consitencia da conta */

			CALL pls_gravar_conta_glosa(cd_motivo_tiss_w, null, null,
						nr_seq_item_p, 'S', ds_observacao_p,
						nm_usuario_p,'A','SCE',
						nr_seq_prestador_w, cd_estabelecimento_p,'',null);
		elsif (vl_liberado_p < vl_apresentado_w) then
			update	pls_conta_glosa
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta_mat	= nr_seq_item_p;
			
			update 	pls_ocorrencia_benef
			set	ie_situacao		= 'A',
				ie_forma_inativacao	 = NULL
			where	nr_seq_conta_mat	= nr_seq_item_p;
		elsif (vl_liberado_p >= vl_apresentado_w) then
			update 	pls_conta_glosa
			set	ie_situacao		= 'I',
				ie_forma_inativacao	= 'U'
			where	nr_seq_conta_mat	= nr_seq_item_p;
		end if;
	end if;
	
	if (ie_origem_p = 'C') or (coalesce(ie_analise_cm_nova_w, 'N') = 'S') then
		ie_status_w	:= 'L';
	else
		ie_status_w 	:= ie_status_w;
	end if;
	
	if	((coalesce(ie_gerar_analise_audit_w,'N') = 'S') and (ie_origem_p <> 'C')) or
		((ie_origem_p = 'C') or (coalesce(ie_analise_cm_nova_w,'N') = 'S')) then
		vl_unitario_p_w		:= coalesce(vl_unitario_p,0);
		vl_liberado_p_w		:= coalesce(vl_liberado_p,0);
		vl_glosa_p_w		:= coalesce(vl_glosa_p,0);
		vl_saldo_p_w		:= coalesce(vl_saldo_p,0);
		vl_pag_medico_conta_p_w	:= coalesce(vl_pag_medico_conta_p,0);
		qt_liberada_p_w		:= coalesce(qt_liberada_p,0);
		
		ie_glosa_w	:= null;
		
		if (ie_origem_p = 'A') then
			ie_glosa_w	:= 'N';
			
			if (vl_liberado_p_w = 0) then
				ie_glosa_w	:= 'S';
			end if;
			
			if (vl_calculado_w = 0) and (vl_apresentado_w = 0) then
				ie_glosa_w	:= 'S';
			end if;
			
			/* Atualizar status de pagamento */

			if (ie_glosa_w = 'S') then
				ie_status_pagamento_w	:= 'G';
			else
				if (vl_liberado_p_w > 0) and (vl_glosa_p_w = 0) then
					ie_status_pagamento_w	:= 'L';
				elsif (vl_liberado_p_w = 0) and (vl_glosa_p_w = 0) then
					ie_status_pagamento_w	:= 'G';
				else
					ie_status_pagamento_w	:= 'P';
				end if;
			end if;
		end if;
		
		vl_glosa_p_w := (vl_apresentado_w - vl_liberado_p_w);
		
		if (vl_glosa_p_w < 0) then
			vl_glosa_p_w := 0;
		end if;
		
		--Retirado o vl provisao e o ie_origem_provisao na OS 696733 conforme tratado com Paulo Rosa apos a geracao do mesmo o valor do mesmo deve ser mantido dgkorz
		update	pls_conta_mat
		set	dt_atualizacao		= clock_timestamp(),
			nm_usuario		= nm_usuario_p,
			vl_unitario		= vl_unitario_p_w,
			vl_liberado		= vl_liberado_p_w,
			vl_glosa		= vl_glosa_p_w,
			vl_saldo		= vl_saldo_p_w,
			vl_beneficiario		= vl_beneficiario_w,
			qt_material		= qt_liberada_p_w,
			ie_status		= ie_status_w,
			dt_liberacao		= clock_timestamp(),
			nm_usuario_liberacao	= nm_usuario_p,			
			ie_glosa		= CASE WHEN ie_glosa_w = NULL THEN ie_glosa  ELSE ie_glosa_w END ,
			ie_status_pagamento	= coalesce(ie_status_pagamento_w,ie_status_pagamento)
		where	nr_sequencia		= nr_seq_item_p
		and	((ie_status	<> 'D') or (ie_status <> 'D'));
		
		/* Se for intercambio */

		if (coalesce(ie_tipo_conta_w, 'O') = 'I') then
			
			update	pls_conta_mat
			set	vl_lib_taxa_material	= coalesce(vl_lib_taxa_mat_p,0),
				vl_glosa_taxa_material	= vl_taxa_material_imp_w - coalesce(vl_lib_taxa_mat_p,0)
			where	nr_sequencia		= nr_seq_item_p
			and	((ie_status	<> 'D') or (ie_status <> 'D'));
		end if;
	end if;
	
	begin
	select	nr_sequencia
	into STRICT	nr_seq_pos_stab_w
	from 	pls_conta_pos_estabelecido
	where 	nr_seq_conta_mat	= nr_seq_item_p
	and	((ie_situacao		= 'A')or (coalesce(ie_situacao::text, '') = ''));
	exception
	when others then
		nr_seq_pos_stab_w := 0;
	end;
	
	if (coalesce(nr_seq_pos_stab_w,0) > 0) then
		update	pls_conta_pos_estabelecido
		set	ie_status_faturamento	= 'P',
			dt_atualizacao		= clock_timestamp(),
			nm_usuario		= nm_usuario_p
		where	nr_sequencia		= nr_seq_pos_stab_w
		and	vl_beneficiario		> 0;
	end if;

	CALL pls_delete_conta_medica_resumo(nr_seq_conta_w,null,nr_seq_item_p,nm_usuario_P);
	
	if (ie_tipo_protocolo_w <> 'R') then--nao deve ser chamada a rotina para protocolos de reembolso
		CALL pls_atualiza_conta_resumo_item(nr_seq_item_p, 'M', nm_usuario_p, ie_conta_inteira_p);
	end if;	

	CALL pls_atualiza_conta_mat_fat(nr_seq_item_p, nm_usuario_p, cd_estabelecimento_p, ie_excluir_fat_w);
elsif (coalesce(nr_seq_item_p,0) <> 0) and (ie_tipo_item_p = 'R') then
	begin
	nr_seq_pos_stab_w	:= 0;
	vl_prestador_w 	:= 0;
	vl_liberado_w	:= 0;
	vl_liberado_p_w	:= coalesce(vl_liberado_p,0);
	vl_glosa_p_w	:= coalesce(vl_glosa_p,0);
	
	select	count(1)
	into STRICT	qt_partic_param_w
	from	pls_proc_participante
	where	nr_sequencia = nr_seq_item_p;
		
	-- Se nao existir o participante passado por parametro informar o usuario atraves de mensagem.
	if (qt_partic_param_w = 0) then
	
	        -- O participante #@NR_SEQ_PARTIC#@ nao foi encontrado, o mesmo pode ter sido excluido. 

		-- Favor verficar nos logs de exclusao na funcao Administracao do Sistema Tasy \ pasta Consulta \ pasta Log exclusao, selecionando nos filtros a tabela 

		-- PLS_PROC_PARTICIPANTE e informando no campo Chave o valor #@NR_SEQ_PARTIC#@.
		CALL wheb_mensagem_pck.exibir_mensagem_abort(272831, 'NR_SEQ_PARTIC=' || nr_seq_item_p || ';');
	end if;
	
	select	coalesce(vl_apresentado,0),
		coalesce(vl_calculado,0),
		coalesce(vl_participante,0),
		nr_seq_conta_proc,
		coalesce(nr_seq_prestador,0),
		nr_seq_honorario_crit,
		ie_status
	into STRICT	vl_apresentado_w,
		vl_calculado_w,
		vl_participante_w,
		nr_seq_conta_proc_w,
		nr_seq_prestador_ww,
		nr_seq_honorario_w,
		ie_status_w
	from	pls_proc_participante
	where	nr_sequencia	= nr_seq_item_p;
	
	select	coalesce(vl_prestador,0),
		coalesce(vl_procedimento_imp,0),
		coalesce(vl_procedimento,0),
		nr_seq_conta,
		ie_repassa_medico,
		coalesce(vl_total_partic,0),
		coalesce(vl_custo_operacional,0),
		coalesce(vl_materiais,0),
		coalesce(vl_prestador,0),
		coalesce(vl_liberado,0),
		qt_procedimento,
		coalesce(vl_procedimento_imp,0),
		coalesce(vl_liberado_co,0),
		coalesce(vl_liberado_material,0),
		coalesce(vl_glosa_co,0),
		coalesce(vl_glosa_material,0),
		coalesce(vl_glosa,0),
		ie_tipo_despesa
	into STRICT	vl_prestador_w,
		vl_apresentado_ww,
		vl_calculado_ww,
		nr_seq_conta_w,
		ie_repassa_medico_w,
		vl_total_partic_w,
		vl_custo_operacional_w,
		vl_filme_w,
		vl_prestador_w,
		vl_liberado_w,
		qt_procedimento_w,
		vl_apresentado_proc_w,
		vl_liberado_co_w,
		vl_liberado_material_w,
		vl_glosa_co_w,
		vl_glosa_material_w,
		vl_glosa_w,
		ie_tipo_despesa_w
	from	pls_conta_proc
	where 	nr_sequencia	= nr_seq_conta_proc_w;
	
	vl_diferenca_apres_w	:= vl_apresentado_ww - vl_calculado_ww;
	
	select	max(ie_tipo_conta),
		max(nr_seq_protocolo)
	into STRICT	ie_tipo_conta_w,
		nr_seq_protocolo_w
	from	pls_conta
	where	nr_sequencia	= nr_seq_conta_w;
		
	if (vl_diferenca_apres_w < 0) then
		vl_diferenca_apres_w	:= 0;
	end if;

	if (ie_origem_p = 'C') or (coalesce(ie_analise_cm_nova_w, 'N') = 'S') then
		ie_status_w	:= 'L';
	else
		ie_status_w 	:= ie_status_w;
	end if;
	
	ie_glosa_w	:= null;

	if (ie_origem_p = 'A') and (ie_analise_cm_nova_w = 'S') and (ie_tipo_despesa_w =  1) then
				
		ie_glosa_w	:= 'N';
			
		if (vl_liberado_p_w = 0) and (vl_glosa_p_w > 0) then
			ie_glosa_w	:= 'S';
		end if;
		
		if (vl_calculado_w = 0) and (vl_apresentado_w = 0) then
			ie_glosa_w	:= 'S';
		elsif (vl_calculado_w > 0) and (vl_liberado_p_w = 0) and (vl_apresentado_w = 0) then
			ie_glosa_w	:= 'S';
		end if;
		/* Atualizar status de pagamento */

		if (ie_glosa_w = 'S') then
			ie_status_pagamento_w	:= 'G';
		else
			if (vl_liberado_p_w > 0) and (vl_glosa_p_w = 0) then
				ie_status_pagamento_w	:= 'L';
			else
				ie_status_pagamento_w	:= 'P';
			end if;
		end if;
	end if;
	
	update	pls_proc_participante		
	set	vl_participante		= coalesce(vl_liberado_p,0),
		vl_glosa		= coalesce(vl_glosa_p,0),
		qt_liberada		= coalesce(qt_liberada_p,0),
		ie_status		= ie_status_w,
		ie_glosa		= CASE WHEN ie_glosa_w = NULL THEN ie_glosa  ELSE ie_glosa_w END ,
		ie_status_pagamento	= coalesce(ie_status_pagamento_w,ie_status_pagamento)
	where	nr_sequencia		= nr_seq_item_p;

	if (ie_analise_cm_nova_w = 'S') then
		/* Francisco - 29/12/2012 - So poder fazer isso quando nao e conta de a500 */

		if (coalesce(ie_tipo_conta_w,'O') <> 'I') then
			/* Somar o valor dos participantes liberado e glosado */

			select	coalesce(sum(a.vl_participante),0),
				coalesce(sum(a.vl_glosa),0)
			into STRICT	vl_total_lib_partic_w,
				vl_total_glosa_partic_w
			from	pls_proc_participante a
			where	a.nr_seq_conta_proc	= nr_seq_conta_proc_w
			and	a.nr_sequencia	<> nr_seq_item_p;
			
			select	count(1)
			into STRICT	qt_part_glosado_w
			from	pls_proc_participante a
			where	a.nr_seq_conta_proc	= nr_seq_conta_proc_w
			and	a.ie_status_pagamento	= 'G';
			
			select	count(1)
			into STRICT	qt_part_liberado_w
			from	pls_proc_participante a
			where	a.nr_seq_conta_proc	= nr_seq_conta_proc_w
			and	a.ie_status_pagamento	= 'L';
			
			select	count(1)
			into STRICT	qt_part_parcial_w
			from	pls_proc_participante a
			where	a.nr_seq_conta_proc	= nr_seq_conta_proc_w
			and	a.ie_status_pagamento	= 'P';
			
			if (qt_part_glosado_w > 0) and (qt_part_liberado_w = 0) and (qt_part_parcial_w = 0) then
				ie_status_pagamento_w	:= 'G';
			elsif (qt_part_liberado_w > 0) and (qt_part_glosado_w = 0) and (qt_part_parcial_w = 0) and (vl_diferenca_apres_w = 0) then
				ie_status_pagamento_w	:= 'L';
			else
				ie_status_pagamento_w	:= 'P';
			end if;
			
			if (ie_glosa_w = 'S') then
			
				
				if  ((coalesce(vl_liberado_co_w,0) > 0) or (coalesce(vl_liberado_material_w,0) > 0)) then
					ie_glosa_w := 'N';
				else
					--Se algum dos participantes do procedimento nao tiver com ie_glosa = 'S' entao muda para 'N' para ser atribuido

					--ao procedimento. Isso corrige o problema de glosar um unico participante na analise.
					select  CASE WHEN count(1)=0 THEN  'S'  ELSE 'N' END  ie_glosa
					into STRICT	ie_glosa_w
					from  	pls_proc_participante
					where  	nr_seq_conta_proc = nr_seq_conta_proc_w
					and (ie_glosa = 'N' or coalesce(ie_glosa::text, '') = '');
				end if;
			end if;
			
			select	coalesce(vl_procedimento_imp,0)
			into STRICT	vl_total_apres_w
			from	pls_conta_proc
			where	nr_sequencia = nr_seq_conta_proc_w;
			
			vl_glosa_final_w := vl_total_glosa_partic_w + coalesce(vl_glosa_p,0) + vl_glosa_co_w + vl_glosa_material_w + vl_diferenca_apres_w;
			vl_total_lib_partic_ww := vl_total_lib_partic_w + coalesce(vl_liberado_p,0) + vl_liberado_co_w + vl_liberado_material_w;
			
			if (vl_glosa_final_w > vl_total_apres_w) then
				vl_glosa_final_w := vl_total_apres_w;
			end if;
			
			if (ie_tipo_despesa_w = '4') and (vl_glosa_final_w = 0) and (vl_total_lib_partic_ww = 0) and (vl_glosa_w > 0) then
				vl_glosa_final_w := vl_glosa_w;
			end if;
			
			/* O valor liberado do item sera o valor Soma do liberado dos participantes
			+ valor liberado do registro selecionado */
			update	pls_conta_proc
			set	vl_liberado_hi		= vl_total_lib_partic_w + coalesce(vl_lib_hi_p,0),
				vl_liberado		= vl_total_lib_partic_ww,
				vl_glosa_hi		= vl_total_glosa_partic_w + coalesce(vl_glosa_p,0),
				vl_glosa		= vl_glosa_final_w,
				ie_status_pagamento	= coalesce(ie_status_pagamento_w,ie_status_pagamento),
				ie_glosa		=  CASE WHEN ie_glosa_w = NULL THEN ie_glosa  ELSE ie_glosa_w END
			where	nr_sequencia		= nr_seq_conta_proc_w
			and	ie_status		<> 'D';
			
		elsif	((coalesce(nr_seq_honorario_w,0) > 0 ) or (ie_repassa_medico_w in ('S', 'H')))then
			select	nr_seq_analise
			into STRICT	nr_seq_analise_w
			from	pls_conta
			where	nr_sequencia	= nr_seq_conta_w;
			
			vl_diferenca_w		:= vl_liberado_p - vl_calculado_w;
			vl_total_partic_w	:= vl_total_partic_w + vl_diferenca_w;
			
			if (vl_apresentado_proc_w = vl_liberado_w) then
				vl_procedimento_w	:= vl_liberado_w;
			else
				vl_procedimento_w	:= coalesce(vl_total_partic_w,0) + coalesce(vl_custo_operacional_w,0) + coalesce(vl_filme_w,0);
			end if;
			
			if (coalesce(vl_liberado_w,0) > 0) then
				vl_liberado_w	:= vl_procedimento_w;
			end if;

			update	pls_conta_proc
			set	vl_prestador 	= vl_procedimento_w,
				vl_liberado 	= vl_liberado_w,
				vl_unitario	= dividir(vl_liberado_w,qt_procedimento_w)
			where	nr_sequencia	= nr_seq_conta_proc_w
			and	ie_status	<> 'D';
			
			select	coalesce(sum(vl_participante),0)
			into STRICT	vl_total_partic_w
			from	pls_proc_participante
			where	nr_seq_conta_proc = nr_seq_conta_proc_w;
			
			
			if (vl_total_partic_w > vl_liberado_w) then
				vl_dif_w := vl_total_partic_w - vl_liberado_w;
				
				if (vl_liberado_p > 0) and (vl_liberado_p >= vl_dif_w) then
					vl_liberado_p 	:= vl_liberado_p - vl_dif_w;
					
					update	pls_proc_participante		
					set	vl_participante		= coalesce(vl_liberado_p,0)
					where	nr_sequencia		= nr_seq_item_p;
				end if;
			end if;
			
		end if;
	elsif	((coalesce(nr_seq_honorario_w,0) > 0 ) or (ie_repassa_medico_w in ('S', 'H')))then
		select	nr_seq_analise
		into STRICT	nr_seq_analise_w
		from	pls_conta
		where	nr_sequencia	= nr_seq_conta_w;
		
		vl_diferenca_w		:= vl_liberado_p - vl_calculado_w;
		vl_total_partic_w	:= vl_total_partic_w + vl_diferenca_w;
		
		if (vl_apresentado_proc_w = vl_liberado_w) then
			vl_procedimento_w	:= vl_liberado_w;
		else
			vl_procedimento_w	:= coalesce(vl_total_partic_w,0) + coalesce(vl_custo_operacional_w,0) + coalesce(vl_filme_w,0);
		end if;
		
		if (coalesce(vl_liberado_w,0) > 0) then
			vl_liberado_w	:= vl_procedimento_w;
		end if;

		update	pls_conta_proc
		set	vl_prestador 	= vl_procedimento_w,
			vl_liberado 	= vl_liberado_w,
			vl_unitario	= dividir(vl_liberado_w,qt_procedimento_w)
		where	nr_sequencia	= nr_seq_conta_proc_w
		and	ie_status	<> 'D';
		
		select	coalesce(sum(vl_participante),0)
		into STRICT	vl_total_partic_w
		from	pls_proc_participante
		where	nr_seq_conta_proc = nr_seq_conta_proc_w;
	
		if (vl_total_partic_w > vl_liberado_w) then
			vl_dif_w := vl_total_partic_w - vl_liberado_w;
			
			if (vl_liberado_p > 0) and (vl_liberado_p >= vl_dif_w) then
				vl_liberado_p 	:= vl_liberado_p - vl_dif_w;
				
				update	pls_proc_participante		
	 			set	vl_participante		= coalesce(vl_liberado_p,0)
				where	nr_sequencia		= nr_seq_item_p;
			end if;
		end if;
	end if;
	
	CALL pls_delete_conta_medica_resumo(nr_seq_conta_w,nr_seq_conta_proc_w,null,nm_usuario_P);
	
	select	max(ie_tipo_protocolo)
	into STRICT	ie_tipo_protocolo_w
	from	pls_protocolo_conta
	where	nr_sequencia	= nr_seq_protocolo_w;
	
	if (ie_tipo_protocolo_w <> 'R') then--nao deve ser chamada a rotina para protocolos de reembolso
		CALL pls_atualiza_conta_resumo_item(nr_seq_conta_proc_w, 'P', nm_usuario_p, ie_conta_inteira_p);	
	end if;	
end;
end if;

if (ie_tipo_protocolo_w	= 'R') and (coalesce(nr_seq_item_p,0) <> 0) then
	
	if (ie_tipo_item_p = 'P') then
		select	max(nr_seq_regra_acao_reemb)
		into STRICT	nr_seq_regra_acao_reemb_w
		from	pls_conta_proc
		where	nr_sequencia	= nr_seq_item_p;
		nr_seq_conta_proc_w	:= nr_seq_item_p;
		
	elsif (ie_tipo_item_p = 'M') then
		select	max(nr_seq_regra_acao_reemb)
		into STRICT	nr_seq_regra_acao_reemb_w
		from	pls_conta_mat
		where	nr_sequencia	= nr_seq_item_p;
		
		nr_seq_conta_mat_w	:= nr_seq_item_p;
	end if;
	if (nr_seq_regra_acao_reemb_w IS NOT NULL AND nr_seq_regra_acao_reemb_w::text <> '') then
		CALL pls_gerenciar_reembolso_pck.pls_gerar_apropriacao(null,nr_seq_conta_proc_w,nr_seq_conta_mat_w,nm_usuario_p);
	end if;
end if;

commit;

if (coalesce(ie_analise_cm_nova_w, 'N') = 'N') then
	begin
	/*Diego OS - 310267 - Atualizar os respectivos valores na analise*/

	update	w_pls_resumo_conta
	set	vl_unitario		= coalesce(vl_unitario_p,0),
		vl_total		= coalesce(vl_liberado_p,0),		
		qt_liberado		= coalesce(qt_liberada_p,0)
		--ie_status		= 'L'
	where	nr_seq_item		= nr_seq_item_p
	and	ie_tipo_item		= ie_tipo_item_p;
	exception
	when others then
		vl_beneficiario_w	:= vl_beneficiario_w;
	end;
end if;

CALL pls_atualizar_utilizacao_guia(nr_seq_conta_w,cd_estabelecimento_p, nm_usuario_p);

if (coalesce(ie_conta_inteira_p, 'N') = 'N') then
	CALL pls_cta_consistir_pck.gerar_resumo_conta(null, null, null, nr_seq_conta_w, nm_usuario_p, cd_estabelecimento_p);
	
	CALL pls_fechar_conta(nr_seq_conta_w, 'N', 'S', 'N', cd_estabelecimento_p, nm_usuario_p, null, null);

	select	nr_seq_protocolo
	into STRICT	nr_seq_protocolo_w
	from	pls_conta
	where	nr_sequencia	= nr_seq_conta_w;

	CALL pls_altera_status_protocolo(nr_seq_protocolo_w, 'L', 'N', cd_estabelecimento_p, nm_usuario_p);
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_atualiza_conta_item ( nr_seq_item_p bigint, ie_tipo_item_p text, nr_seq_motivo_glosa_p bigint, vl_unitario_p bigint, vl_liberado_p INOUT bigint, vl_glosa_p bigint, vl_saldo_p bigint, vl_prestador_p bigint, qt_liberada_p bigint, ds_observacao_p text, ie_origem_p text, cd_estabelecimento_p bigint, nm_usuario_p text, ie_commit_p text, vl_pag_medico_conta_p bigint, ie_conta_inteira_p text, ie_tipo_liberacao_p text, ie_gerar_analise_aud_p text, vl_lib_hi_p bigint, vl_lib_material_p bigint, vl_lib_co_p bigint, vl_lib_taxa_hi_p bigint, vl_lib_taxa_mat_p bigint, vl_lib_taxa_co_p bigint) FROM PUBLIC;

