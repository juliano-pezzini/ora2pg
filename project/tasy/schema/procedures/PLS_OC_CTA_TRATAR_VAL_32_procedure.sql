-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_32 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Aplicar a validacao para gerar ocorrencia em itens simultaneos ou concorrentes
Rotina refeita para utilizar nova pasta (estrutura) criada em Glosas e Ocorrencias
Nova pasta "Combinacao de Itens"
------------------------------------------------------------------------------------------------------------------

Locais de chamada direta:
[ X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
qt_registro_valido_w		integer;
dados_cab_regra_w		pls_simult_concor_pck.t_dado_cab_regra;
ds_sql_w			varchar(12000);
ds_observacao_w			varchar(4000);
bind_sql_w			sql_pck.t_dado_bind;
cursor_w			sql_pck.t_cursor;
cd_guia_referencia_w		pls_conta_v.cd_guia_referencia%type;
nr_seq_segurado_w		pls_conta_v.nr_seq_segurado%type;
dt_item_w			timestamp;
nr_seq_selecao_w		pls_selecao_ocor_cta.nr_sequencia%type;
ie_tipo_registro_w		pls_selecao_ocor_cta.ie_tipo_registro%type;
qt_agrup_item_w			integer;
qt_casou_and_w			integer;
qt_casou_ou_w			integer;
qt_casou_pacote_and_w		integer;
qt_casou_pacote_ou_w		integer;
dt_item_ini_w			timestamp;
dt_item_fim_w			timestamp;
qt_total_item_guia_w		integer;
ie_atendeu_regra_w		boolean;
qt_dif_dias_w			integer;
qt_tot_casou_proc_and_w		integer;
qt_tot_casou_proc_ou_w		integer;
qt_tot_casou_proc_pacote_and_w	integer;
qt_tot_casou_proc_pacote_or_w	integer;
qt_tot_casou_mat_and_w		integer;
qt_tot_casou_mat_ou_w		integer;
qt_tot_item_guia_proc_w		integer;
qt_tot_item_guia_mat_w		integer;
dados_tb_selecao_w		pls_tipos_ocor_pck.dados_table_selecao_ocor;
ie_proc_e_w			varchar(1);
ie_proc_ou_w			varchar(1);
ie_mat_e_w			varchar(1);
ie_mat_ou_w			varchar(1);
ie_gera_ocor_item_w		pls_combinacao_item_tm.ie_gera_ocorrencia%type;
nr_indice_w			integer;
qt_tot_agrup_proc_and_w 	integer;
qt_tot_agrup_mat_and_w		integer;
nr_seq_combinacao_item_w	pls_oc_cta_val_comb_item.nr_seq_combinacao_item%type;
nr_seq_conta_w			pls_conta.nr_sequencia%type;
ie_analise_cm_nova_w		pls_parametros.ie_analise_cm_nova%type;
nr_seq_prestador_exec_princ_w	pls_conta.nr_seq_prestador_exec_princ%type;

-- regras de combinacao de itens que serao processadas na validacao
c_somente_regra CURSOR(	nr_seq_oc_cta_comb_p	dados_regra_p.nr_sequencia%type) FOR
	SELECT	a.nr_seq_combinacao_item
	from	pls_oc_cta_val_comb_item a
	where	a.nr_seq_oc_cta_comb	= nr_seq_oc_cta_comb_p;

-- todos os procedimentos da selecao que existem na regra de combinacao de itens que esta sendo processada
c_reg_existe_proc CURSOR(	nr_id_transacao_pc	pls_selecao_ocor_cta.nr_id_transacao%type,
				nr_seq_comb_item_p	pls_oc_cta_val_comb_item.nr_seq_combinacao_item%type) FOR
	SELECT	a.nr_sequencia,
		'S' ie_valido,
		a.ds_observacao
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	and	exists (SELECT	1
			from	pls_combinacao_item_tm z
			where	z.nr_seq_combinacao = nr_seq_comb_item_p
			and	z.ie_tipo_registro = 'P'
			and	z.ie_origem_proced = b.ie_origem_proced
			and	z.cd_procedimento = b.cd_procedimento)
	
union all

	-- pacotes nao existem dentro de pls_combinacao_item_tm
	select	a.nr_sequencia,
		'S' ie_valido,
		a.ds_observacao
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	and	b.ie_tipo_despesa = '4'
	and	exists (select	1
			from	pls_comb_cta_item_proc z
			where	z.nr_seq_combinacao = nr_seq_comb_item_p
			and	z.ie_tipo_desp_proc = '4');
			
-- todos os materiais da selecao que existem na regra de combinacao de itens que esta sendo processada
c_reg_existe_mat CURSOR(	nr_id_transacao_pc	pls_selecao_ocor_cta.nr_id_transacao%type,
				nr_seq_comb_item_p	pls_oc_cta_val_comb_item.nr_seq_combinacao_item%type) FOR
	SELECT	a.nr_sequencia,
		'S' ie_valido,
		a.ds_observacao
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_mat b
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	and	b.nr_sequencia = a.nr_seq_conta_mat
	and	exists (SELECT	1
			from	pls_combinacao_item_tm z
			where	z.nr_seq_combinacao = nr_seq_comb_item_p
			and	z.ie_tipo_registro = 'M'
			and	z.nr_seq_material = b.nr_seq_material);

-- Informacoes da validacao de itens simultaneos/concorrentes
c_regra_comb CURSOR(	nr_seq_oc_cta_comb_p	dados_regra_p.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia	nr_seq_validacao,
		a.nr_seq_combinacao_item,
		b.nr_sequencia nr_seq_combinada,
		b.dt_inicio_vigencia,
		b.dt_fim_vigencia,
		coalesce(b.qt_dias_considerar, 0) qt_dias_considerar,
		coalesce(b.ie_conta_igual_comb, 'N') ie_conta_igual_comb,
		coalesce(b.ie_ou_excecao, 'N') ie_ou_excecao,
		coalesce(b.ie_ocorrencia_conta, 'N') ie_ocorrencia_conta,
		coalesce(b.ie_tipo_verificacao, '1') ie_tipo_verificacao,
		(SELECT	count(1)
		 from	pls_combinacao_item_tm x
		 where  x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'P'
		 ) qt_regra_proc,
		 (select	count(1)
		 from	pls_comb_cta_item_proc z
		 where  z.nr_seq_combinacao = b.nr_sequencia
		 and	z.ie_tipo_desp_proc = '4') qt_regra_pacote,
		(select	count(1)
		 from	pls_combinacao_item_tm x
		 where  x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'P'
		 and	x.ie_and_or = 'AND') qt_regra_proc_and,
		(select	count(1)
		 from	pls_comb_cta_item_proc z
		 where  z.nr_seq_combinacao = b.nr_sequencia
		 and	z.ie_tipo_desp_proc = '4'
		 and	z.ie_and_or = 'AND') qt_regra_pacote_and,
		(select	count(1)
		 from	pls_comb_cta_item_proc z
		 where  z.nr_seq_combinacao = b.nr_sequencia
		 and	z.ie_tipo_desp_proc = '4'
		 and	z.ie_and_or = 'OR') qt_regra_pacote_or,
		(select	count(1)
		 from	pls_combinacao_item_tm x
		 where  x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'P'
		 and	x.ie_and_or = 'OR') qt_regra_proc_or,
		(select	count(1)
		 from	pls_combinacao_item_tm x
		 where  x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'M') qt_regra_mat,
		(select	count(1)
		 from	pls_combinacao_item_tm x
		 where  x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'M'
		 and	x.ie_and_or = 'AND') qt_regra_mat_and,
		(select	count(1)
		 from	pls_combinacao_item_tm x
		 where  x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'M'
		 and	x.ie_and_or = 'OR') qt_regra_mat_or,
		(select	count(distinct x.ie_agrupamento_item)
		 from	pls_combinacao_item_tm x
		 where	x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'P'
		 and	x.ie_and_or = 'AND') qt_grupos_distintos_proc,
		 (select	count(distinct x.ie_agrupamento_item)
		 from	pls_combinacao_item_tm x
		 where	x.nr_seq_combinacao = b.nr_sequencia
		 and	x.ie_tipo_registro  = 'M'
		 and	x.ie_and_or = 'AND') qt_grupos_distintos_mat,
		coalesce(b.ie_mesmo_prestador_exec_princ, 'N') ie_mesmo_prestador_exec_princ
	from	pls_oc_cta_val_comb_item a,
		pls_combinacao_item_cta b
	where	a.nr_seq_oc_cta_comb	= nr_seq_oc_cta_comb_p
	and	b.nr_sequencia = a.nr_seq_combinacao_item;
	
c_guia CURSOR(	nr_id_transacao_pc		pls_selecao_ocor_cta.nr_id_transacao%type,
		nr_seq_combinacao_item_pc	pls_oc_cta_val_comb_item.nr_seq_combinacao_item%type) FOR
	SELECT	distinct sel.nr_seq_segurado,
		sel.cd_guia_referencia,
		(SELECT max(x.nr_seq_prestador_exec_princ) from pls_conta x where x.nr_sequencia = sel.nr_seq_conta) nr_seq_prestador_exec_princ
	from	pls_oc_cta_selecao_ocor_v sel
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	exists (select 1
      			 from   pls_conta_proc_v p,
               			pls_combinacao_item_tm a
       			where   p.nr_sequencia      = sel.nr_seq_conta_proc
       			and   	a.cd_procedimento   = p.cd_procedimento
       			and     a.ie_origem_proced  = p.ie_origem_proced
			and	a.nr_seq_combinacao = nr_seq_combinacao_item_pc
			and (coalesce(p.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
       			
union all

                        select  1
       			from    pls_conta_mat m,
               			pls_combinacao_item_tm a
       			where   m.nr_sequencia 	   = sel.nr_seq_conta_mat
       			and     a.nr_seq_material  = m.nr_seq_material
			and	a.nr_seq_combinacao = nr_seq_combinacao_item_pc
			and (coalesce(m.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N'));
	
c_dt_item CURSOR(	nr_id_transacao_pc		pls_selecao_ocor_cta.nr_id_transacao%type,
			nr_seq_combinacao_item_pc	pls_oc_cta_val_comb_item.nr_seq_combinacao_item%type) FOR
	SELECT	distinct sel.nr_seq_segurado,
		sel.dt_item,
		(SELECT max(x.nr_seq_prestador_exec_princ) from pls_conta x where x.nr_sequencia = sel.nr_seq_conta) nr_seq_prestador_exec_princ
	from	pls_oc_cta_selecao_ocor_v sel
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	exists (select 1
      			 from   pls_conta_proc_v p,
               			pls_combinacao_item_tm a
       			where   p.nr_sequencia      = sel.nr_seq_conta_proc
       			and   	a.cd_procedimento   = p.cd_procedimento
       			and     a.ie_origem_proced  = p.ie_origem_proced
			and	a.nr_seq_combinacao = nr_seq_combinacao_item_pc
			and (coalesce(p.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
       			
union all

                        select  1
       			from    pls_conta_mat m,
               			pls_combinacao_item_tm a
       			where   m.nr_sequencia 	   = sel.nr_seq_conta_mat
       			and     a.nr_seq_material  = m.nr_seq_material
			and	a.nr_seq_combinacao = nr_seq_combinacao_item_pc
			and (coalesce(m.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N'));
			
c_nr_seq_conta CURSOR(	nr_id_transacao_pc		pls_selecao_ocor_cta.nr_id_transacao%type,
			nr_seq_combinacao_item_pc	pls_oc_cta_val_comb_item.nr_seq_combinacao_item%type) FOR
	SELECT	distinct sel.nr_seq_segurado,
		sel.nr_seq_conta,
		(SELECT max(x.nr_seq_prestador_exec_princ) from pls_conta x where x.nr_sequencia = sel.nr_seq_conta) nr_seq_prestador_exec_princ
	from	pls_oc_cta_selecao_ocor_v sel
	where	sel.nr_id_transacao = nr_id_transacao_pc
	and	sel.ie_valido = 'S'
	and	exists (select 1
      			 from   pls_conta_proc_v p,
               			pls_combinacao_item_tm a
       			where   p.nr_sequencia      = sel.nr_seq_conta_proc
       			and   	a.cd_procedimento   = p.cd_procedimento
       			and     a.ie_origem_proced  = p.ie_origem_proced
			and	a.nr_seq_combinacao = nr_seq_combinacao_item_pc
			and (coalesce(p.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
       			
union all

                        select  1
       			from    pls_conta_mat m,
               			pls_combinacao_item_tm a
       			where   m.nr_sequencia 	   = sel.nr_seq_conta_mat
       			and     a.nr_seq_material  = m.nr_seq_material
			and	a.nr_seq_combinacao = nr_seq_combinacao_item_pc
			and (coalesce(m.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N'));

-- todos os itens para futuro lancamento de ocorrencia quando processamento for por guia	
c_lanc_it_guia CURSOR(	nr_id_transacao_pc	pls_selecao_ocor_cta.nr_id_transacao%type,
			nr_seq_segurado_pc	pls_conta.nr_seq_segurado%type,
			cd_guia_referencia_pc	pls_conta.cd_guia_referencia%type,
			nr_seq_comb_item_pc	pls_combinacao_item_cta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_selecao,
		coalesce(z.ie_gera_ocorrencia, 'N') ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b,
		pls_combinacao_item_tm z
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.cd_guia_referencia = cd_guia_referencia_pc
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and	z.nr_seq_combinacao = nr_seq_comb_item_pc
	and	z.ie_tipo_registro = 'P'
	and	z.ie_origem_proced = b.ie_origem_proced
	and	z.cd_procedimento = b.cd_procedimento
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	
union all

	-- pacotes nao existem na pls_combinacao_item_tm e sao definidos durante a consistencia da conta

	-- por isso o tratamento e feito desta maneira
	SELECT	a.nr_sequencia nr_seq_selecao,
		'S' ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.cd_guia_referencia = cd_guia_referencia_pc
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and	b.ie_tipo_despesa = '4'
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	and	exists (select	1
			from	pls_comb_cta_item_proc z
			where	z.nr_seq_combinacao = nr_seq_comb_item_pc
			and	z.ie_tipo_desp_proc = '4')
	
union all

	select	a.nr_sequencia nr_seq_selecao,
		coalesce(z.ie_gera_ocorrencia, 'N') ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_mat b,
		pls_combinacao_item_tm z
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.cd_guia_referencia = cd_guia_referencia_pc
	and	b.nr_sequencia = a.nr_seq_conta_mat
	and	z.nr_seq_combinacao = nr_seq_comb_item_pc
	and	z.ie_tipo_registro = 'M'
	and	z.nr_seq_material = b.nr_seq_material
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N');

-- todos os itens para futuro lancamento de ocorrencia quando processamento for por data do item	
c_lanc_it_data CURSOR(	nr_id_transacao_pc	pls_selecao_ocor_cta.nr_id_transacao%type,
			nr_seq_segurado_pc	pls_conta.nr_seq_segurado%type,
			dt_item_pc		pls_selecao_ocor_cta.dt_item%type,
			nr_seq_comb_item_pc	pls_combinacao_item_cta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_selecao,
		coalesce(z.ie_gera_ocorrencia, 'N') ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b,
		pls_combinacao_item_tm z
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.dt_item = dt_item_pc
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and	z.nr_seq_combinacao = nr_seq_comb_item_pc
	and	z.ie_tipo_registro = 'P'
	and	z.ie_origem_proced = b.ie_origem_proced
	and	z.cd_procedimento = b.cd_procedimento
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	
union all

	-- pacotes nao existem na pls_combinacao_item_tm e sao definidos durante a consistencia da conta

	-- por isso o tratamento e feito desta maneira
	SELECT	a.nr_sequencia nr_seq_selecao,
		'S' ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.dt_item = dt_item_pc
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and	b.ie_tipo_despesa = '4'
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	and	exists (select	1
			from	pls_comb_cta_item_proc z
			where	z.nr_seq_combinacao = nr_seq_comb_item_pc
			and	z.ie_tipo_desp_proc = '4')
	
union all

	select	a.nr_sequencia nr_seq_selecao,
		coalesce(z.ie_gera_ocorrencia, 'N') ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_mat b,
		pls_combinacao_item_tm z
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.dt_item = dt_item_pc
	and	b.nr_sequencia = a.nr_seq_conta_mat
	and	z.nr_seq_combinacao = nr_seq_comb_item_pc
	and	z.ie_tipo_registro = 'M'
	and	z.nr_seq_material = b.nr_seq_material
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N');
	
c_lanc_it_seq_conta CURSOR(	nr_id_transacao_pc	pls_selecao_ocor_cta.nr_id_transacao%type,
				nr_seq_segurado_pc	pls_conta.nr_seq_segurado%type,
				nr_seq_conta_pc		pls_selecao_ocor_cta.nr_seq_conta%type,
				nr_seq_comb_item_pc	pls_combinacao_item_cta.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_selecao,
		coalesce(z.ie_gera_ocorrencia, 'N') ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b,
		pls_combinacao_item_tm z
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.nr_seq_conta = nr_seq_conta_pc
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and	z.nr_seq_combinacao = nr_seq_comb_item_pc
	and	z.ie_tipo_registro = 'P'
	and	z.ie_origem_proced = b.ie_origem_proced
	and	z.cd_procedimento = b.cd_procedimento
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	
union all

	-- pacotes nao existem na pls_combinacao_item_tm e sao definidos durante a consistencia da conta

	-- por isso o tratamento e feito desta maneira
	SELECT	a.nr_sequencia nr_seq_selecao,
		'S' ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_proc b
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.nr_seq_conta = nr_seq_conta_pc
	and	b.nr_sequencia = a.nr_seq_conta_proc
	and	b.ie_tipo_despesa = '4'
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N')
	and	exists (select	1
			from	pls_comb_cta_item_proc z
			where	z.nr_seq_combinacao = nr_seq_comb_item_pc
			and	z.ie_tipo_desp_proc = '4')
	
union all

	select	a.nr_sequencia nr_seq_selecao,
		coalesce(z.ie_gera_ocorrencia, 'N') ie_gera_ocorrencia
	from	pls_oc_cta_selecao_ocor_v a,
		pls_conta_mat b,
		pls_combinacao_item_tm z
	where	a.nr_id_transacao = nr_id_transacao_pc
	and	a.ie_valido = 'S'
	and	a.nr_seq_segurado = nr_seq_segurado_pc
	and	a.nr_seq_conta = nr_seq_conta_pc
	and	b.nr_sequencia = a.nr_seq_conta_mat
	and	z.nr_seq_combinacao = nr_seq_comb_item_pc
	and	z.ie_tipo_registro = 'M'
	and	z.nr_seq_material = b.nr_seq_material
	and (coalesce(b.ie_glosa, 'N') = 'N' or ie_analise_cm_nova_w = 'N');

BEGIN

select	coalesce(max(ie_analise_cm_nova),'S')
into STRICT	ie_analise_cm_nova_w
from	pls_parametros;

-- Deve se ter a informacao da regra para que a validacao seja aplicada.
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then
	
	-- usa uma tabela para armazenar as combinacoes de itens.

	-- no futuro isso deve ser feito atraves de uma view materializada, nao foi feito ainda por motivo de nao existir suporte para este tipo de objetos no TASY
	CALL pls_gerencia_upd_obj_pck.atualizar_objetos(nm_usuario_p, 'PLS_OC_CTA_TRATAR_VAL_32', 'PLS_COMBINACAO_ITEM_TM');
	
	------------------------------------------------------------------------------------------------------------------------------------------

	-- processo que invalida todos os registros que nao tem regra de combinacao de itens

	-- feito antes para desconsiderar o processamento desnecessario de uma grande massa quando nao existe regra para nada que faca parte dela

	-- faz muito sentido e melhora muito a performance

	
	-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
	CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);
	
	-- combinacoes que serao processadas por essa ocorrencia
	for	r_c_somente_regra_w in c_somente_regra(dados_regra_p.nr_sequencia) loop
		
		-- limpa as variaveis
		dados_tb_selecao_w.nr_seq_selecao.delete;
		dados_tb_selecao_w.ie_valido.delete;
		dados_tb_selecao_w.ds_observacao.delete;
		
		-- retorna todos os procedimentos que deverao ficar/continuar validos
		open c_reg_existe_proc(	nr_id_transacao_p, r_c_somente_regra_w.nr_seq_combinacao_item);
		loop
			fetch c_reg_existe_proc bulk collect into 	dados_tb_selecao_w.nr_seq_selecao,
									dados_tb_selecao_w.ie_valido,
									dados_tb_selecao_w.ds_observacao
			limit pls_util_pck.qt_registro_transacao_w;
			exit when dados_tb_selecao_w.nr_seq_selecao.count = 0;
			
			CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao,
									dados_tb_selecao_w.ds_seqs_selecao, 
									'SEQ', 
									dados_tb_selecao_w.ds_observacao, 
									dados_tb_selecao_w.ie_valido, 
									nm_usuario_p);
		end loop;
		close c_reg_existe_proc;
		
		-- limpa as variaveis novamente
		dados_tb_selecao_w.nr_seq_selecao.delete;
		dados_tb_selecao_w.ie_valido.delete;
		dados_tb_selecao_w.ds_observacao.delete;
		
		-- retorna todos os materiais que deverao ficar/continuar validos
		open c_reg_existe_mat(	nr_id_transacao_p, r_c_somente_regra_w.nr_seq_combinacao_item);
		loop
			fetch c_reg_existe_mat bulk collect into 	dados_tb_selecao_w.nr_seq_selecao,
									dados_tb_selecao_w.ie_valido,
									dados_tb_selecao_w.ds_observacao
			limit pls_util_pck.qt_registro_transacao_w;
			exit when dados_tb_selecao_w.nr_seq_selecao.count = 0;
			
			CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao,
									dados_tb_selecao_w.ds_seqs_selecao, 
									'SEQ', 
									dados_tb_selecao_w.ds_observacao, 
									dados_tb_selecao_w.ie_valido, 
									nm_usuario_p);
		end loop;
		close c_reg_existe_mat;
	
	end loop;
	
	-- seta os registros que serao validos ou invalidos apos o processamento 
	CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
	
	-- fim do processo que invalida todos os registros que nao tem regra de combinacao de itens

	------------------------------------------------------------------------------------------------------------------------------------------

	
	-- daqui em diante processa as regras normalmente para decidir se gera ou nao ocorrencia 

	-- nos registros que sobraram (se sobraram registros validos)
	select	count(1)
	into STRICT	qt_registro_valido_w
	from	pls_oc_cta_selecao_ocor_v a
	where	a.nr_id_transacao = nr_id_transacao_p
	and	a.ie_valido = 'S';
	
	-- se ainda existem registros validos processa as regras normalmente
	if (qt_registro_valido_w > 0) then
	
		-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados

		-- e feito novamente para reiniciar o "ciclo" da validacao e marcar corretamente o que vai ser processado novamente
		CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);
		
		-- Buscar os dados da regra de validacao conforme montado pelo usuario.
		for	r_c_regra_comb_w in c_regra_comb(dados_regra_p.nr_sequencia) loop
			
			-- se tiver alguma regra cadastrada processa
			if (r_c_regra_comb_w.qt_regra_proc > 0 or r_c_regra_comb_w.qt_regra_mat > 0) then
			
				dados_cab_regra_w.nr_sequencia			:= r_c_regra_comb_w.nr_seq_combinada;
				dados_cab_regra_w.dt_inicio_vigencia		:= r_c_regra_comb_w.dt_inicio_vigencia;
				dados_cab_regra_w.dt_fim_vigencia		:= r_c_regra_comb_w.dt_fim_vigencia;
				dados_cab_regra_w.qt_dias_considerar		:= r_c_regra_comb_w.qt_dias_considerar;
				dados_cab_regra_w.ie_conta_igual_comb		:= r_c_regra_comb_w.ie_conta_igual_comb;
				dados_cab_regra_w.ie_ocorrencia_conta		:= r_c_regra_comb_w.ie_ocorrencia_conta;
				dados_cab_regra_w.ie_ou_excecao			:= r_c_regra_comb_w.ie_ou_excecao;
				dados_cab_regra_w.qt_regra_proc			:= r_c_regra_comb_w.qt_regra_proc + r_c_regra_comb_w.qt_regra_pacote;
				dados_cab_regra_w.qt_regra_mat			:= r_c_regra_comb_w.qt_regra_mat;
				dados_cab_regra_w.qt_regra_proc_and		:= r_c_regra_comb_w.qt_regra_proc_and;
				dados_cab_regra_w.qt_regra_proc_or		:= r_c_regra_comb_w.qt_regra_proc_or;
				dados_cab_regra_w.qt_regra_mat_and		:= r_c_regra_comb_w.qt_regra_mat_and;
				dados_cab_regra_w.qt_regra_mat_or		:= r_c_regra_comb_w.qt_regra_mat_or;
				dados_cab_regra_w.ie_tipo_verificacao		:= r_c_regra_comb_w.ie_tipo_verificacao;
				dados_cab_regra_w.ie_mesmo_prestador_exec_princ	:= r_c_regra_comb_w.ie_mesmo_prestador_exec_princ;
				nr_seq_combinacao_item_w			:= r_c_regra_comb_w.nr_seq_combinacao_item;

				
				-- por atendimento considera o segurado e a guia
				if (dados_cab_regra_w.ie_tipo_verificacao = '1') then
					open c_guia(nr_id_transacao_p, nr_seq_combinacao_item_w);
				elsif (dados_cab_regra_w.ie_tipo_verificacao = '2') then
					--  busca por segurado e data do item
					open c_dt_item(nr_id_transacao_p, nr_seq_combinacao_item_w);
				else
					-- busca por segurado e conta  
					open c_nr_seq_conta(nr_id_transacao_p, nr_seq_combinacao_item_w);
				end if;
				
				loop
					-- faz o loop de acordo com o tipo de validacao
					if (dados_cab_regra_w.ie_tipo_verificacao = '1') then
					
						fetch c_guia into nr_seq_segurado_w, cd_guia_referencia_w, nr_seq_prestador_exec_princ_w;
						EXIT WHEN NOT FOUND; /* apply on c_guia */
						
					elsif (dados_cab_regra_w.ie_tipo_verificacao = '2') then
					
						fetch c_dt_item into nr_seq_segurado_w, dt_item_w, nr_seq_prestador_exec_princ_w;
						EXIT WHEN NOT FOUND; /* apply on c_dt_item */
					else
						fetch c_nr_seq_conta into nr_seq_segurado_w, nr_seq_conta_w, nr_seq_prestador_exec_princ_w;
						EXIT WHEN NOT FOUND; /* apply on c_nr_seq_conta */
					end if;
					
					-- busca o select que trara os dados dos itens que precisam ser analisados
					bind_sql_w := pls_simult_concor_pck.obter_select_val_32(	dados_cab_regra_w, dados_regra_p, nr_seq_segurado_w, cd_guia_referencia_w, dt_item_w, nr_seq_conta_w, nr_seq_prestador_exec_princ_w, nr_id_transacao_p, bind_sql_w);
												
					
					-- inicializa as variaveis que conterao os totais
					qt_tot_casou_proc_and_w	:= 0;
					qt_tot_casou_proc_ou_w	:= 0;
					qt_tot_casou_proc_pacote_and_w := 0;
					qt_tot_casou_proc_pacote_or_w := 0;
					qt_tot_casou_mat_and_w	:= 0;
					qt_tot_casou_mat_ou_w	:= 0;
					qt_tot_item_guia_proc_w := 0;
					qt_tot_item_guia_mat_w := 0;
					qt_tot_agrup_proc_and_w := 0;
					qt_tot_agrup_mat_and_w := 0;
					
					-- cursor que le as quantidades de itens para guias ou datas

					-- sao armazenados dados em variaveis e mais abaixo e feito o processamento para decidir se lanca ou nao a ocorrencia
					bind_sql_w := sql_pck.executa_sql_cursor(	ds_sql_w, bind_sql_w);
					loop
						fetch cursor_w
						into 	ie_tipo_registro_w, qt_casou_and_w, qt_casou_ou_w,
							qt_casou_pacote_and_w, qt_casou_pacote_ou_w,
							qt_agrup_item_w, dt_item_ini_w, dt_item_fim_w,
							qt_total_item_guia_w;
						EXIT WHEN NOT FOUND; /* apply on cursor_w */
						
						ie_atendeu_regra_w := true;
						
						-- se foi informada a diferenca entre datas so faz a verificacao caso a validacao seja por guia

						-- pois se for por data todas as datas serao iguais e nao fara sentido algum
						if (dados_cab_regra_w.qt_dias_considerar > 0 and dados_cab_regra_w.ie_tipo_verificacao = '1') then
						
							qt_dif_dias_w	:= round(dt_item_fim_w - dt_item_ini_w);
			
							-- Se a quantidade de dias nao se enquadrar, nao pode aplicar a regra 
							if (qt_dif_dias_w > dados_cab_regra_w.qt_dias_considerar) then
								ie_atendeu_regra_w := false;
							end if;
						end if;
						
						-- os totais existentes devem ser alimentados sempre, independente de ter atendido ou nao a regra

						-- pois se a regra nao foi atendida, o total deve ser armazenado, porque ele nao obedece as regras
						if (ie_tipo_registro_w = 'P') then
							qt_tot_item_guia_proc_w := qt_tot_item_guia_proc_w + qt_total_item_guia_w;
							
						elsif (ie_tipo_registro_w = 'M') then
							qt_tot_item_guia_mat_w := qt_tot_item_guia_mat_w + qt_total_item_guia_w;
						end if;
						
						-- se a regra de data foi atendida armazena os totalizadores
						if (ie_atendeu_regra_w) then
							
							if (ie_tipo_registro_w = 'P') then
								
								qt_tot_casou_proc_and_w := qt_tot_casou_proc_and_w + qt_casou_and_w;
								qt_tot_casou_proc_ou_w := qt_tot_casou_proc_ou_w + qt_casou_ou_w;
								qt_tot_agrup_proc_and_w := qt_tot_agrup_proc_and_w + qt_agrup_item_w;
								qt_tot_casou_proc_pacote_and_w := qt_tot_casou_proc_pacote_and_w + qt_casou_pacote_and_w;
								qt_tot_casou_proc_pacote_or_w := qt_tot_casou_proc_pacote_or_w + qt_casou_pacote_ou_w;

							elsif (ie_tipo_registro_w = 'M') then
								
								qt_tot_casou_mat_and_w := qt_tot_casou_mat_and_w + qt_casou_and_w;
								qt_tot_casou_mat_ou_w := qt_tot_casou_mat_ou_w + qt_casou_ou_w;
								qt_tot_agrup_mat_and_w := qt_tot_agrup_mat_and_w + qt_agrup_item_w;
							end if;
						end if;
					end loop;
					close cursor_w;

					ie_proc_e_w := 'N';
					ie_mat_e_w := 'N';
					ie_proc_ou_w := 'N';
					ie_mat_ou_w := 'N';
					
					-- regra AND procedimento
					if (dados_cab_regra_w.ie_conta_igual_comb = 'S') then

						-- se for para regra AND considerar tudo o que esta na regra e somente o que esta na regra

						-- verifica somente se todos os itens da regra existem na guia e 

						-- se nao existem outros itens na guia

						-- nesse caso a quantidade de itens da guia deve ser igual a que casou
						if	(qt_tot_casou_proc_and_w = r_c_regra_comb_w.qt_regra_proc_and AND qt_tot_casou_proc_and_w = qt_tot_item_guia_proc_w) then
							
							ie_proc_e_w := 'S';
							
						-- caso os totais dos grupos sejam iguais tambem valida

						-- resolve a situacao de regras em branco ou cadastro por grupos que acabam tendo varios materiais na tabela TM

						-- e nem todos precisam ter o casamento feito, apenas todos os materiais existentes na conta devem existir na tabela TM

						-- e o que casou deve ser igual ao que existe na guia
						elsif	(qt_tot_agrup_proc_and_w = r_c_regra_comb_w.qt_grupos_distintos_proc AND qt_tot_casou_proc_and_w = qt_tot_item_guia_proc_w)then
					
							ie_proc_e_w := 'S';
						end if;
					-- verifica somente se todos os itens da regra existem na guia
					elsif (qt_tot_casou_proc_and_w = r_c_regra_comb_w.qt_regra_proc_and) then
						
						ie_proc_e_w := 'S';
					-- Para o caso de grupos na regra. sera valido quando os grupos que tiveram casamento forem iguais ao total da regra.	

					-- resolve a situacao de regras em branco ou cadastro por grupos que acabam tendo varios materiais na tabela TM

					-- e nem todos precisam ter o casamento feito, apenas todos os procedimentos existentes na conta devem existir na tabela TM
					elsif (qt_tot_agrup_proc_and_w = r_c_regra_comb_w.qt_grupos_distintos_proc) then				
					
						ie_proc_e_w := 'S';
					else
						ie_proc_e_w := 'N';
					end if;
					
					-- se tiver regra para pacote precisa existir pelo menos um pacote

					-- em toda a selecao de guia ou data
					if (r_c_regra_comb_w.qt_regra_pacote_and > 0) then
						-- se nao tiver nenhuma outra regra, apenas precisa ter pelo menos um pacote
						if (r_c_regra_comb_w.qt_regra_proc_and = 0) then
							-- pelo menos um pacote
							if (qt_tot_casou_proc_pacote_and_w > 0) then
								ie_proc_e_w := 'S';
							else
								ie_proc_e_w := 'N';
							end if;
						else
							if (ie_proc_e_w = 'S' and qt_tot_casou_proc_pacote_and_w > 0) then
								ie_proc_e_w := 'S';
							else
								ie_proc_e_w := 'N';
							end if;
						end if;
					end if;
					
					-- regra AND material
					if (dados_cab_regra_w.ie_conta_igual_comb = 'S') then

						-- se for para regra AND considerar tudo o que esta na regra e somente o que esta na regra

						-- verifica somente se todos os itens da regra existem na guia e 

						-- se nao existem outros itens na guia
						if	(qt_tot_casou_mat_and_w = r_c_regra_comb_w.qt_regra_mat_and AND qt_tot_casou_mat_and_w = qt_tot_item_guia_mat_w) then
							
							ie_mat_e_w := 'S';
							
						-- caso os totais dos grupos sejam iguais valida

						-- resolve a situacao de regras em branco ou cadastro por grupos que acabam tendo varios materiais na tabela TM

						-- e nem todos precisam ter o casamento feito, apenas todos os materiais existentes na conta devem existir na tabela TM

						-- e o que casou deve ser igual ao que existe na guia
						elsif	(qt_tot_agrup_mat_and_w = r_c_regra_comb_w.qt_grupos_distintos_mat AND qt_tot_casou_mat_and_w = qt_tot_item_guia_mat_w) then
					
							ie_mat_e_w := 'S';
						end if;
					-- verifica somente se todos os itens da regra existem na guia ou

					-- se todos os itens da guia foram casados com itens (previnir regra em branco)
					elsif (qt_tot_casou_mat_and_w = r_c_regra_comb_w.qt_regra_mat_and) then
						
						ie_mat_e_w := 'S';
						
					-- Para o caso de grupos na regra. sera valido quando os grupos que tiveram casamento forem iguais ao total da regra.	

					-- resolve a situacao de regras em branco ou cadastro por grupos que acabam tendo varios materiais na tabela TM

					-- e nem todos precisam ter o casamento feito, apenas todos os materiais existentes na conta devem existir na tabela TM
					elsif (qt_tot_agrup_mat_and_w = r_c_regra_comb_w.qt_grupos_distintos_mat) then				
					
						ie_mat_e_w := 'S';
					else
						ie_mat_e_w := 'N';
					end if;
					
					-- regra OU procedimento e material

					-- nao existe processamento de regra OU se o ie_conta_igual_comb = S
					if (dados_cab_regra_w.ie_conta_igual_comb = 'N') then
						
						-- regra OU procedimento

						-- se casou alguma coisa ou se nao tem regra cadastrada
						if (qt_tot_casou_proc_ou_w > 0 or r_c_regra_comb_w.qt_regra_proc_or = 0) then
							ie_proc_ou_w := 'S';
						else
							ie_proc_ou_w := 'N';
						end if;
						
						-- regra OU material

						-- se casou alguma coisa ou se nao tem regra cadastrada
						if (qt_tot_casou_mat_ou_w > 0 or r_c_regra_comb_w.qt_regra_mat_or = 0) then
							ie_mat_ou_w := 'S';
						else
							ie_mat_ou_w := 'N';
						end if;
						
						-- se tiver regra para pacote precisa existir pelo menos um pacote

						-- em toda a selecao de guia ou data
						if (r_c_regra_comb_w.qt_regra_pacote_or > 0) then
							-- se nao tiver nenhuma outra regra, apenas precisa ter pelo menos um pacote
							if (r_c_regra_comb_w.qt_regra_proc_or = 0) then
								-- pelo menos um pacote
								if (qt_tot_casou_proc_pacote_or_w > 0) then
									ie_proc_ou_w := 'S';
								else
									ie_proc_ou_w := 'N';
								end if;
							else
								if (ie_proc_ou_w = 'S' and qt_tot_casou_proc_pacote_or_w > 0) then
									ie_proc_ou_w := 'S';
								else
									ie_proc_ou_w := 'N';
								end if;
							end if;
						end if;
						
						-- se alguma situacao acima for verdade

						-- feito isso para previnir os casos em que exista uma regra OU cadastrada, por exemplo, para procedimento

						-- e a mesma nao se encaixe e nao tenha nada para material. 

						-- acima, quando nao existe regra para item diz que a regra e valida, 

						-- entretanto como e um OU se a que tem nao casar entao nada pode ser valido
						if (ie_proc_ou_w = 'S' or ie_mat_ou_w = 'S') then
						
							-- se o procedimento tem S porque nao tinha regra cadastrada
							if (ie_proc_ou_w = 'S' and r_c_regra_comb_w.qt_regra_proc_or = 0) then
								-- caso o ie_mat for N, esse vira N tambem
								if (ie_mat_ou_w = 'N') then
									ie_proc_ou_w := 'N';
								end if;
							end if;
							
							-- se o material tem S porque nao tinha regra cadastrada
							if (ie_mat_ou_w = 'S' and r_c_regra_comb_w.qt_regra_mat_or = 0) then
								-- caso o ie_proc for N, esse vira N tambem
								if (ie_proc_ou_w = 'N') then
									ie_mat_ou_w := 'N';
								end if;
							end if;
						end if;
					
					else
						ie_proc_ou_w := 'S';
						ie_mat_ou_w := 'S';
					end if;
					
					-- se regra ou for considerada excecao
					if (dados_cab_regra_w.ie_ou_excecao = 'S') then
						
						-- se casou alguma coisa nao gera nada
						if (qt_tot_casou_proc_ou_w > 0 or qt_tot_casou_mat_ou_w > 0 or (r_c_regra_comb_w.qt_regra_pacote_or > 0 and qt_tot_casou_proc_pacote_or_w > 0)) then
							ie_proc_e_w := 'N';
							ie_mat_e_w := 'N';
							ie_proc_ou_w := 'N';
							ie_mat_ou_w := 'N';
						end if;
					
					end if;
					
					

					-- manda para o banco se casou

					-- regra AND deve casar para proc e mat e regra OU apenas um dois dois casando ja atende

					-- se nao casar nenhuma regra OU e o checkbox de regra OU ser excecao estiver marcado, gera ocorrencia
					if	((ie_proc_e_w = 'S' and ie_mat_e_w = 'S') and
						(
						(ie_proc_ou_w = 'S' or ie_mat_ou_w = 'S') or (ie_proc_ou_w = 'N' and ie_mat_ou_w = 'N' and dados_cab_regra_w.ie_ou_excecao = 'S'))
						) then
						
						
					
						ds_observacao_w := substr(pls_simult_concor_pck.obter_obs_val_32(	dados_cab_regra_w,
															cd_guia_referencia_w,
															nr_seq_segurado_w,
															dt_item_w,
															nr_seq_conta_w,
															dados_regra_p.ie_evento), 1, 2000);
						-- se entrou aqui significa que a ocorrencia deve ser lancada.

						-- entao, busca-se tudo o que esta na tabela de selecao e na estrutura de combinacao e lanca ocorrencia


						-- por atendimento considera o segurado e a guia
						if (dados_cab_regra_w.ie_tipo_verificacao = '1') then
							open c_lanc_it_guia(	nr_id_transacao_p, nr_seq_segurado_w,
										cd_guia_referencia_w, dados_cab_regra_w.nr_sequencia);
						elsif (dados_cab_regra_w.ie_tipo_verificacao = '2') then
							--  busca por segurado e data do item
							open c_lanc_it_data(	nr_id_transacao_p, nr_seq_segurado_w,
										dt_item_w, dados_cab_regra_w.nr_sequencia);
						else
							--busca por segurado e sequencia da conta
							open c_lanc_it_seq_conta(	nr_id_transacao_p, nr_seq_segurado_w,
											nr_seq_conta_w, dados_cab_regra_w.nr_sequencia);
							
						end if;
						
						nr_indice_w := 0;
						dados_tb_selecao_w.nr_seq_selecao.delete;
						dados_tb_selecao_w.ds_seqs_selecao.delete;
						dados_tb_selecao_w.ie_valido.delete;
						dados_tb_selecao_w.ds_observacao.delete;
						loop
							-- abre o cursor de acordo com o tipo de validacao
							if (dados_cab_regra_w.ie_tipo_verificacao = '1') then
							
								fetch c_lanc_it_guia into nr_seq_selecao_w, ie_gera_ocor_item_w;
								EXIT WHEN NOT FOUND; /* apply on c_lanc_it_guia */
								
							elsif (dados_cab_regra_w.ie_tipo_verificacao = '2') then
							
								fetch c_lanc_it_data into nr_seq_selecao_w, ie_gera_ocor_item_w;
								EXIT WHEN NOT FOUND; /* apply on c_lanc_it_data */
								
							else
								
								fetch c_lanc_it_seq_conta into nr_seq_selecao_w, ie_gera_ocor_item_w;
								EXIT WHEN NOT FOUND; /* apply on c_lanc_it_seq_conta */
								
							end if;
							
							-- se for para gerar ocorrencia no item ou na conta, sinaliza para gerar
							if (ie_gera_ocor_item_w = 'S' or dados_cab_regra_w.ie_ocorrencia_conta = 'S') then
								
								dados_tb_selecao_w.ie_valido(nr_indice_w) := 'S';
								dados_tb_selecao_w.nr_seq_selecao(nr_indice_w) := nr_seq_selecao_w;
								dados_tb_selecao_w.ds_seqs_selecao(nr_indice_w) := null;
								dados_tb_selecao_w.ds_observacao(nr_indice_w) := ds_observacao_w;
							
								if (nr_indice_w >= pls_cta_consistir_pck.qt_registro_transacao_w) then
									CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao,
															dados_tb_selecao_w.ds_seqs_selecao, 
															'SEQ', 
															dados_tb_selecao_w.ds_observacao, 
															dados_tb_selecao_w.ie_valido, 
															nm_usuario_p);
									dados_tb_selecao_w.nr_seq_selecao.delete;
									dados_tb_selecao_w.ds_seqs_selecao.delete;
									dados_tb_selecao_w.ie_valido.delete;
									dados_tb_selecao_w.ds_observacao.delete;
									nr_indice_w := 0;
								else
									nr_indice_w := nr_indice_w + 1;
								end if;
							end if;
						end loop;

						-- se sobrou alguma coisa manda para o banco
						CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao,
												dados_tb_selecao_w.ds_seqs_selecao, 
												'SEQ', 
												dados_tb_selecao_w.ds_observacao, 
												dados_tb_selecao_w.ie_valido, 
												nm_usuario_p);
						
						-- fecha o cursor de acordo com o tipo de validacao
						if (dados_cab_regra_w.ie_tipo_verificacao = '1') then
							close c_lanc_it_guia;
						elsif (dados_cab_regra_w.ie_tipo_verificacao = '2') then
							close c_lanc_it_data;
						else
							close c_lanc_it_seq_conta;
						end if;
						
						dados_tb_selecao_w.nr_seq_selecao.delete;
						dados_tb_selecao_w.ds_seqs_selecao.delete;
						dados_tb_selecao_w.ie_valido.delete;
						dados_tb_selecao_w.ds_observacao.delete;
					end if;

				end loop;
				
				-- faz o fechamento do cursor de acordo com o tipo de validacao
				if (dados_cab_regra_w.ie_tipo_verificacao = '1') then
					close c_guia;
				elsif (dados_cab_regra_w.ie_tipo_verificacao = '2') then
					close c_dt_item;
				else
					close c_nr_seq_conta;
				end if;
			end if;
		end loop;
		
		-- seta os registros que serao validos ou invalidos apos o processamento 
		CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
	end if;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_32 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

