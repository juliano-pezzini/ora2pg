-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_oc_concorrente ( nr_seq_regra_p bigint, cd_procedimento_p bigint, ie_origem_proced_p bigint, dt_procedimento_p timestamp, nr_seq_conta_p bigint, cd_estabelecimento_p bigint, nm_usuario_p text, ie_gerar_ocorrencia_p INOUT text) AS $body$
DECLARE


qt_procedimentos_principal_w		bigint;
qt_procedimentos_w			bigint;
cd_procedimento_w			bigint;
ie_origem_proced_w			bigint;
ie_gera_ocorrencia_w			varchar(1);
qt_dias_w				smallint;
nr_seq_segurado_w			bigint;
cd_guia_referencia_w			varchar(20);
dt_regra_proc_w				timestamp;
dt_procedimento_param_w			timestamp;
nr_seq_grupo_rec_w			bigint;
nr_seq_grupo_rec_ww			bigint;

BEGIN
/*Definição da regra de concorrente, a mesma deve ser gerada sempre que houver um item com o campo proc principal marcado na wcpanel itens e ao menos um sem o campo marcado, não há necessidade de haver todos os itens na conta
para estes casos deve ser utilizado a regra de simultâneo
/* William - OS 397802 - Performance, trocado NVL/MAX por EXCEPTION */

begin
select	qt_dias
into STRICT	qt_dias_w
from	pls_regra_concorrente
where	nr_sequencia	= nr_seq_regra_p;
exception
when others then
	qt_dias_w := 999;
end;

dt_regra_proc_w	:= dt_procedimento_p - qt_dias_w;

dt_regra_proc_w := trunc(dt_regra_proc_w,'dd');

dt_procedimento_param_w := fim_dia(dt_procedimento_p);

select	nr_seq_segurado,
	cd_guia_referencia
into STRICT	nr_seq_segurado_w,
	cd_guia_referencia_w
from	pls_conta
where	nr_sequencia	= nr_seq_conta_p;

/*Obter quantos procedimentos principais existem*/

select	count(a.nr_sequencia)
into STRICT	qt_procedimentos_principal_w
from	pls_proc_concorrente a
where	a.nr_seq_regra 	= nr_seq_regra_p
and	a.ie_principal	= 'S'
and	a.ie_situacao	= 'A'
and	exists (SELECT	1
		 from	pls_conta_proc	x,
			pls_conta	c
		 where	x.nr_seq_conta		= c.nr_sequencia
		 and	c.nr_seq_segurado	= nr_seq_segurado_w
		 and	c.cd_guia_referencia	= cd_guia_referencia_w
		 and	x.cd_procedimento 	= a.cd_procedimento
		 and	x.ie_origem_proced	= a.ie_origem_proced
		 and	x.dt_procedimento 	between dt_regra_proc_w and dt_procedimento_param_w
		
union all

		 SELECT	1
		 from	pls_conta_proc	x,
			pls_conta	c
		 where	x.nr_seq_conta		= c.nr_sequencia
		 and	c.nr_seq_segurado	= nr_seq_segurado_w
		 and	c.nr_sequencia		= nr_seq_conta_p
		 and	x.cd_procedimento 	= a.cd_procedimento
		 and	x.ie_origem_proced	= a.ie_origem_proced
		 and	x.dt_procedimento 	between dt_regra_proc_w and dt_procedimento_param_w)  LIMIT 1;
		 /* William - OS 397802 - Performance, ajustado as tabelas e as datas */

/*Se existir ao menos um procedimento principal na conta*/

if (qt_procedimentos_principal_w > 0) then
	select	count(a.nr_sequencia)
	into STRICT	qt_procedimentos_w
	from	pls_proc_concorrente a
	where	a.nr_seq_regra 	= nr_seq_regra_p
	and	a.ie_principal	= 'N'
	and	a.ie_situacao	= 'A'
	and	exists (SELECT	1
			 from	pls_conta_proc	x,
				pls_conta	c
			 where	x.nr_seq_conta		= c.nr_sequencia
			 and	c.nr_seq_segurado	= nr_seq_segurado_w
			 and	c.cd_guia_referencia	= cd_guia_referencia_w
			 and	x.cd_procedimento 	= a.cd_procedimento
			 and	x.ie_origem_proced	= a.ie_origem_proced
			 and	x.dt_procedimento between dt_regra_proc_w and dt_procedimento_param_w
			
union all

			 SELECT	1
			 from	pls_conta_proc	x,
				pls_conta	c
			 where	x.nr_seq_conta		= c.nr_sequencia
			 and	c.nr_seq_segurado	= nr_seq_segurado_w
			 and	c.nr_sequencia		= nr_seq_conta_p
			 and	x.cd_procedimento 	= a.cd_procedimento
			 and	x.ie_origem_proced	= a.ie_origem_proced
			 and	x.dt_procedimento between dt_regra_proc_w and dt_procedimento_param_w)  LIMIT 1;
	/*tratamento para receita*/

	 if (qt_procedimentos_w > 0) then
		if (coalesce(cd_procedimento_p,0) > 0) then

			select 	max(a.nr_seq_grupo_rec)
			into STRICT	nr_seq_grupo_rec_w
			from	pls_proc_concorrente a
			where	nr_seq_regra = nr_seq_regra_p;

			select	max(nr_seq_grupo_rec)
			into STRICT	nr_seq_grupo_rec_ww
			from	procedimento
			where	cd_procedimento		= cd_procedimento_p
			and	ie_origem_proced	= ie_origem_proced_p;


			if (nr_seq_grupo_rec_w  = nr_seq_grupo_rec_ww)	and
				((nr_seq_grupo_rec_w	> 0) 			or (nr_seq_grupo_rec_ww	> 0))			then
				ie_gera_ocorrencia_w	:= 'S';
				qt_procedimentos_w	:= 1;
			end if;

		end if;
	end if;


	/*Se haver ao menor um procedimento principal com um não principal  é gerado ocorrencia*/

	if (qt_procedimentos_w > 0) then
		ie_gera_ocorrencia_w := 'S';

		/*Se for uma verificação de itens é verificado se deve gerar ocorrencia naquele item*/

		if (coalesce(cd_procedimento_p,0) > 0) then
			select	CASE WHEN count(a.nr_sequencia)=0 THEN 'N'  ELSE 'S' END
			into STRICT	ie_gera_ocorrencia_w
			from	pls_proc_concorrente a
			where	a.nr_seq_regra 		= nr_seq_regra_p
			and	a.ie_ocorrencia		= 'S'
			and	a.ie_situacao		= 'A'
			and	a.cd_procedimento	= cd_procedimento_p
			and	a.ie_origem_proced	= ie_origem_proced_p;
		end if;
	end if;
end if;

ie_gerar_ocorrencia_p := ie_gera_ocorrencia_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_oc_concorrente ( nr_seq_regra_p bigint, cd_procedimento_p bigint, ie_origem_proced_p bigint, dt_procedimento_p timestamp, nr_seq_conta_p bigint, cd_estabelecimento_p bigint, nm_usuario_p text, ie_gerar_ocorrencia_p INOUT text) FROM PUBLIC;

