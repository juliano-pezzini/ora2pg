-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE fechar_conta_paciente ( nr_interno_conta_p bigint, nr_atendimento_p bigint, ie_status_acerto_p bigint, nm_usuario_p text, ds_erro_p INOUT text) AS $body$
DECLARE



cd_empresa_w		empresa.cd_empresa%type;
ie_geracao_w		ctb_regra_geracao_lote_rec.ie_geracao%type;
ie_ctb_online_w		ctb_param_lote_nf.ie_ctb_online%type	:= 'N';
ds_erro_w			varchar(255) 	:= '';
ie_tipo_convenio_w			smallint		:= 0;
ie_fecha_atendimento_w		varchar(1)	:= '';
ie_fecha_conta_w			varchar(1)	:= 'N';
qt_processo_pendente_w		bigint	:= 0;
ie_gera_longa_perm_w		varchar(1)	:= 'N';
ie_tipo_atendimento_w		smallint		:= 0;
nr_seq_apresent_w			bigint	:= 0;
ie_complexidade_w			varchar(1)	:= 'B';
cd_estabelecimento_w		integer	:= 0;
ie_repasse_w			varchar(01)	:= 'N';
vl_conta_w			double precision	:= 0;
vl_desconto_w			double precision	:= 0;
vl_item_w				double precision;
vl_guia_w			double precision;
ie_clinica_alta_w			varchar(03);
qt_anos_w			integer;
cd_convenio_w			integer;
qt_aih_vinculada_w			integer;
nr_aih_w				bigint;
qt_aih_unif_w			bigint;
qt_laudo_aih_unif_w			bigint;
ie_gera_longa_perm_unif_w		varchar(1)	:= 'N';
ie_status_acerto_w			integer;
ie_repasse_proc_conv_w		varchar(1);
ie_repasse_mat_conv_w		varchar(1);
ie_gerar_alta_tesouraria_w		varchar(1);
ie_alta_w				varchar(1);

qt_reg_w				bigint;
qt_desc_conta_w			bigint;
nr_seq_mat_desc_w		bigint;
nr_seq_desc_w			bigint;
qt_exclusao_w			bigint;
cd_proc_long_perm_w		bigint;
ie_orig_proc_long_perm_w		bigint;
nr_seq_proc_desc_w		bigint;
qt_erro_w				bigint;
qt_contas_abertas_w		bigint;
ie_vincular_laudos_aih_w	varchar(10)	:= 'N';
qt_desconto_w			bigint;
qt_regra_atend_conv_w		bigint:=0;
qt_regra_instrumentador_w	bigint;
ie_mexico_w			varchar(2):= 'N';
ds_nls_territory_w		varchar(64);
cd_pais_w			bigint := philips_param_pck.get_cd_pais;
ie_tipo_atend_conta_w           conta_paciente.ie_tipo_atend_conta%type := 0;
ie_gerar_seq_planserv_w         varchar(255);
ie_permite_desd_planserv_w       varchar(1) := 'N';
cont_w				bigint;
ie_vinc_apac_w                  bigint;
ie_existe_conta_w               bigint;
ie_vincular_automatic_bpa_w     varchar(2);
nr_atendimento_w		bigint	:= nr_atendimento_p;
ie_desconto_contabil_w          parametro_faturamento.ie_desconto_contabil%type;

c01 CURSOR FOR
	--OS  222371
	SELECT	count(*), b.nr_sequencia
	from	mat_atend_paciente_valor a,
		material_atend_paciente  b
	where	b.nr_sequencia = a.nr_seq_material
	and 	a.ie_tipo_valor	= 3
	and 	b.nr_interno_conta = nr_interno_conta_p
	group by b.nr_sequencia
	having count(*) > 1
	order by b.nr_sequencia;

c02 CURSOR FOR
	SELECT	count(*), b.nr_sequencia
	from	proc_paciente_valor a,
		procedimento_paciente  b
	where	b.nr_sequencia = a.nr_seq_procedimento
	and 	a.ie_tipo_valor	= 3
	and 	b.nr_interno_conta = nr_interno_conta_p
	group by b.nr_sequencia
	having count(*) > 1
	order by b.nr_sequencia;
	
C03 CURSOR FOR
	SELECT	a.nr_seq_material,
		a.nr_seq_desconto
	from	mat_atend_paciente_valor a,
		material_atend_paciente  b
	where	(nr_seq_desconto IS NOT NULL AND nr_seq_desconto::text <> '')
	and 	a.ie_tipo_valor	= 3
	and 	a.nr_seq_material = b.nr_sequencia
	and 	b.nr_interno_conta = nr_interno_conta_p;
	
C04 CURSOR FOR
	SELECT	a.nr_seq_procedimento,
		a.nr_seq_desconto
	from	proc_paciente_valor    a,
		procedimento_paciente  b
	where	(nr_seq_desconto IS NOT NULL AND nr_seq_desconto::text <> '')
	and 	a.ie_tipo_valor	= 3
	and 	a.nr_seq_procedimento = b.nr_sequencia
	and 	b.nr_interno_conta = nr_interno_conta_p;


BEGIN

if (coalesce(cd_pais_w::text, '') = '') then
	cd_pais_w := 1;
end if;

begin
select	substr(value,1,64)
into STRICT	ds_nls_territory_w
from	v$nls_parameters
where	parameter = 'NLS_TERRITORY';
exception
when others then
	ds_nls_territory_w:='BRAZIL';	
end;

if (ds_nls_territory_w = 'MEXICO') or (cd_pais_w = 2) then
	ie_mexico_w := 'S';
else	
	ie_mexico_w := 'N';
end if;

begin
CALL gerar_agrupamento_mat(nr_interno_conta_p,nm_usuario_p);
exception
when others then
	qt_erro_w:=1;
end;


begin

select	b.ie_tipo_convenio,
	c.ie_tipo_atendimento,
	ie_complexidade,
	c.cd_estabelecimento,
	a.cd_convenio_parametro,
	coalesce(a.ie_tipo_atend_conta,0)
into STRICT	ie_tipo_convenio_w,
	ie_tipo_atendimento_w,
	ie_complexidade_w,
	cd_estabelecimento_w,
	cd_convenio_w,
	ie_tipo_atend_conta_w
from	conta_paciente a,
	convenio b,
	atendimento_paciente c
where	a.cd_convenio_parametro	= b.cd_convenio
and	a.nr_interno_conta	= nr_interno_conta_p
and	c.nr_atendimento	= a.nr_atendimento;
exception
when others then
	ie_tipo_convenio_w := 0;
end;
if (coalesce(nr_atendimento_w::text, '') = '' or nr_atendimento_w <0) then
	select	max(nr_atendimento)
	into STRICT	nr_atendimento_w
	from	conta_paciente
	where	nr_interno_conta = nr_interno_conta_p;
end if;
ie_gerar_alta_tesouraria_w      := coalesce(Obter_Valor_Param_Usuario(67,547,Obter_Perfil_Ativo,nm_usuario_p,cd_estabelecimento_w),'N');
ie_gerar_seq_planserv_w         := coalesce(Obter_Valor_Param_Usuario(67,734,Obter_Perfil_Ativo,nm_usuario_p,cd_estabelecimento_w),'0');
ie_vincular_automatic_bpa_w	:= coalesce(Obter_Valor_Param_Usuario(1125,173,Obter_Perfil_Ativo,nm_usuario_p,cd_estabelecimento_w),'N');

begin
select	coalesce(cd_proc_long_perm,0),
	ie_orig_proc_long_perm,
	coalesce(ie_permite_desd_planserv,'N')
into STRICT	cd_proc_long_perm_w,
	ie_orig_proc_long_perm_w,
	ie_permite_desd_planserv_w
from	convenio_estabelecimento
where	cd_convenio 		= cd_convenio_w
and	cd_estabelecimento	= cd_estabelecimento_w;
exception
when others then
	cd_proc_long_perm_w		:= 0;
	ie_orig_proc_long_perm_w	:= 0;
	ie_permite_desd_planserv_w 	:= 'N';
end;

/* Gerar procedimento CIH(SUS) para internados de convenios */

if (ie_tipo_convenio_w	<> 3) and (ie_tipo_atendimento_w	= 1) 	and (ie_status_acerto_p 	= 2) 	then
	begin
	CALL gerar_procedimento_cih( nr_atendimento_w,
					cd_convenio_w,
					ie_tipo_atendimento_w,
					nr_interno_conta_p,
					nm_usuario_p);
	end;
end if;

select	count(1)
into STRICT	qt_regra_instrumentador_w
from	regra_taxa_instrumentador
where	cd_convenio = cd_convenio_w;

if (qt_regra_instrumentador_w	> 0) then
	gerar_taxa_instrumentador(nr_interno_conta_p,nm_usuario_p);
end if;

/* Verificar se o atendimento e SUS AIH novo */

select	count(1)
into STRICT	qt_aih_unif_w
from	sus_aih_unif
where	nr_atendimento	= nr_atendimento_w  LIMIT 1;

if (ie_tipo_convenio_w	= 3) and (ie_tipo_atendimento_w	= 1) and (ie_status_acerto_p = 2) then
	begin

	if (qt_aih_unif_w	= 0) then
		begin
		/* Rotina para vincular conta com AIH e laudos */

		select	count(1)
		into STRICT	qt_aih_vinculada_w
		from	sus_aih
		where	nr_atendimento		= nr_atendimento_w
		and	nr_interno_conta	= nr_interno_conta_p  LIMIT 1;
		
		if (qt_aih_vinculada_w	= 0) then
			 begin
			 select	min(nr_aih)
			 into STRICT	nr_aih_w
			 from	sus_aih
			 where	nr_atendimento		= nr_atendimento_w
			 and	coalesce(nr_interno_conta::text, '') = '';
			
			nr_aih_w	:= coalesce(nr_aih_w,0);
			
			 if (nr_aih_w > 0) then
				begin
				/* Laudos vincula por trigger */

				update	sus_aih
				set	 nr_interno_conta	= nr_interno_conta_p
				where	 nr_atendimento		= nr_atendimento_w
				and	 nr_aih			= nr_aih_w;
				exception
				when others then
					nr_aih_w	:= nr_aih_w;
				if (coalesce(wheb_usuario_pck.get_ie_commit, 'S') = 'S') then commit; end if;
				end;
			end if;
			 end;
		end if;

		ie_gera_longa_perm_w	:= 'N';
		
		/* Parametro que define se gera longa permanencia automatica */

		begin
		select	ie_gera_longa_perman
		into STRICT	ie_gera_longa_perm_w
		from	sus_parametros
		where	cd_estabelecimento	= cd_estabelecimento_w;
		exception
		when others then
			begin
			select	coalesce(vl_parametro,vl_parametro_padrao)
			into STRICT	ie_gera_longa_perm_w
			from	funcao_parametro
			where	cd_funcao		= 81
			and	nr_sequencia	= 22;
			exception
		      	when others then
	        	   	ie_gera_longa_perm_w := 'N';
			end;
		end;
		if (ie_gera_longa_perm_w = 'S') then
			CALL gravar_longa_permanencia(nr_atendimento_w,
						nr_interno_conta_p,
						nm_usuario_p);
		end if;

		CALL gerar_diaria_uti_sus(nr_atendimento_w, nr_interno_conta_p, nm_usuario_p);
		CALL sus_gerar_trat_psiq(nr_atendimento_w, nr_interno_conta_p, nm_usuario_p, cd_estabelecimento_w);
		end;
	elsif (qt_aih_unif_w	> 0) then
		begin
		select	coalesce(max(ie_gera_longa_perm),'N')
		into STRICT	ie_gera_longa_perm_unif_w
		from	sus_parametros_aih
		where	cd_estabelecimento	= cd_estabelecimento_w;
		
		select	max(ie_status_acerto)
		into STRICT	ie_status_acerto_w
		from	conta_paciente
		where	nr_interno_conta = nr_interno_conta_p;

		if (ie_gera_longa_perm_unif_w	= 'S') and (ie_status_acerto_w = 1) then
			CALL sus_gerar_longa_permanencia(nr_atendimento_w, nr_interno_conta_p, nm_usuario_p);
		end if;

		end;
	end if;

	if (qt_aih_unif_w	= 0 )  then /*Felipe Martini em 23/01/2008 OS80393*/
		CALL gravar_proc_adicional_sus(nr_interno_conta_p,
					  nr_atendimento_w,
				  	  nm_usuario_p);
	end if;
	
	ie_vincular_laudos_aih_w := coalesce(obter_valor_param_usuario(1123,180,obter_perfil_ativo, nm_usuario_p, 0),'N');
	
	if (ie_vincular_laudos_aih_w = 'S') then
	
		CALL sus_vincular_laudo_conta(nr_interno_conta_p,nm_usuario_p);
		
		select	count(*)
		into STRICT	qt_laudo_aih_unif_w
		from	sus_laudo_paciente
		where	nr_interno_conta	= nr_interno_conta_p
		and	nr_atendimento		= nr_atendimento_w
		and	ie_classificacao 	= 1
		and	ie_tipo_laudo_sus 	= 0;
		
		if (qt_laudo_aih_unif_w	> 0) then
			begin
			select	coalesce(max(ie_gera_longa_perm),'N')
			into STRICT	ie_gera_longa_perm_unif_w
			from	sus_parametros_aih
			where	cd_estabelecimento	= cd_estabelecimento_w;
			
			select	max(ie_status_acerto)
			into STRICT	ie_status_acerto_w
			from	conta_paciente
			where	nr_interno_conta = nr_interno_conta_p;
	
			if (ie_gera_longa_perm_unif_w	= 'S') and (ie_status_acerto_w = 1) then
				CALL sus_gerar_longa_permanencia(nr_atendimento_w, nr_interno_conta_p, nm_usuario_p);
			end if;
			end;
		end if;
	end if;
	end;
end if;

/*if	(nvl(cd_proc_long_perm_w,0)	<> 0) and
	(ie_tipo_convenio_w		<> 3) and
	(ie_tipo_atendimento_w		= 1) and
	(ie_status_acerto_p		= 2) then
	begin
	gerar_longa_permanencia_conv(nr_atendimento_w,nr_interno_conta_p,cd_proc_long_perm_w,ie_orig_proc_long_perm_w,nm_usuario_p);
	end;
end if;*/
if (ie_status_acerto_p = 2) then
	CALL acerta_diverg_convenio_conta(nr_interno_conta_p);
end if;

SELECT * FROM consiste_conta_paciente(nr_interno_conta_p, nr_atendimento_w, ie_fecha_atendimento_w, ie_fecha_conta_w, qt_processo_pendente_w, ds_erro_w) INTO STRICT ie_fecha_atendimento_w, ie_fecha_conta_w, qt_processo_pendente_w, ds_erro_w;

if (ie_fecha_conta_w 	= 'S') or (ie_status_acerto_p 	<> 2 ) or (ie_tipo_convenio_w	= 3  ) then

	if (qt_aih_unif_w		> 0) then
		begin
		select	coalesce(max(ie_gera_longa_perm),'N')
		into STRICT	ie_gera_longa_perm_unif_w
		from	sus_parametros_aih
		where	cd_estabelecimento	= cd_estabelecimento_w;

		select	max(ie_status_acerto)
		into STRICT	ie_status_acerto_w
		from	conta_paciente
		where	nr_interno_conta = nr_interno_conta_p;

		if (ie_gera_longa_perm_unif_w	= 'S') and (ie_status_acerto_w = 1) then
			CALL sus_gerar_longa_permanencia(nr_atendimento_w, nr_interno_conta_p, nm_usuario_p);
		end if;

		end;
	end if;

	select 	coalesce(sum(vl_item),0)
	into STRICT	vl_conta_w
	from	conta_paciente_consiste_v
	where	nr_interno_conta = nr_interno_conta_p
	and	coalesce(cd_motivo_exc_conta::text, '') = ''
	and	coalesce(nr_seq_proc_pacote,nr_sequencia) = nr_sequencia;

	update conta_paciente
	set 	ie_status_acerto	= ie_status_acerto_p,
		dt_atualizacao		= clock_timestamp(),
		nm_usuario		= nm_usuario_p,
		vl_conta		= vl_conta_w
	where nr_interno_conta 		= nr_interno_conta_p
	and ie_status_acerto		<> ie_status_acerto_p;

	SELECT * FROM consiste_conta_paciente(nr_interno_conta_p, nr_atendimento_w, ie_fecha_atendimento_w, ie_fecha_conta_w, qt_processo_pendente_w, ds_erro_w) INTO STRICT ie_fecha_atendimento_w, ie_fecha_conta_w, qt_processo_pendente_w, ds_erro_w;	

end if;

CALL gerar_conta_paciente_guia(nr_interno_conta_p, ie_status_acerto_p);

/* Consiste valor dos itens com valor da conta_paciente_guia */
select  case when pkg_i18n.get_user_locale = 'es_BO' 
                then coalesce(max((select get_guia_value_without_taxes(nr_atendimento, 
                              nr_interno_conta_p, ie_mexico_w, ie_tipo_convenio_w, NULL, 'S') )),0)
             else coalesce(sum(vl_item),0)
        end
into STRICT 	vl_item_w
from 	conta_paciente_consiste_v
where 	nr_interno_conta	= nr_interno_conta_p
and	(((ie_mexico_w = 'S') and ((coalesce(nr_seq_proc_pacote::text, '') = '') or (ie_proc_mat = 1 AND nr_sequencia = nr_seq_proc_pacote))) or
	((ie_mexico_w = 'N') and ((coalesce(nr_seq_proc_pacote::text, '') = '') or (nr_sequencia <> nr_seq_proc_pacote))))
and	((ie_tipo_convenio_w <> 3) or (ie_proc_mat = 1))
and	coalesce(cd_motivo_exc_conta::text, '') = '';

select     coalesce(sum(vl_guia),0)
into STRICT vl_guia_w
from conta_paciente_guia
where nr_interno_conta	= nr_interno_conta_p;

if (vl_item_w <> vl_guia_w) then
	ds_erro_w		:= substr(ds_erro_w || '8 ', 1, 255);
	ie_fecha_conta_w	:= 'N';
end if;

select	count(*)
into STRICT	vl_guia_w
from (
	SELECT	cd_autorizacao,
		coalesce(sum(vl_guia),0)
	from conta_paciente_guia
	where nr_interno_conta	= nr_interno_conta_p
	group by cd_autorizacao
	having coalesce(sum(vl_guia),0) < 0) alias5;

if (vl_guia_w > 0) then
	ds_erro_w		:= substr(ds_erro_w || '14 ', 1, 255);
	ie_fecha_conta_w	:= 'N';
end if;

if (ie_fecha_conta_w = 'S') and (ie_status_acerto_p = 2) then
        begin
	CALL atualizar_tabela_custo_conta(nr_interno_conta_p);
	CALL atualizar_espec_medic_conta(nr_interno_conta_p);
	CALL atualizar_especialidade_conta(nr_interno_conta_p);
	CALL atualizar_funcao_medic_conta(nr_interno_conta_p);
	CALL atualizar_espec_conta(nr_interno_conta_p);
	CALL atualiza_codigo_convenio(nr_interno_conta_p,null);
	CALL atualizar_conta_contabil_conta(nr_interno_conta_p, 'S');

	if (ie_tipo_convenio_w = 3) then
		CALL atualizar_classif_sus(nr_interno_conta_p);

                if (ie_tipo_atendimento_w <> 1) and (ie_vincular_automatic_bpa_w = 'S') then
        
                        /*Verifica se esta vinculada a uma APAC*/

                        select  count(*)
                        into STRICT    ie_vinc_apac_w
                        from    sus_apac_unif
                        where   nr_interno_conta = nr_interno_conta_p;

                        /*Verifica se existe algum BPA sem vinculo de conta*/

                        select  count(*)
                        into STRICT    ie_existe_conta_w
                        from    sus_bpa_unif
                        where   nr_atendimento = nr_atendimento_w
                        and     coalesce(nr_interno_conta::text, '') = '';

                        /*Faz o vinculo apos mudar o status da conta BPA*/

                        if (ie_vinc_apac_w = 0) and (ie_existe_conta_w > 0) then
                                CALL sus_vincular_bpa_conta(nr_atendimento_w, nr_interno_conta_p, nm_usuario_p);
                        end if;
                end if;
	end if;

	if (coalesce(ie_complexidade_w::text, '') = '') then
		select obter_complexidade_conta(nr_interno_conta_p)
		into STRICT	ie_complexidade_w;
	end if;

	select nextval('conta_paciente_seq2')
	into STRICT nr_seq_apresent_w
	;

	select   obter_valor_conv_estab(cd_convenio_w,cd_estabelecimento_w,'IE_REPASSE_PROC'),
		 obter_valor_conv_estab(cd_convenio_w,cd_estabelecimento_w,'IE_REPASSE_MAT')
	into STRICT	 ie_repasse_proc_conv_w,
		 ie_repasse_mat_conv_w
	;

	ie_repasse_w := 'N';
	if ((ie_repasse_proc_conv_w = 'C') or (ie_repasse_mat_conv_w = 'C')) then
		ie_repasse_w := 'S';
	end if;

	if ((coalesce(ie_repasse_proc_conv_w::text, '') = '') and (coalesce(ie_repasse_mat_conv_w::text, '') = '')) then
		select coalesce(max('S'),'N')
		into STRICT ie_repasse_w
		from parametro_faturamento
		where cd_estabelecimento = cd_estabelecimento_w
		  and ((ie_repasse_mat = 'C') or (ie_repasse_proc = 'C'));
	end if;

	select	sum(vl_desconto)
	into STRICT		vl_desconto_w
	from (SELECT coalesce(sum(b.vl_procedimento),0) vl_desconto
		from proc_paciente_valor b,
		     procedimento_paciente a
		where a.nr_sequencia     = b.nr_seq_procedimento
		  and b.ie_tipo_valor    = 3
		  and a.nr_interno_conta = nr_interno_conta_p
		  and a.nr_sequencia <> coalesce(a.nr_seq_proc_pacote,0)
		
union all

		SELECT coalesce(sum(b.vl_material),0)
		from	mat_atend_paciente_valor b,
			material_atend_paciente a
		where a.nr_sequencia     = b.nr_seq_material
		  and b.ie_tipo_valor    = 3
		  and a.nr_interno_conta = nr_interno_conta_p) alias6;

	/* Fim */

	if (ie_repasse_w = 'S') then
		CALL gerar_conta_paciente_repasse(nr_interno_conta_p, nm_usuario_p);


	/* Elemar em 11/03/04 - retirar inconsistencia 3,4 e 5 das contas fechadas */

	update conta_paciente
	set ds_inconsistencia =  retirar_inconsistencia(retirar_inconsistencia(retirar_inconsistencia(ds_inconsistencia,'3'),'4'),'5')
	where nr_atendimento = nr_atendimento_w
	  and not exists (	SELECT 1 from conta_paciente
				where nr_atendimento = nr_atendimento_w
				  and ie_status_acerto = 1);
	end if;
	
	select	count(1)
	into STRICT	cont_w
	from	REGRA_REPASSE_CONPACI
	where	cd_estabelecimento	= cd_estabelecimento_w;
	
	if (coalesce(cont_w,0) > 0) then
		--Gera repasse para as contas, conforme regra cadastrada na Regras e Criterios de repasse > Regra repasse conta.
		CALL Gerar_Repasse_Conta(nr_interno_conta_p,nm_usuario_p,cd_estabelecimento_w);
	end if;	
	
	CALL gerar_regra_tx_mat_prest(nr_interno_conta_p,nm_usuario_p);
        end;
end if;

	
CALL atualiza_setor_receita(nr_interno_conta_p);

select	obter_clinica_alta(nr_atendimento_w)
into STRICT	ie_clinica_alta_w
;
update	atendimento_paciente
set ie_clinica_alta		= ie_clinica_alta_w
where	nr_atendimento	= nr_atendimento_w;

update conta_paciente
set ds_inconsistencia 		= ds_erro_w,
	dt_atualizacao		= clock_timestamp(),
	nm_usuario		= nm_usuario_p,
	ie_complexidade		= ie_complexidade_w,
	nr_seq_apresent		= nr_seq_apresent_w,
	--vl_conta 			= vl_conta_w,
	vl_desconto 		= vl_desconto_w
where nr_interno_conta = nr_interno_conta_p;

if (ie_permite_desd_planserv_w = 'S') and (ie_gerar_seq_planserv_w <> '0') and (ie_tipo_atend_conta_w > 0) and (obter_se_contido(ie_tipo_atend_conta_w,ie_gerar_seq_planserv_w) = 'S') then
		
	update	conta_paciente
	set	nr_seq_ordem =  nextval('conta_paciente_ordem_seq')
	where 	nr_interno_conta = nr_interno_conta_p
	and 	coalesce(nr_seq_ordem::text, '') = '';
						
end if;


-- Verificar se ha  itens que estao duplicados na tabela mat_atend_paciente_valor com ie_tipo_valor = 3 (Desconto)
select 	count(*)
into STRICT	qt_desc_conta_w
from 	conta_paciente_desconto
where 	nr_interno_conta = nr_interno_conta_p;

if (qt_desc_conta_w = 1) then

	open c01;
	loop
	fetch c01 into
		qt_reg_w,
		nr_seq_mat_desc_w;
	EXIT WHEN NOT FOUND; /* apply on c01 */
		begin

		select 	max(nr_sequencia)
		into STRICT	nr_seq_desc_w
		from 	conta_paciente_desconto
		where 	nr_interno_conta = nr_interno_conta_p;

		select 	count(*)
		into STRICT	qt_exclusao_w
		from 	mat_atend_paciente_valor
		where 	nr_seq_material = nr_seq_mat_desc_w
		and 	coalesce(nr_seq_desconto,0) <> nr_seq_desc_w
		and 	ie_tipo_valor = 3;

		if (qt_reg_w <> qt_exclusao_w) then -- Verificar para nao excluir todos os registros
			delete from mat_atend_paciente_valor
			where nr_seq_material = nr_seq_mat_desc_w
			and coalesce(nr_seq_desconto,0) <> nr_seq_desc_w
			and ie_tipo_valor = 3;

		end if;

		end;
	end loop;
	close c01;

	-- Verificar se ha  itens que estao duplicados na tabela procedimento_paciente_valor com ie_tipo_valor = 3 (Desconto)
	qt_reg_w	:= '';
	open c02;
	loop
	fetch c02 into
		qt_reg_w,
		nr_seq_proc_desc_w;
	EXIT WHEN NOT FOUND; /* apply on c02 */
		begin

		select 	max(nr_sequencia)
		into STRICT	nr_seq_desc_w
		from 	conta_paciente_desconto
		where 	nr_interno_conta = nr_interno_conta_p;

		select 	count(*)
		into STRICT	qt_exclusao_w
		from 	proc_paciente_valor
		where 	nr_seq_procedimento = nr_seq_proc_desc_w
		and 	coalesce(nr_seq_desconto,0) <> nr_seq_desc_w
		and 	ie_tipo_valor = 3;

		if (qt_reg_w <> qt_exclusao_w) then -- Verificar para nao excluir todos os registros
			delete 	FROM proc_paciente_valor
			where 	nr_seq_procedimento = nr_seq_proc_desc_w
			and 	coalesce(nr_seq_desconto,0) <> nr_seq_desc_w
			and 	ie_tipo_valor = 3;

		end if;

		end;
	end loop;
	close c02;

end if;


-- Verificar os itens que estao nas tabelas mat_atend_paciente_valor/proc_paciente_valor e que nao tem mais nr_seq_desconto correspondente
open C03;
loop
fetch C03 into	
	nr_seq_mat_desc_w,
	nr_seq_desc_w;
EXIT WHEN NOT FOUND; /* apply on C03 */
	begin
	
	select 	count(*)
	into STRICT	qt_desconto_w
	from 	conta_paciente_desconto
	where 	nr_interno_conta = nr_interno_conta_p
	and 	nr_sequencia = nr_seq_desc_w;
	
	if (qt_desconto_w = 0) then
		
		begin
		delete
		from 	mat_atend_paciente_valor
		where 	nr_seq_material = nr_seq_mat_desc_w
		and 	nr_seq_desconto = nr_seq_desc_w
		and 	ie_tipo_valor = 3;				
		exception
		when others then
			qt_desconto_w:= 1;
		end;
		
	end if;
	
	end;
end loop;
close C03;

open C04;
loop
fetch C04 into	
	nr_seq_proc_desc_w,
	nr_seq_desc_w;
EXIT WHEN NOT FOUND; /* apply on C04 */
	begin
	
	select 	count(*)
	into STRICT	qt_desconto_w
	from 	conta_paciente_desconto
	where 	nr_interno_conta = nr_interno_conta_p
	and 	nr_sequencia = nr_seq_desc_w;
	
	if (qt_desconto_w = 0) then
		
		begin
		delete
		from 	proc_paciente_valor
		where 	nr_seq_procedimento = nr_seq_proc_desc_w
		and 	nr_seq_desconto = nr_seq_desc_w
		and 	ie_tipo_valor = 3;				
		exception
		when others then
			qt_desconto_w:= 1;
		end;
		
	end if;
	
	end;
end loop;
close C04;


begin
	select 	count(1)
	into STRICT	qt_regra_atend_conv_w
	from	conv_regra_tipo_atend
	where	cd_convenio = cd_convenio_w;
exception
	when others then
	qt_regra_atend_conv_w:=0;
end;

if	qt_regra_atend_conv_w > 0 then
	CALL gerar_conpaci_tipo_atend_conv(nr_interno_conta_p,nm_usuario_p,null);
end if;

CALL atualizar_resumo_conta(nr_interno_conta_p, ie_status_acerto_p);
CALL atualizar_repasse_calc(nr_interno_conta_p);
ds_erro_p := ds_erro_w;


cd_empresa_w	:= obter_empresa_estab(cd_estabelecimento_w);	


CALL ctb_parametros_cc_rateio_pck.atualiza_cc_procedimento(	nr_atendimento_w,
							nm_usuario_p);

ie_geracao_w	:= ctb_online_pck.get_geracao_lote_receita( cd_convenio_w, 
				cd_estabelecimento_w,		
				nm_usuario_p,
				ie_tipo_convenio_w);

/* Evento Disparo da Contabilizacao Lote Receita		*/

ie_ctb_online_w := ctb_online_pck.get_modo_lote( 6, cd_estabelecimento_w, cd_empresa_w);
	
if (ie_ctb_online_w = 'S' and ie_geracao_w = 'FCP') then

	CALL ctb_contab_onl_lote_receita(nr_seq_protocolo_p  =>  null,
                                nr_interno_conta_p  =>  nr_interno_conta_p,
                                nm_usuario_p        =>  nm_usuario_p,
                                ie_operacao_p       =>  1,
                                ie_commit_p         =>  'N',
                                dt_referencia_p     =>  clock_timestamp());

                     
end if;	

/* Evento Disparo da Contabilizacao Lote Repasse Terceiro 	*/
				
ie_ctb_online_w := ctb_online_pck.get_modo_lote( 14, cd_estabelecimento_w, cd_empresa_w);

if (ie_ctb_online_w = 'S') then
	select	a.ie_geracao
	into STRICT 	ie_geracao_w 	
	from 	ctb_param_lote_repasse a
	where	a.cd_empresa	= cd_empresa_w
	and	coalesce(a.cd_estab_exclusivo, cd_estabelecimento_w)	= cd_estabelecimento_w;
		
	if (ie_geracao_w = 'FCP')  then
		CALL ctb_contab_onl_repasse(null,nr_interno_conta_p,null,nm_usuario_p,1,'S','N');	
	end if;
end if;

select	coalesce(max(ie_desconto_contabil), 'N')
into STRICT	ie_desconto_contabil_w
from 	parametro_faturamento
where	cd_estabelecimento	= cd_estabelecimento_w;

if (ie_desconto_contabil_w = 'S') then
        CALL gerar_desconto_conta_contab(nr_atendimento_p, nr_interno_conta_p, nm_usuario_p, cd_estabelecimento_w);
end if;

if (coalesce(wheb_usuario_pck.get_ie_commit, 'S') = 'S') then commit; end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE fechar_conta_paciente ( nr_interno_conta_p bigint, nr_atendimento_p bigint, ie_status_acerto_p bigint, nm_usuario_p text, ds_erro_p INOUT text) FROM PUBLIC;

