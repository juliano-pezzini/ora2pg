-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_103_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) is -- Cursor para buscar os doc
 sql_cursor_w varchar(4000) RETURNS varchar AS $body$
DECLARE


_ora2pg_r RECORD;
sql_cursor_ww		varchar(4000);
BEGIN

sql_cursor_ww	:= 	'select	a.nr_documento, '  || pls_util_pck.enter_w ||
			'	a.dt_fim_vigencia, ' || pls_util_pck.enter_w ||
			'	pls_obter_nome_documento(a.nr_seq_tipo_documento) ds_documento '  || pls_util_pck.enter_w ||
			'from	pls_prestador_tipo_doc	a ' || pls_util_pck.enter_w ||
			'where	a.nr_seq_prestador	= :nr_seq_prestador '|| pls_util_pck.enter_w;
bind_sql_valor_p := sql_pck.bind_variable(':nr_seq_prestador', nr_seq_prestador_pc, bind_sql_valor_p);

sql_cursor_ww	:= 	sql_cursor_ww || 'and     (dt_fim_vigencia - trunc(sysdate)) <= :qt_dia_antecedente ' ||  pls_util_pck.enter_w;
bind_sql_valor_p := sql_pck.bind_variable(':qt_dia_antecedente', coalesce(qt_dia_antecedente_pc, 0), bind_sql_valor_p);

if (nr_seq_tipo_documento_pc IS NOT NULL AND nr_seq_tipo_documento_pc::text <> '') then
	sql_cursor_ww :=	sql_cursor_ww || '	and	nr_seq_tipo_documento = :nr_seq_tipo_documento ' || pls_util_pck.enter_w;
	bind_sql_valor_p := sql_pck.bind_variable(':nr_seq_tipo_documento', nr_seq_tipo_documento_pc, bind_sql_valor_p);
end if;

return sql_cursor_ww;

end;


-- Monta o SQL do cursor c02 - Cursor com os prestadores a serem avaliados (estão agrupados, pois não tem sentido validar o mesmo varias vezes), se alterar o where aqui, tem que alterar no C03
function monta_sql_c02(	nr_id_transacao_pc	pls_oc_cta_selecao_ocor_v.nr_id_transacao%type,
				ie_tipo_prestador_pc	pls_oc_cta_val_doc_prest.ie_tipo_prestador%type,
				bind_sql_c02_p 		in out	sql_pck.t_dado_bind) return varchar2 is
sql_cursor_ww		varchar2(4000);
begin

sql_cursor_ww := '';
-- Primeiro, verifica qual tipo do prestador deve ser utilizado
-- A - Protocolo (Atendimento), E - Executor, S - Solicitante
if (ie_tipo_prestador_pc = 'A') then

	-- Do atendimento (Protocolo)
	sql_cursor_ww	:=	sql_cursor_ww ||'select	prot.nr_seq_prestador_conv nr_seq_prestador ' || pls_util_pck.enter_w;

end if; -- Fim do atendimento (Protocolo)
-- Executor
if (ie_tipo_prestador_pc = 'E') then

	sql_cursor_ww	:=	sql_cursor_ww ||'select	conta.nr_seq_prest_exec_conv nr_seq_prestador ' || pls_util_pck.enter_w;

end if;

-- Solicitante
if (ie_tipo_prestador_pc = 'S') then

	-- Se for importação
	sql_cursor_ww	:=	sql_cursor_ww ||'select	conta.nr_seq_prest_solic_conv nr_seq_prestador ' || pls_util_pck.enter_w;

end if;

-- Montagem das tabelas, quando for do protocolo, será adicionado a pls_protocolo_conta
sql_cursor_ww	:=	sql_cursor_ww ||'from	pls_oc_cta_selecao_imp	sel, ' || pls_util_pck.enter_w;
sql_cursor_ww	:=	sql_cursor_ww ||'pls_conta_imp			conta ' || pls_util_pck.enter_w;

--  Quando for do protocolo, OBRIGATORIAMENTE deverá ser adicionado a pls_protocolo_conta
if (ie_tipo_prestador_pc = 'A') then

	sql_cursor_ww	:=	sql_cursor_ww ||',pls_protocolo_conta_imp		prot ' || pls_util_pck.enter_w;
end if;


sql_cursor_ww	:=	sql_cursor_ww ||'where	conta.nr_sequencia		= sel.nr_seq_conta '|| pls_util_pck.enter_w;
--  Quando for do protocolo, OBRIGATORIAMENTE deverá ser adicionado a pls_protocolo_conta
if (ie_tipo_prestador_pc = 'A') then

	sql_cursor_ww	:=	sql_cursor_ww ||'and	prot.nr_sequencia		= conta.nr_seq_protocolo' || pls_util_pck.enter_w;
end if;

sql_cursor_ww	:=	sql_cursor_ww ||'and	sel.nr_id_transacao 		= :nr_id_transacao '|| pls_util_pck.enter_w;
bind_sql_c02_p := sql_pck.bind_variable(':nr_id_transacao', coalesce(nr_id_transacao_pc, 0), bind_sql_c02_p);

sql_cursor_ww	:=	sql_cursor_ww ||'and	sel.ie_valido			= ''S'' '|| pls_util_pck.enter_w;

-- Agrupa conforme o tipo de prestador e evento
-- Atendimento (Protocolo)
if (ie_tipo_prestador_pc = 'A') then

	sql_cursor_ww	:=	sql_cursor_ww ||'group by prot.nr_seq_prestador_conv '|| pls_util_pck.enter_w;

end if;

-- Executor
if (ie_tipo_prestador_pc = 'E') then

	sql_cursor_ww	:=	sql_cursor_ww ||'group by prot.nr_seq_prest_exec_conv '|| pls_util_pck.enter_w;

end if;

-- Solicitante
if (ie_tipo_prestador_pc = 'S') then

	sql_cursor_ww	:=	sql_cursor_ww ||'group by prot.nr_seq_prest_solic_conv '|| pls_util_pck.enter_w;

end if;

return sql_cursor_ww;

end;


-- Cursor com as contas da seleção que são condizentes com o prestador passado, bem como os demais dados para gerar a ocorrencia
function monta_sql_c03(	nr_id_transacao_pc	pls_oc_cta_selecao_ocor_v.nr_id_transacao%type,
				nr_seq_prestador_pc	pls_conta.nr_seq_prestador%type,
				ds_lista_documento_pc	varchar2,
				ie_tipo_prestador_pc	pls_oc_cta_val_doc_prest.ie_tipo_prestador%type,
				bind_sql_c03_p 		in out	sql_pck.t_dado_bind) return varchar2 is

sql_cursor_ww		varchar2(8000);

begin


sql_cursor_ww	:= '';

sql_cursor_ww	:=	sql_cursor_ww ||'select	sel.nr_sequencia nr_seq_selecao, '|| pls_util_pck.enter_w;
sql_cursor_ww	:=	sql_cursor_ww ||'	''S'' ie_valido, '|| pls_util_pck.enter_w;
-- Tem que ser concatenado desta forma, pois o binding não suporta o tamanho do campo
sql_cursor_ww	:=	sql_cursor_ww ||'	'''||ds_lista_documento_pc||''' ds_observacao '|| pls_util_pck.enter_w;
sql_cursor_ww	:=	sql_cursor_ww ||'from	pls_oc_cta_selecao_imp	sel, '|| pls_util_pck.enter_w;
sql_cursor_ww	:=	sql_cursor_ww ||'	pls_conta_imp		conta '|| pls_util_pck.enter_w;

-- Se for tipo de prestador atendimento (protocolo), deve OBRIGATORIAMENTE incluir a pls_protocolo_conta
if (ie_tipo_prestador_pc = 'A') then

	sql_cursor_ww	:=	sql_cursor_ww ||'	,pls_protocolo_conta_imp	prot '|| pls_util_pck.enter_w;
end if;

sql_cursor_ww	:=	sql_cursor_ww ||'where	conta.nr_sequencia		= sel.nr_seq_conta '|| pls_util_pck.enter_w;

-- Se for tipo de prestador atendimento (protocolo), deve OBRIGATORIAMENTE incluir a pls_protocolo_conta
if (ie_tipo_prestador_pc = 'A') then

	sql_cursor_ww	:=	sql_cursor_ww ||'and	prot.nr_sequencia	= conta.nr_seq_protocolo '|| pls_util_pck.enter_w;
end if;

sql_cursor_ww	:=	sql_cursor_ww ||'and	sel.nr_id_transacao 		= :nr_id_transacao '|| pls_util_pck.enter_w;
bind_sql_c03_p := sql_pck.bind_variable(':nr_id_transacao', coalesce(nr_id_transacao_pc, 0), bind_sql_c03_p);

sql_cursor_ww	:=	sql_cursor_ww ||'and	sel.ie_valido			= ''S'''|| pls_util_pck.enter_w;


-- Faz a seleção do prestador conforme o tipo passado na regra
-- Atendimento (protocolo)
if (ie_tipo_prestador_pc = 'A') then

	sql_cursor_ww	:=	sql_cursor_ww ||'and	prot.nr_seq_prestador_conv	= :nr_seq_prestador '|| pls_util_pck.enter_w;

end if;

-- Executor
if (ie_tipo_prestador_pc = 'E') then

	sql_cursor_ww	:=	sql_cursor_ww ||'and	conta.nr_seq_prest_exec_conv	= :nr_seq_prestador '|| pls_util_pck.enter_w;

end if;

-- Solicitante
if (ie_tipo_prestador_pc = 'S') then

	sql_cursor_ww	:=	sql_cursor_ww ||'and	conta.nr_seq_prest_solic_conv	= :nr_seq_prestador '|| pls_util_pck.enter_w;

end if;

bind_sql_c03_p := sql_pck.bind_variable(':nr_seq_prestador', coalesce(nr_seq_prestador_pc, 0), bind_sql_c03_p);

return sql_cursor_ww;

end;

begin

-- Executa apenas se exitir regra
if (nr_seq_combinada_p IS NOT NULL AND nr_seq_combinada_p::text <> '') then

	-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
	CALL pls_ocor_imp_pck.atualiza_campo_auxiliar(	'V',
							'N',
							nr_id_transacao_p,
							null);

	-- carrega as regras da ocorrencia
	for r_c01_w in c01(nr_seq_combinada_p) loop

		-- A sequencia da validação é a seguinte
		--	1 - Carregar os prestadores agrupados
		--	2 - Verificar se os prestadores tem doc vencidos
		--	3 - Se tiver, carrega então as contas para mandar
		-- Essa ordem foi estabelecida para fins de performance, onde foi considerado melhor avaliar os doc menos vezes( pois estão agrupado)
		-- e depois carregar as respectivas contas para a ocorrencia, do que avaliar os doc de cada conta / prestador
		bind_sql_c02_w.delete;
		sql_cursor_c02_w	:= monta_sql_c02(nr_id_transacao_p, r_c01_w.ie_tipo_prestador, bind_sql_c02_w);

		bind_sql_c02_w := sql_pck.executa_sql_cursor(sql_cursor_c02_w, bind_sql_c02_w);

		-- Se abriu o cursor corretamente, e tem dados nele
		if (c02_w%isopen) then

			loop
			fetch	c02_w
			into	nr_seq_prestador_w;
			EXIT WHEN NOT FOUND; /* apply on c02_w */

				-- Monta o cursor de documentos venc
				sql_cursor_w := monta_sql_cursor(nr_seq_prestador_w, r_c01_w.qt_dia_antecedente, r_c01_w.nr_seq_tipo_documento, bind_sql_valor_w);

				-- Abre o cursor de documentos venc
				bind_sql_valor_w := sql_pck.executa_sql_cursor(sql_cursor_w, bind_sql_valor_w);

				-- Limpa a lista de documentos localizados
				ds_lista_documento_w	:= null;
				-- Se abriu o cursor corretamente, e tem dados nele
				if (cursor_documento_w%isopen) then
					loop
						fetch	cursor_documento_w
						into	nr_documento_w, dt_fim_vigencia_w,  ds_documento_w;
						EXIT WHEN NOT FOUND; /* apply on cursor_documento_w */

						-- Monta a lista de doc da obs
						-- Numero doc não é obrigatorio, se não tiver, suprime ele
						if (nr_documento_w IS NOT NULL AND nr_documento_w::text <> '') then
							ds_lista_documento_w := substr(ds_lista_documento_w || 'Nr Doc: ' || nr_documento_w, 1, 4000);
						end if;

						ds_lista_documento_w := substr(ds_lista_documento_w ||' Tipo doc: '|| ds_documento_w || ' Dt vencto: ' || dt_fim_vigencia_w || pls_util_pck.enter_w, 1, 4000);

					end loop;
					close cursor_documento_w;
				end if; -- Fim se possui documentos
				-- Se possuir algum documento, carrega as contas do prestador, e gera a ocorrencia
				if (ds_lista_documento_w IS NOT NULL AND ds_lista_documento_w::text <> '') then
					-- Abre o curso com as contas do prestador, que devem possuir ocorrencias
					bind_sql_c03_w.delete;
					sql_cursor_c03_w	:= monta_sql_c03(nr_id_transacao_p, nr_seq_prestador_w, ds_lista_documento_w, r_c01_w.ie_tipo_prestador, bind_sql_c03_w);

					bind_sql_c03_w := sql_pck.executa_sql_cursor(sql_cursor_c03_w, bind_sql_c03_w);

					-- Se abriu o cursor corretamente, e possui dados
					if (c03_w%isopen) then

						loop
							--limpa as variáveis
							SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
						fetch  c03_w bulk collect into
							tb_seq_selecao_w,
							tb_valido_w,
							tb_observacao_w
							limit pls_cta_consistir_pck.qt_registro_transacao_w;

						exit when tb_seq_selecao_w.count = 0;

							--Grava as informações na tabela de seleção
							CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w,
													tb_valido_w,
													tb_observacao_w,
													nr_id_transacao_p,
													'SEQ');
						end loop; -- Fim das contas selecionadas
					end if; -- Abriu o c03
				end if; -- Fim gerar ocorrencia
			end loop; -- percorrer c02
		end if; -- Abriu C02
	end loop; -- C01 - Regras criadas
	-- seta os registros que serão válidos ou inválidos após o processamento
	CALL pls_ocor_imp_pck.atualiza_campo_valido('V',
						'N',
						ie_regra_excecao_p,
						null,
						nr_id_transacao_p,
						null);

end if; --  Fim se exite regra
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_103_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) is  sql_cursor_w varchar(4000) FROM PUBLIC;

