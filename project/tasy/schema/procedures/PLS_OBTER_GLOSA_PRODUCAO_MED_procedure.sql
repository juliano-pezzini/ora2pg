-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_obter_glosa_producao_med ( nr_seq_protocolo_p bigint, dt_protocolo_p timestamp, nr_seq_prestador_p bigint, qt_contas_informadas_p bigint, ie_tipo_guia_p bigint, dt_recebimento_p timestamp, qt_contas_inf_p bigint, ie_variacao_valor_p INOUT text, ie_variacao_qtd_p INOUT text, qt_permitida_p INOUT bigint, vl_permitido_p INOUT bigint) AS $body$
DECLARE

 
/* 
ie_variacao_w = 
	QE	= Quantidade de contas menor do que o protocolo anterior 
	QA	= Quantidade de contas maior que do ultimo protocolo 
	QO	= Quantidade Igual do protocolo anterior 
	ME	- Menor 
	MA	- Maior 
	CO	- Correspende ao valor da regra 
	RN	- Regra não informada 
*/
 
ie_variacao_w			varchar(2) := 'RN';
vl_total_ant_w			double precision;
vl_total_w			double precision;
vl_total_ww			double precision;
nr_seq_protocolo_w		bigint;
nr_seq_prestador_w		bigint;
cd_cgc_prestador_imp      varchar(14);
nr_cpf_prestador_imp      varchar(11);
nr_seq_classificacao_w		bigint;
qt_variacao_menor_w		double precision;
qt_variacao_maior_w		double precision;
ie_tipo_prestador_w		varchar(2);
cd_cgc_prestador_imp_w		varchar(14);
nr_cpf_prestador_imp_w		varchar(11);
qt_conta_w			bigint;
qt_conta_ant_w			bigint := 0;
qt_var_conta_menor_w		double precision;
qt_var_conta_maior_w		double precision;
ie_tipo_guia_w			varchar(10);
vl_total_ant_ww			double precision;
qt_conta_ant_ww			bigint;
ie_tipo_contador_w		varchar(2);
nr_seq_protocolo_ww		bigint;
ie_variacao_qtd_w		varchar(2);
ie_variacao_valor_w		varchar(2);
vl_permitido_w			double precision;
qt_permitida_w			bigint;
qt_contas_informadas_w		bigint;
nr_seq_prestador_ww		bigint;
dt_inicio_vigencia_w		timestamp;
dt_fim_vigencia_w		timestamp;
dt_protocolo_w			timestamp;
qt_atual_w			bigint:= 0;
qt_atual_ww			bigint:= 0;
ie_tipo_guia_ww			bigint;
qt_vezes_w			bigint:=0;
ie_data_referencia_w		varchar(2);
dt_recebimento_w		timestamp;
dt_referencia_w			timestamp;
nr_seq_classificacao_regra_w	bigint;
ie_regra_valida_w		varchar(1);

/*Cursor que obtem as regras*/
 
C01 CURSOR FOR 
	SELECT	coalesce(qt_variacao_menor,0), 
		coalesce(qt_variacao_maior,0), 
		coalesce(qt_var_conta_menor,0), 
		coalesce(qt_var_conta_maior,0), 
		coalesce(ie_tipo_contador,'E'), 
		dt_inicio_vigencia, 
		dt_fim_vigencia, 
		coalesce(ie_tipo_guia,0), 
		nr_seq_prestador, 
		ie_data_referencia, 
		coalesce(nr_seq_classificacao,0) 
	from	pls_regra_controle_prod 
	where	coalesce(nr_Seq_prestador,coalesce(nr_seq_prestador_w,0))	= coalesce(nr_seq_prestador_w,0) 
	and	ie_situacao		= 'A' 
	and	coalesce(ie_tipo_prestador, 'B')	= ie_tipo_prestador_w 
	and	((coalesce(nr_seq_classificacao::text, '') = '') or (nr_seq_classificacao_w = nr_seq_classificacao)) 
	and	coalesce(ie_tipo_guia,coalesce(ie_tipo_guia_w,0))		= coalesce(ie_tipo_guia_w,0) 
	and	((trunc(coalesce(dt_protocolo_p,dt_protocolo_w)) between trunc(coalesce(dt_inicio_vigencia,coalesce(dt_protocolo_p,dt_protocolo_w)-1)) and trunc(coalesce(dt_fim_vigencia,coalesce(dt_protocolo_p,dt_protocolo_w)+1)) 
	and	ie_data_referencia = 'M') 
	or (trunc(coalesce(dt_recebimento_p,dt_recebimento_w)) between trunc(coalesce(dt_inicio_vigencia,coalesce(dt_recebimento_p,dt_recebimento_w)-1)) and trunc(coalesce(dt_fim_vigencia,coalesce(dt_recebimento_p,dt_recebimento_w)+1)) 
	and	ie_data_referencia = 'R')) 
	order by coalesce(nr_seq_classificacao,0), 
		 coalesce(ie_tipo_guia,0), 
		 coalesce(ie_tipo_prestador,'A'), 
		 coalesce(nr_seq_prestador,0);

/*Cursor que obtem os protocolos segundo o campo "Tipo periodo"*/
 
C02 CURSOR FOR 
	SELECT	a.nr_sequencia 
	from	pls_protocolo_conta a, 
		pls_prestador b 
	where	a.nr_seq_prestador = b.nr_sequencia 
	and	a.ie_situacao		not in ('RE','A') 
	and	a.nr_seq_prestador	= coalesce(nr_seq_prestador_ww,nr_seq_prestador_w) 
	and	((b.nr_seq_classificacao	= nr_seq_classificacao_regra_w) or (nr_seq_classificacao_regra_w = 0)) 
	and	((a.ie_tipo_guia		= ie_tipo_guia_ww) or ( ie_tipo_guia_ww = 0)) 
	and	((a.nr_sequencia		= nr_seq_protocolo_ww AND ie_tipo_contador_w = 'E') 
	or	((ie_data_referencia_w = 'M') 
	and	((((trunc(a.dt_protocolo) between(to_date(obter_inicio_fim_semana(dt_protocolo_w-7, 'I'))) and (to_date(obter_inicio_fim_semana(dt_protocolo_w-7, 'F')))) and (ie_tipo_contador_w = 'S')) 
	or	((trunc(a.dt_protocolo) = trunc(dt_protocolo_w)) and (ie_tipo_contador_w = 'D'))) 
	and (trunc(a.dt_protocolo) between trunc(coalesce(dt_inicio_vigencia_w,a.dt_protocolo-1)) and trunc(coalesce(dt_fim_vigencia_w,a.dt_protocolo+1))))) 
	or	((ie_data_referencia_w = 'R') 
	and	((((trunc(a.dt_recebimento) between(to_date(obter_inicio_fim_semana(dt_recebimento_w-7, 'I'))) and (to_date(obter_inicio_fim_semana(dt_recebimento_w-7, 'F')))) and (ie_tipo_contador_w = 'S')) 
	or	((trunc(a.dt_recebimento) = trunc(dt_recebimento_w)) and (ie_tipo_contador_w = 'D'))) 
	and (trunc(a.dt_recebimento) between trunc(coalesce(dt_inicio_vigencia_w,a.dt_recebimento-1)) and trunc(coalesce(dt_fim_vigencia_w,a.dt_recebimento+1)))))) 
	and 	((a.ie_tipo_protocolo = 'C') or (a.ie_tipo_protocolo = 'I'));
--Diego OS 314738 - obter_inicio_fim_semana + 1 para que pegue o periodo segunda a domingo (o padrão da rotina é domingo a segunda) 
C03 CURSOR FOR 
	SELECT	a.nr_sequencia 
	from	pls_protocolo_conta a, 
		pls_prestador b 
	where	a.nr_seq_prestador	= b.nr_sequencia 
	and	a.ie_situacao		not in ('RE','A') 
	and	a.nr_seq_prestador	= coalesce(nr_seq_prestador_ww, nr_seq_prestador_w) 
	and	((b.nr_seq_classificacao	= nr_seq_classificacao_regra_w) or (nr_seq_classificacao_regra_w = 0)) 
	and	a.nr_sequencia		<> nr_seq_protocolo_p 
	and	((a.ie_tipo_guia		= coalesce(ie_tipo_guia_ww,0)) or (coalesce(ie_tipo_guia_ww,0) = 0)) 
	and	((a.nr_sequencia		= nr_seq_protocolo_ww AND ie_tipo_contador_w = 'E') 
	or	((ie_data_referencia_w = 'M') 
	and	((((trunc(a.dt_protocolo) between(to_date(obter_inicio_fim_semana(dt_protocolo_w, 'I'))) and (to_date(obter_inicio_fim_semana(dt_protocolo_w, 'F')))) and (ie_tipo_contador_w = 'S')) 
	or	((trunc(a.dt_protocolo) = trunc(dt_protocolo_w)) and (ie_tipo_contador_w = 'D'))) 
	and (trunc(a.dt_protocolo) between trunc(coalesce(dt_inicio_vigencia_w,a.dt_protocolo-1)) and trunc(coalesce(dt_fim_vigencia_w,a.dt_protocolo+1))))) 
	or	((ie_data_referencia_w = 'R') 
	and	((((trunc(a.dt_recebimento) between(to_date(obter_inicio_fim_semana(dt_recebimento_w, 'I'))) and (to_date(obter_inicio_fim_semana(dt_recebimento_w, 'F')))) and (ie_tipo_contador_w = 'S')) 
	or	((trunc(a.dt_recebimento) = trunc(a.dt_recebimento)) and (ie_tipo_contador_w = 'D'))) 
	and (trunc(a.dt_recebimento) between trunc(coalesce(dt_inicio_vigencia_w,a.dt_recebimento-1)) and trunc(coalesce(dt_fim_vigencia_w,a.dt_recebimento+1)))))) 
	and 	((a.ie_tipo_protocolo = 'C') or (a.ie_tipo_protocolo = 'I'));
	/*criado o cursor para atender a OS	333748, o mesmo trará os protocolos cadastrador no período da regra*/
 	
 

BEGIN 
if (coalesce(nr_seq_protocolo_p,0) <> 0) then 
	/*Dados do protocolo*/
 
	begin 
	select	nr_seq_prestador_imp_ref, 
		cd_cgc_prestador_imp, 
		nr_cpf_prestador_imp, 
		ie_tipo_guia, 
		qt_contas_informadas, 
		nr_seq_prestador, 
		coalesce(dt_protocolo,clock_timestamp()), 
		coalesce(dt_recebimento,clock_timestamp()) 
	into STRICT	nr_seq_prestador_w, 
		cd_cgc_prestador_imp_w, 
		nr_cpf_prestador_imp_w, 
		ie_tipo_guia_w, 
		qt_contas_informadas_w, 
		nr_seq_prestador_ww, 
		dt_protocolo_w, 
		dt_recebimento_w 
	from	pls_protocolo_conta 
	where	nr_sequencia	= nr_seq_protocolo_p;
	exception 
	when others then 
		nr_seq_prestador_w	:= nr_seq_prestador_p;
		dt_protocolo_w		:= coalesce(dt_protocolo_p,clock_timestamp());
		ie_tipo_guia_w		:= ie_tipo_guia_p;
		dt_recebimento_w	:= coalesce(dt_recebimento_p,clock_timestamp());
		qt_contas_informadas_w	:= qt_contas_inf_P;
	end;
	 
	if (coalesce(qt_contas_informadas_w,0) = 0) then 
		qt_contas_informadas_w	:= 0;
	end if;
	 
	if (coalesce(nr_seq_prestador_w::text, '') = '')then 
		nr_seq_prestador_w	:= nr_seq_prestador_ww;
	end if;
	if (coalesce(dt_protocolo_w::text, '') = '') then 
		dt_protocolo_w	:= clock_timestamp();
	end if;
 
	if (coalesce(nr_seq_prestador_w::text, '') = '' )then 
		nr_seq_prestador_w	:= pls_obter_prestador_imp(cd_cgc_prestador_imp_w, nr_cpf_prestador_imp_w, nr_seq_prestador_w, null, null, null);
	end if;
 
	if (coalesce(nr_seq_prestador_w,0) = 0) then 
		nr_seq_prestador_w	:= nr_seq_prestador_ww;
	end if;
else 
	nr_seq_prestador_w	:= nr_seq_prestador_p;
	dt_protocolo_w		:= dt_protocolo_p;
	ie_tipo_guia_w		:= ie_tipo_guia_p;
end if;
 
if (coalesce(nr_seq_prestador_w,0) > 0) then 
	/*Obtenção da soma dos valores importados nos procedimentos no protocolo */
 
	select	coalesce(sum(a.vl_procedimento_imp),0) 
	into STRICT	vl_total_w 
	from	pls_conta_proc	a, 
		pls_conta	b 
	where	a.nr_seq_conta		= b.nr_sequencia 
	and	b.nr_seq_protocolo	= nr_seq_protocolo_p;
 
	/*Obtenção da soma dos valores importados nos materiais no protocolo */
 
	select	coalesce(sum(a.vl_material_imp),0) 
	into STRICT	vl_total_ww 
	from	pls_conta_mat	a, 
		pls_conta	b 
	where	a.nr_seq_conta		= b.nr_sequencia 
	and	b.nr_seq_protocolo	= nr_seq_protocolo_p;
 
	/*Quantidade de contas.*/
 
	select	count(1) 
	into STRICT	qt_conta_w 
	from	pls_conta 
	where	nr_seq_protocolo	= nr_seq_protocolo_p;
	 
	if (coalesce(qt_contas_informadas_p,0) <> 0) then 
		qt_conta_w	:= qt_contas_informadas_p;
	else 
		if (coalesce(qt_contas_informadas_w,0) <> 0) then 
			qt_conta_w	:= qt_contas_informadas_w;
		end if;
	end if;
	 
	vl_total_w	:= vl_total_w + vl_total_ww;
 
	/*Dados do prestador*/
 
	select	max(nr_seq_classificacao), 
		max(coalesce(ie_tipo_prestador, 'B')) 
	into STRICT	nr_seq_classificacao_w, 
		ie_tipo_prestador_w 
	from	pls_prestador 
	where	nr_sequencia		= nr_seq_prestador_w;
 
	open C01;
	loop 
	fetch C01 into	 
		qt_variacao_menor_w, 
		qt_variacao_maior_w, 
		qt_var_conta_menor_w, 
		qt_var_conta_maior_w, 
		ie_tipo_contador_w, 
		dt_inicio_vigencia_w, 
		dt_fim_vigencia_w, 
		ie_tipo_guia_ww, 
		nr_seq_prestador_ww, 
		ie_data_referencia_w, 
		nr_seq_classificacao_regra_w;
	EXIT WHEN NOT FOUND; /* apply on C01 */
		begin 
		if (coalesce(ie_data_referencia_w,'M') = 'M') then 
			dt_referencia_w := coalesce(dt_protocolo_p,coalesce(dt_protocolo_w,clock_timestamp()));
		else 
			dt_referencia_w	:= coalesce(dt_recebimento_p,coalesce(dt_recebimento_w,clock_timestamp()));
		end if;
		 
		ie_regra_valida_w := 'S';
		 
		-- Se tiver data de inicio informada, o tipo de contador for semanal 
		-- e a data de referência do protocolo for na primeira semana da data de início de vigência 
		-- a regra não será aplicada, pois não existe base de cálculo anterior para aplicação da regra 
		if (dt_inicio_vigencia_w IS NOT NULL AND dt_inicio_vigencia_w::text <> '') and (ie_tipo_contador_w = 'S') then 
			if (dt_referencia_w between obter_inicio_fim_semana(dt_inicio_vigencia_w, 'I') and obter_inicio_fim_semana(dt_inicio_vigencia_w, 'F')) then 
				ie_regra_valida_w := 'N';
			end if;
		end if;
		 
		if (ie_regra_valida_w = 'S') then	 
			qt_atual_w	:= 0;
			qt_conta_ant_w	:= 0;
			 
			select	max(nr_sequencia) 
			into STRICT	nr_seq_protocolo_ww 
			from	pls_protocolo_conta 
			where	coalesce(nr_seq_prestador,nr_seq_prestador_ww)	= nr_seq_prestador_ww 
			and	((ie_tipo_guia		= ie_tipo_guia_ww) or ( ie_tipo_guia_ww = 0)) 
			and	nr_sequencia		< nr_seq_protocolo_p 
			and	ie_situacao		not in ('RE','A');
			 
			if (qt_variacao_menor_w > 0) and (qt_variacao_maior_w > 0)	 then 
				open C02;
				loop 
				fetch C02 into	 
					nr_seq_protocolo_w;
				EXIT WHEN NOT FOUND; /* apply on C02 */
					begin 
					/*Regra de valor*/
 
					 
					--select	nvl(pls_obter_valor_protocolo(nr_sequencia,'T'),0) 
					--into	vl_total_ant_ww 
					--from	pls_protocolo_conta 
					--where	nr_sequencia = nr_seq_protocolo_w; 
					vl_total_ant_ww	:= coalesce(pls_obter_valor_protocolo(nr_seq_protocolo_w,'T'),0);
					 
					vl_total_ant_w	:= coalesce(vl_total_ant_ww,0) + coalesce(vl_total_ant_w,0);
					end;
				end loop;
				close C02;
										 
				if	((vl_total_ant_w - (dividir((vl_total_ant_w* qt_variacao_menor_w), 100) )) > vl_total_w) then 
					vl_permitido_w 	   := vl_total_ant_w - (dividir((vl_total_ant_w* qt_variacao_menor_w), 100));
					ie_variacao_valor_w := 'ME';
				elsif	((vl_total_ant_w + (dividir((vl_total_ant_w* qt_variacao_maior_w), 100) )) < vl_total_w) then 
					vl_permitido_w 	   := vl_total_ant_w + (dividir((vl_total_ant_w* qt_variacao_maior_w), 100));
					ie_variacao_valor_w := 'MA';
				else 
					ie_variacao_valor_w := 'CO';
				end if;										
			end if;	
			 
			if (coalesce(qt_var_conta_menor_w,0) > 0) or (coalesce(qt_var_conta_maior_w,0) > 0) then 
				begin 
				qt_conta_ant_w	:= 0;
				 
				begin 
				nr_seq_protocolo_w	:= 0;
				open C02;
				loop 
				fetch C02 into	 
					nr_seq_protocolo_w;
				EXIT WHEN NOT FOUND; /* apply on C02 */
					begin 
					/*Regra de Qt de conta*/
 
					/*OS - 333748*/
 
					qt_vezes_w:=qt_vezes_w + 1;
					qt_conta_ant_ww	:= 0;
 
					select	coalesce(sum(qt_contas_informadas),0) 
					into STRICT	qt_conta_ant_ww 
					from	pls_protocolo_conta 
					where	nr_sequencia	= nr_seq_protocolo_w;
					 
					if (qt_conta_ant_ww = 0) then 
						select	count(1) 
						into STRICT	qt_conta_ant_ww 
						from	pls_conta 
						where	nr_seq_protocolo	= nr_seq_protocolo_w;
					end if;
					 
					qt_conta_ant_w	:= coalesce(qt_conta_ant_ww,0) + coalesce(qt_conta_ant_w,0);
					end;
				end loop;
				close C02;
				end;
				 
				begin 
				nr_seq_protocolo_w	:= 0;
				open C03;
				loop 
				fetch C03 into	 
					nr_seq_protocolo_w;
				EXIT WHEN NOT FOUND; /* apply on C03 */
					begin 
					/*Regra de Qt de conta*/
 
					/*OS - 333748*/
 
					qt_atual_ww	:= 0;
 
					select	coalesce(sum(qt_contas_informadas),0) 
					into STRICT	qt_atual_ww 
					from	pls_protocolo_conta 
					where	nr_sequencia	= nr_seq_protocolo_w;
					 
					if (qt_atual_ww = 0) then 
						select	count(1) 
						into STRICT	qt_atual_ww 
						from	pls_conta 
						where	nr_seq_protocolo	= nr_seq_protocolo_w;
					end if;
					 
					qt_atual_w	:= coalesce(qt_atual_ww,0) + coalesce(qt_atual_w,0);
					end;
				end loop;
				close C03;
				end;
			 
				if	((qt_conta_ant_w - (dividir((qt_conta_ant_w* qt_var_conta_menor_w), 100) )) > qt_conta_w + qt_atual_w) and 
					((qt_conta_ant_w - (dividir((qt_conta_ant_w* qt_var_conta_menor_w), 100) )) > 0) and (qt_var_conta_menor_w <> 0) then			 
					qt_permitida_w 	  := qt_conta_ant_w - (dividir((qt_conta_ant_w* qt_var_conta_menor_w), 100) + qt_atual_w );
					ie_variacao_qtd_w := 'QE';
 
				elsif	(((qt_conta_ant_w + (dividir((qt_conta_ant_w* qt_var_conta_maior_w), 100) ) ) < qt_conta_w + qt_atual_w) and 
					((qt_conta_ant_w + (dividir((qt_conta_ant_w* qt_var_conta_maior_w), 100) )) > 0) and (qt_var_conta_maior_w <> 0)) or (qt_conta_ant_w = 0) then 
					qt_permitida_w 	  := (qt_conta_ant_w + (dividir((qt_conta_ant_w* qt_var_conta_maior_w), 100)) - qt_atual_w);
					ie_variacao_qtd_w := 'QA';
				else 
					ie_variacao_qtd_w := 'QO';
				end if;
				 
				end;
			end if;
		end if;
		end;
	end loop;
	close C01;
end if;
 
ie_variacao_qtd_p 	:= ie_variacao_qtd_w;
ie_variacao_valor_p 	:= ie_variacao_valor_w;
vl_permitido_p 		:= vl_permitido_w;
qt_permitida_p 		:= qt_permitida_w;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_obter_glosa_producao_med ( nr_seq_protocolo_p bigint, dt_protocolo_p timestamp, nr_seq_prestador_p bigint, qt_contas_informadas_p bigint, ie_tipo_guia_p bigint, dt_recebimento_p timestamp, qt_contas_inf_p bigint, ie_variacao_valor_p INOUT text, ie_variacao_qtd_p INOUT text, qt_permitida_p INOUT bigint, vl_permitido_p INOUT bigint) FROM PUBLIC;

