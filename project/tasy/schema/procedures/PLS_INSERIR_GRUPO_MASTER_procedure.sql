-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_inserir_grupo_master ( nr_seq_analise_p bigint, nr_seq_grupo_p bigint, cd_estabelecimento_p bigint, ie_permite_desvincular_p text, nm_usuario_p text) AS $body$
DECLARE

 
ie_status_w			varchar(1);				
nr_seq_ordem_w			bigint;
qt_grupos_finalizados_w		bigint;
nr_seq_ordem_ww			bigint;
qt_mesma_ordem_w		bigint;
nr_seq_audit_conta_grupo_w	bigint;
qt_grupo_em_aud_w		bigint;
nm_grupo_w			varchar(4000);
nr_seq_grupo_rep_w		pls_auditoria_conta_grupo.nr_seq_grupo%type;

/* 
	ESTA ROTINA INSERE UM GRUPO DE ACESSO TOTAL NO FLUXO DA ANALISE. 
	É DESVINCULADO O AUDITOR DO GRUPO ATUAL DA ANÁLISE E INSERIDO O GRUPO DE ACESSO TOTAL ANTES DESTE, PARA QUE POSSA ASSUMIR A ANÁLISE. 
*/
 
 

BEGIN 
 
/* Francisco - 15/11/2013 - OS 662810 - Fiz o tratamento do parametro 17 dentro da procedure */
 
select	max(a.nr_sequencia) 
into STRICT	nr_seq_audit_conta_grupo_w 
from	pls_auditoria_conta_grupo a 
where	a.nr_seq_analise = nr_seq_analise_p 
and (a.ie_pre_analise = 'N' or coalesce(a.ie_pre_analise::text, '') = '') 
and	a.nr_seq_ordem = ( SELECT min(nr_seq_ordem) 
			  from  pls_auditoria_conta_grupo x 
			  where  x.nr_seq_analise = a.nr_seq_analise 
			  and   coalesce(x.dt_liberacao::text, '') = '' 
			  and (a.ie_pre_analise = 'N' or coalesce(a.ie_pre_analise::text, '') = '') 
			  );
			  
if (nr_seq_audit_conta_grupo_w > 0) then 
	select	count(1) 
	into STRICT	qt_grupo_em_aud_w 
	from	pls_auditoria_conta_grupo a 
	where	coalesce(a.dt_final_analise::text, '') = '' 
	and	(a.dt_inicio_auditor IS NOT NULL AND a.dt_inicio_auditor::text <> '') 
	and	a.nr_seq_analise = nr_seq_analise_p 
	and  	a.nr_sequencia  = nr_seq_audit_conta_grupo_w;
	 
	if (qt_grupo_em_aud_w > 0) then 
		if (ie_permite_desvincular_p = 'S') then 
			CALL pls_finalizar_tempo_auditor(nr_seq_audit_conta_grupo_w,nr_seq_analise_p,nm_usuario_p,cd_estabelecimento_p);
		else 
			CALL wheb_mensagem_pck.exibir_mensagem_abort(269508);
		end if;
	end if;
end if;
 
select coalesce(max(a.nr_seq_ordem),0)	 
into STRICT	nr_seq_ordem_w -- ordem do grupo que ainda nao terminou a liberacao 
from  pls_auditoria_conta_grupo a  
where  a.nr_seq_analise	= nr_seq_analise_p 
and	coalesce(a.dt_liberacao::text, '') = '' 
and   a.nr_seq_ordem	=	(SELECT	min(nr_seq_ordem) 
				from	pls_auditoria_conta_grupo x 
				where	x.nr_seq_analise = a.nr_seq_analise 
				and	coalesce(x.dt_liberacao::text, '') = '');
 
--OS1408280, quando era inserido dois grupos de acesso total não era possível finalizar análise do grupo				 
select	max(nr_seq_grupo) 
into STRICT	nr_seq_grupo_rep_w 
from	pls_auditoria_conta_grupo 
where	nr_seq_analise	= nr_seq_analise_p 
and	nr_seq_grupo	= nr_seq_grupo_p;
 
if (nr_seq_grupo_rep_w IS NOT NULL AND nr_seq_grupo_rep_w::text <> '') then		 
	nm_grupo_w	:= pls_obter_nome_grupo_auditor(nr_seq_grupo_p);
 
	--'O grupo '||nm_grupo_w||' já existe na análise com a ordem '||nr_seq_ordem_w||'. Não é possivel inserir um grupo sequencial a ele mesmo.' 
	CALL wheb_mensagem_pck.exibir_mensagem_abort(181113,'NM_GRUPO_W=' || nm_grupo_w || ';NR_SEQ_ORDEM_W=' || nr_seq_ordem_w);		
end if;
 
nr_seq_ordem_ww	:= 	(coalesce(nr_Seq_ordem_w,0) - 1); --a ordem que vai ser inserida no fluxo 
select 	count(1) 
into STRICT	qt_mesma_ordem_w 
from 	pls_auditoria_conta_grupo 
where	nr_seq_ordem 	= nr_seq_ordem_ww 
and	nr_seq_analise = nr_seq_analise_p;
 
/*Se existe ordens iguais, a rotina vai tratar para inserir o novo grupo com ordem diferente dos que existem, vai ser inserido antes do grupo atual do fluxo*/
 
if (qt_mesma_ordem_w > 0) then	 
	update pls_auditoria_conta_grupo 
	set	nr_seq_ordem	= (nr_seq_ordem - 1), 
		dt_atualizacao	= clock_timestamp(), 
		nm_usuario 	= nm_usuario_p 
	where	nr_Seq_ordem < nr_seq_ordem_w 
	and	nr_seq_analise = nr_seq_analise_p;
end if;	
 
insert into pls_auditoria_conta_grupo(ds_conta, 
	ds_observacao, 
	dt_atualizacao, 
	dt_atualizacao_nrec, 
	dt_final_analise, 
	dt_inicio_analise, 
	dt_inicio_auditor, 
	dt_liberacao, 
	ie_manual, 
	nm_auditor_atual, 
	nm_usuario, 
	nm_usuario_nrec,     
	nr_seq_analise, 
	nr_seq_grupo, 
	nr_seq_ordem,       
	nr_sequencia) 
values ('', 
	'', 
	clock_timestamp(), 
	clock_timestamp(), 
	null, 
	null, 
	null, 
	null, 
	'S', 
	'', 
	nm_usuario_p, 
	nm_usuario_p, 
	nr_seq_analise_p, 
	nr_seq_grupo_p, 
	nr_seq_ordem_ww, 
	nextval('pls_auditoria_conta_grupo_seq'));
 
select 	count(nr_sequencia) 
into STRICT	qt_grupos_finalizados_w 
from 	pls_auditoria_conta_grupo 
where	nr_Seq_analise = nr_seq_analise_p 
and	(dt_liberacao IS NOT NULL AND dt_liberacao::text <> '');
 
/*Se existir um grupo finalizado (ou seja com data de liberação) se coloca a análise em em auditoria senão em aguardando auditoria*/
 
if (qt_grupos_finalizados_w = 0) then 
	ie_status_w := 'G';
else 
	ie_status_w := 'A';
end if;
 
CALL pls_alterar_status_analise_cta(nr_seq_analise_p, ie_status_w, 'PLS_INSERIR_GRUPO_MASTER', nm_usuario_p, cd_estabelecimento_p);
 
update	pls_conta 
set	ie_status 	= 'A'	 
where	nr_seq_analise = nr_seq_analise_p;
 
/*drquadros 626182 - Atualizar o campo pois se na análise não houver nenhum grupo auditor o mesmo estará como N*/
 
update 	pls_analise_conta 
set	ie_auditoria 	= 'S' 
where	nr_sequencia	= nr_seq_analise_p;
 
CALL pls_atualizar_grupo_penden(nr_seq_analise_p, cd_estabelecimento_p, nm_usuario_p);
 
commit;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_inserir_grupo_master ( nr_seq_analise_p bigint, nr_seq_grupo_p bigint, cd_estabelecimento_p bigint, ie_permite_desvincular_p text, nm_usuario_p text) FROM PUBLIC;

