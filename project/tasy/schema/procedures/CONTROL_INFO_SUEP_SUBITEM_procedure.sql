-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE control_info_suep_subitem (nr_seq_inf_p text, nr_seq_subitem_p bigint, nm_usuario_p text) AS $body$
WITH RECURSIVE cte AS (
DECLARE


   signsList_c CURSOR FOR
      SELECT (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level))::numeric  as nr_seq_inf,
             row_number() OVER () as seq

      (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level) IS NOT NULL AND (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level))::text <> '')
        UNION ALL
DECLARE


   signsList_c CURSOR FOR
      SELECT (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level))::numeric  as nr_seq_inf,
             row_number() OVER () as seq
        
      (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level) IS NOT NULL AND (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level))::text <> '')
       JOIN cte c ON ()

) SELECT * FROM cte
union

      SELECT nr_seq_inf, 0 as seq
        from informacao_suep
       where nr_seq_subitem = nr_seq_subitem_p
         and nr_seq_inf not in (WITH RECURSIVE cte AS (
select regexp_substr(nr_seq_inf_p, '[^,]+', 1, level)
                
              (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level) IS NOT NULL AND (regexp_substr(nr_seq_inf_p, '[^,]+', 1, level))::text <> '')  UNION ALL
select regexp_substr(nr_seq_inf_p, '[^,]+', 1, level) JOIN cte c ON ()

) SELECT * FROM cte;
)
       order by seq;
;

   qt_cursor_w        informacao_suep.nr_sequencia%type;
   qt_delete_w        informacao_suep.nr_sequencia%type;
   qt_update_w        informacao_suep.nr_sequencia%type;
   qt_reg_info_suep_w informacao_suep.nr_sequencia%type;
   nr_sequencia_w     informacao_suep.nr_sequencia%type;

   type reg_c is table of signsList_c%RowType;
   vet_reg_c reg_c;

   type registro is table of informacao_suep%rowtype index by integer;
   r_registros_w     registro;
   r_update_w        dbms_sql.number_table;
   r_update_seq_w    dbms_sql.number_table;
   r_delete_w        dbms_sql.number_table;

BEGIN

   qt_cursor_w        := 0;
   qt_delete_w        := 0;
   qt_update_w        := 0;
   qt_reg_info_suep_w := 0;

   if (coalesce(nr_seq_inf_p::text, '') = '') then
      delete from informacao_suep where nr_seq_subitem = nr_seq_subitem_p;
   else

      open signsList_c;
      loop
         fetch signsList_c bulk collect
            into vet_reg_c limit 1000;
         for i in 1 .. vet_reg_c.Count loop

            if (vet_reg_c[i].seq = 0) then
               qt_delete_w := qt_delete_w + 1;
               r_delete_w(qt_delete_w) := vet_reg_c[i].nr_seq_inf;
            else
               begin

                  begin
                     select 1
                       into STRICT qt_reg_info_suep_w
                       from informacao_suep a
                      where nr_seq_subitem = nr_seq_subitem_p
                        and nr_seq_inf = vet_reg_c[i].nr_seq_inf;
                  exception
                     when no_data_found then
                        qt_reg_info_suep_w := 0;
                     when too_many_rows then
                        qt_reg_info_suep_w := 0;
                  end;

                  if qt_reg_info_suep_w > 0 then
                     qt_update_w := qt_update_w + 1;
                     r_update_w(qt_update_w)     := vet_reg_c[i].nr_seq_inf;
                     r_update_seq_w(qt_update_w) := vet_reg_c[i].seq;
                  else
                  
                     qt_cursor_w := qt_cursor_w + 1;
                     select nextval('informacao_suep_seq')
                       into STRICT nr_sequencia_w
;

                     r_registros_w[qt_cursor_w].nr_sequencia        := nr_sequencia_w;
                     r_registros_w[qt_cursor_w].dt_atualizacao      := clock_timestamp();
                     r_registros_w[qt_cursor_w].nm_usuario          := nm_usuario_p;
                     r_registros_w[qt_cursor_w].dt_atualizacao_nrec := clock_timestamp();
                     r_registros_w[qt_cursor_w].nm_usuario_nrec     := nm_usuario_p;
                     r_registros_w[qt_cursor_w].nr_seq_apres        := vet_reg_c[i].seq;
                     r_registros_w[qt_cursor_w].nr_seq_inf          := vet_reg_c[i].nr_seq_inf;
                     r_registros_w[qt_cursor_w].nr_seq_subitem         := nr_seq_subitem_p;
                  end if;
               end;
            end if;

         end loop;
         EXIT WHEN NOT FOUND; /* apply on signsList_c */
      end loop;
      close signsList_c;

      if (r_registros_w.count > 0) then
         begin
         
            FORALL i IN INDICES OF r_registros_w
               insert into informacao_suep values r_registros_w(i);

            r_registros_w.delete;

            commit;

         end;
      end if;

      if (r_delete_w.count > 0) then
         begin
         
            forall i in r_delete_w.first .. r_delete_w.last
               delete from informacao_suep
                where nr_seq_subitem = nr_seq_subitem_p
                  and nr_seq_inf  = r_delete_w(i);

            r_delete_w.delete;

            commit;

         end;
      end if;

      if (r_update_w.count > 0) then
         begin
         
            forall i in r_update_w.first .. r_update_w.last
               update informacao_suep
                  set nr_seq_apres = r_update_seq_w(i)
                where nr_seq_subitem  = nr_seq_subitem_p
                  and nr_seq_inf   = r_update_w(i);

            r_update_w.delete;
            r_update_seq_w.delete;

            commit;

         end;
      end if;
   end if;

   dbms_session.free_unused_user_memory;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE control_info_suep_subitem (nr_seq_inf_p text, nr_seq_subitem_p bigint, nm_usuario_p text) FROM PUBLIC;

