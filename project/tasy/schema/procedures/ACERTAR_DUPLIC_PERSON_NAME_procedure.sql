-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE acertar_duplic_person_name ( cd_pessoa_origem_p text, cd_pessoa_destino_p text, nm_usuario_p text) AS $body$
DECLARE


-- variaveis
nr_seq_person_name_origem_w     person_name.nr_sequencia%type;
nr_seq_person_name_destino_w    person_name.nr_sequencia%type;
nr_sequencia_novo_w             person_name.nr_sequencia%type   := null;

ds_given_name_origem_w          person_name.ds_given_name%type;
ds_family_origem_w              person_name.ds_family_name%type;
ds_component_name_1_origem_w    person_name.ds_component_name_1%type;
ds_component_name_2_origem_w    person_name.ds_component_name_2%type;
ds_component_name_3_origem_w    person_name.ds_component_name_3%type;

ds_given_name_atual_w           person_name.ds_given_name%type;
ds_family_atual_w               person_name.ds_family_name%type;
ds_component_name_1_atual_w     person_name.ds_component_name_1%type;
ds_component_name_2_atual_w     person_name.ds_component_name_2%type;
ds_component_name_3_atual_w     person_name.ds_component_name_3%type;

qt_registro_w                   bigint;

mensagem_w varchar(120);

-- Cusores
c_person_name CURSOR(nr_seq_person_name_pc bigint) FOR
SELECT  a.*
from    person_name a
where   a.nr_sequencia  = nr_seq_person_name_pc;

-- Inicio da procedure 
BEGIN

if (cd_pessoa_origem_p IS NOT NULL AND cd_pessoa_origem_p::text <> '') and (cd_pessoa_destino_p IS NOT NULL AND cd_pessoa_destino_p::text <> '') then

    begin -- Obter o nr_seq_person_name para origem
        select  a.nr_seq_person_name
        into STRICT    nr_seq_person_name_origem_w
        from    pessoa_fisica a
        where   a.cd_pessoa_fisica = cd_pessoa_origem_p;
    exception
        when others then
            nr_seq_person_name_origem_w    := null;
    end;

    begin -- Obter o nr_seq_person_name para destino
        select  a.nr_seq_person_name
        into STRICT    nr_seq_person_name_destino_w
        from    pessoa_fisica a
        where   a.cd_pessoa_fisica = cd_pessoa_destino_p;
    exception
        when others then
            nr_seq_person_name_destino_w    := null;
    end;

	--UPDATE

	--Para cada linha no destino, verificar se tem uma igual na origem, se tiver,

	--o campo que estiver preenchido na origem e nao no destino, ira atualizar
     
    begin
        for linha_cursor in c_person_name(nr_seq_person_name_destino_w) loop      
            begin -- armazena os valores dos campos da origem em variaveis
                select  a.ds_given_name,
                        a.ds_family_name,
                        a.ds_component_name_1,
                        a.ds_component_name_2,
                        a.ds_component_name_3                
                into STRICT    ds_given_name_origem_w,
                        ds_family_origem_w,
                        ds_component_name_1_origem_w,
                        ds_component_name_2_origem_w,
                        ds_component_name_3_origem_w                
                from    person_name a
                where   a.nr_sequencia  = nr_seq_person_name_origem_w
                and     a.ds_type       = linha_cursor.ds_type;
            exception
                when others then
                    ds_given_name_origem_w          := null;
                    ds_family_origem_w              := null;
                    ds_component_name_1_origem_w    := null;
                    ds_component_name_2_origem_w    := null;
                    ds_component_name_3_origem_w    := null;
            end;

            -- Armazena os valores tratados
            ds_given_name_atual_w         := coalesce(linha_cursor.ds_given_name, ds_given_name_origem_w);
            ds_family_atual_w             := coalesce(linha_cursor.ds_family_name, ds_family_origem_w);
            ds_component_name_1_atual_w   := coalesce(linha_cursor.ds_component_name_1, ds_component_name_1_origem_w);
            ds_component_name_2_atual_w   := coalesce(linha_cursor.ds_component_name_2, ds_component_name_2_origem_w);
            ds_component_name_3_atual_w   := coalesce(linha_cursor.ds_component_name_3, ds_component_name_3_origem_w);

            -- Atualiza o destino com os valores tratados
            update person_name
            set ds_given_name       = ds_given_name_atual_w,
                ds_family_name      = ds_family_atual_w,
                ds_component_name_1 = ds_component_name_1_atual_w,
                ds_component_name_2 = ds_component_name_2_atual_w,
                ds_component_name_3 = ds_component_name_3_atual_w,
                nm_usuario          = nm_usuario_p,
                dt_atualizacao      = clock_timestamp()
            where nr_sequencia      = nr_seq_person_name_destino_w
            and   ds_type             = linha_cursor.ds_type;

        end loop;
    end;

	
	-- INSERT

	--Processo inverso do UPDATE, para casos onde tem um ds_type que nao existe 

	--no destino
	

    begin
        if (coalesce(nr_seq_person_name_destino_w::text, '') = '') then
		select	nextval('person_name_seq')
		into STRICT	nr_sequencia_novo_w
		;
        end if;
        for linha_cursor in c_person_name(nr_seq_person_name_origem_w) loop
            begin -- conta quantos no destino possuem o mesmo tipo da origem
                select  count(1)
                into STRICT    qt_registro_w
                from    person_name a
                where   a.nr_sequencia = nr_seq_person_name_destino_w
                and     a.ds_type      = linha_cursor.ds_type;
            end;

            -- Ira fazer o INSERT somente se o qt_registro_w for zero
            if (qt_registro_w = 0) then

                insert into person_name(
                    nr_sequencia,
                    dt_atualizacao,
                    nm_usuario,
                    dt_atualizacao_nrec,
                    nm_usuario_nrec,
                    ds_type,
                    ds_given_name,
                    ds_family_name,
                    ds_component_name_1,
                    ds_component_name_2,
                    ds_component_name_3)
                values (
                    coalesce(nr_seq_person_name_destino_w,nr_sequencia_novo_w),
                    clock_timestamp(),
                    nm_usuario_p,
                    clock_timestamp(),
                    nm_usuario_p,
                    linha_cursor.ds_type,
                    linha_cursor.ds_given_name,
                    linha_cursor.ds_family_name,
                    linha_cursor.ds_component_name_1,
                    linha_cursor.ds_component_name_2,
                    linha_cursor.ds_component_name_3);
            end if;

        end loop; -- Fim loop INSERT
        if (nr_sequencia_novo_w IS NOT NULL AND nr_sequencia_novo_w::text <> '') then
            update  pessoa_fisica
            set     nr_seq_person_name  = nr_sequencia_novo_w
            where   cd_pessoa_fisica = cd_pessoa_destino_p;
        end if;
    end;

	--DELETE

	--Depois que o merge foi realizado, o registro origem deve ser excluido
    if (nr_seq_person_name_origem_w IS NOT NULL AND nr_seq_person_name_origem_w::text <> '') then
        begin
            delete
            from    person_name
            where   nr_sequencia = nr_seq_person_name_origem_w;
        end;
    end if;
end if;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE acertar_duplic_person_name ( cd_pessoa_origem_p text, cd_pessoa_destino_p text, nm_usuario_p text) FROM PUBLIC;

