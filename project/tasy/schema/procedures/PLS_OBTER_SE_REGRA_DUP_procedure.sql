-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_obter_se_regra_dup ( nr_seq_regra_oc_p bigint, nm_usuario_p text, nr_seq_conta_p bigint, nr_seq_proc_p bigint, nr_seq_mat_p bigint, nr_seq_regra_duplic_p bigint, nr_seq_estrutura_p bigint, cd_procedimento_regra_p bigint, ie_origem_proced_regra_p bigint, ds_observacao_p INOUT text, nr_Seq_conta_dup_p INOUT bigint, nr_Seq_proc_partic_p INOUT bigint, ie_duplicado_p INOUT text, cd_area_procedimento_regra_p bigint, cd_especialidade_regra_p bigint, cd_grupo_proc_regra_p bigint, ie_origem_ocorrencia_p text) AS $body$
DECLARE

/* 	ie_origem_ocorrencia_p:
	'C' = Se é uma regra da pasta conta médica
	'I' = Se é uma regra da pasta procedimetos/materiais
*/
	/*LITORAL 1099*/

cd_procedimento_w		varchar(20);
cd_medico_executor_w		varchar(20);
cd_guia_referencia_w		varchar(20);
cd_guia_w			varchar(20);
cd_medico_executor_ww		varchar(20);
cd_medico_partic_w		varchar(10);
cd_procedimento_ww		bigint;
cd_proc_w			bigint;
cd_procedimento_www		varchar(20);
cd_area_procedimento_w		bigint;
cd_espec_w			bigint;
cd_grupo_proced_w		bigint;
cd_area_procedimento_regra_w	bigint;
cd_especialidade_regra_w	bigint;
cd_grupo_proc_regra_w		bigint;
cd_area_procedimento_out_w	bigint;
cd_especialidade_out_w		bigint;
dt_procedimento_ww		timestamp;
dt_emissao_w			timestamp;
dt_atend_ref_ww			timestamp;
dt_inicio_proc_ww		timestamp;
ds_observacao_w			varchar(4000):= '';
ds_obs_w			varchar(4000):= '';
ie_w				bigint;
ie_tipo_guia_w 			varchar(3);
ie_origem_proced_w		varchar(2);
ie_tipo_guia_ww			varchar(3);
ie_regra_duplicidade_w		varchar(5);
ie_estrutura_w			varchar(2);
ie_origem_proc_w		bigint;
ie_estrutura_ww			varchar(2);
ie_origem_proced_www		varchar(2);
ie_origem_proced_ww		bigint;
ie_estrutura_ok_w		varchar(1);
nr_seq_prestador_exec_w		bigint;
nr_Seq_segurado_w		bigint;
nr_seq_grau_partic_w		bigint;
nr_seq_protocolo_w		bigint;
nr_seq_conta_ww			bigint;
nr_seq_prestador_exec_ww	bigint;
nr_Seq_segurado_ww		bigint;
nr_seq_grau_partic_ww		bigint;
nr_Seq_proc_partic_w		bigint;
nr_Seq_prestador_partic_w	bigint;
nr_seq_proc_ref_w		bigint;
nr_Seq_conta_dup_w		bigint;
qt_participantes_w		bigint;
qt_participante_w		bigint;
qt_itens_semelhantes_w		bigint;
nr_seq_menor_proc_w		bigint;
nr_Seq_proc_princ_w		bigint;
nr_Seq_conta_dup_ww		bigint:=null;
nm_usuario_log_w		varchar(20):='';
nr_Seq_regra_log_w		bigint;
ie_ativa_log_w			varchar(1);

/*regra deprofissional */

/* 	IE_DUPLICIDADE - DOMINIO 4693	*/

/* 1 -	 Mesmo profissional, participação e serviço	*/

/*todos participantes do procedimento*/

/*	Alterado para mesma participação serviço tratado em conexão com Rodrigo dia 17/10/2012 */

C01 CURSOR FOR
	SELECT	a.nr_sequencia,
		a.cd_medico,
		a.nr_seq_grau_partic,
		a.nr_seq_prestador,
		b.cd_procedimento,
		b.ie_origem_proced,
		coalesce(b.nr_seq_proc_ref,b.nr_sequencia)
	from 	pls_proc_participante 	a,
		pls_conta_proc 		b
	where	b.nr_sequencia 		= a.nr_seq_conta_proc
	and	b.nr_sequencia 		= nr_seq_proc_p
	and	a.ie_status		<> 'C'
	and	b.ie_status		<> 'D';

C02 CURSOR FOR /*OBTER SE EXISTE DUPLICIDADE*/
	-- o serviço da possivel conta duplicada deve ser verificado se esta na mesma estrutura informada na regra de ocorrencia.
	SELECT 	distinct
		a.nr_sequencia,
		b.cd_procedimento,
		b.ie_origem_proced
	from	pls_conta 		a,
		pls_conta_proc		b
	where	a.nr_Sequencia 		= b.nr_seq_conta
	and	a.nr_sequencia		<> nr_seq_conta_ww  --contas diferentes
	and	a.nr_Seq_prestador_exec = nr_Seq_prestador_exec_ww  --mesmo prestador executor
	and	((a.cd_medico_executor	= cd_medico_executor_ww) or (coalesce(a.cd_medico_executor::text, '') = '' and coalesce(cd_medico_executor_ww::text, '') = '')) --mesmo medico
	and	a.nr_seq_segurado 	= nr_seq_segurado_ww  --mesmo segurado
	and	coalesce(a.cd_guia_referencia,a.cd_guia) <> cd_guia_referencia_w  -- CONTAS SEM LIGAÇÃO
	and	trunc(b.dt_procedimento) = trunc(dt_procedimento_ww) --serviço realizado no mesmo dia
	and	((dt_inicio_proc		 = dt_inicio_proc_ww) or (coalesce(dt_inicio_proc::text, '') = '' and coalesce(dt_inicio_proc_ww::text, '') = ''))
	and 	coalesce(a.ie_glosa,'N') 	<> 'S'
	and	b.ie_status		<> 'D'
	order by nr_Sequencia desc;

--distinct por grau de participação
C03 CURSOR FOR
	SELECT	distinct
		a.nr_seq_grau_partic,
		a.nr_sequencia
	from 	pls_proc_participante 	a,
		pls_conta_proc 		b
	where	b.nr_sequencia 		= a.nr_seq_conta_proc
	and	b.nr_sequencia 		= nr_seq_proc_p
	and	coalesce(a.ie_status,'U')	<> 'C'
	and	coalesce(a.IE_GERADA_CTA_HONORARIO,'N') <> 'S'
	and	a.ie_status		<> 'C'
	and	b.ie_status		<> 'D';

C04 CURSOR FOR
	SELECT	distinct
		cd_medico
	from	pls_proc_participante   a,
		pls_conta_proc		b
	where	b.nr_sequencia 		= a.nr_seq_conta_proc
	and	a.nr_seq_grau_partic 	= nr_seq_grau_partic_w
	and	b.nr_sequencia 		= nr_seq_proc_p
	and	a.ie_status		<> 'C'
	and	b.ie_status		<> 'D'
	order by cd_medico;


BEGIN
nr_Seq_conta_dup_p	:= null;
nr_Seq_proc_partic_p	:= null;
ie_duplicado_p		:= 'N';
/*obtendo dados da regra*/

begin
select	ie_regra_duplicidade
into STRICT	ie_regra_duplicidade_w
from 	pls_oc_regra_duplic
where	nr_sequencia 		= nr_seq_regra_duplic_p
and	ie_situacao 		= 'A';
exception
when others then
	ie_regra_duplicidade_w := null;
end;
/*obter dados conta proc*/

if (coalesce( nr_seq_proc_p, 0) > 0 ) then
	/* OBTER  DADOS DA CONTA PARA VERIFICAR DUPLICIDADE */

	begin
	select	a.nr_sequencia,
		a.ie_tipo_guia,
		a.nr_Seq_prestador_exec,
		a.cd_medico_executor,
		a.nr_seq_segurado,
		a.dt_atendimento_referencia,
		b.dt_procedimento,
		b.cd_procedimento,
		b.ie_origem_proced,
		a.cd_guia_referencia,
		a.cd_guia,
		a.nr_Seq_grau_partic,
		b.dt_inicio_proc,
		b.nr_Seq_proc_princ
	into STRICT	nr_seq_conta_ww,
		ie_tipo_guia_ww,
		nr_Seq_prestador_exec_ww,
		cd_medico_executor_ww,
		nr_seq_segurado_ww,
		dt_atend_ref_ww,
		dt_procedimento_ww,
		cd_procedimento_ww,
		ie_origem_proced_ww,
		cd_guia_referencia_w,
		cd_guia_w,
		nr_Seq_grau_partic_ww,
		dt_inicio_proc_ww,
		nr_Seq_proc_princ_w
	from	pls_conta 		a,
		pls_conta_proc		b
	where	a.nr_Sequencia 		= b.nr_seq_conta
	and	b.nr_sequencia 		= nr_Seq_proc_p;
	exception
	when others then
		nr_seq_conta_ww			:= null;
		ie_tipo_guia_ww			:= null;
		nr_Seq_prestador_exec_ww 	:= null;
		cd_medico_executor_ww		:= null;
		nr_seq_segurado_ww		:= null;
		dt_atend_ref_ww			:= null;
		dt_procedimento_ww		:= null;
	end;
	/*Consistencia de valor nulo realizado fora dos campos do select*/

	cd_guia_referencia_w	:= coalesce(cd_guia_referencia_w,cd_guia_w);
	dt_procedimento_ww	:= trunc(dt_procedimento_ww);
	/*pré-validação*/

	if ( ie_regra_duplicidade_w = 2) then
		select	count(b.nr_sequencia)
		into STRICT	qt_itens_semelhantes_w
		from  	pls_conta  	a,
			pls_conta_proc 	b
		where 	a.nr_sequencia 	  	= b.nr_seq_conta
		and	a.nr_seq_segurado 	= nr_seq_segurado_ww
		and	trunc(b.dt_procedimento) = dt_procedimento_ww
		and	coalesce(a.cd_guia_referencia, a.cd_guia) <> cd_guia_referencia_w
		and	b.ie_status		<> 'D';

		/*Verifica se o beneficiario tem contas com data de procedimento do mesmo dia deste procedimento a ser consistido*/

		if ( coalesce( qt_itens_semelhantes_w ,0) = 0) then
			goto final;
		end if;
	end if;

	/*Se existir CD_PROCEDIMENTO na regra, entao verifica se eh igual  ao procedimento que esta sendo verificado, se nao for, aborta a checagem da regra*/

	if	((( cd_procedimento_ww <> cd_procedimento_regra_p) and (coalesce(cd_procedimento_regra_p,0) <> 0))  and
		(( ie_origem_proced_ww <> ie_origem_proced_regra_p) and (coalesce(ie_origem_proced_regra_p,0)<> 0)))  then
		goto final; --SE TEM PROCEDIMENTO INFORMADO NA REGRA E NAO ENCAIXAR COM O DA CONTA,, CAI FORA DA VERIFICACAO
	end if;
	/*Obtem os campos da regra de ocorrência*/

	ie_estrutura_ok_w := pls_obter_se_proc_estrutura( cd_procedimento_ww, ie_origem_proced_ww, cd_area_procedimento_regra_p, cd_especialidade_regra_p, cd_grupo_proc_regra_p, ie_estrutura_ok_w);
	/*Caso o procedimento da conta nao se encaixe nos campos da estrutura do procedimento*/

	if ( ie_estrutura_ok_w = 'N') then
		goto final;
	end if;
end if;
/*OBTER SE PROCEDIMENTO / MAT FAZ PARTE DA ESTRUTURA INFORMADA NA REGRA*/

if ( coalesce(nr_seq_estrutura_p,0) > 0) and
	((( coalesce(cd_procedimento_ww,0)>0) and (coalesce(ie_origem_proced_ww,0)>0) ) or (coalesce(nr_seq_mat_p,0)>0) )  then
	ie_estrutura_w :=  pls_obter_se_estrut_ocorrencia(nr_seq_estrutura_p, cd_procedimento_ww,ie_origem_proced_ww, nr_seq_mat_p);
	if ( ie_estrutura_w = 'N') then
		goto final;
	end if;	-- ITEM DA CONTA NAO PARTICIPA DA ESTRUTURA E CAI FORA DA REGRA
end if;
/*PROCEDIMENTO*/

if (coalesce(nr_Seq_proc_p,0) > 0 ) then
	/*Mesmo profissional, participação e serviço*/

	if ( ie_regra_duplicidade_w = '1') then
		/*    Na função OPS-Glosas e ocorrências, solicitamos ter a possibilidade de criar uma regra para a situação de que
		quando um procedimento for realizado por mais de um executor, seja gerada glosa caso a participação destes participantes sejam iguais.
		Lembrando que deve gerar glosa caso o mesmo executor esteja informado duas vezes com o mesmo grau de participação para o mesmo serviço também. */
		/*Compara os participantes*/

		/* Se o procedimento estiver apontando para outro procedimento executado, este cai fora */

		/*if	( nvl(nr_Seq_proc_princ_w,0) > 0) then

			goto final;
		end if;		*/
		select	min(nr_sequencia)
		into STRICT	nr_seq_menor_proc_w
		from 	pls_conta_proc
		where	cd_procedimento  = cd_procedimento_ww
		and	ie_origem_proced = ie_origem_proced_ww
		and	trunc(dt_procedimento)  = dt_procedimento_ww
		and	dt_inicio_proc  = dt_inicio_proc_ww
		and	nr_seq_conta 	 = nr_seq_conta_ww
		and	ie_status	<> 'D';

		/*Verifica se o procedimento é o principal*/

		select	count(1)
		into STRICT	qt_participantes_w
		from 	pls_proc_participante 	a,
			pls_conta_proc		b
		where 	a.nr_Seq_conta_proc 	= b.nr_sequencia
		and	b.nr_sequencia 		= nr_Seq_proc_p
		and	a.ie_status		<> 'C'
		and	b.ie_status		<> 'D';

		if (coalesce(qt_participantes_w,0) >0) then
			open C03;
			loop
			fetch C03 into
				nr_seq_grau_partic_w,
				nr_seq_proc_partic_w;
			EXIT WHEN NOT FOUND; /* apply on C03 */
				begin
				SELECT * FROM pls_obter_profissionais_duplic(	nr_Seq_proc_p, nr_seq_conta_ww, nr_seq_segurado_ww, cd_guia_referencia_w, nr_seq_grau_partic_w, nr_seq_proc_partic_w, nm_usuario_p, cd_procedimento_ww, ie_origem_proced_ww, dt_procedimento_ww, ds_observacao_w, ie_duplicado_p, nr_Seq_estrutura_p, cd_area_procedimento_regra_p, cd_especialidade_regra_p, cd_grupo_proc_regra_p, null) INTO STRICT ds_observacao_w, ie_duplicado_p;

				ds_obs_w	:= substr( ds_obs_w||ds_observacao_w ,1,4000);

				if (ie_duplicado_p = 'S') then
					goto final;
				end if;

				end;
			end loop;
			close C03;
		else
			SELECT * FROM pls_obter_profissionais_duplic( nr_Seq_proc_p, nr_seq_conta_ww, nr_seq_segurado_ww, cd_guia_referencia_w, nr_Seq_grau_partic_ww, null, nm_usuario_p, cd_procedimento_ww, ie_origem_proced_ww, dt_procedimento_ww, ds_observacao_w, ie_duplicado_p, nr_Seq_estrutura_p, cd_area_procedimento_regra_p, cd_especialidade_regra_p, cd_grupo_proc_regra_p, cd_medico_executor_ww) INTO STRICT ds_observacao_w, ie_duplicado_p;

			ds_obs_w	:= substr(ds_obs_w||ds_observacao_w ,1,4000);
		end if;
	end if;
	/*
	IDENTIFICAR SE HÁ CONTAS QUE NÃO ESTÃO LIGADAS MAS POSSUEM PROCEDIMENTOS:
	- QUE FORAM REALIZADOS PELO MESMO PRESTADOR EXECUTANTE;
	- QUE POSSUEM O MESMO BENEFICIÁRIO;
	- POSSUEM MESMO PROFISSIONAL QUE EXECUTOU O SERVIÇO;
	- MESMA DATA DE REALIZAÇÃO DO SERVIÇO - MESMO SENDO OUTRO SERVIÇO, MAS QUE SEJA DA MESMA ESTRUTURA-
	O OBJETIVO É SABER SE HÁ SERVIÇOS - MESMO DIFERENTES MAS QUE SEJAM DA MESMA ESTRUTURA - QUE FORAM EXECUTADOS NO MESMO DIA,
	MAS O PRESTADOR MANDOU EM  GUIAS  SEM LIGAÇÃO E EM ORDENS DE ENVIO DIFERENTES, ASSIM , SEGUNDO O RODRIGO, PODE OCORRER ERROS NO CALCULO DA TAXA DE EXECUÇÃO:
	EX: MANDAR A GUIA COM MENOR VALOR PRMEIRO, ENTÃO SER COBRADO EM 100%, DEPOIS ENVIAR A OUTRA GUIA - DO MESMO SERVIÇO OU DA MESMA ESTRUTURA - COM VALOR MAIS ALTO E SER COBRADO 70%.
	SEGUNDO O RODRIGO, EXISTEM CALCULOS QUE SAO FEITOS : QUANDO UM GRUPO DE PROCEDIMENTOS SÃO EXECUTADOS EM CONJUNTO SOFREM UM DECRESCIMO DE VALOR.
	A SOLICITAÇÃO EH PARA IDENTIFICAR POSSIVEIS "DUPLICIDADES "ENTRE AS CONTAS, MESMO ELAS SENDO CADASTRADAS COM LIGAÇÕES DIFERENTES
	*/
	if ( ie_regra_duplicidade_w = '2') then /* Cobrança duplicada em contas sem ligação*/
		open C02; --verifica a conta com
		loop
		fetch C02 into
			nr_Seq_conta_dup_w,
			cd_proc_w,
			ie_origem_proc_w;
		EXIT WHEN NOT FOUND; /* apply on C02 */
			begin

			ie_estrutura_ww		:= ''; -- se encaixa com campo estrutura da regra de ocorrencia
			ie_estrutura_ok_w 	:= ''; -- se encaixa com os campos de area, especialidade e grupo na regra de ocorrencia
			/*verifica se o serviço da possivel conta duplicada é da mesma estrutura ocorrência informada na regra*/

			if ( coalesce(nr_Seq_conta_dup_ww,0) <> coalesce(nr_Seq_conta_dup_w,0) ) then


				if (coalesce(nr_seq_estrutura_p,0) > 0) then

					ie_estrutura_ww		:=  pls_obter_se_estrut_ocorrencia(nr_seq_estrutura_p, cd_proc_w, ie_origem_proc_w, null);

					if ( ie_estrutura_ww = 'N') then
						goto final2;
					end if;
				end if;

				/*verifica se o procedimento encaixa na regra de ocorrencia - campos area,especialidade e grupo*/

				if (cd_area_procedimento_regra_p IS NOT NULL AND cd_area_procedimento_regra_p::text <> '')or (cd_especialidade_regra_p IS NOT NULL AND cd_especialidade_regra_p::text <> '') or (cd_grupo_proc_regra_p IS NOT NULL AND cd_grupo_proc_regra_p::text <> '') then
					ie_estrutura_ok_w  := pls_obter_se_proc_estrutura( 	cd_proc_w, ie_origem_proc_w, cd_area_procedimento_regra_p, cd_especialidade_regra_p, cd_grupo_proc_regra_p, ie_estrutura_ok_w );


					if (ie_estrutura_ok_w = 'N') then

						goto final2;
					end if;
				end if;
				if	(cd_proc_w = cd_procedimento_ww AND ie_origem_proc_w = ie_origem_proced_ww)or
					((ie_estrutura_ww = 'S') or (ie_estrutura_ok_w = 'S')) then
					begin

					nr_Seq_conta_dup_ww 	:= nr_Seq_conta_dup_w;

					/*Se há contas duplicadas*/

					nr_Seq_conta_dup_p	:= nr_Seq_conta_dup_ww;
					nr_Seq_proc_partic_p	:= null;
					ie_duplicado_p		:= 'S';
					ds_observacao_w		:= substr(ds_observacao_w|| nr_Seq_conta_dup_ww||', ' ,1,4000);

					end;
				end if;
			end if;
			end;
		<<final2>>

		ie_duplicado_p := ie_duplicado_p;
		end loop;
		close C02;
		--OBSERVACAO DAS CONTAS QUE PODEM ESTAR "DUPLICADAS".
		ds_obs_w	:= substr(ds_obs_w||ds_observacao_w ,1,4000);

	end if;

end if;
<<final>>
if (C03%ISOPEN) then
	close C03;
end if;
if (C02%ISOPEN) then
	close C02;
end if;
if (C01%ISOPEN) then
	close C01;
end if;
ds_observacao_p		:= ds_obs_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_obter_se_regra_dup ( nr_seq_regra_oc_p bigint, nm_usuario_p text, nr_seq_conta_p bigint, nr_seq_proc_p bigint, nr_seq_mat_p bigint, nr_seq_regra_duplic_p bigint, nr_seq_estrutura_p bigint, cd_procedimento_regra_p bigint, ie_origem_proced_regra_p bigint, ds_observacao_p INOUT text, nr_Seq_conta_dup_p INOUT bigint, nr_Seq_proc_partic_p INOUT bigint, ie_duplicado_p INOUT text, cd_area_procedimento_regra_p bigint, cd_especialidade_regra_p bigint, cd_grupo_proc_regra_p bigint, ie_origem_ocorrencia_p text) FROM PUBLIC;

