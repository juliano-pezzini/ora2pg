-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE ptu_gerar_nota_compl_regra (( nr_seq_cobranca_p bigint, nm_usuario_p text) is nr_nota_w ptu_nota_cobranca.nr_nota%type) RETURNS integer AS $body$
DECLARE

ds_retorno_w	integer;
BEGIN

-- se o numero de caracteres atual somado ao limite do ptu passar o valor limite do TISS, então é retornado apenas a diferença.
if (qt_limite_char_ptu_p + qt_char_compl_atual_p > qt_limite_char_compl_p) then
	-- Pega a diferenca entre o limite do tiss e a soma do limite PTU com o qt caracteres atual, e subtrai do limite do PTU
	ds_retorno_w	:= qt_limite_char_ptu_p - ((qt_limite_char_ptu_p + qt_char_compl_atual_p) - qt_limite_char_compl_p);
else	-- se não passou o limite de caracteres do TISS, retorna o limite do PTU
	ds_retorno_w	:= qt_limite_char_ptu_p;
end if;

return ds_retorno_w;

end;

begin

select	max(nr_nota),
	max(nr_lote),
	max(nr_seq_conta)
into STRICT	nr_nota_w,
	nr_lote_w,
	nr_seq_conta_cobr_w
from	ptu_nota_cobranca
where	nr_sequencia = nr_seq_cobranca_p;

select	max(ie_tipo_guia)
into STRICT	ie_tipo_guia_w
from	pls_conta
where	nr_sequencia = nr_seq_conta_cobr_w;

select	coalesce(sum(length(ds_complemento)),0),
	count(1)
into STRICT 	qt_char_compl_atual_w,
	qt_compl_atual_w
from	ptu_nota_complemento
where	nr_seq_nota_cobr = nr_seq_cobranca_p;

-- Quantidade limite de caracteres por observação segundo o PTU
qt_limite_char_ptu_w := 100;

-- Quantidade limite de carachteres por observacao segundo o TISS
qt_limite_char_compl_w := 500;

for	r_c01_w in c01( ie_tipo_guia_w ) loop
	for r_c02_w in c02( r_c01_w.nr_sequencia ) loop

		-- Atualmente, por definições internas, só pode ter no maximo 5 registros, Independente se foi alcancado o limite de 500 caracteres ou não
		if (qt_compl_atual_w < 5) then

			-- Marca o inicio da leitura dos caracteres da observacao, que será fragmentada conforme limite do PTU
			nr_inicio_obs_ptu_w := 1;

			-- Verifica o limite atual de char PTU, conforme limite total do TISS
			qt_limite_char_ptu_atual_w := ret_limite_char_atual_ptu(qt_limite_char_ptu_w, qt_limite_char_compl_w, qt_char_compl_atual_w);

			-- Se não passou o limite de characteres do TISS, então ainda tem caracteres "sobrando", então busca o complemento e prossegue com a rotina
			if (qt_limite_char_ptu_atual_w > 0) then

				-- Busca o complemento completo
				ds_complemento_temp_w := pls_obter_info_ptu_compl_linha(nr_seq_cobranca_p, r_c02_w.ds_complemento);

				-- Fraciona o complemento completo
				ds_complemento_w := substr(ds_complemento_temp_w, nr_inicio_obs_ptu_w, qt_limite_char_ptu_atual_w);

				-- enquanto possuir conteudo no complemento e caracteres "sobrando"
				while	(((trim(both ds_complemento_w) IS NOT NULL AND (trim(both ds_complemento_w))::text <> '')) and (qt_limite_char_ptu_atual_w > 0) and (qt_compl_atual_w) < 5) loop
					-- Por preucaução, ainda é consultado se o complemento inserido não é identico a algum já existente, para o mesmo tipo.
					-- Essa restrição existia na rotina antiga e foi preservada
					select	count(1)
					into STRICT	qt_complemento_w
					from	ptu_nota_complemento
					where	nr_seq_nota_cobr	= nr_seq_cobranca_p
					and	ie_tipo_complemento	= r_c01_w.ie_tipo_complemento
					and	ds_complemento		= ds_complemento_w;

					-- Se não tem nenhum repetido para o complemento da cobrança de mesmo tipo
					if (qt_complemento_w = 0) then
						insert into ptu_nota_complemento(	nr_sequencia,				nr_seq_nota_cobr,			nr_lote,
											nr_nota,				ie_tipo_complemento,			ds_complemento,
											dt_atualizacao,				nm_usuario,				dt_atualizacao_nrec,
											nm_usuario_nrec,			especif_material)
										SELECT	nextval('ptu_nota_complemento_seq'),	nr_seq_cobranca_p,			nr_lote_w,
											nr_nota_w,				r_c01_w.ie_tipo_complemento,		ds_complemento_w,
											clock_timestamp(),				nm_usuario_p,				clock_timestamp(),
											nm_usuario_p,				null
										;

						qt_compl_atual_w := qt_compl_atual_w + 1;
					end if;

					-- soma a quantidade limite de caracteres inseridos no total de caracteres do complemento
					qt_char_compl_atual_w := qt_char_compl_atual_w + qt_limite_char_ptu_atual_w;

					-- Verifica o limite atual de char PTU
					qt_limite_char_ptu_atual_w := ret_limite_char_atual_ptu(qt_limite_char_ptu_w, qt_limite_char_compl_w, qt_char_compl_atual_w);

					-- Atualiza a posição inicial da observação, conforme caracteres sobrando com base no limite do PTU
					nr_inicio_obs_ptu_w := nr_inicio_obs_ptu_w + (qt_limite_char_ptu_atual_w);

					-- Carrega apenas um "fragmento" da observação, conforme determinação do PTU, será inserido varios registros para ficar no mesmo limite
					ds_complemento_w := substr(ds_complemento_temp_w, nr_inicio_obs_ptu_w, qt_limite_char_ptu_atual_w);
				end loop; -- Fim while limite de caracteres permitido
			end if; -- Não passou o limite de caracteres
		end if; -- fim se tem menos de 5 registros
	end loop;
end loop;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE ptu_gerar_nota_compl_regra (( nr_seq_cobranca_p bigint, nm_usuario_p text) is nr_nota_w ptu_nota_cobranca.nr_nota%type) FROM PUBLIC;

