-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE gerar_tx_tempo_setor (DT_PARAMETRO_P timestamp, NM_USUARIO_P text, NR_ATENDIMENTO_P bigint DEFAULT 0) AS $body$
DECLARE

			
nr_atendimento_w			bigint;
cd_estabelecimento_w		smallint;
dt_entrada_w				timestamp;
ie_tipo_convenio_w			smallint;
ie_tipo_atendimento_w		smallint;
nr_seq_atepacu_atual_w		bigint;
nr_seq_atepacu_ant_w		bigint;
qt_tx_hora_w				bigint;
ie_classificacao_w			varchar(1);
nr_sequencia_w				bigint;

dt_entrada_unidade_w		timestamp;
cd_setor_atendimento_w		bigint;
cd_procedimento_w			bigint;
ie_origem_proced_w			bigint;
cd_convenio_w				integer;
cd_categoria_w				varchar(10);
nr_doc_convenio_w			varchar(30);
ie_tipo_guia_w				varchar(30);
cd_senha_w 					varchar(30);
cd_cgc_prestador_w			varchar(14);
nr_seq_proc_interno_w		bigint;

ie_medico_executor_w		varchar(2);
cd_medico_executor_w		varchar(10);
ie_funcao_medico_w			varchar(10)	:= 0;
cd_pessoa_fisica_w			varchar(10);
cd_profissional_w			varchar(10);
nr_seq_classificacao_w		bigint;
qt_tolerancia_w				bigint;
nr_seq_w					bigint;
qt_min_cobranca_w			bigint;
dt_ultima_taxa_hora_w		timestamp;

ie_clinica_w				integer;
cd_especialidade_medica_w		integer		:= 0;

sql_err_w				varchar(2000);
dt_entrada_unidade_ant_w		timestamp;
cd_setor_atendimento_ant_w		bigint;
dt_saida_unidade_ant_w			timestamp;

ie_via_acesso_w				varchar(1);
ie_limite_w				varchar(1);
ie_lancamento_w				varchar(1);
ds_observacao_exp_w			varchar(255) := substr(wheb_mensagem_pck.get_texto(297857),1,254);
ie_forma_geracao_w				conv_regra_tx_tempo_setor.ie_forma_geracao%type;
dt_saida_unidade_w				timestamp;
cd_unidade_basica_w				varchar(10);
cd_unidade_compl_w				varchar(10);
nr_seq_regra_tx_w				bigint;
cd_unidade_basica_ant_w			varchar(10);
cd_unidade_compl_ant_w			varchar(10);
qt_mincobr_tolerancia_w			bigint;
dt_entrada_unidade_com_toler_w 	timestamp;
ie_considera_regra_unidade_w	varchar(1);
dt_taxa_w						timestamp;
qt_taxa_unidade_w				bigint:= 0;
dt_consiste_tolerancia_w		timestamp;
dt_inicio_vigencia_w			conv_regra_tx_tempo_setor.dt_inicio_vigencia%type;
dt_final_vigencia_w				conv_regra_tx_tempo_setor.dt_final_vigencia%type;
ie_validar_proc_int_w			conv_regra_tx_tempo_setor.ie_validar_proc_int%type;
ie_rn_regra_tx_tempo_setor_w	parametro_faturamento.ie_rn_regra_tx_tempo_setor%type;

C00 CURSOR FOR
	SELECT	e.nr_atendimento,
		e.dt_entrada,
		e.cd_estabelecimento,
		coalesce(e.ie_tipo_convenio,0),
		e.ie_tipo_atendimento,
		e.nr_seq_classificacao,
		e.ie_clinica
	from	atendimento_paciente e
	where	e.dt_entrada	<= dt_parametro_p
	and	((nr_atendimento_p = 0) or (e.nr_atendimento = nr_atendimento_p))
	and	coalesce(e.dt_fim_conta::text, '') = ''
	and	coalesce(e.ie_tipo_convenio,0) <> 3
	and	coalesce(e.dt_alta,to_date('2999','yyyy')) > dt_parametro_p
	order by e.nr_atendimento;
		
C02 CURSOR FOR
	SELECT	coalesce(cd_procedimento,0),
		ie_origem_proced,
		nr_seq_proc_interno,
		coalesce(qt_tolerancia,0),
		coalesce(qt_min_cobranca,0),
		coalesce(ie_limite,'N'),
		coalesce(ie_forma_geracao,'N'),
		nr_sequencia,
		coalesce(qt_mincobr_tolerancia,0) qt_mincobr_tolerancia,
		dt_inicio_vigencia,
		dt_final_vigencia,
		coalesce(ie_validar_proc_int,'N')
	from	conv_regra_tx_tempo_setor
	where	coalesce(cd_convenio, coalesce(cd_convenio_w,0)) 	= coalesce(cd_convenio_w,0)
	and 	cd_setor_atendimento 	= cd_setor_atendimento_w
	and 	dt_parametro_p between coalesce(dt_inicio_vigencia, dt_parametro_p) and coalesce(dt_final_vigencia, dt_parametro_p + 365)
	and	coalesce(cd_estabelecimento, coalesce(cd_estabelecimento_w,0)) 	= coalesce(cd_estabelecimento_w,0)
	and  	coalesce(cd_unidade_basica , coalesce(cd_unidade_basica_w,0))		= coalesce(cd_unidade_basica_w,0)
	and 	coalesce(cd_unidade_compl, coalesce(cd_unidade_compl_w,0)) 		= coalesce(cd_unidade_compl_w,0)
	and 	coalesce(ie_situacao,'I') = 'A'
	order by coalesce(cd_convenio,9999),
	coalesce(ie_limite,'N') desc;
	
C03 CURSOR FOR
	SELECT	/*+ INDEX (A ATEPACU_ATEPACI_FK_I) */			a.nr_seq_interno
	from 	setor_atendimento c,
			atend_paciente_unidade a
	where	a.nr_atendimento 			= nr_atendimento_w
	and		c.cd_setor_atendimento		= a.cd_setor_atendimento
	and 	a.dt_entrada_unidade 		<= DT_PARAMETRO_P
	and		(c.cd_classif_setor(1,2,3,4,5,8)-- pronto socorro(1),centro cirurgico(2),unidades de internacao(3),UTI(4), Servicos Especiais(5),Home Care(8)		
			or (ie_rn_regra_tx_tempo_setor_w = 'S' AND c.cd_classif_setor = 9))-- recem nascidos(9)
	order by coalesce(a.dt_saida_unidade, a.dt_entrada_unidade + 9999) desc;
	
C04 CURSOR FOR
	SELECT	/*+ INDEX (A ATEPACU_ATEPACI_FK_I) */			a.nr_seq_interno
	from 	setor_atendimento c,
			atend_paciente_unidade a
	where	a.nr_atendimento 		= nr_atendimento_w
	and	c.cd_setor_atendimento		= a.cd_setor_atendimento
	and 	a.dt_entrada_unidade 		<= DT_PARAMETRO_P
	and 	nr_seq_atepacu_atual_w > 0
	and 	a.nr_seq_interno < nr_seq_atepacu_atual_w
	and 	(c.cd_classif_setor(1,2,3,4,5,8)-- pronto socorro(1),centro cirurgico(2),unidades de internacao(3),UTI(4), Servicos Especiais(5), Home Care(8)
			or (ie_rn_regra_tx_tempo_setor_w = 'S' AND c.cd_classif_setor = 9))-- recem nascidos(9)
	order by coalesce(a.dt_saida_unidade, a.dt_entrada_unidade + 9999) desc;
	

BEGIN

--gravar_log_cliente( 'INICIO   => DT_PARAMETRO_P = '|| to_char(dt_parametro_p,'dd/MM/yyyy hh24:mi:ss'));
OPEN C00;
LOOP
   	FETCH C00 into
        nr_atendimento_w,
		dt_entrada_w,
		cd_estabelecimento_w,
		ie_tipo_convenio_w,
		ie_tipo_atendimento_w,
		nr_seq_classificacao_w,
		ie_clinica_w;
   	EXIT WHEN NOT FOUND; /* apply on c00 */
	BEGIN
	
	--gravar_log_cliente( ' NR_ATENDIMENTO ENCAIXADO= '||nr_atendimento_w);

	
	--Obter o valor do parametro para validar regra 'taxa tempo setor' - recem-nascido
	
	select	coalesce(max(ie_rn_regra_tx_tempo_setor),'N')
	into STRICT	ie_rn_regra_tx_tempo_setor_w
	from	parametro_faturamento
	where	cd_estabelecimento = cd_estabelecimento_w;
	
	--gravar_log_cliente('PARAMETRO ie_rn_regra_tx_tempo_setor='||ie_rn_regra_tx_tempo_setor_w);	

	
	--Obter_Atepacu_paciente(nr_atendimento_w, 'IA'); 
	nr_seq_atepacu_atual_w	:= 0;
	
	/*VAI OBTER A MOVIMENTACAO MAIS ATUAL, BASEADO NA DATA DA JOB(DATA MENOR QUE A DATA DA JOB)*/

	open C03;
	loop
	fetch C03 into	
		nr_seq_atepacu_atual_w;
	EXIT WHEN NOT FOUND; /* apply on C03 */
		begin		
		nr_seq_atepacu_atual_w	:= nr_seq_atepacu_atual_w;
		exit;
		end;
	end loop;
	close C03;
	
	--gravar_log_cliente( ' SEQ MOVIMENTACAO ATUAL= '||nr_seq_atepacu_atual_w);
	
	select 	max(cd_setor_atendimento),
			max(dt_entrada_unidade),
			max(dt_saida_unidade),
			max(cd_unidade_basica),
			max(cd_unidade_compl)
	into STRICT	cd_setor_atendimento_w,
			dt_entrada_unidade_w,
			dt_saida_unidade_w,
			cd_unidade_basica_w,
			cd_unidade_compl_w
	from 	atend_paciente_unidade
	where	nr_seq_interno = nr_seq_atepacu_atual_w;
	
	--gravar_log_cliente('OBTENDO CONVENIO...');

	
	-- obter o convenio de execucao 
	begin	
	SELECT * FROM obter_convenio_execucao(nr_atendimento_w, trunc(DT_PARAMETRO_P,'hh'), cd_convenio_w, cd_categoria_w, nr_doc_convenio_w, ie_tipo_guia_w, cd_senha_w) INTO STRICT cd_convenio_w, cd_categoria_w, nr_doc_convenio_w, ie_tipo_guia_w, cd_senha_w;
	exception
		when others then
		cd_convenio_w		:= null;
		cd_categoria_w		:= null;
		nr_doc_convenio_w	:= null;
		ie_tipo_guia_w		:= null;
		cd_senha_w		:= null;
		
		sql_err_w := substr(SQLERRM, 1, 1800);
		insert into W_LOG_TX_TEMPO_SETOR(NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
			values (nextval('w_log_tx_tempo_setor_seq'), clock_timestamp(), nm_usuario_p, clock_timestamp(), nm_usuario_p, sql_err_w, nr_atendimento_w, 1);
	end;
	
	--gravar_log_cliente('CONVENIO='||cd_convenio_w);

	
	--OBTER O VALOR DO PARAMETRO DO CADASTRO DE CONVENIOS\RELACIONAMENTO\ESTAB
	begin
		select  coalesce(ie_taxa_tempo_unidade ,'N')
		into STRICT   	ie_considera_regra_unidade_w
		from    convenio_estabelecimento
		where   cd_estabelecimento 	= cd_estabelecimento_w
		and     cd_convenio 		= cd_convenio_w;
		
		--gravar_log_cliente('PARAMETRO ie_considera_regra_unidade_w='||ie_considera_regra_unidade_w);
		
	exception
	when others then
		sql_err_w := substr(SQLERRM, 1, 1800);
		insert into W_LOG_TX_TEMPO_SETOR(NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
			values (nextval('w_log_tx_tempo_setor_seq'), clock_timestamp(), nm_usuario_p, clock_timestamp(), nm_usuario_p, sql_err_w, nr_atendimento_w, 1);
	end;	

	
	/*VAI OBTER SE HOUVE MOVIMENTACAO ANTERIOR NO MESMO SETOR */


	-- SE VAI CONSIDERAR A ENTRADA NO SETOR OU A MOVIMENTACAO MAIS ATUAL(UMA MOVIMENTACAO MAIS ATUAL NO MESMO SETOR, APENAS TROCANDO A UNIDADE)

	-- PARAMETRIZADO EM CADASTRO DE CONVENIO - REGRAS DO ESTABELECIMENTO

	-- N= VERIFICA MOVIMENTACAO ANTERIOR; 

	-- S= VERIFICA MOVIMENTACAO MAIS ATUAL;
	if (coalesce(ie_considera_regra_unidade_w,'N') = 'N') then
	
		-- Verificar se a movimentacao nao foi realizada para um mesmo setor (Apenas troca de leito)	OS 458159
		nr_seq_atepacu_ant_w	:= 0;
		
		open C04;
		loop
		fetch C04 into	
			nr_seq_atepacu_ant_w;
		EXIT WHEN NOT FOUND; /* apply on C04 */
			begin
			nr_seq_atepacu_ant_w:= nr_seq_atepacu_ant_w;
			exit;
			end;
		end loop;
		close C04;
		
		select 	max(cd_setor_atendimento),
				max(dt_entrada_unidade),
				max(dt_saida_unidade),
				max(cd_unidade_basica),
				max(cd_unidade_compl)
		into STRICT	cd_setor_atendimento_ant_w,
				dt_entrada_unidade_ant_w,
				dt_saida_unidade_ant_w,
				cd_unidade_basica_ant_w,
				cd_unidade_compl_ant_w
		from 	atend_paciente_unidade
		where	nr_seq_interno = nr_seq_atepacu_ant_w;	
		
		/*CASO SEJA MOVIMENTACAO NO MESMO SETOR - CONSIDERAR MOVIMENTACAO ANTERIOR, QUE E O INICIO DA ENTRADA NO SETOR*/

		if (cd_setor_atendimento_ant_w = cd_setor_atendimento_w) then
			cd_setor_atendimento_w	:= cd_setor_atendimento_ant_w;
			dt_entrada_unidade_w  	:= dt_entrada_unidade_ant_w;
			dt_saida_unidade_w    	:= dt_saida_unidade_ant_w;
			cd_unidade_basica_w 	:= cd_unidade_basica_ant_w;
			cd_unidade_compl_w 		:= cd_unidade_compl_ant_w;
			--gravar_log_cliente( ' <TEM MOVIMENTACAO ANTERIOR NO MESMO SETOR> SEQ MOVIMENTACAO ANTERIOR= '||nr_seq_atepacu_ant_w);
		end if;	
		
	end if;
	
	
	cd_procedimento_w:= 0;
	open C02;
	loop
	fetch C02 into	
		cd_procedimento_w,
		ie_origem_proced_w,
		nr_seq_proc_interno_w,
		qt_tolerancia_w,
		qt_min_cobranca_w,
		ie_limite_w,
		ie_forma_geracao_w,
		nr_seq_regra_tx_w,
		qt_mincobr_tolerancia_w,
		dt_inicio_vigencia_w	,
		dt_final_vigencia_w,
		ie_validar_proc_int_w;
	EXIT WHEN NOT FOUND; /* apply on C02 */
		begin
		
		/*CAMPOS DA REGRA DE TAXA TEMPO SETOR*/

		cd_procedimento_w		:= cd_procedimento_w;		/*TAXA A SER GERADA*/
		ie_origem_proced_w		:= ie_origem_proced_w;
		nr_seq_proc_interno_w	:= nr_seq_proc_interno_w;
		qt_tolerancia_w			:= qt_tolerancia_w; 		/* TOLERANCIA PARA DEFINIR SE GERA TAXA NA HORA DE ENTRADA NO SETOR*/
		qt_min_cobranca_w		:= qt_min_cobranca_w; 		/* O INTERVALO ENTRE A GERACAO DAS TAXAS */
		qt_mincobr_tolerancia_w	:= qt_mincobr_tolerancia_w;	/* ESTE CAMPO DEFINE O TEMPO QUE SERA CONSIDERADO PARA O INICIO DA GERACAO DE TAXA*/

			
		--gravar_log_cliente('INICIO - CURSOR C02 - REGRAS ENCAIXADAS TX TEMPO SETOR'

							-- ||'nr_seq_regra_tx_w= '||nr_seq_regra_tx_w	

							-- ||'; qt_tolerancia_w= '||qt_tolerancia_w

							-- ||'; qt_min_cobranca_w= '||qt_min_cobranca_w

							-- ||'; cd_unidade_basica_w= '||cd_unidade_basica_w

							-- ||'; cd_unidade_compl_w= '||cd_unidade_compl_w

							-- ||'; cd_procedimento_w= '||cd_procedimento_w

							-- ||'; ie_origem_proced_w= '||ie_origem_proced_w

							-- ||'; qt_mincobr_tolerancia_w='||qt_mincobr_tolerancia_w

							-- );
							
		if (cd_procedimento_w = 0) then
			goto Proximo;			
		end if;
		
		select	max(ie_classificacao)
		into STRICT	ie_classificacao_w
		from	procedimento
		where	cd_procedimento		= cd_procedimento_w
		and		ie_origem_proced	= ie_origem_proced_w;
		
		-- obter medico executor 
		SELECT * FROM consiste_medico_executor(cd_estabelecimento_w, cd_convenio_w, cd_setor_atendimento_w, cd_procedimento_w, ie_origem_proced_w, ie_tipo_atendimento_w, null, nr_seq_proc_interno_w, ie_medico_executor_w, cd_cgc_prestador_w, cd_medico_executor_w, cd_profissional_w, cd_pessoa_fisica_w, trunc(DT_PARAMETRO_P,'hh'), nr_seq_classificacao_w, 'N', null, null) INTO STRICT ie_medico_executor_w, cd_cgc_prestador_w, cd_medico_executor_w, cd_profissional_w;
				
		if (coalesce(ie_medico_executor_w,'Z') <> 'F') then
			cd_medico_executor_w:= '';
		end if;
		
		SELECT * FROM obter_proced_espec_medica(cd_estabelecimento_w, cd_convenio_w, cd_procedimento_w, ie_origem_proced_w, null, null, null, ie_clinica_w, cd_setor_atendimento_w, cd_especialidade_medica_w, ie_funcao_medico_w, cd_medico_executor_w, nr_seq_proc_interno_w, ie_tipo_atendimento_w) INTO STRICT cd_especialidade_medica_w, ie_funcao_medico_w;
			
		if (coalesce(cd_cgc_prestador_w::text, '') = '') then
			select	max(a.cd_cgc)
			into STRICT	cd_cgc_prestador_w
			from 	estabelecimento a,
				atendimento_paciente b
			where	a.cd_estabelecimento 	= b.cd_estabelecimento
			and	b.nr_atendimento 	= nr_atendimento_w;
		end if;	
		
		select 	substr(obter_regra_via_acesso(cd_procedimento_w, ie_origem_proced_w, cd_estabelecimento_w, cd_convenio_w),1,2)
		into STRICT	ie_via_acesso_w
		;

		ie_lancamento_w := 'S';
		
		/*VERIFICA SE DEVE GERAR TAXA POR PASSAGEM DE UNIDADE*/

		if (ie_limite_w = 'S') then
			if (ie_considera_regra_unidade_w = 'S') then
				if (ie_validar_proc_int_w = 'S') and (nr_seq_proc_interno_w IS NOT NULL AND nr_seq_proc_interno_w::text <> '') then
					select	count(1)
					into STRICT	qt_taxa_unidade_w
					from	procedimento_paciente a
					where	a.nr_seq_atepacu = nr_seq_atepacu_atual_w
					and	a.nr_atendimento = nr_atendimento_w
					and	a.nr_seq_proc_interno = nr_seq_proc_interno_w
					and	coalesce(cd_motivo_exc_conta::text, '') = '';
				else			
					select	count(1)
					into STRICT	qt_taxa_unidade_w
					from	procedimento_paciente a
					where	a.nr_seq_atepacu = nr_seq_atepacu_atual_w
					and	a.nr_atendimento = nr_atendimento_w
					and	a.cd_procedimento = cd_procedimento_w
					and	a.ie_origem_proced = ie_origem_proced_w
					and	coalesce(cd_motivo_exc_conta::text, '') = '';
				end if;

					
				if ( qt_taxa_unidade_w >0) then
					ie_lancamento_w := 'N';
				end if;
			end if;
		end if;
		
		
		if (ie_considera_regra_unidade_w = 'S') then
			if (ie_validar_proc_int_w = 'S') and (nr_seq_proc_interno_w IS NOT NULL AND nr_seq_proc_interno_w::text <> '') then
				select	count(1)
				into STRICT	qt_taxa_unidade_w
				from	procedimento_paciente a
				where	a.nr_seq_atepacu = nr_seq_atepacu_atual_w
				and	a.nr_atendimento = nr_atendimento_w
				and	a.nr_seq_proc_interno = nr_seq_proc_interno_w
				and	coalesce(cd_motivo_exc_conta::text, '') = '';
			else
				select	count(1)
				into STRICT	qt_taxa_unidade_w
				from	procedimento_paciente a
				where	a.cd_setor_atendimento = cd_setor_atendimento_w
				and	a.nr_atendimento = nr_atendimento_w
				and	a.cd_procedimento = cd_procedimento_w
				and	a.ie_origem_proced = ie_origem_proced_w
				and	coalesce(cd_motivo_exc_conta::text, '') = '';
			end if;
				
			if ( qt_taxa_unidade_w >0) then
				ie_lancamento_w := 'N';
			end if;
		
		end if;
			
		
		 -- gravar_log_cliente('------->ANTES PRIMEIRO TESTE----> ');

		 -- gravar_log_cliente('ie_forma_geracao_w= '||ie_forma_geracao_w

		 -- ||';dt_entrada_unidade_w='||to_char(dt_entrada_unidade_w,'dd/MM/yyyy hh24:mi:ss')

		 -- ||';qt_tolerancia_w='||qt_tolerancia_w

		 -- ||';  dt_entrada_unidade_w + (qt_tolerancia_w/1440)= '||to_char(dt_entrada_unidade_w + (qt_tolerancia_w/1440),'dd/MM/yyyy hh24:mi:ss') 

		 -- ||'; trunc(DT_PARAMETRO_P,hh)='||to_char(trunc(DT_PARAMETRO_P,'hh'),'dd/MM/yyyy hh24:mi:ss'));

		
		/*INICIA A VERIFICACAO DE TOLERANCIA (SE GERA A TAXA NA MESMA HORA DE ENTRADA)*/


		
		-- Ex: Paciente entrou 07:49:02 e a job rodou as 08:00. A tolerancia e 5 min.

		-- Deve cobrar a taxa das 07:49:02 + tolerancia e das 08:00
		if	((
				(ie_forma_geracao_w = 'N') and --Gerar 1' taxa setor c/ base na dt entrada + min tolerancia
				(dt_entrada_unidade_w + (qt_tolerancia_w/1440) <  trunc(DT_PARAMETRO_P,'hh')) and
				((trunc(dt_entrada_unidade_w,'hh') + 60/1440) = trunc(DT_PARAMETRO_P,'hh')) and (qt_mincobr_tolerancia_w = 0)
			)
			or
			(	/*SE CHECADO, GERA TAXA UMA VEZ CASO O PACIENTE AINDA ESTEJA NA UNIDADE OU SE SAIU DA UNIDADE E ULTRAPASSOU TEMPO DE TOLERANCIA*/
				(ie_forma_geracao_w = 'S') and  --Gerar 1' taxa setor c/ base na dt entrada + min tolerancia(trunc(dt_entrada_unidade_w,'hh') + 60/1440) = trunc(DT_PARAMETRO_P,'hh') and --1
				((coalesce(dt_saida_unidade_w::text, '') = '') or  --2
				(dt_saida_unidade_w >= (dt_entrada_unidade_w + (qt_tolerancia_w/1440))))
			)) and (ie_lancamento_w = 'S') then --3
			/*
			1 - Sempre gerar a 1' taxa do setor dentro da hora truncada da entrada no setor.
			Ex: entrada 10:31 logo 10:00 + 60 min = 11:00 ou seja, quando dt_parametro_p for igual a 11:00, sera gerada a 1' taxa. Ou seja,
			sempre gerar a 1' tx quando a hora do job for igual a hora de entrada.
			2 - Considerando o cenario acima, se o paciente ja tiver saido da unidade entao testa o 3, senao sempre gera.
			3 - Caso o paciente tenha saido, testar se a hora de saida + tolerancia, sao maiores que a entrada + tolerancia. Pois estmamos testando para
			a primeira taxa a ser gerada. Logo se o paciente saiu antes do prazo de tolerancia, nao sera gerada diaria para o setor.
			ex:	entrada setor 10:40 
				tolerancia = 30 min
				Saida setor = 11:08
			considerando este cenario, nao sera gerada a tx, pois 10:40 + 30 toler = 11:10, logo o paciente saiu as 11:08. Se o mesmo tivesse saido as 11:10 ou 11:11 a taxa seria gerada.
			
			*/
	
			select 	nextval('procedimento_paciente_seq')
			into STRICT	nr_seq_w
			;
				
			--gravar_log_cliente('---->PASSOU PRIMEIRO TESTE, INSERINDO PROCEDIMENTO nr_seq_w='||nr_seq_w);
				
			begin
			insert into procedimento_paciente(
				nr_sequencia,			nr_atendimento,		dt_entrada_unidade,		cd_procedimento,	dt_procedimento,
				cd_convenio,			cd_categoria,		nr_doc_convenio,		ie_tipo_guia,		cd_senha,
				ie_auditoria,			ie_emite_conta,		cd_cgc_prestador,		ie_origem_proced,	nr_seq_exame,
				nr_seq_proc_interno,	qt_procedimento,	cd_setor_atendimento,	nr_seq_atepacu,		nr_seq_cor_exec,
				ie_funcao_medico,		vl_procedimento,	ie_proc_princ_atend,	ie_video,			tx_medico,
				tx_anestesia,			tx_procedimento,	ie_valor_informado,		ie_guia_informada,	cd_situacao_glosa,
				nm_usuario_original,	ds_observacao,		dt_atualizacao,			nm_usuario,			cd_pessoa_fisica,
				cd_medico_executor,		cd_especialidade, 	ie_via_acesso)
			values(
				nr_seq_w,				nr_atendimento_w,		dt_entrada_unidade_w,	cd_procedimento_w,		dt_entrada_unidade_w + (qt_tolerancia_w/1440),
				cd_convenio_w,			cd_categoria_w,			nr_doc_convenio_w,		ie_tipo_guia_w,			cd_senha_w,
				'N',					null,					cd_cgc_prestador_w,		ie_origem_proced_w,		null,
				nr_seq_proc_interno_w,	1,						cd_setor_atendimento_w,	nr_seq_atepacu_atual_w,	null,
				ie_funcao_medico_w,		100,					'N',					'N',					100,
				100,					100,					'N',					'N',					0,
				nm_usuario_p,			ds_observacao_exp_w,	clock_timestamp(),			nm_usuario_p,		cd_profissional_w,
				cd_medico_executor_w,	cd_especialidade_medica_w, ie_via_acesso_w);
			exception
				when others then
				sql_err_w := substr(SQLERRM, 1, 1800);
				insert into W_LOG_TX_TEMPO_SETOR(NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
					values (nextval('w_log_tx_tempo_setor_seq'), clock_timestamp(), nm_usuario_p, clock_timestamp(), nm_usuario_p, sql_err_w, nr_atendimento_w, 2);
				
				--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);		
				goto Proximo;
			end;
			
			CALL consistir_regra_adic_hora(cd_procedimento_w,
						ie_origem_proced_w,
						nr_seq_proc_interno_w,
						cd_convenio_w,
						cd_estabelecimento_w,
						nr_seq_w,
						nr_atendimento_w,
						dt_entrada_unidade_w + (qt_tolerancia_w/1440),
						nm_usuario_p);
				
			begin
			if (ie_classificacao_w in ('1','8')) then 		
				CALL atualiza_preco_procedimento(nr_seq_w, cd_convenio_w, nm_usuario_p);
				CALL gerar_taxa_sala_porte(nr_atendimento_w, dt_entrada_unidade_w, trunc(DT_PARAMETRO_P,'hh'), cd_procedimento_w, nr_seq_w, nm_usuario_p);
			else
				CALL atualiza_preco_servico(nr_seq_w,nm_usuario_p);
			end if;
			exception
				when others then
				sql_err_w := substr(SQLERRM, 1, 1800);
				insert into W_LOG_TX_TEMPO_SETOR(NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
					values (nextval('w_log_tx_tempo_setor_seq'), clock_timestamp(), nm_usuario_p, clock_timestamp(), nm_usuario_p, sql_err_w, nr_atendimento_w, 3);
				
				--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);		
				goto Proximo;
			end;
			
			CALL gerar_autor_regra(nr_atendimento_w, null, nr_seq_w, null, null, nr_seq_proc_interno_w,
					'CP',nm_usuario_p,null,null,null,null,null,null,'','','');
			
		end if; --FIM VERIFICACAO TOLERANCIA
		
		ie_lancamento_w:= 'S';
		
		--gravar_log_cliente('---->VERIFICA REGRA DE QT DE COBRANCA. qt_min_cobranca_w= '||qt_min_cobranca_w);

		
		/*QT MIN COBRANCA CADASTRADA NA REGRA - SE INFORMADO, VERIFICA SE O TEMPO PASSOU. CASO NAO INFORMADO, VER O ELSE*/

		if ( coalesce(qt_min_cobranca_w,0) > 0) then
		
			begin
			/*OBTEM O HORARIO EM QUE A ULTIMA TAXA FOI GERADA - INICIALMENTE CONSIDERA A DATA/HORA DA ENTRADA NO SETOR*/

			if (ie_validar_proc_int_w = 'S') and (nr_seq_proc_interno_w IS NOT NULL AND nr_seq_proc_interno_w::text <> '') then
				select	max(dt_procedimento)
				into STRICT	dt_ultima_taxa_hora_w
				from	procedimento_paciente
				where	nr_atendimento = nr_atendimento_w
				and	nr_seq_proc_interno = nr_seq_proc_interno_w
				and	cd_setor_atendimento = cd_setor_atendimento_w
				and	dt_entrada_unidade >= dt_entrada_unidade_w
				and	coalesce(cd_motivo_exc_conta::text, '') = '';
			else			
				select	max(dt_procedimento)
				into STRICT	dt_ultima_taxa_hora_w
				from	procedimento_paciente
				where	nr_atendimento = nr_atendimento_w
				and	cd_procedimento = cd_procedimento_w
				and	ie_origem_proced = ie_origem_proced_w
				and	cd_setor_atendimento = cd_setor_atendimento_w
				and	dt_entrada_unidade >= dt_entrada_unidade_w
				and	coalesce(cd_motivo_exc_conta::text, '') = '';
			end if;
			
			exception
				when others then
					dt_ultima_taxa_hora_w:= dt_entrada_unidade_w;					
			end;
			
			if ( coalesce(dt_ultima_taxa_hora_w::text, '') = '') THEN /*SE NAO EXISTE TAXA GERADA*/
				
				dt_ultima_taxa_hora_w := dt_entrada_unidade_w + (qt_mincobr_tolerancia_w/1440); /* tolerancia de cobranca*/

				
				--Se a data de entrada no setor, E menor do que a data de inicio de vigencia,

				-- o lancamento deve ser feito a partir da data de inicio da vigencia
				if (dt_ultima_taxa_hora_w < coalesce(dt_inicio_vigencia_w,dt_ultima_taxa_hora_w)) then
					dt_ultima_taxa_hora_w := dt_inicio_vigencia_w + (qt_mincobr_tolerancia_w/1440); /* tolerancia de cobranca*/
				end if;				
			end if;
			
			ie_lancamento_w:= 'S';
			
			if (ie_limite_w = 'S') then --CHECKBOX Cobrar apenas 1x por passagem de setor (Nao recomendado)
				
				/*VERIFICA SE DEVE GERAR TAXA POR PASSAGEM DE UNIDADE*/

				if ( coalesce(ie_considera_regra_unidade_w,'N')= 'S') then
					if (ie_validar_proc_int_w = 'S') and (nr_seq_proc_interno_w IS NOT NULL AND nr_seq_proc_interno_w::text <> '') then
						select	count(1)
						into STRICT	qt_taxa_unidade_w
						from	procedimento_paciente a
						where	a.nr_seq_atepacu = nr_seq_atepacu_atual_w
						and	a.nr_atendimento = nr_atendimento_w
						and	a.nr_seq_proc_interno = nr_seq_proc_interno_w
						and	coalesce(a.cd_motivo_exc_conta::text, '') = '';
					else
						select	count(1)
						into STRICT	qt_taxa_unidade_w
						from	procedimento_paciente a
						where	a.nr_seq_atepacu = nr_seq_atepacu_atual_w
						and	a.nr_atendimento = nr_atendimento_w
						and	a.cd_procedimento = cd_procedimento_w
						and	a.ie_origem_proced = ie_origem_proced_w
						and	coalesce(a.cd_motivo_exc_conta::text, '') = '';
					end if;

						
					if ( qt_taxa_unidade_w >0) then
						ie_lancamento_w := 'N';
					end if;
				else								
					if (dt_ultima_taxa_hora_w > dt_entrada_unidade_w) then -- se tem taxa gerada posterior a data de entrada na unidade nao deve lancar
						ie_lancamento_w:= 'N';
					end if;
				end if;				
			end if;
			
			/*if	(dt_entrada_unidade_w = dt_ultima_taxa_hora_w - (qt_tolerancia_w/1440)) then
				dt_ultima_taxa_hora_w:= dt_ultima_taxa_hora_w - (qt_tolerancia_w/1440);
			end if;*/

			
			-- gravar_log_cliente('------->ANTES SEGUNDO TESTE----> ');

			-- gravar_log_cliente(

			-- 'ie_forma_geracao_w= '||ie_forma_geracao_w

			-- ||';dt_ultima_taxa_hora_w='||to_char(dt_ultima_taxa_hora_w,'dd/MM/yyyy hh24:mi:ss')

			-- ||';qt_min_cobranca_w='||qt_min_cobranca_w

			-- ||';dt_saida_unidade_w='||to_char(dt_saida_unidade_w,'dd/MM/yyyy hh24:mi:ss')

			-- ||';ie_lancamento_w='||ie_lancamento_w

			-- ||';((dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440))= '||to_char((dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440)),'dd/MM/yyyy hh24:mi:ss')

			-- ||'; trunc(DT_PARAMETRO_P,hh)='||to_char(trunc(DT_PARAMETRO_P,'hh'),'dd/MM/yyyy hh24:mi:ss'));


			
			/*VERIFICA SE MIN DE COBRANCA FOI ATENDIDA, CASO SIM, ENTAO GERA TAXA*/

			
			RAISE NOTICE 'dt_ultima_taxa_hora_w= %', to_char(dt_ultima_taxa_hora_w,'dd/mm/yyyy hh24:mi:ss');
			RAISE NOTICE 'qt_min_cobranca_w= %', qt_min_cobranca_w;
			RAISE NOTICE 'qt_min_calc %', (qt_min_cobranca_w/1440);
			RAISE NOTICE 'dt_param_orig_p= %', to_char(DT_PARAMETRO_P,'dd/mm/yyyy hh24:mi:ss');
			RAISE NOTICE 'dt_param_p= %', to_char(trunc(DT_PARAMETRO_P,'hh'),'dd/mm/yyyy hh24:mi:ss');
			RAISE NOTICE 'ie_lancamento_w= %', ie_lancamento_w;
			
			if	(						
					(((dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440)) <  trunc(DT_PARAMETRO_P,'hh')) and (qt_min_cobranca_w >= 60))
					or --inicio alteracao
					(
						(ie_forma_geracao_w = 'S') and --CHECKBOX "Gerar 1' taxa setor c/ base na dt entrada + min tolerancia"
						(nvl(dt_saida_unidade_w,trunc(DT_PARAMETRO_P,'hh')) > trunc(DT_PARAMETRO_P,'hh')) and --1
						(dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440)) <= dt_saida_unidade_w
					)
				) and --2				
				(ie_lancamento_w = 'S') then
				begin
					/*	
					1 - Testar se o paciente ja saiu da unidade
					2 -  Se a soma da ultima taxa gerada + minutos cobranca for menor que a saida da unidade, entao deve gerar tx.
					Ex:   ultima tx 11:35 + 60 minutos cobranca = 12:35, logo minha saida do setor foi as 12:40, entao devo gerar uma ultima tx para o setor.
					
					*/
				
					select 	procedimento_paciente_seq.NextVal
					into	nr_seq_w
					from 	dual;
					
					--gravar_log_cliente('---->PASSOU TESTE 2 -> INSERINDO PROCEDIMENTO. SEQ='||nr_seq_w);
					
					begin
					insert into procedimento_paciente( 
						nr_sequencia,			nr_atendimento,		dt_entrada_unidade,			cd_procedimento,	dt_procedimento,
						cd_convenio,			cd_categoria,		nr_doc_convenio,			ie_tipo_guia,		cd_senha,
						ie_auditoria,			ie_emite_conta,		cd_cgc_prestador,			ie_origem_proced,	nr_seq_exame,
						nr_seq_proc_interno,	qt_procedimento,	cd_setor_atendimento,		nr_seq_atepacu,		nr_seq_cor_exec,
						ie_funcao_medico,		vl_procedimento,	ie_proc_princ_atend,		ie_video,			tx_medico,
						tx_anestesia,			tx_procedimento,	ie_valor_informado,			ie_guia_informada,	cd_situacao_glosa,
						nm_usuario_original,	ds_observacao,		dt_atualizacao,				nm_usuario,			cd_pessoa_fisica,
						cd_medico_executor,		cd_especialidade,	ie_via_acesso)
					values( 
						nr_seq_w,				nr_atendimento_w,	dt_entrada_unidade_w,		cd_procedimento_w,		dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440),
						cd_convenio_w,			cd_categoria_w,		nr_doc_convenio_w,			ie_tipo_guia_w,			cd_senha_w,
						'N',					null,				cd_cgc_prestador_w,			ie_origem_proced_w	,	null,
						nr_seq_proc_interno_w,	1,					cd_setor_atendimento_w,		nr_seq_atepacu_atual_w,	null,
						ie_funcao_medico_w,		100,				'N',						'N',					100,
						100,					100,				'N',						'N',					0,
						nm_usuario_p,			ds_observacao_exp_w	,sysdate,					nm_usuario_p,			cd_profissional_w,
						cd_medico_executor_w,	cd_especialidade_medica_w, 						ie_via_acesso_w);
					exception
						when others then
							sql_err_w := substr(SQLERRM, 1, 1800);
							insert into W_LOG_TX_TEMPO_SETOR (NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
								values (W_LOG_TX_TEMPO_SETOR_seq.NextVal, sysdate, nm_usuario_p, sysdate, nm_usuario_p, sql_err_w, nr_atendimento_w, 4);
								
							--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);		
							goto Proximo;
					end;
					
					consistir_regra_adic_hora(cd_procedimento_w,
								ie_origem_proced_w,
								nr_seq_proc_interno_w,
								cd_convenio_w,
								cd_estabelecimento_w,
								nr_seq_w,
								nr_atendimento_w,
								dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440),
								nm_usuario_p);
					
						
					begin
					if	(ie_classificacao_w in ('1','8')) then 		
						atualiza_preco_procedimento(nr_seq_w, cd_convenio_w, nm_usuario_p);
						gerar_taxa_sala_porte(nr_atendimento_w, dt_entrada_unidade_w, trunc(DT_PARAMETRO_P,'hh'), cd_procedimento_w, nr_seq_w, nm_usuario_p);
					else
						atualiza_preco_servico(nr_seq_w,nm_usuario_p);
					end if;
					exception
						when others then
						sql_err_w := substr(SQLERRM, 1, 1800);
						insert into W_LOG_TX_TEMPO_SETOR (NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
							values (W_LOG_TX_TEMPO_SETOR_seq.NextVal, sysdate, nm_usuario_p, sysdate, nm_usuario_p, sql_err_w, nr_atendimento_w, 5);
							
						--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);	
						goto Proximo;
					end;
					
					gerar_autor_regra(nr_atendimento_w, null, nr_seq_w, null, null, nr_seq_proc_interno_w,
						'CP',nm_usuario_p,null,null,null,null,null,null,'','','');
				end;
			elsif 	(((dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440)) <  trunc(DT_PARAMETRO_P+(qt_min_cobranca_w/1440),'hh')) and (qt_min_cobranca_w < 60)) and 
				(ie_lancamento_w = 'S') then
				begin
					while ((dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440)) <  nvl(dt_saida_unidade_w,trunc(DT_PARAMETRO_P+(qt_min_cobranca_w/1440),'hh'))) loop
					begin
					/*	
					1 - Testar se o paciente ja saiu da unidade
					2 -  Se a soma da ultima taxa gerada + minutos cobranca for menor que a saida da unidade, entao deve gerar tx.
					Ex:   ultima tx 11:35 + 60 minutos cobranca = 12:35, logo minha saida do setor foi as 12:40, entao devo gerar uma ultima tx para o setor.
					
					*/
				
					select 	procedimento_paciente_seq.NextVal
					into	nr_seq_w
					from 	dual;
					
					--gravar_log_cliente('---->PASSOU TESTE 2 -> INSERINDO PROCEDIMENTO. SEQ='||nr_seq_w);
					
					begin
					insert into procedimento_paciente( 
						nr_sequencia,			nr_atendimento,		dt_entrada_unidade,			cd_procedimento,	dt_procedimento,
						cd_convenio,			cd_categoria,		nr_doc_convenio,			ie_tipo_guia,		cd_senha,
						ie_auditoria,			ie_emite_conta,		cd_cgc_prestador,			ie_origem_proced,	nr_seq_exame,
						nr_seq_proc_interno,	qt_procedimento,	cd_setor_atendimento,		nr_seq_atepacu,		nr_seq_cor_exec,
						ie_funcao_medico,		vl_procedimento,	ie_proc_princ_atend,		ie_video,			tx_medico,
						tx_anestesia,			tx_procedimento,	ie_valor_informado,			ie_guia_informada,	cd_situacao_glosa,
						nm_usuario_original,	ds_observacao,		dt_atualizacao,				nm_usuario,			cd_pessoa_fisica,
						cd_medico_executor,		cd_especialidade,	ie_via_acesso)
					values( 
						nr_seq_w,			nr_atendimento_w,	dt_entrada_unidade_w,		cd_procedimento_w,		dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440),
						cd_convenio_w,			cd_categoria_w,		nr_doc_convenio_w,			ie_tipo_guia_w,			cd_senha_w,
						'N',				null,				cd_cgc_prestador_w,			ie_origem_proced_w	,	null,
						nr_seq_proc_interno_w,	1,	cd_setor_atendimento_w,		nr_seq_atepacu_atual_w,	null,
						ie_funcao_medico_w,		100,				'N',						'N',					100,
						100,				100,				'N',						'N',					0,
						nm_usuario_p,			ds_observacao_exp_w	,sysdate,					nm_usuario_p,			cd_profissional_w,
						cd_medico_executor_w,	cd_especialidade_medica_w, 						ie_via_acesso_w);
					exception
						when others then
							sql_err_w := substr(SQLERRM, 1, 1800);
							insert into W_LOG_TX_TEMPO_SETOR (NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
								values (W_LOG_TX_TEMPO_SETOR_seq.NextVal, sysdate, nm_usuario_p, sysdate, nm_usuario_p, sql_err_w, nr_atendimento_w, 4);
								
							--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);		
							goto Proximo;
					end;
					
					consistir_regra_adic_hora(cd_procedimento_w,
								ie_origem_proced_w,
								nr_seq_proc_interno_w,
								cd_convenio_w,
								cd_estabelecimento_w,
								nr_seq_w,
								nr_atendimento_w,
								dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440),
								nm_usuario_p);
					
						
					begin
					if	(ie_classificacao_w in ('1','8')) then 		
						atualiza_preco_procedimento(nr_seq_w, cd_convenio_w, nm_usuario_p);
						gerar_taxa_sala_porte(nr_atendimento_w, dt_entrada_unidade_w, trunc(DT_PARAMETRO_P,'hh'), cd_procedimento_w, nr_seq_w, nm_usuario_p);
					else
						atualiza_preco_servico(nr_seq_w,nm_usuario_p);
					end if;
					exception
						when others then
						sql_err_w := substr(SQLERRM, 1, 1800);
						insert into W_LOG_TX_TEMPO_SETOR (NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
							values (W_LOG_TX_TEMPO_SETOR_seq.NextVal, sysdate, nm_usuario_p, sysdate, nm_usuario_p, sql_err_w, nr_atendimento_w, 5);
							
						--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);	
						goto Proximo;
					end;
					
					gerar_autor_regra(nr_atendimento_w, null, nr_seq_w, null, null, nr_seq_proc_interno_w,
						'CP',nm_usuario_p,null,null,null,null,null,null,'','','');
					
					
					dt_ultima_taxa_hora_w := (dt_ultima_taxa_hora_w + (qt_min_cobranca_w/1440));	
					end;
					end loop;
				end;
			end if;
		else
			--gravar_log_cliente('---->VERIFICANDO SE EXISTE ESTA TAXA NESTE HORARIO. qt_tx_hora_w='||qt_tx_hora_w);
			
			if	(ie_validar_proc_int_w = 'S') and
				(nr_seq_proc_interno_w is not null) then
				select	count(1)
				into	qt_tx_hora_w
				from	procedimento_paciente
				where	nr_atendimento = nr_atendimento_w
				and	nr_seq_proc_interno = nr_seq_proc_interno_w
				and	cd_setor_atendimento = cd_setor_atendimento_w
				and	cd_motivo_exc_conta is null
				and	trunc(dt_procedimento,'hh') = trunc(DT_PARAMETRO_P,'hh'); --se tem taxa gerada na mesma hora
			else
				select	count(1)
				into	qt_tx_hora_w
				from	procedimento_paciente
				where	nr_atendimento = nr_atendimento_w
				and	cd_procedimento = cd_procedimento_w
				and	ie_origem_proced = ie_origem_proced_w
				and	cd_setor_atendimento = cd_setor_atendimento_w
				and	cd_motivo_exc_conta is null
				and	trunc(dt_procedimento,'hh') = trunc(DT_PARAMETRO_P,'hh'); --se tem taxa gerada na mesma hora
			end if;
			
			
			/* SE NAO TEM QT MIN COBRANCA CADASTRADO, VERIFICA SE EXISTE TAXA NO HORARIO. CASO NAO TENHA, GERA TAXA- NORMALMENTE SERA DE HORA EM HORA */

			if	(qt_tx_hora_w = 0) then
				
				begin
					/*OBTEM O HORARIO EM QUE A ULTIMA TAXA FOI GERADA - INICIALMENTE CONSIDERA A DATA/HORA DA ENTRADA NO SETOR*/

					if	(ie_validar_proc_int_w = 'S') and
						(nr_seq_proc_interno_w is not null) then
						select	max(dt_procedimento)
						into	dt_ultima_taxa_hora_w
						from	procedimento_paciente
						where	nr_atendimento = nr_atendimento_w
						and	nr_seq_proc_interno = nr_seq_proc_interno_w
						and	cd_setor_atendimento = cd_setor_atendimento_w
						and	cd_motivo_exc_conta is null
						and	dt_entrada_unidade >= dt_entrada_unidade_w
						and	((ie_forma_geracao_w = 'N') or (dt_entrada_unidade <> dt_procedimento));
					else
						select	max(dt_procedimento)
						into	dt_ultima_taxa_hora_w
						from	procedimento_paciente
						where	nr_atendimento = nr_atendimento_w
						and	cd_procedimento = cd_procedimento_w
						and	ie_origem_proced = ie_origem_proced_w
						and	cd_setor_atendimento = cd_setor_atendimento_w
						and	cd_motivo_exc_conta is null
						and	dt_entrada_unidade >= dt_entrada_unidade_w
						and	((ie_forma_geracao_w = 'N') or (dt_entrada_unidade <> dt_procedimento));
					end if;

				exception
					when others then
					dt_ultima_taxa_hora_w:= dt_entrada_unidade_w;					
				end;
						
				
				if (dt_ultima_taxa_hora_w is null) THEN /*SE AINDA NAO EXISTE TAXA GERADA, PEGA A ENTRADA DO PACIENTE*/
								
					dt_ultima_taxa_hora_w := dt_entrada_unidade_w + (qt_mincobr_tolerancia_w/1440); /* tolerancia de cobranca*/
					dt_consiste_tolerancia_w := dt_entrada_unidade_w +  (qt_mincobr_tolerancia_w/1440);
					
					--Se a data de entrada no setor, e menor do que a data de inicio de vigencia,

					-- o lancamento deve ser feito a partir da data de inicio da vigencia
					if (dt_ultima_taxa_hora_w < nvl(dt_inicio_vigencia_w,dt_ultima_taxa_hora_w)) then
						dt_ultima_taxa_hora_w := dt_inicio_vigencia_w + (qt_mincobr_tolerancia_w/1440); /* tolerancia de cobranca*/
						dt_consiste_tolerancia_w := dt_inicio_vigencia_w +  (qt_mincobr_tolerancia_w/1440);
					end if;
					
					
				else					
					dt_ultima_taxa_hora_w := (dt_ultima_taxa_hora_w + 60/1440);/*INCREMENTA 1 HORA QUE E O INTERVALO QUE A JOB RODA*/
					
					dt_consiste_tolerancia_w := dt_ultima_taxa_hora_w;
				end if;
	
				/*CASO NAO TENHA MIN DE TOLERANCIA DE COBRANCA, OBTEM A DATA DA JOB(PADRAO), SENAO PEGA A DATA DA TAXA + TOLERANCIA DE COBRANCA*/

				begin
					select 	decode(qt_mincobr_tolerancia_w,0,trunc(DT_PARAMETRO_P,'hh'),dt_ultima_taxa_hora_w)
					into 	dt_taxa_w
					from 	dual;
				exception
				when others then
					dt_taxa_w:= trunc(DT_PARAMETRO_P,'hh');	
				end;
								

				ie_lancamento_w:= 'S';
				
				if	(ie_limite_w = 'S') then --CHECKBOX Cobrar apenas 1x por passagem de setor (Nao recomendado)
					/*VERIFICA SE DEVE GERAR TAXA POR PASSAGEM DE UNIDADE*/

					if ( nvl(ie_considera_regra_unidade_w,'N')= 'S') then
						if	(ie_validar_proc_int_w = 'S') and
							(nr_seq_proc_interno_w is not null) then
							select	count(1)
							into	qt_taxa_unidade_w
							from	procedimento_paciente a
							where	nr_atendimento = nr_atendimento_w
							and	nr_seq_proc_interno = nr_seq_proc_interno_w
							and	cd_setor_atendimento = cd_setor_atendimento_w
							and	cd_motivo_exc_conta is null;
						else
							select	count(1)
							into	qt_taxa_unidade_w
							from	procedimento_paciente a
							where	nr_atendimento = nr_atendimento_w
							and	cd_procedimento = cd_procedimento_w
							and	ie_origem_proced = ie_origem_proced_w
							and	cd_setor_atendimento = cd_setor_atendimento_w
							and	cd_motivo_exc_conta is null;
						end if;

							
						if ( qt_taxa_unidade_w >0) then
							ie_lancamento_w := 'N';
						end if;
					else
						if (dt_ultima_taxa_hora_w > dt_entrada_unidade_w) then -- se tem taxa gerada posterior a data de entrada na unidade nao deve lancar
							ie_lancamento_w:= 'N';
						end if;
					end if;						
				end if;
				
				/*SE EXISTIR TOLERANCIA DE COBRANCA INFORMADA NA REGRA, VERIFICA SE FOI RESPEITADO O TEMPO PARA TAXA SER INSERIDA */
				
				 if (qt_mincobr_tolerancia_w > 0) and (dt_consiste_tolerancia_w >=  trunc(DT_PARAMETRO_P,'hh') ) then
					ie_lancamento_w:= 'N';
				 end if;
					
				if (ie_lancamento_w = 'S') then
				
					-- Cobranca da Taxa Hora cheia
					select 	procedimento_paciente_seq.NextVal
					into	nr_sequencia_w
					from 	dual;
					
					--gravar_log_cliente('---->PASSOU TESTE 3(SEM MIN COBRANCA INFORMADO) -> INSERINDO PROCEDIMENTO. nr_sequencia_w='||nr_sequencia_w);
					
					begin
					insert into procedimento_paciente( 
							nr_sequencia,			nr_atendimento,		dt_entrada_unidade,		cd_procedimento,	dt_procedimento,
							cd_convenio,			cd_categoria,		nr_doc_convenio,		ie_tipo_guia,		cd_senha,
							ie_auditoria,			ie_emite_conta,		cd_cgc_prestador,		ie_origem_proced,	nr_seq_exame,
							nr_seq_proc_interno,	qt_procedimento,	cd_setor_atendimento,	nr_seq_atepacu,		nr_seq_cor_exec,
							ie_funcao_medico,		vl_procedimento,	ie_proc_princ_atend,	ie_video,			tx_medico,
							tx_anestesia,			tx_procedimento,	ie_valor_informado,		ie_guia_informada,	cd_situacao_glosa,
							nm_usuario_original,	ds_observacao,		dt_atualizacao,			nm_usuario,			cd_pessoa_fisica,
							cd_medico_executor,		cd_especialidade,	ie_via_acesso)
						values( 
							nr_sequencia_w,			nr_atendimento_w,	dt_entrada_unidade_w,		cd_procedimento_w,		dt_taxa_w,
							cd_convenio_w,			cd_categoria_w,		nr_doc_convenio_w,			ie_tipo_guia_w,			cd_senha_w,
							'N',					null,				cd_cgc_prestador_w,			ie_origem_proced_w,		null,
							nr_seq_proc_interno_w,	1,					cd_setor_atendimento_w,		nr_seq_atepacu_atual_w,	null,
							ie_funcao_medico_w,		100,				'N',						'N',					100,
							100,					100,				'N',						'N',					0,
							nm_usuario_p,			ds_observacao_exp_w	,sysdate,					nm_usuario_p,			cd_profissional_w,
							cd_medico_executor_w,	cd_especialidade_medica_w, ie_via_acesso_w);
					exception
						when others then
						sql_err_w := substr(SQLERRM, 1, 1800);
						insert into W_LOG_TX_TEMPO_SETOR (NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
							values (W_LOG_TX_TEMPO_SETOR_seq.NextVal, sysdate, nm_usuario_p, sysdate, nm_usuario_p, sql_err_w, nr_atendimento_w, 6);
							
						--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);		
						goto Proximo;
					end;
					
					commit;	
					
					consistir_regra_adic_hora(cd_procedimento_w,
								ie_origem_proced_w,
								nr_seq_proc_interno_w,
								cd_convenio_w,
								cd_estabelecimento_w,
								nr_sequencia_w,
								nr_atendimento_w,
								trunc(DT_PARAMETRO_P,'hh'),
								nm_usuario_p);

					begin
					if	(ie_classificacao_w in ('1','8')) then 		
						atualiza_preco_procedimento(nr_sequencia_w, cd_convenio_w, nm_usuario_p);
						gerar_taxa_sala_porte(nr_atendimento_w, dt_entrada_unidade_w, trunc(DT_PARAMETRO_P,'hh'), cd_procedimento_w, nr_sequencia_w, nm_usuario_p);
					else
						atualiza_preco_servico(nr_sequencia_w,nm_usuario_p);
					end if;
					exception
						when others then
						sql_err_w := substr(SQLERRM, 1, 1800);
						insert into W_LOG_TX_TEMPO_SETOR (NR_SEQUENCIA, DT_ATUALIZACAO, NM_USUARIO, DT_ATUALIZACAO_NREC, NM_USUARIO_NREC, DS_LOG, NR_ATENDIMENTO, IE_ORDEM)
							values (W_LOG_TX_TEMPO_SETOR_seq.NextVal, sysdate, nm_usuario_p, sysdate, nm_usuario_p, sql_err_w, nr_atendimento_w, 7);
							
						--gravar_log_cliente('ERRO-->nr_seq_regra_tx_w='||nr_seq_regra_tx_w);		
						goto Proximo;
					end;
					
					gerar_autor_regra(nr_atendimento_w, null, nr_sequencia_w, null, null, nr_seq_proc_interno_w,
						'CP',nm_usuario_p,null,null,null,null,null,null,'','','');
				
				end if;
				
			end if;
		
		end if;
	
		<<Proximo>>
			cd_procedimento_w:= 0;	
			
		end;
	end loop;
	close C02;
	
	END;
END LOOP;
CLOSE C00;

--gravar_log_cliente( 'FIM');
commit;

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE gerar_tx_tempo_setor (DT_PARAMETRO_P timestamp, NM_USUARIO_P text, NR_ATENDIMENTO_P bigint DEFAULT 0) FROM PUBLIC;

