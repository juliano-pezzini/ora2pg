-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_74_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) AS $body$
DECLARE



_ora2pg_r RECORD;
type tb_valor is table of bigint index by varchar(500);
type tb_itens is table of bigint index by varchar(500);

tb_seq_selecao_w		pls_util_cta_pck.t_number_table;
tb_valido_w			pls_util_cta_pck.t_varchar2_table_1;
tb_observacao_w			pls_util_cta_pck.t_varchar2_table_4000;

tb_valor_w		tb_valor;
tb_proc_w		tb_itens;
tb_mat_w		tb_itens;
tb_conta_w		tb_itens;

ds_agrupamento_w	varchar(500);
ds_agrup_old_w		varchar(500);

cd_guia_referencia_w	pls_oc_cta_selecao_ocor_v.cd_guia_referencia%type;
nr_seq_segurado_w	pls_oc_cta_selecao_ocor_v.nr_seq_segurado%type;
nr_seq_conta_w		pls_oc_cta_selecao_ocor_v.nr_seq_conta%type;
vl_item_w		pls_conta_proc_ocor_v.vl_procedimento%type;
vl_Item_tst_w		pls_conta_proc_ocor_v.vl_procedimento%type;


dados_selecao_w		pls_tipos_ocor_pck.dados_table_selecao_ocor;
i			integer;

qt_procedimento		integer;
qt_material		integer;
ie_realiza_validacao	varchar(1);

ds_observacao_w	varchar(255);

-- Informacoes da regra de validacao
cs_val CURSOR(nr_seq_oc_cta_comb_pc	pls_oc_cta_combinada.nr_sequencia%type) FOR
	SELECT	a.ie_incidencia,
		a.ie_valor_base,
		a.ie_considera_tx_intercambio,
		a.vl_base,
		a.ie_origem_proced,
		a.cd_procedimento,
		a.nr_seq_material,
		a.ie_considera_referencia,
		coalesce(a.ie_desconsidera_opme_pacote, 'N') ie_desconsidera_opme_pacote
	from	pls_oc_cta_val_vl_atend a
	where	a.nr_seq_oc_cta_comb = nr_seq_oc_cta_comb_pc;
	
-- Monta o cenario da selecao para o tipo de incidencia cadastrado na regra
cs_agrup CURSOR(nr_id_transacao_pc	pls_oc_cta_selecao_imp.nr_id_transacao%type,
		ie_origem_proced_pc		pls_conta_proc_imp.ie_origem_proced_conv%type,
		cd_procedimento_pc		pls_conta_proc_ocor_v.cd_procedimento%type,
		nr_seq_material_pc		pls_conta_mat_ocor_v.nr_seq_material%type,
		ie_considera_referencia_pc	 pls_oc_cta_val_vl_atend.ie_considera_referencia%type,
		ie_desconsidera_opme_pacote_pc	 pls_oc_cta_val_vl_atend.ie_desconsidera_opme_pacote%type) FOR
	SELECT	a.nr_seq_segurado,
		a.cd_guia_referencia,
		a.nr_seq_conta,
		a.nr_seq_conta_proc,
		a.nr_seq_conta_mat,
		coalesce(b.ie_filtro_proc, 'N') ie_filtro_proc,
		coalesce(b.ie_filtro_mat, 'N') ie_filtro_mat,
		c.vl_total vl_itens,
		c.ie_origem_proced_conv ie_origem_proced,
		c.cd_procedimento_conv cd_procedimento,
		null nr_seq_material,
		a.nr_sequencia,
		c.ie_tipo_despesa_conv ie_tipo_despesa_proc,
		null ie_tipo_despesa_mat,
		d.nr_seq_guia_conv,
		d.cd_estabelecimento		
	FROM pls_conta_imp d, pls_conta_proc_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_pc and a.ie_valido		= 'S'  and c.nr_sequencia 		= a.nr_seq_conta_proc and d.nr_sequencia 		= c.nr_seq_conta
	
union all

	SELECT	a.nr_seq_segurado,
		a.cd_guia_referencia,
		a.nr_seq_conta,
		a.nr_seq_conta_proc,
		a.nr_seq_conta_mat,
		coalesce(b.ie_filtro_proc, 'N') ie_filtro_proc,
		coalesce(b.ie_filtro_mat, 'N') ie_filtro_mat,
		c.vl_total vl_itens,
		null ie_origem_proced,
		null cd_procedimento,
		c.nr_seq_material_conv nr_seq_material,
		a.nr_sequencia,
		null ie_tipo_despesa_proc,
		c.ie_tipo_despesa_conv	ie_tipo_despesa_mat,
		d.nr_seq_guia_conv,
		d.cd_estabelecimento		
	FROM pls_conta_imp d, pls_conta_mat_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_pc and a.ie_valido		= 'S'  and c.nr_sequencia 		= a.nr_seq_conta_mat and d.nr_sequencia 		= c.nr_seq_conta
	 
union all

	select		a.nr_seq_segurado,
			a.cd_guia_referencia,
			a.nr_seq_conta,
			a.nr_seq_conta_proc,
			a.nr_seq_conta_mat,
			coalesce(b.ie_filtro_proc, 'N') ie_filtro_proc,
			coalesce(b.ie_filtro_mat, 'N') ie_filtro_mat,
			(coalesce((select sum(case when(ie_considera_referencia_pc = 'N') and (ie_origem_proced_pc = proc.ie_origem_proced_conv) and (cd_procedimento_pc = proc.cd_procedimento_conv) then 0
						else 	proc.vl_total
					end)
			from	 pls_conta_proc_imp proc
			where	 proc.nr_seq_conta = c.nr_sequencia),0)) vl_itens,		
			null ie_origem_proced,
			null cd_procedimento,
			null nr_seq_material,
			a.nr_sequencia,
			null ie_tipo_despesa_proc,
			null ie_tipo_despesa_mat,
			c.nr_seq_guia_conv,
			c.cd_estabelecimento
	FROM pls_conta_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_pc and a.ie_valido		= 'S' and coalesce(a.nr_seq_conta_proc::text, '') = '' and coalesce(a.nr_seq_conta_mat::text, '') = ''  and c.nr_sequencia 		= a.nr_seq_conta and ie_desconsidera_opme_pacote_pc = 'N'
	 
union all

	select		a.nr_seq_segurado,
			a.cd_guia_referencia,
			a.nr_seq_conta,
			a.nr_seq_conta_proc,
			null nr_seq_conta_mat,
			coalesce(b.ie_filtro_proc, 'N') ie_filtro_proc,
			coalesce(b.ie_filtro_mat, 'N') ie_filtro_mat,			
			(coalesce((select sum(case when(ie_considera_referencia_pc = 'N') and (ie_origem_proced_pc = proc.ie_origem_proced_conv) and (cd_procedimento_pc = proc.cd_procedimento_conv) then 0
						else 	proc.vl_total
					end)
			from	 pls_conta_proc_imp proc
			where	 proc.nr_seq_conta = c.nr_sequencia),0)) vl_itens,
			d.ie_origem_proced ie_origem_proced,
			d.cd_procedimento cd_procedimento,
			null nr_seq_material,
			a.nr_sequencia,
			d.ie_tipo_despesa ie_tipo_despesa_proc,
			null ie_tipo_despesa_mat,
			c.nr_seq_guia_conv,
			c.cd_estabelecimento
	FROM pls_conta_proc_ocor_v d, pls_conta_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_pc and a.ie_valido		= 'S' and coalesce(a.nr_seq_conta_proc::text, '') = '' and coalesce(a.nr_seq_conta_mat::text, '') = ''  and c.nr_sequencia 		= a.nr_seq_conta and c.nr_sequencia		= d.nr_seq_conta and ie_desconsidera_opme_pacote_pc = 'S'
	 
union all

	select		a.nr_seq_segurado,
			a.cd_guia_referencia,
			a.nr_seq_conta,
			null nr_seq_conta_proc,
			a.nr_seq_conta_mat,
			coalesce(b.ie_filtro_proc, 'N') ie_filtro_proc,
			coalesce(b.ie_filtro_mat, 'N') ie_filtro_mat,			
			(coalesce((select sum(case	when(ie_considera_referencia_pc = 'N') and (nr_seq_material_pc = mat.nr_seq_material_conv) then 0
						else mat.vl_total
					end)
			from	 pls_conta_mat_imp mat
			where	 mat.nr_seq_conta = c.nr_sequencia),0)) vl_itens,
			null  ie_origem_proced,
			null  cd_procedimento,
			d.nr_seq_material,
			a.nr_sequencia,
			null ie_tipo_despesa_proc,
			d.ie_tipo_despesa	ie_tipo_despesa_mat,
			c.nr_seq_guia_conv,
			c.cd_estabelecimento
	FROM pls_conta_mat_ocor_v d, pls_conta_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_pc and a.ie_valido		= 'S' and coalesce(a.nr_seq_conta_proc::text, '') = '' and coalesce(a.nr_seq_conta_mat::text, '') = ''  and c.nr_sequencia 		= a.nr_seq_conta and c.nr_sequencia		= d.nr_seq_conta and ie_desconsidera_opme_pacote_pc = 'S' order by nr_seq_segurado, cd_guia_referencia, nr_seq_conta;
	
-- Obter o saldo restante para o procedimento indicado
c_conta_autor_proc CURSOR(	nr_seq_guia_p		 pls_guia_plano.nr_sequencia%type,
				ie_origem_proced_p	 pls_conta_proc_ocor_v.ie_origem_proced%type,
				cd_procedimento_p	 pls_conta_proc_ocor_v.cd_procedimento%type,
				cd_estabelecimento_p	 estabelecimento.cd_estabelecimento%type) FOR
				
	SELECT	max(conta_autor.qt_saldo)	qt_saldo,
		max(conta_autor.qt_utilizada)	qt_utilizada,
		max(conta_autor.qt_autorizada)	qt_autorizada,
		count(0)			qt_registro
	from	table(pls_conta_autor_pck.obter_dados(nr_seq_guia_p, 'P', cd_estabelecimento_p, ie_origem_proced_p, cd_procedimento_p)) conta_autor;

-- Obter o saldo referente ao material especificado.
c_conta_autor_mat CURSOR(	nr_seq_guia_p		 pls_guia_plano.nr_sequencia%type,
				nr_seq_material_p	 pls_conta_mat_ocor_v.nr_seq_material%type,
				cd_estabelecimento_p	 estabelecimento.cd_estabelecimento%type) FOR
	
	SELECT	max(conta_autor.qt_saldo)	qt_saldo,
		max(conta_autor.qt_utilizada)	qt_utilizada,
		max(conta_autor.qt_autorizada)	qt_autorizada,
		count(0)			qt_registro
	from	table(pls_conta_autor_pck.obter_dados(nr_seq_guia_p, 'M', cd_estabelecimento_p, null, null, nr_seq_material_p)) conta_autor;

-- auxiliar para evitar duplicidade de codigo na hora de gravar os registros, e necessario

-- por que no final do processo temos que verificar o ultimo registro.
procedure gerencia_selecao(	ds_agrupamento_p	ds_agrupamento_w%type,
				ie_verifica_commit_p	boolean,
				ie_atualiza_nulo_p	boolean,
				nr_seq_selecao_p	pls_oc_cta_selecao_imp.nr_Sequencia%type,
				ds_observacao_p		text) is;
BEGIN

-- comeca limpando os valores;.
cd_guia_referencia_w	:= null;
nr_seq_segurado_w	:= null;
nr_seq_conta_w		:= null;

-- verifica se pelo menos o agrupamento e valido.
if (ds_agrupamento_p IS NOT NULL AND ds_agrupamento_p::text <> '') then
	
	-- obter todos os registros da selecao para aquele atendimento para atualizar todos.
	tb_seq_selecao_w(i) := nr_seq_selecao_p;		
	tb_valido_w(i) := 'S';
	tb_observacao_w(i) := ds_observacao_p || campo_mascara_virgula_casas(tb_valor_w(ds_agrupamento_p), 2);
	
	-- se tiver chego na quantidade de commit envia para o banco.
	if (i = pls_cta_consistir_pck.qt_registro_transacao_w or ie_verifica_commit_p = false) then

		--Grava as informacoes na tabela de selecao
		CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w,
								tb_valido_w,
								tb_observacao_w, 
								nr_id_transacao_p, 
								'SEQ');
		--limpa as variaveis
		SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

		-- limpa inclusive o controle de itens que ja foram considerados para nao incomodar.
		tb_valor_w.delete;
		tb_mat_w.delete;
		tb_conta_w.delete;
		tb_proc_w.delete;
			
		i := 0;
	else
		i := i + 1;
	end if;
	
-- Senao verifica se e para atualizar mesmo que o parametro for nulo.
elsif (ie_atualiza_nulo_p) then
		
	--Grava as informacoes na tabela de selecao
	CALL pls_ocor_imp_pck.gerencia_selecao_validacao(	tb_seq_selecao_w,
							tb_valido_w,
							tb_observacao_w, 
							nr_id_transacao_p, 
							'SEQ');
	--limpa as variaveis
	SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;

	-- limpa inclusive o controle de itens que ja foram considerados para nao incomodar.
	tb_valor_w.delete;
	tb_mat_w.delete;
	tb_conta_w.delete;
	tb_proc_w.delete;
end if;

end;

begin
-- So processa dados se tiver regra valida.
if (nr_seq_combinada_p IS NOT NULL AND nr_seq_combinada_p::text <> '') then
	--O atendimento supera o valor maximo permitido pela operadora. Valor total:
	ds_observacao_w:= wheb_mensagem_pck.get_texto(795501) || pls_util_pck.enter_w || wheb_mensagem_pck.get_texto(795502);
	
	
	
	-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
	CALL pls_ocor_imp_pck.atualiza_campo_auxiliar(	'V',
							'N', 
							nr_id_transacao_p, 
							null);
	
	-- Varrer as regras de validacao cadastrada para a ocorrencia
	for rw_val_w in cs_val(nr_seq_combinada_p) loop
	
		-- Testa se deve realizar a validacao desta regra, pois e possivel configurar um procedimento ou material

		-- de referencia na regra, caso isso aconteca, a selecao avaliada deve possuir pelo menos um procedimento ou material

		-- correspondente, caso nao possuam nao devem ser avaliadas.

		
		--limpa as variaveis
		SELECT * FROM pls_ocor_imp_pck.limpar_nested_tables(	tb_seq_selecao_w, tb_valido_w, tb_observacao_w) INTO STRICT _ora2pg_r;
 	tb_seq_selecao_w := _ora2pg_r.tb_nr_seq_selecao_p; tb_valido_w := _ora2pg_r.tb_ie_valido_p; tb_observacao_w := _ora2pg_r.tb_ds_observacao_p;
		
		qt_procedimento := 0;
		qt_material := 0;
		
		-- se tiver procedimento informado, verifica se esta presente em algum item
		if (rw_val_w.cd_procedimento IS NOT NULL AND rw_val_w.cd_procedimento::text <> '') then
			select	count(1)
			into STRICT	qt_procedimento
			FROM pls_conta_proc_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_p and a.ie_valido		= 'S'  and c.nr_seq_conta 		= a.nr_seq_conta and c.cd_procedimento_conv	= rw_val_w.cd_procedimento and c.ie_origem_proced_conv	= rw_val_w.ie_origem_proced;
		end if;
		
		if (rw_val_w.nr_seq_material IS NOT NULL AND rw_val_w.nr_seq_material::text <> '') then
			select	count(1)
			into STRICT	qt_material
			FROM pls_conta_mat_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_p and a.ie_valido		= 'S'  and c.nr_seq_conta 		= a.nr_seq_conta and c.nr_seq_material_conv	= rw_val_w.nr_seq_material;
		end if;
		
		-- Se a regra nao tiver um procedimento ou material informado, a regra e avaliada normalmente.
		ie_realiza_validacao := 'S';
		
		if	((rw_val_w.cd_procedimento IS NOT NULL AND rw_val_w.cd_procedimento::text <> '' AND qt_procedimento > 0) or (coalesce(rw_val_w.cd_procedimento::text, '') = '')) then
			ie_realiza_validacao := 'S';
		else
			ie_realiza_validacao := 'N';
		end if;
		
		-- se validou os procedimento, verifica os materiais
		if (ie_realiza_validacao = 'S') and
			((rw_val_w.nr_seq_material IS NOT NULL AND rw_val_w.nr_seq_material::text <> '' AND qt_material > 0) or (coalesce(rw_val_w.nr_seq_material::text, '') = '')) then
			ie_realiza_validacao := 'S';
		else
			ie_realiza_validacao := 'N';
		end if;
	
		if (ie_realiza_validacao = 'S') then
			-- inicializa o controle
			i := 0; 	
			-- Como na tabela de selecao pode ter varias vezes o mesmo item para cada filtro, e alem disso

			-- dependendo da incidencia da regra, nos filtros por procedimento ou material, sempre sao

			-- considerados procedimentos e materiais por que existe a regra que se a aplicacao

			-- for na conta e tiver excecao por item e este item se encaixar entao a ocorrencia nao e gerada.

			-- Esta validacao em especifico funciona um pouco diferente, pois os filtros serao utilizados para definir

			-- quais itens serao considerados no somatorio total e a excecao de filtros nao deve influenciar na geracao da ocorrencia,

			-- apenas no somatorio total. Por este motivo precisamos ver quem esta na tabela de selecao e o por que  esta la,

			-- e feito um outer join com os filtros para definir se o procedimento ou material foi incluido por conta da regra que ja descrevi acima

			-- ou se foi filtrado mesmo. Se nao for utilizado filtros na ocorrencia, entao ninguem tera filtro informado na tabela de selecao e somente 

			-- a conta estara na tabela de selecao, por isso consideramos o seu valor total.
			for rw_agrup_w	in cs_agrup(	nr_id_transacao_p,
							rw_val_w.ie_origem_proced,
							rw_val_w.cd_procedimento,
							rw_val_w.nr_seq_material,
							rw_val_w.ie_considera_referencia,
							rw_val_w.ie_desconsidera_opme_pacote) loop
					
					-- Para definir a incidencia da validacao, simplesmente definimos o indexador da tabela que guarda o valor total,

					-- como se fosse um group by e aqui estamos definindo quais campos serao considerados

					-- Atendimento
					if (rw_val_w.ie_incidencia = 'A') then
							
						ds_agrupamento_w := rw_agrup_w.nr_seq_segurado || '||' || rw_agrup_w.cd_guia_referencia;
					-- Conta
					else
						ds_agrupamento_w := rw_agrup_w.nr_seq_conta;
					end if;
					
					-- Aqui decidimos qual o valor que deve ser considerado e se deve ser contada a taxa de intercambio ou nao.
					vl_item_w := rw_agrup_w.vl_itens;
										
					-- Verifica se o item esta incluso como referencia, qual o seu tipo e se deve ser considerado.

					
					-- Se a regra possuir um procedimento de referencia que nao deve ser considerado na conta, e o mesmo esta na conta
					if 	((rw_val_w.ie_origem_proced IS NOT NULL AND rw_val_w.ie_origem_proced::text <> '') and (rw_val_w.cd_procedimento IS NOT NULL AND rw_val_w.cd_procedimento::text <> '') and (rw_val_w.ie_considera_referencia = 'N')) and
						(rw_val_w.ie_origem_proced = rw_agrup_w.ie_origem_proced AND rw_val_w.cd_procedimento = rw_agrup_w.cd_procedimento) then
						vl_item_w	:= 0;
					end if;
					
					-- Se a regra possuir um material como referencia, que nao deve ser considerado na conta, o mesmo devera ser zerado
					if 	(rw_val_w.nr_seq_material IS NOT NULL AND rw_val_w.nr_seq_material::text <> '' AND rw_val_w.ie_considera_referencia = 'N') and (rw_val_w.nr_seq_material = rw_agrup_w.nr_seq_material) then
						vl_item_w	:= 0;
					end if;
					
					if (rw_val_w.ie_desconsidera_opme_pacote = 'S' AND rw_agrup_w.ie_tipo_despesa_proc = 4) then
					
						for dados_conta_autor_proc_w in c_conta_autor_proc(rw_agrup_w.nr_seq_guia_conv,
												   rw_agrup_w.ie_origem_proced,
												   rw_agrup_w.cd_procedimento,
												   rw_agrup_w.cd_estabelecimento) loop
							
							-- Se a quantidade utilizada for igual a autorizada, quer dizer que nao deve contar o valor porque o item esta autorizado

							-- Se a quantidade de itens autorizados for maior que a utilizada, deve zerar o valor do item no somatorio porque se enquadra como autorizado

							-- Se o item nao esta na guia entao deve ser considerado como nao autorizado e manter o valor
							if (dados_conta_autor_proc_w.qt_registro = 1) then
								if (dados_conta_autor_proc_w.qt_autorizada >= dados_conta_autor_proc_w.qt_utilizada) then							
									vl_item_w	:= 0;
								elsif (dados_conta_autor_proc_w.qt_saldo >= 0) then
								-- Se a quantidade de itens utilizados for maior que a autorizada, deve contar o valor dos itens utilizados a mais e zerado o que foi autorizado. 

								-- Logo, deve deconsiderar o que tem saldo maior ou igual a zero.
									vl_item_w	:=  0;							
								elsif (dados_conta_autor_proc_w.qt_saldo < 0) then
									vl_item_w	:=  round((dividir(vl_item_w, dados_conta_autor_proc_w.qt_utilizada))::numeric,2);
								end if;
							end if;
						end loop;
					end if;
					
					if (rw_val_w.ie_desconsidera_opme_pacote = 'S' AND rw_agrup_w.ie_tipo_despesa_mat= 7) then
					
						for dados_conta_autor_mat_w in c_conta_autor_mat(rw_agrup_w.nr_seq_guia_conv,
												rw_agrup_w.nr_seq_material,
												rw_agrup_w.cd_estabelecimento) loop

							if (dados_conta_autor_mat_w.qt_registro = 1) then
								if (dados_conta_autor_mat_w.qt_autorizada >= dados_conta_autor_mat_w.qt_utilizada) then										
									vl_item_w	:= 0;
								elsif (dados_conta_autor_mat_w.qt_saldo >= 0) then
									vl_item_w	:=  0;
								elsif (dados_conta_autor_mat_w.qt_saldo < 0) then
									vl_item_w	:=  round((dividir(vl_item_w, dados_conta_autor_mat_w.qt_utilizada))::numeric,2);
								end if;
							end if;
						end loop;
					end if;

					if (vl_item_w	> 0) then
						begin
						if (rw_val_w.cd_procedimento IS NOT NULL AND rw_val_w.cd_procedimento::text <> '') then
			                    select	count(nr_sequencia)
								into STRICT	qt_procedimento
								from (	SELECT c.nr_sequencia
											FROM pls_conta_proc_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_p and a.ie_valido		= 'S'  and c.nr_seq_conta 		= a.nr_seq_conta and c.cd_procedimento_conv	= rw_val_w.cd_procedimento and c.ie_origem_proced_conv	= rw_val_w.ie_origem_proced and rw_val_w.ie_incidencia	= 'A' and a.cd_guia_referencia	= rw_agrup_w.cd_guia_referencia and a.nr_seq_segurado	= rw_agrup_w.nr_seq_segurado
											
union all

											SELECT  c.nr_sequencia
											FROM pls_conta_proc_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_p and a.ie_valido			= 'S'  and c.nr_seq_conta 		= a.nr_seq_conta and c.cd_procedimento_conv	= rw_val_w.cd_procedimento and c.ie_origem_proced_conv	= rw_val_w.ie_origem_proced and rw_val_w.ie_incidencia	= 'C' and a.nr_seq_conta		= rw_agrup_w.nr_seq_conta ) alias3;	
						end if;
		
		                if (rw_val_w.nr_seq_material IS NOT NULL AND rw_val_w.nr_seq_material::text <> '') then
			                select	count(nr_sequencia)
							into STRICT	qt_material
							from (	SELECT 	c.nr_sequencia	
										FROM pls_conta_mat_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_p and a.ie_valido		= 'S'  and c.nr_seq_conta 		= a.nr_seq_conta and c.nr_seq_material_conv	= rw_val_w.nr_seq_material and rw_val_w.ie_incidencia	= 'A' and a.cd_guia_referencia	= rw_agrup_w.cd_guia_referencia and a.nr_seq_segurado	= rw_agrup_w.nr_seq_segurado
										
union all

										SELECT  c.nr_sequencia	
										FROM pls_conta_mat_imp c, pls_oc_cta_selecao_imp a
LEFT OUTER JOIN pls_oc_cta_filtro b ON (a.nr_seq_filtro = b.nr_sequencia)
WHERE a.nr_id_transacao	= nr_id_transacao_p and a.ie_valido		= 'S'  and c.nr_seq_conta 		= a.nr_seq_conta and c.nr_seq_material_conv	= rw_val_w.nr_seq_material and rw_val_w.ie_incidencia	= 'C' and a.nr_seq_conta		= rw_agrup_w.nr_seq_conta ) alias2;
						end if;
						
						if	(rw_val_w.cd_procedimento IS NOT NULL AND rw_val_w.cd_procedimento::text <> '' AND qt_procedimento = 0)  then
							vl_item_w := '0';
						end if;
		
						-- se validou os procedimento, verifica os materiais
						if	(rw_val_w.nr_seq_material IS NOT NULL AND rw_val_w.nr_seq_material::text <> '' AND qt_material = 0) then
								vl_item_w := '0';
						end if;
						end;
					end if;					
					
					
					-- Se o filtro for a nivel de conta, podemos ter procedimentos, materiais e ate mesmo contas como retorno, por isso

					-- devemos apenas tomar cuidado com qual item e e se ele ja nao foi considerado.
					if (rw_agrup_w.ie_filtro_proc = 'N' and rw_agrup_w.ie_filtro_mat = 'N') then
					
						-- Se tiver procedimento considera como procedimento neste caso.
						if (rw_agrup_w.nr_seq_conta_proc IS NOT NULL AND rw_agrup_w.nr_seq_conta_proc::text <> '') then
						
							-- so considera se ainda nao foi contado
							if (not tb_proc_w.exists(rw_agrup_w.nr_seq_conta_proc)) then
								
								if (tb_valor_w.exists(ds_agrupamento_w)) then
								
									tb_valor_w(ds_agrupamento_w) := coalesce(tb_valor_w(ds_agrupamento_w),0) + vl_item_w;
									
								else
								
									tb_valor_w(ds_agrupamento_w) := coalesce(vl_item_w,0);
									
								end if;
								
								tb_proc_w(rw_agrup_w.nr_seq_conta_proc) := coalesce(vl_item_w,0);
							end if;
						-- Se tiver material considera como material.
						elsif (rw_agrup_w.nr_seq_conta_mat IS NOT NULL AND rw_agrup_w.nr_seq_conta_mat::text <> '') then
						
							-- so considera se ainda nao foi contado
							if (not tb_mat_w.exists(rw_agrup_w.nr_seq_conta_mat)) then
								
								if (tb_valor_w.exists(ds_agrupamento_w)) then
								
									tb_valor_w(ds_agrupamento_w) := coalesce(tb_valor_w(ds_agrupamento_w),0) + coalesce(vl_item_w,0);
								else
									tb_valor_w(ds_agrupamento_w) := coalesce(vl_item_w,0);
								end if;
								
								tb_mat_w(rw_agrup_w.nr_seq_conta_mat) := coalesce(vl_item_w,0);
							end if;
						-- se nao o valor e o total da conta.
						else	
							-- so considera se ainda nao foi contado
							if (not tb_conta_w.exists(rw_agrup_w.nr_seq_conta)) then
								
								if (tb_valor_w.exists(ds_agrupamento_w)) then
								
									tb_valor_w(ds_agrupamento_w) := coalesce(tb_valor_w(ds_agrupamento_w),0) + coalesce(vl_item_w,0);
								else
									tb_valor_w(ds_agrupamento_w) := coalesce(vl_item_w,0);
								end if;
								
								tb_conta_w(rw_agrup_w.nr_seq_conta) := coalesce(vl_item_w,0);
							end if;
						end if;
					-- Se for filtor de procedimento so vai contar os procedimentos
					elsif (rw_agrup_w.ie_filtro_proc = 'S' and (rw_agrup_w.nr_seq_conta_proc IS NOT NULL AND rw_agrup_w.nr_seq_conta_proc::text <> '')) then
						
						if (not tb_proc_w.exists(rw_agrup_w.nr_seq_conta_proc)) then
						
							if (tb_valor_w.exists(ds_agrupamento_w)) then
								
								tb_valor_w(ds_agrupamento_w) := coalesce(tb_valor_w(ds_agrupamento_w),0) + coalesce(vl_item_w,0);
							else
								tb_valor_w(ds_agrupamento_w) := coalesce(vl_item_w,0);
							end if;
								
							tb_proc_w(rw_agrup_w.nr_seq_conta_proc) := coalesce(vl_item_w,0);
						end if;
					-- Se for filtro de material so vai considerar os materiais
					elsif (rw_agrup_w.ie_filtro_mat = 'S' and (rw_agrup_w.nr_seq_conta_mat IS NOT NULL AND rw_agrup_w.nr_seq_conta_mat::text <> '')) then
						
						if (not tb_mat_w.exists(rw_agrup_w.nr_seq_conta_mat)) then
							
							if (tb_valor_w.exists(ds_agrupamento_w)) then
								
								tb_valor_w(ds_agrupamento_w) := coalesce(tb_valor_w(ds_agrupamento_w),0) + coalesce(vl_item_w,0);
							else
								tb_valor_w(ds_agrupamento_w) := coalesce(vl_item_w,0);
							end if;
								
							tb_mat_w(rw_agrup_w.nr_seq_conta_mat) := coalesce(vl_item_w,0);
						end if;
					end if;	
					
					-- so faz para o primeiro e quando tiver mudado de valor do agrupamento.
					if (coalesce(ds_agrup_old_w::text, '') = '' or ds_agrup_old_w <> ds_agrupamento_w) then
						
						-- para o primeiro, se for por conta ja tem que verificar.
						if (coalesce(ds_agrup_old_w::text, '') = '') then
							
							ds_agrup_old_w := ds_agrupamento_w;
						end if;
						
						-- se o valor total considerado para este registro for maior que o permitido entao guarda na tabela para manda para o banco depois;
						if (tb_valor_w.exists(ds_agrup_old_w) and tb_valor_w(ds_agrup_old_w) > rw_val_w.vl_base) then
							
							-- realiza os procedimentos necessario para gravar os registros na selecao,
							CALL gerencia_selecao(ds_agrup_old_w, true, false, rw_agrup_w.nr_sequencia, ds_observacao_w);
						end if;
					end if;
					
					ds_agrup_old_w := ds_agrupamento_w;

			end loop; -- dados da tabela de selecao
			
			-- Faz de novo para o utlimo caso se algum tiver sido retornado, isso se faz necessario por que o ultimo nao

			-- entrara na condeicao de mudanca da guia.
			if (ds_agrup_old_w IS NOT NULL AND ds_agrup_old_w::text <> '') then
				
				if (tb_valor_w.exists(ds_agrup_old_w) and tb_valor_w(ds_agrup_old_w) > rw_val_w.vl_base) then
				
					-- realiza os procedimentos necessario para gravar os registros na selecao,

					-- neste caso nao respeitamos a quantidade de commit para pegar tuodo que nao foi commitado ainda,

					-- no maximo vai passar uma linha da quantidade.
					CALL gerencia_selecao(ds_agrup_old_w, false, false, null, null);
				else
					-- Se a guia nao for valida tem que gravar as outras que ja estavam antes na tabela de selecao;
					CALL gerencia_selecao(null, false, true, null, null);
				end if;
			end if;

		end if; -- executa validacao
		
		-- seta os registros que serao validos ou invalidos apos o processamento 
		CALL pls_ocor_imp_pck.atualiza_campo_auxiliar(	'V',
								'N', 
								nr_id_transacao_p, 
								null);
		
		-- SOMENTE PARA ESTA VALIDACAO!!!!!

		-- Tem que limpar esta tabela por que na hora de gravar esta ocorrencia, se um item tiver caido na excecao nao tem problema, pode gerar para a conta.

		-- Como nesta validacao consideramos que as excecoes sao usadas apenas para definir os itens que serao considerados no somatorio total do atendimento

		-- nao podemos desconsiderar uma conta por seu item ter sido considerado em excecao.
		EXECUTE 'truncate table pls_oc_cta_conta_ex';
	end loop; --regras
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_74_imp ( nr_seq_combinada_p pls_oc_cta_combinada.nr_sequencia%type, ie_regra_excecao_p pls_oc_cta_combinada.ie_excecao%type, nr_id_transacao_p pls_oc_cta_selecao_imp.nr_id_transacao%type) FROM PUBLIC;

