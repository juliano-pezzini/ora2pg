-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_53 (( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) is /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Aplicar a validação de duplicidade de itens
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 dados_validacao_w pls_tipos_ocor_pck.dados_val_duplic_item) RETURNS varchar AS $body$
DECLARE

ds_result_w 		varchar(2000);
ds_observacao_w		varchar(20000);
ds_sql_w		varchar(4000);
ds_campo_sql_w		varchar(300);
ds_campo_sql_data_w	varchar(100);
ds_filtro_sql_w		varchar(1000);
dt_procedimento_w	timestamp;
qt_repeticao_w		integer;

nr_seq_conta_ant_w	pls_conta.nr_sequencia%type;

tb_date_w		pls_util_cta_pck.t_date_table;
tb_guia_referencia_w	pls_util_cta_pck.t_varchar2_table_20;
tb_fatura_w		pls_util_cta_pck.t_number_table;
tb_seq_conta_w		pls_util_cta_pck.t_number_table;
tb_seq_conta_proc_w	pls_util_cta_pck.t_number_table;
tb_seq_protocolo_w	pls_util_cta_pck.t_number_table;

bind_sql_valor_w	sql_pck.t_dado_bind;
cursor_w		sql_pck.t_cursor;
BEGIN

ds_result_w := null;

ds_campo_sql_w := '';
if (dados_regra_p.ie_evento = 'IMP') then
	case dados_validacao_p.ie_mesmo_horario
		-- mesma hora
		when 'H' then
			ds_campo_sql_w := 'nvl(proc.dt_procedimento_real_hh, proc.dt_procedimento_imp_hh)';
		-- Mesma hora e minuto
		when 'M' then
			ds_campo_sql_w := 'nvl(proc.dt_procedimento_real_min, proc.dt_procedimento_imp_min)';
		-- Mesma hora e minuto
		when 'S' then
			ds_campo_sql_w := 'nvl(proc.dt_procedimento_real, proc.dt_procedimento_imp)';
		-- verifica somente se é a mesma data
		else
			ds_campo_sql_w := 'nvl(proc.dt_procedimento_real_trunc, proc.dt_procedimento_imp_trunc)';

	end case;
else
	case dados_validacao_p.ie_mesmo_horario
		-- mesma hora
		when 'H' then
			ds_campo_sql_w := 'proc.dt_procedimento_real_hh';
		-- Mesma hora e minuto
		when 'M' then
			ds_campo_sql_w := 'proc.dt_procedimento_real_min';
		-- Mesma hora e minuto
		when 'S' then
			ds_campo_sql_w := 'proc.dt_procedimento_real';
		-- verifica somente se é a mesma data
		else
			ds_campo_sql_w := 'proc.dt_procedimento_real_trunc';
	end case;
end if;

-- campo de data que será utilizado para comparação
ds_campo_sql_data_w := ds_campo_sql_w;

-- busca o valor da data que será utilizado como filtro abaixo na comparação
-- faço dentro desta rotina para centralizar o tratamento para datas
EXECUTE 'select ' || ds_campo_sql_data_w || ' from pls_conta_proc_ocor_v proc where nr_sequencia = :nr_sequencia'
into STRICT dt_procedimento_w
using dados_proc_p.nr_sequencia;


cd_medico_atual_w := pls_obter_dados_medico_exec( dados_proc_p.nr_sequencia, 'P');

-- coloca quebra de linha e vírgula
ds_campo_sql_w := ds_campo_sql_w || ',';
ds_campo_sql_w := ds_campo_sql_w || pls_tipos_ocor_pck.enter_w;

ds_filtro_sql_w := '';

if (dados_validacao_p.ie_mesmo_beneficiario = 'S' and (dados_proc_p.nr_seq_segurado IS NOT NULL AND dados_proc_p.nr_seq_segurado::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.nr_seq_segurado = :nr_seq_segurado ' || pls_tipos_ocor_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_segurado', dados_proc_p.nr_seq_segurado, bind_sql_valor_w);
end if;

if (dados_validacao_p.ie_via_acesso = 'S' and (dados_proc_p.ie_via_acesso IS NOT NULL AND dados_proc_p.ie_via_acesso::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.ie_via_acesso = :ie_via_acesso ' || pls_tipos_ocor_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':ie_via_acesso', dados_proc_p.ie_via_acesso, bind_sql_valor_w);
end if;

if (dados_validacao_p.ie_somente_integrado = 'S' ) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.ie_situacao_protocolo in (''D'',''T'') ' || pls_tipos_ocor_pck.enter_w;
end if;

if (dados_validacao_p.ie_desconsidera_item_glosado = 'S') then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.ie_glosa = ''N'' ' || pls_tipos_ocor_pck.enter_w;
end if;

if (dados_regra_p.ie_evento = 'IMP') then
	if (dados_proc_p.nr_seq_prestador_exec_imp_ref IS NOT NULL AND dados_proc_p.nr_seq_prestador_exec_imp_ref::text <> '') then
		ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.nr_seq_prestador_exec_imp_ref = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w;
     		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_proc_p.nr_seq_prestador_exec_imp_ref, bind_sql_valor_w);
	end if;
	--Em caso de importação, compara o cd_guia_solic_imp com(Do procedimento ou  material que esta sendo comparado) com o
	--nvl do campo cd_guia_solic_imp com o cd_guia_referencia, pois  o proc ou mat que esta sendo comparado também deve retornar no select.
	--Por que é feito um group by entre os campos e quando a quantidade de registros de um agrupamento for maior que 1 é que tem registro duplicado.
	if (dados_validacao_p.ie_mesma_guia = 'S' and (dados_proc_p.cd_guia_solic_imp IS NOT NULL AND dados_proc_p.cd_guia_solic_imp::text <> '')) then
		ds_filtro_sql_w	:= ds_filtro_sql_w || ' and nvl(proc.cd_guia_referencia, proc.cd_guia_solic_imp) = :cd_guia_referencia_imp ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia_imp', dados_proc_p.cd_guia_solic_imp, bind_sql_valor_w);
	end if;
else

	if (dados_proc_p.nr_seq_prestador_exec IS NOT NULL AND dados_proc_p.nr_seq_prestador_exec::text <> '') then
		ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_proc_p.nr_seq_prestador_exec, bind_sql_valor_w);
	end if;
	if (dados_proc_p.nr_seq_congenere IS NOT NULL AND dados_proc_p.nr_seq_congenere::text <> '') then
		ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.nr_seq_congenere = :nr_seq_congenere ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_congenere', dados_proc_p.nr_seq_congenere, bind_sql_valor_w);
	end if;
	--Se for informado na regra para validar  guia  e por fatura, então faz um or
	if (dados_validacao_p.ie_mesma_guia = 'S' and dados_validacao_p.ie_mesma_fatura = 'S' and
		(dados_proc_p.cd_guia_referencia IS NOT NULL AND dados_proc_p.cd_guia_referencia::text <> '') and (dados_proc_p.nr_seq_fatura IS NOT NULL AND dados_proc_p.nr_seq_fatura::text <> '')) then
		ds_filtro_sql_w	:= ds_filtro_sql_w || ' and (proc.cd_guia_referencia = :cd_guia_referencia or proc.nr_seq_fatura = :nr_seq_fatura) ' || pls_tipos_ocor_pck.enter_w;
     		bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia', dados_proc_p.cd_guia_referencia, bind_sql_valor_w);
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_fatura', dados_proc_p.nr_seq_fatura, bind_sql_valor_w);
	else
		-- Se a restrição for por mesma guia, adicionar a condição
		if (dados_validacao_p.ie_mesma_guia = 'S' and (dados_proc_p.cd_guia_referencia IS NOT NULL AND dados_proc_p.cd_guia_referencia::text <> '')) then
			ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.cd_guia_referencia = :cd_guia_referencia ' || pls_tipos_ocor_pck.enter_w;
		     	bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia', dados_proc_p.cd_guia_referencia, bind_sql_valor_w);
		end if;
		--Se restrição for por fatura, então adiciona a condição
		if (dados_validacao_p.ie_mesma_fatura = 'S' and (dados_proc_p.nr_seq_fatura IS NOT NULL AND dados_proc_p.nr_seq_fatura::text <> '')) then
			ds_filtro_sql_w	:= ds_filtro_sql_w || ' and proc.nr_seq_fatura = :nr_seq_fatura ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_fatura', dados_proc_p.nr_seq_fatura, bind_sql_valor_w);
		end if;
	end if;
end if;

case dados_validacao_p.ie_profissional_intercambio
	-- Profissional executor
	when 'ME' then

		--Se  for intercâmbio.
		if (dados_conta_p.ie_origem_conta = 'A') then

			ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.sg_cons_prof_prest_nota_serv = :sg_cons_prof_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.nr_cons_prof_prest_nota_serv = :nr_cons_prof_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.sg_uf_cons_prest_nota_serv = :sg_uf_cons_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':sg_cons_prof_prest_nota_serv', dados_proc_p.sg_cons_prof_prest_nota_serv, bind_sql_valor_w);
			bind_sql_valor_w := sql_pck.bind_variable(':nr_cons_prof_prest_nota_serv', dados_proc_p.nr_cons_prof_prest_nota_serv, bind_sql_valor_w);
			bind_sql_valor_w := sql_pck.bind_variable(':sg_uf_cons_prest_nota_serv', dados_proc_p.sg_uf_cons_prest_nota_serv, bind_sql_valor_w);
		end if;
	-- Prestador executor caso profissional não informado
	when 'PE' then
		if ( coalesce(dados_proc_p.sg_cons_prof_prest_nota_serv::text, '') = '') and ( coalesce(dados_proc_p.nr_cons_prof_prest_nota_serv::text, '') = '') and ( coalesce(dados_proc_p.sg_uf_cons_prest_nota_serv::text, '') = '') then
			ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.cd_prest_nota_serv = :cd_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':cd_prest_nota_serv', dados_proc_p.cd_prest_nota_serv, bind_sql_valor_w);
		else
			ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.sg_cons_prof_prest_nota_serv = :sg_cons_prof_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.nr_cons_prof_prest_nota_serv = :nr_cons_prof_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.sg_uf_cons_prest_nota_serv = :sg_uf_cons_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':sg_cons_prof_prest_nota_serv', dados_proc_p.sg_cons_prof_prest_nota_serv, bind_sql_valor_w);
			bind_sql_valor_w := sql_pck.bind_variable(':nr_cons_prof_prest_nota_serv', dados_proc_p.nr_cons_prof_prest_nota_serv, bind_sql_valor_w);
			bind_sql_valor_w := sql_pck.bind_variable(':sg_uf_cons_prest_nota_serv', dados_proc_p.sg_uf_cons_prest_nota_serv, bind_sql_valor_w);
		end if;
	-- Porfissional Executor e CBO
	when 'MC' then

		if ( coalesce(dados_proc_p.sg_cons_prof_prest_nota_serv::text, '') = '') and ( coalesce(dados_proc_p.nr_cons_prof_prest_nota_serv::text, '') = '') and ( coalesce(dados_proc_p.sg_uf_cons_prest_nota_serv::text, '') = '') then

			ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.cd_prest_nota_serv = :cd_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':cd_prest_nota_serv', dados_proc_p.cd_prest_nota_serv, bind_sql_valor_w);
		else

			ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.sg_cons_prof_prest_nota_serv = :sg_cons_prof_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.nr_cons_prof_prest_nota_serv = :nr_cons_prof_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.sg_uf_cons_prest_nota_serv = :sg_uf_cons_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w ||
							      ' and proc.sg_uf_cons_prest_nota_serv = :sg_uf_cons_prest_nota_serv ' || pls_tipos_ocor_pck.enter_w;

			bind_sql_valor_w := sql_pck.bind_variable(':sg_cons_prof_prest_nota_serv', dados_proc_p.sg_cons_prof_prest_nota_serv, bind_sql_valor_w);
			bind_sql_valor_w := sql_pck.bind_variable(':nr_cons_prof_prest_nota_serv', dados_proc_p.nr_cons_prof_prest_nota_serv, bind_sql_valor_w);
			bind_sql_valor_w := sql_pck.bind_variable(':sg_uf_cons_prest_nota_serv', dados_proc_p.sg_uf_cons_prest_nota_serv, bind_sql_valor_w);
		end if;

		ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.nr_seq_cbo_saude = :nr_seq_cbo_saude ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_cbo_saude', dados_conta_p.nr_seq_cbo_saude, bind_sql_valor_w);

	else
		null;
end case;


-- Prestador
case dados_validacao_p.ie_profissional
	-- Profissional executor
	--A opção 'ME' neste caso é muito cara para manter no SQL, então foi delegada no loop de verificação, ganhando performance
	-- Prestador executor caso profissional não informado
	when 'PE' then

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Se tiver prestador exec, se não tiver, o profissional vai ser avaliado no loop, por questões de performance
			if	((dados_proc_p.nr_seq_prestador_exec_imp_ref IS NOT NULL AND dados_proc_p.nr_seq_prestador_exec_imp_ref::text <> '') and (coalesce(cd_medico_atual_w.cd_medico_executor::text, '') = '')) then

				ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.nr_seq_prestador_exec_imp_ref = :nr_seq_prestador_exec_imp_ref ' || pls_tipos_ocor_pck.enter_w;
				bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec_imp_ref', dados_proc_p.nr_seq_prestador_exec_imp_ref, bind_sql_valor_w);
			end if;

		else
			-- Se tiver prestador exec, se não tiver, o profissional vai ser avaliado no loop, por questões de performance
			if	(dados_proc_p.nr_seq_prestador_exec IS NOT NULL AND dados_proc_p.nr_seq_prestador_exec::text <> '' AND cd_medico_atual_w.cd_medico_executor IS NOT NULL AND cd_medico_atual_w.cd_medico_executor::text <> '') then

				ds_filtro_sql_w := ds_filtro_sql_w || ' and proc.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w;
				bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_proc_p.nr_seq_prestador_exec, bind_sql_valor_w);
			end if;

		end if;


	-- Profissional Executor e CBO
	-- Opção 'MC'
	-- Como profissional pode estar informado nos participantes, ele será avaliado no loop abaixo,
	-- por questões de performance
	else
		null;
end case;


if (dados_validacao_p.ie_considera_cons_desc = 'N') and (dados_conta_p.ie_origem_conta = 'A') then
	ds_filtro_sql_w := ds_filtro_sql_w || ' and nr_cons_prof_prest_nota_serv <> ''0000'' ';
end if;
-- monta o select para retornar inclusive alguns dados que serão colocados na observação
ds_sql_w :=	'select	' || ds_campo_sql_w ||
		'	proc.cd_guia_referencia,' || pls_tipos_ocor_pck.enter_w ||
		'	proc.nr_seq_fatura,' || pls_tipos_ocor_pck.enter_w ||
		'	proc.nr_seq_conta,' || pls_tipos_ocor_pck.enter_w ||
		'	proc.nr_sequencia nr_seq_conta_proc,' || pls_tipos_ocor_pck.enter_w ||
		'	proc.nr_seq_protocolo ' || pls_tipos_ocor_pck.enter_w ||
		'from	pls_conta_proc_ocor_v proc' || pls_tipos_ocor_pck.enter_w ||
		'where	proc.ie_origem_proced = :ie_origem_proced' || pls_tipos_ocor_pck.enter_w ||
		'and	proc.cd_procedimento = :cd_procedimento' || pls_tipos_ocor_pck.enter_w ||
		ds_filtro_sql_w ||
		'order by proc.nr_seq_conta';

		bind_sql_valor_w := sql_pck.bind_variable(':ie_origem_proced', dados_proc_p.ie_origem_proced, bind_sql_valor_w);
		bind_sql_valor_w := sql_pck.bind_variable(':cd_procedimento', dados_proc_p.cd_procedimento, bind_sql_valor_w);

ds_observacao_w := null;
qt_repeticao_w	:= 0;
nr_seq_conta_ant_w := null;

bind_sql_valor_w := sql_pck.executa_sql_cursor(ds_sql_w, bind_sql_valor_w);

loop
	fetch cursor_w bulk collect
	into  tb_date_w, tb_guia_referencia_w, tb_fatura_w, tb_seq_conta_w, tb_seq_conta_proc_w, tb_seq_protocolo_w
	limit pls_util_cta_pck.qt_registro_transacao_w;

	exit when tb_seq_conta_w.count = 0;

	for i in tb_seq_conta_w.first..tb_seq_conta_w.last loop

		-- retorno no comando SQL todos os materiais que estão duplicados e faço a restrição por data aqui neste if.
		-- o motivo é bem simples: PERFORMANCE.
		-- se for verificado nesta rotina, existem  nvls e tratamentos de datas e o banco consegue processar muito bem isso com group by e contar as repetições
		-- então assim é feito, juntamos toda a massa e verificamos o que está duplicado e apenas consideramos neste if os que tem a mesma data
		if	((tb_date_w(i) = dt_procedimento_w) or (coalesce(tb_date_w(i)::text, '') = '' and coalesce(dt_procedimento_w::text, '') = '')) then

			ie_valido_w := 'S';

			--Tem que buscar o executor diretamente do procedimento, pois alguns tipos de guia não tem mais o executor. faço a comparação aqui para
			--o select do cursor já ter diminuído a massa de dados e ter um custo menor essa verificação de profissional executor
			if	((dados_validacao_p.ie_profissional_intercambio = 'ME' and dados_conta_p.ie_origem_conta <> 'A') or
				-- OU Se for a opção de profissional executor, que não seja do intercambio
				 (dados_validacao_p.ie_profissional = 'ME' AND dados_conta_p.ie_origem_conta <> 'A') or
				-- OU se for para verificar pelo profissional executor, mas o mesmo está em branco, e precisa buscar então o Prestador executor, e que não seja de intercambio
				-- No caso, se for verificar pelo Prestador executor, ele já foi filtrado no cursor, senão, vai ter que buscar o profissional executor
				 (dados_validacao_p.ie_profissional = 'PE' AND cd_medico_atual_w.cd_medico_executor IS NOT NULL AND cd_medico_atual_w.cd_medico_executor::text <> '') or
				 -- OU se for para validar o profissional + CBO
				 (dados_validacao_p.ie_profissional = 'MC')) then

				cd_medico_outra_conta_w := pls_obter_dados_medico_exec(tb_seq_conta_proc_w(i),'P');



				--quando ocorrência utilizar mesmo profissional executor, então não gera se um dos executores for nulo.
				--Em tese não deveria ocorrer um executor nulo, porém não faz sentido gerar a ocorrência mesmo nesses casos.
				-- Ainda no caso do Profissional + CBO
				if	((coalesce(cd_medico_outra_conta_w.cd_medico_executor,'X') <> coalesce(cd_medico_atual_w.cd_medico_executor, 'Z')) and (dados_validacao_p.ie_profissional != 'MC')) or
					 -- OU deve considerar mesmo profissional e mesmo CBO
					((dados_validacao_p.ie_profissional = 'MC') and
					 ((coalesce(cd_medico_outra_conta_w.cd_medico_executor,'X') <> coalesce(cd_medico_atual_w.cd_medico_executor, 'Z')) or (cd_medico_outra_conta_w.nr_seq_cbo_saude <> cd_medico_atual_w.nr_seq_cbo_saude))) then

					ie_valido_w := 'N';
				end if;

			else
				ie_valido_w := 'S';
			end if;

			--ie_valido_w somente será 'N' caso a validação for por profissional executor e não for conta de intercâmbio o mesmo for diferente do procedimento que esta sendo consistido.
			--Se for conta de intercâmbio, a verificação não será baseada no médico_executor obtido de conta/participante.
			if (ie_valido_w = 'S') then

				-- só manda para a observação se for para uma nova conta
				if (coalesce(nr_seq_conta_ant_w::text, '') = '' or nr_seq_conta_ant_w != tb_seq_conta_w(i)) then
					-- quebra de linha
					ds_observacao_w := ds_observacao_w || pls_tipos_ocor_pck.enter_w;

					if ((tb_guia_referencia_w(i) IS NOT NULL AND (tb_guia_referencia_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' guia: ' || tb_guia_referencia_w(i);
					end if;

					if ((tb_fatura_w(i) IS NOT NULL AND (tb_fatura_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' fatura: ' || tb_fatura_w(i);
					end if;

					if ((tb_seq_conta_w(i) IS NOT NULL AND (tb_seq_conta_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' conta: ' || tb_seq_conta_w(i);
					end if;

					if ((tb_seq_protocolo_w(i) IS NOT NULL AND (tb_seq_protocolo_w(i))::text <> '')) then
						ds_observacao_w := ds_observacao_w || ' protocolo: ' || tb_seq_protocolo_w(i);
					end if;

					ds_observacao_w := ds_observacao_w || ';';
				end if;

				qt_repeticao_w := qt_repeticao_w + 1;
				nr_seq_conta_ant_w := tb_seq_conta_w(i);
			end if;
		end if;

	end loop;

	-- reinicia as variáveis table
	tb_date_w.delete;
	tb_guia_referencia_w.delete;
	tb_fatura_w.delete;
	tb_seq_conta_w.delete;
	tb_seq_conta_proc_w.delete;
	tb_seq_protocolo_w.delete;
end loop;
close cursor_w;

-- se teve observação e se a quantidade de repetição for maior que um, significa que tivemos itens repetidos
if ((ds_observacao_w IS NOT NULL AND ds_observacao_w::text <> '') and qt_repeticao_w > 1) then
	-- retorna somente 2000 pelo motivo que a variável table utilizada para inserção da observação aceita somente isso
	ds_result_w := 'Item com duplicidade. Os dados são:' || substr(ds_observacao_w, 0, 1850);
end if;

return ds_result_w;

end;

function obter_item_duplicado_mat(	dados_validacao_p	pls_tipos_ocor_pck.dados_val_duplic_item,
					dados_mat_p		pls_tipos_ocor_pck.dados_conta_mat,
					dados_regra_p		pls_tipos_ocor_pck.dados_regra,
					dados_conta_p		pls_tipos_ocor_pck.dados_conta
					) return varchar2 is
ds_result_w 		varchar2(2000);
ds_observacao_w		varchar2(20000);
ds_sql_w		varchar2(4000);
ds_campo_sql_w		varchar2(600);
ds_campo_sql_data_w	varchar2(600);
ds_filtro_sql_w		varchar2(1000);
dt_material_w		date;
qt_repeticao_w		pls_integer;

nr_seq_conta_ant_w	pls_conta.nr_sequencia%type;

tb_date_w		pls_util_cta_pck.t_date_table;
tb_guia_referencia_w	pls_util_cta_pck.t_varchar2_table_20;
tb_fatura_w		pls_util_cta_pck.t_number_table;
tb_seq_conta_w		pls_util_cta_pck.t_number_table;
tb_seq_conta_mat_w	pls_util_cta_pck.t_number_table;
tb_seq_protocolo_w	pls_util_cta_pck.t_number_table;

bind_sql_valor_w	sql_pck.t_dado_bind;
cursor_w		sql_pck.t_cursor;
ds_data_w		varchar2(600);


begin

ds_result_w := null;

ds_campo_sql_w := '';

-- Tratamento para usar dt_inicio_atend_mat e dt_inicio_atend_mat_imp
-- foi feito tratamento aqui e não na pls_conta_mat_atual para evitar impacto em outras areas do sistema.
if (dados_regra_p.ie_evento = 'IMP') then
	ds_data_w:=	'nvl(dt_inicio_atend_mat,dt_inicio_atend_mat_imp)';
else
	ds_data_w:= 	'dt_inicio_atend_mat';
end if;

case dados_validacao_p.ie_mesmo_horario
	-- mesma hora
	when 'H' then
		ds_campo_sql_w := 'trunc(' || ds_data_w || ',''hh'')';
	-- Mesma hora e minuto
	when 'M' then
		ds_campo_sql_w := 'trunc(' || ds_data_w || ',''mi'')';

	-- Mesma hora, minuto e segundo
	when 'S' then
		ds_campo_sql_w := ds_data_w;
	-- verifica somente se é a mesma data
	else
		ds_campo_sql_w := 'trunc(' || ds_data_w || ',''dd'')';
end case;

-- campo de data que será utilizado para comparação
ds_campo_sql_data_w := ds_campo_sql_w;

-- busca o valor da data que será utilizado como filtro abaixo na comparação
-- faço dentro desta rotina para centralizar o tratamento para datas
EXECUTE 'select ' || ds_campo_sql_data_w || ' from pls_conta_mat_ocor_v mat where nr_sequencia = :nr_sequencia'
into STRICT dt_material_w
using dados_mat_p.nr_sequencia;

-- coloca  vírgula
ds_campo_sql_w := ds_campo_sql_w || ',';
ds_campo_sql_w := ds_campo_sql_w || pls_tipos_ocor_pck.enter_w;

ds_filtro_sql_w := '';

--se restringir por mesmo beneficiário
if (dados_validacao_p.ie_mesmo_beneficiario = 'S' and (dados_mat_p.nr_seq_segurado IS NOT NULL AND dados_mat_p.nr_seq_segurado::text <> '')) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and mat.nr_seq_segurado = :nr_seq_segurado'||pls_tipos_ocor_pck.enter_w;
	bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_segurado', dados_mat_p.nr_seq_segurado, bind_sql_valor_w);
end if;

if (dados_validacao_p.ie_somente_integrado = 'S' ) then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and mat.ie_situacao_protocolo in (''D'',''T'') ' || pls_tipos_ocor_pck.enter_w;
end if;

if (dados_validacao_p.ie_desconsidera_item_glosado = 'S') then
	ds_filtro_sql_w	:= ds_filtro_sql_w || ' and mat.ie_glosa = ''N'' ' || pls_tipos_ocor_pck.enter_w;
end if;

if (dados_regra_p.ie_evento = 'IMP') then
	-- o campo nr_seq_prestador_exec_imp_ref foi criado para armazenar o valor do prestador executor durante a importação do XML
	-- é feito um OR para retornar para filtrar os dois campos (busca o que está sendo importado e os que já existem na base)
	-- nunca existe congênere informada para importação XML
	if (dados_mat_p.nr_seq_prestador_exec_imp_ref IS NOT NULL AND dados_mat_p.nr_seq_prestador_exec_imp_ref::text <> '') then
		ds_filtro_sql_w := ds_filtro_sql_w || ' and mat.nr_seq_prestador_exec_imp_ref = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w;
     		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_mat_p.nr_seq_prestador_exec_imp_ref, bind_sql_valor_w);
	end if;
	--Em caso de importação, compara o cd_guia_solic_imp com(Do procedimento ou  material que esta sendo comparado) com o
	--nvl do campo cd_guia_solic_imp com o cd_guia_referencia, pois  o proc ou mat que esta sendo comparado também deve retornar no select.
	--Por que é feito um group by entre os campos e quando a quantidade de registros de um agrupamento for maior que 1 é que tem registro duplicado.
	if (dados_validacao_p.ie_mesma_guia = 'S' and (dados_mat_p.cd_guia_solic_imp IS NOT NULL AND dados_mat_p.cd_guia_solic_imp::text <> '')) then
		ds_filtro_sql_w	:= ds_filtro_sql_w || ' and nvl(mat.cd_guia_referencia, mat.cd_guia_solic_imp) = :cd_guia_referencia_imp' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia_imp', dados_mat_p.cd_guia_solic_imp, bind_sql_valor_w);
	end if;
else
	-- senão faz filtros específicos se for necessário
	if (dados_mat_p.nr_seq_prestador_exec IS NOT NULL AND dados_mat_p.nr_seq_prestador_exec::text <> '') then
		ds_filtro_sql_w := ds_filtro_sql_w || ' and mat.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_prestador_exec', dados_mat_p.nr_seq_prestador_exec, bind_sql_valor_w);
	end if;
	if (dados_mat_p.nr_seq_congenere IS NOT NULL AND dados_mat_p.nr_seq_congenere::text <> '') then
		ds_filtro_sql_w := ds_filtro_sql_w || ' and mat.nr_seq_congenere = :nr_seq_congenere ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_congenere', dados_mat_p.nr_seq_congenere, bind_sql_valor_w);
	end if;

	--Se for informado na regra para validar  guia  e por fatura, então faz um or
	if (dados_validacao_p.ie_mesma_guia = 'S' and dados_validacao_p.ie_mesma_fatura = 'S' and
		 (dados_mat_p.cd_guia_referencia IS NOT NULL AND dados_mat_p.cd_guia_referencia::text <> '') and (dados_mat_p.nr_seq_fatura IS NOT NULL AND dados_mat_p.nr_seq_fatura::text <> '')) then
		ds_filtro_sql_w	:= ds_filtro_sql_w || ' and (mat.cd_guia_referencia = :cd_guia_referencia or mat.nr_seq_fatura = :nr_seq_fatura) ' || pls_tipos_ocor_pck.enter_w;
		bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia', dados_mat_p.cd_guia_referencia, bind_sql_valor_w);
		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_fatura', dados_mat_p.nr_seq_fatura, bind_sql_valor_w);
	else
		-- Se a restrição for por mesma guia, adicionar a condição
		if (dados_validacao_p.ie_mesma_guia = 'S' and (dados_mat_p.cd_guia_referencia IS NOT NULL AND dados_mat_p.cd_guia_referencia::text <> '')) then
			ds_filtro_sql_w	:= ds_filtro_sql_w || ' and mat.cd_guia_referencia = :cd_guia_referencia ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':cd_guia_referencia', dados_mat_p.cd_guia_referencia, bind_sql_valor_w);
		end if;
		--Se restrição for por fatura, então adiciona a condição
		if (dados_validacao_p.ie_mesma_fatura = 'S' and (dados_mat_p.nr_seq_fatura IS NOT NULL AND dados_mat_p.nr_seq_fatura::text <> '')) then
			ds_filtro_sql_w	:= ds_filtro_sql_w || ' and mat.nr_seq_fatura = :nr_seq_fatura ' || pls_tipos_ocor_pck.enter_w;
			bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_fatura', dados_mat_p.nr_seq_fatura, bind_sql_valor_w);
		end if;
	end if;
end if;

-- monta o select para retornar inclusive alguns dados que serão colocados na observação
ds_sql_w :=	'select	' || ds_campo_sql_w ||
		'	mat.cd_guia_referencia,' || pls_tipos_ocor_pck.enter_w ||
		'	mat.nr_seq_fatura,' || pls_tipos_ocor_pck.enter_w ||
		'	mat.nr_seq_conta,' || pls_tipos_ocor_pck.enter_w ||
		'	mat.nr_sequencia nr_seq_conta_mat,' || pls_tipos_ocor_pck.enter_w ||
		'	mat.nr_seq_protocolo ' || pls_tipos_ocor_pck.enter_w ||
		'from	pls_conta_mat_ocor_v mat ' || pls_tipos_ocor_pck.enter_w ||
		'where	mat.nr_seq_material = :nr_seq_material' || pls_tipos_ocor_pck.enter_w ||
		ds_filtro_sql_w ||
		'order by mat.nr_seq_conta';

		bind_sql_valor_w := sql_pck.bind_variable(':nr_seq_material', dados_mat_p.nr_seq_material, bind_sql_valor_w);

ds_observacao_w := null;
qt_repeticao_w	:= 0;
nr_seq_conta_ant_w := null;
bind_sql_valor_w := sql_pck.executa_sql_cursor(ds_sql_w, bind_sql_valor_w);

loop
	fetch cursor_w bulk collect
	into  tb_date_w, tb_guia_referencia_w, tb_fatura_w, tb_seq_conta_w, tb_seq_conta_mat_w, tb_seq_protocolo_w
	limit pls_util_cta_pck.qt_registro_transacao_w;

	exit when tb_seq_conta_w.count = 0;

	for i in tb_seq_conta_w.first..tb_seq_conta_w.last loop

		-- retorno no comando SQL todos os materiais que estão duplicados e faço a restrição por data aqui neste if.
		-- o motivo é bem simples: PERFORMANCE.
		-- se for verificado nesta rotina, existem  nvls e tratamentos de datas e o banco consegue processar muito bem isso com group by e contar as repetições
		-- então assim é feito, juntamos toda a massa e verificamos o que está duplicado e apenas consideramos neste if os que tem a mesma data
		if	((tb_date_w(i) = dt_material_w) or (coalesce(tb_date_w(i)::text, '') = '' and coalesce(dt_material_w::text, '') = '')) then

			-- só manda para a observação se for para uma nova conta
			if (coalesce(nr_seq_conta_ant_w::text, '') = '' or nr_seq_conta_ant_w != tb_seq_conta_w(i)) then
				-- quebra de linha
				ds_observacao_w := ds_observacao_w || pls_tipos_ocor_pck.enter_w;

				if ((tb_guia_referencia_w(i) IS NOT NULL AND (tb_guia_referencia_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' guia: ' || tb_guia_referencia_w(i);
				end if;

				if ((tb_fatura_w(i) IS NOT NULL AND (tb_fatura_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' fatura: ' || tb_fatura_w(i);
				end if;

				if ((tb_seq_conta_w(i) IS NOT NULL AND (tb_seq_conta_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' conta: ' || tb_seq_conta_w(i);
				end if;

				if ((tb_seq_protocolo_w(i) IS NOT NULL AND (tb_seq_protocolo_w(i))::text <> '')) then
					ds_observacao_w := ds_observacao_w || ' protocolo: ' || tb_seq_protocolo_w(i);
				end if;

				ds_observacao_w := ds_observacao_w || ';';
			end if;

			qt_repeticao_w := qt_repeticao_w + 1;
			nr_seq_conta_ant_w := tb_seq_conta_w(i);
		end if;
	end loop;

	-- reinicia as variáveis table
	tb_date_w.delete;
	tb_guia_referencia_w.delete;
	tb_fatura_w.delete;
	tb_seq_conta_w.delete;
	tb_seq_conta_mat_w.delete;
	tb_seq_protocolo_w.delete;
end loop;
close cursor_w;

-- se teve observação e se a quantidade de repetição for maior que um, significa que tivemos itens repetidos
if ((ds_observacao_w IS NOT NULL AND ds_observacao_w::text <> '') and qt_repeticao_w > 1) then
	-- retorna somente 2000 pelo motivo que a variável table utilizada para inserção da observação aceita somente isso
	ds_result_w := 'Item com duplicidade. Os dados são:' || substr(ds_observacao_w, 0, 1850);
end if;

return ds_result_w;

end;

begin

ds_obs_item_duplicado_w := null;

-- Deve ter informação de uma regra válida para que seja aplicada a validação.
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then

	-- Aqui irá varrer as regras cadastradas para a validação, para esta validação por enquanto só é permitida uma regra, portanto será
	-- passado apenas uma vez.
	for	r_c_regras_val_w in c_regras_val(dados_regra_p.nr_sequencia) loop

		begin

		-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
		CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);

		-- Atualizar os dados validação.
		dados_validacao_w.nr_sequencia			:= r_c_regras_val_w.nr_seq_validacao;
		dados_validacao_w.ie_mesmo_horario		:= r_c_regras_val_w.ie_mesmo_horario;
		dados_validacao_w.ie_mesma_guia			:= r_c_regras_val_w.ie_mesma_guia;
		dados_validacao_w.ie_mesma_fatura 		:= r_c_regras_val_w.ie_mesma_fatura;
		dados_validacao_w.ie_mesmo_beneficiario		:= r_c_regras_val_w.ie_mesmo_beneficiario;
		dados_validacao_w.ie_profissional_intercambio	:= r_c_regras_val_w.ie_profissional_intercambio;
		dados_validacao_w.ie_via_acesso 		:= r_c_regras_val_w.ie_via_acesso;
		dados_validacao_w.ie_considera_cons_desc	:= r_c_regras_val_w.ie_considera_cons_desc;
		dados_validacao_w.ie_profissional		:= r_c_regras_val_w.ie_profissional;
		dados_validacao_w.ie_somente_integrado		:= r_c_regras_val_w.ie_somente_integrado;
		dados_validacao_w.ie_desconsidera_item_glosado := r_c_regras_val_w.ie_desconsidera_item_glosado;

		i := 0;
		pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);

		for r_C01_w in C01(nr_id_transacao_p) loop

			-- Obter os valores da linha atual do cursor.
			dados_tab_selecao_w.nr_sequencia     := r_C01_w.nr_seq_selecao;
			dados_tab_selecao_w.ie_tipo_registro := r_C01_w.ie_tipo_registro;
			dados_tab_selecao_w.nr_seq_item      := r_C01_w.nr_seq_item;

			-- alimenta as variáveis de acordo com o tipo do item (procedimento ou material)
			if (dados_tab_selecao_w.ie_tipo_registro = 'P') then
				dados_proc_w.ie_origem_proced 			:= r_C01_w.ie_origem_proced;
				dados_proc_w.cd_procedimento 			:= r_C01_w.cd_procedimento;
				dados_proc_w.nr_seq_prestador_exec		:= r_C01_w.nr_seq_prestador_exec;
				dados_proc_w.nr_seq_congenere 			:= r_C01_w.nr_seq_congenere;
				dados_proc_w.nr_seq_fatura			:= r_C01_w.nr_seq_fatura;
				dados_proc_w.cd_guia_referencia			:= r_C01_w.cd_guia_referencia;
				dados_proc_w.cd_guia_solic_imp			:= r_C01_w.cd_guia_solic_imp;
				dados_proc_w.nr_sequencia			:= r_C01_w.nr_sequencia;
				dados_proc_w.nr_seq_segurado			:= r_C01_w.nr_seq_segurado;
				dados_proc_w.cd_prest_nota_serv 		:= r_C01_w.cd_prest_nota_serv;
				dados_proc_w.nr_seq_prestador_exec_imp_ref	:= r_C01_w.nr_seq_prestador_exec_imp_ref;
				dados_proc_w.sg_cons_prof_prest_nota_serv 	:= r_C01_w.sg_cons_prof_prest_nota_serv;
				dados_proc_w.nr_cons_prof_prest_nota_serv 	:= r_C01_w.nr_cons_prof_prest_nota_serv;
				dados_proc_w.sg_uf_cons_prest_nota_serv	 	:= r_C01_w.sg_uf_cons_prest_nota_serv;
				dados_conta_w.ie_origem_conta		 	:= r_C01_w.ie_origem_conta;
				dados_proc_w.ie_via_acesso			:= r_c01_w.ie_via_acesso;
				dados_conta_w.nr_seq_cbo_saude			:= r_C01_w.nr_seq_cbo_saude;

			else
				dados_mat_w.nr_seq_material 			:= r_C01_w.nr_seq_material;
				dados_mat_w.nr_seq_prestador_exec		:= r_C01_w.nr_seq_prestador_exec;
				dados_mat_w.nr_seq_congenere 			:= r_C01_w.nr_seq_congenere;
				dados_mat_w.nr_seq_fatura			:= r_C01_w.nr_seq_fatura;
				dados_mat_w.cd_guia_referencia			:= r_C01_w.cd_guia_referencia;
				dados_mat_w.cd_guia_solic_imp			:= r_C01_w.cd_guia_solic_imp;
				dados_mat_w.nr_sequencia			:= r_C01_w.nr_sequencia;
				dados_mat_w.nr_seq_prestador_exec_imp_ref	:= r_C01_w.nr_seq_prestador_exec_imp_ref;
				dados_mat_w.nr_seq_segurado 			:= r_C01_w.nr_seq_segurado;
				dados_conta_w.ie_origem_conta			:= r_C01_w.ie_origem_conta;
				dados_conta_w.nr_seq_cbo_saude			:= r_C01_w.nr_seq_cbo_saude;

			end if;

			-- faz a validação se existe item duplicado e se existir já retorna os dados para colocar na observação
			if (dados_tab_selecao_w.ie_tipo_registro = 'P') then
				ds_obs_item_duplicado_w := obter_item_duplicado_proc(	dados_validacao_w, dados_proc_w, dados_regra_p, dados_conta_w);
			else
				ds_obs_item_duplicado_w := obter_item_duplicado_mat(	dados_validacao_w, dados_mat_w, dados_regra_p, dados_conta_w);
			end if;

			-- significa que encontrou duplicidade de itens e deve gerar ocorrência para o item que está selecionado na tabela de seleção
			if (ds_obs_item_duplicado_w IS NOT NULL AND ds_obs_item_duplicado_w::text <> '') then

				dados_tb_selecao_w.nr_seq_selecao(i)	:= dados_tab_selecao_w.nr_sequencia;
				dados_tb_selecao_w.ds_observacao(i)	:= ds_obs_item_duplicado_w;
				dados_tb_selecao_w.ie_valido(i)		:= 'S';

				-- Quando tiver atingido a quantidade máxima de registros então irá mandar para banco.
				if (i = pls_util_cta_pck.qt_registro_transacao_w) then

					-- Grava as alterações na tabela
					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao,
											pls_tipos_ocor_pck.clob_table_vazia,
											'SEQ', dados_tb_selecao_w.ds_observacao,
											dados_tb_selecao_w.ie_valido, nm_usuario_p);

					-- Zera as listas e o índice para recomeçar o processo.
					pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);
					i := 0;
				else
					i := i + 1;
				end if;
			end if;
		end loop;

		-- se sobrou algum registro manda para o banco
		if (dados_tb_selecao_w.nr_seq_selecao.count > 0) then
			-- Grava as alterações na tabela
			CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	dados_tb_selecao_w.nr_seq_selecao,
									pls_tipos_ocor_pck.clob_table_vazia,
									'SEQ', dados_tb_selecao_w.ds_observacao,
									dados_tb_selecao_w.ie_valido, nm_usuario_p);

			-- Zera as listas e o índice para recomeçar o processo.
			pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_selecao_w);
			i := 0;
		end if;

		exception
		when others then
			-- Insere o log na tabela e aborta a operação
			CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(dados_regra_p, null, nr_id_transacao_p, nm_usuario_p);
		end;

		-- seta os registros que serão válidos ou inválidos após o processamento
		CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
	end loop; -- c_regras_val
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_53 (( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, nm_usuario_p usuario.nm_usuario%type) is  dados_validacao_w pls_tipos_ocor_pck.dados_val_duplic_item) FROM PUBLIC;

