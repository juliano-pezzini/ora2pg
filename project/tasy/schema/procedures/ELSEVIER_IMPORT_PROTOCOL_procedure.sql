-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE elsevier_import_protocol ( ds_json_p text, nm_usuario_p text, ds_erro_p out text, ie_tipo_erro_p out text ) is --Variables log error
 ds_protocol_w varchar(255) AS $body$
DECLARE

	_ora2pg_r RECORD;
nr_sequencia_w	protocolo_medicacao.nr_sequencia%type;
BEGIN
	select	coalesce(max(nr_sequencia), 0) + 1
	into STRICT	nr_sequencia_w
	from	protocolo_medicacao
	where	cd_protocolo = cd_protocolo_p;

	return;
end;

procedure add_advisory(order_p philips_json) is
	ds_link_avisory_w	protocolo_guia_inf_avisos.ds_link%type := null;
	ds_descricao_w		protocolo_guia_inf_avisos.ds_descricao%type;	
begin
	if (order_p.exist('guidance')) then
		ds_link_avisory_w := order_p.get['guidance'].get_string();
		ds_link_avisory_w := regexp_replace(ds_link_avisory_w, '^http:', 'https:' );
	end if;
	
	ds_descricao_w	:= philips_json(philips_json_list(philips_json(order_p.get('parameters')).get('NonorderableNarrative')).get(1)).get['value'].get_string();
	
	insert into protocolo_guia_inf_avisos(
		nr_sequencia,
		nr_seq_guia_inf,
		ds_descricao,
		ds_link,
		dt_atualizacao,
		dt_atualizacao_nrec,
		nm_usuario,
		nm_usuario_nrec
	) values (
		nextval('protocolo_guia_inf_avisos_seq'),
		nr_seq_guia_inf_w,
		ds_descricao_w,
		ds_link_avisory_w,
		clock_timestamp(),
		clock_timestamp(),
		nm_usuario_p,
		nm_usuario_p
	);
end;

procedure exec_elsevier_import_order(ds_name_p in varchar2) is
begin
    ds_item_protocol_w :=  ds_name_p;

    SELECT * FROM elsevier_import_order(cd_protocolo_w, nr_sequencia_w, order_w, nm_usuario_p) INTO STRICT _ora2pg_r;
 nr_seq_guia_inf_w := _ora2pg_r.nr_seq_guia_inf_p; inconsistencies_warning_w := _ora2pg_r.inconsistencies_warning_p;

    if (inconsistencies_warning_w IS NOT NULL AND inconsistencies_warning_w::text <> '')then
        ie_tipo_erro_p := 'W';
    end if;
end;

function is_advisory(order_p philips_json) return;
end;

begin

order_set_w	:= philips_json(ds_json_p);

-- Read the orderset info
cd_sistema_externo_w	:= order_set_w.get['groupId'].get_number();
nr_versao_maior_w	:= order_set_w.get['versionMajor'].get_number();
nr_versao_menor_w	:= order_set_w.get['versionMinor'].get_number();
title_w			:= substr(order_set_w.get['title'].get_string(), 1, 50);
keywords_w		:= philips_json_list(order_set_w.get('keywords'));

if (order_set_w.exist('guidanceURL')) then
	ds_link_w	:= order_set_w.get['guidanceURL'].get_string();
	ds_link_w	:= regexp_replace(ds_link_w, '^http:', 'https:' );
end if;

-- Inactivate previous versions of this protocol
update tipo_protocolo set ie_situacao = 'I' where cd_tipo_protocolo in (SELECT nr_seq_tipo_prot from protocolo_guia_inf where cd_sistema_externo = cd_sistema_externo_w);

-- Also Inactivate their Elsevier data
update protocolo_guia_inf set ie_situacao = 'I' where cd_sistema_externo = cd_sistema_externo_w;

-- Inactivate modules
update protocolo_modulo set ie_situacao = 'I' where cd_tipo_protocolo in (SELECT nr_seq_tipo_prot from protocolo_guia_inf where cd_sistema_externo = cd_sistema_externo_w);

select	nextval('tipo_protocolo_seq')
into STRICT	cd_tipo_protocolo_w
;

-- Add the protocolo data
insert into tipo_protocolo(
	cd_tipo_protocolo,
	ds_tipo_protocolo,
	ie_associar_proc,
	ie_banco_sangue,
	ie_frase_padrao,
	ie_prescricao_dieta,
	ie_prescricao_gasoterapia,
	ie_prescricao_hemodialise,
	ie_prescricao_medic,
	ie_prescricao_oxig,
	ie_prescricao_peritoneal,
	ie_prescricao_proc,
	ie_prescricao_rec,
	ie_prescricao_solucao,
	ie_situacao,
	ie_utilizado_pa,
	dt_atualizacao,
	dt_atualizacao_nrec,
	nm_usuario,
	nm_usuario_nrec,
	ie_tipo_protocolo
) values (
	cd_tipo_protocolo_w,
	title_w,
	'N',
	'S',
	'N',
	'S',
	'S',
	'S',
	'S',
	'S',
	'S',
	'S',
	'S',
	'S',
	'A',
	'N',
	clock_timestamp(),
	clock_timestamp(),
	nm_usuario_p,
	nm_usuario_p,
	'P'
);

for i in 1..keywords_w.count loop
	if (substr(keywords_w.get[i].get_string(), 0, 5) = 'CID10') then
		select	nextval('protocolo_doenca_sugestao_seq')
		into STRICT	nr_sequencia_cid_w
		;
	
		cd_doenca_cid_w := substr(keywords_w.get[i].get_string(), 7, LENGTH(keywords_w.get[i].get_string()));		
				
		insert into protocolo_doenca_sugestao(
			nr_sequencia,
			cd_doenca_cid,
			dt_atualizacao,
			nm_usuario,
			dt_atualizacao_nrec,
			nm_usuario_nrec,
			cd_tipo_protocolo
		) values (
			nr_sequencia_cid_w,
			cd_doenca_cid_w,
			clock_timestamp(),
			nm_usuario_p,
			clock_timestamp(),
			nm_usuario_p,
			cd_tipo_protocolo_w
		);
	end if;
end loop;

select	nextval('protocolo_guia_inf_seq')
into STRICT	nr_seq_guia_inf_w
;

-- Add new Elsevier data
if (order_set_w.get['type'].get_string() = 'MODULE') then
	ie_modulo_w	:= 'S';
	ds_titulo_w	:= order_set_w.get['title'].get_string();
end if;

insert into protocolo_guia_inf(
	nr_sequencia,
	cd_sistema_externo,
	nr_seq_tipo_prot,
	ds_link,
	nr_versao_maior,
	nr_versao_menor,
	ie_situacao,
	dt_atualizacao,
	dt_atualizacao_nrec,
	nm_usuario,
	nm_usuario_nrec,
	ie_tipo,
	ie_modulo,
	ds_titulo
) values (
	nr_seq_guia_inf_w,
	cd_sistema_externo_w,
	cd_tipo_protocolo_w,
	ds_link_w,
	nr_versao_maior_w,
	nr_versao_menor_w,
	'A',
	clock_timestamp(),
	clock_timestamp(),
	nm_usuario_p,
	nm_usuario_p,
	'P',
	ie_modulo_w,
	ds_titulo_w
);

-- Read the subitems
sections_w := philips_json_list(order_set_w.get('subItems'));

for i in 1..sections_w.count loop
	section_w	:= philips_json(sections_w.get(i));
	linked_type_w	:= section_w.get['type'].get_string();

	-- At this level it is expected to have only sections
	if (section_w.get['type'].get_string() = 'SECTION') then
		name_w			:= substr(section_w.get['name'].get_string(), 1, 250);
        ds_protocol_w := name_w;
		without_folder_w	:= false; -- Everytime we start a new section, we reset this flag to avoid using the same previous protocolo_medicacao
		linked_type_w		:= section_w.get['type'].get_string();

		if (section_w.exist('guidance')) then
			ds_link_w := section_w.get['guidance'].get_string();
			ds_link_w := regexp_replace(ds_link_w, '^http:', 'https:' );
		else
			ds_link_w := null;
		end if;
		
		select	nextval('protocolo_seq'),
			nextval('protocolo_guia_inf_seq')
		into STRICT	cd_protocolo_w,
			nr_seq_guia_inf_w
		;
		
		select (coalesce(max(nr_sequencia), 0) + 1) nr_sequencia
		into STRICT	nr_seq_protocolo_w
		from	protocolo
		where	cd_tipo_protocolo = cd_tipo_protocolo_w;

		--GRUPO = G -> IE_TIPO
		insert into protocolo(
			cd_protocolo,
			cd_tipo_protocolo,
			nr_sequencia,
			nm_protocolo,
			nr_seq_apres,
			ie_codigo_interno,
			ie_exige_grupo_desc,
			ie_situacao,
			dt_atualizacao,
			nm_usuario
		) values (
			cd_protocolo_w,
			cd_tipo_protocolo_w,
			nr_seq_protocolo_w,
			name_w,
			i,
			'N',
			'N',
			'A',
			clock_timestamp(),
			nm_usuario_p
		);

		insert into protocolo_guia_inf(
			nr_sequencia,
			nr_seq_tipo_prot,
			nr_seq_protocolo,
			ds_link,
			ie_situacao,
			dt_atualizacao,
			dt_atualizacao_nrec,
			nm_usuario,
			nm_usuario_nrec,
			ie_tipo
		) values (
			nr_seq_guia_inf_w,
			cd_tipo_protocolo_w,
			cd_protocolo_w,
			ds_link_w,
			'A',
			clock_timestamp(),
			clock_timestamp(),
			nm_usuario_p,
			nm_usuario_p,
			'G'
		);

		-- Read the section subItems, we can expect folders and orders
		if ((section_w.get('subItems') IS NOT NULL AND (section_w.get('subItems'))::text <> '')) then
			section_subitems_w	:= philips_json_list(section_w.get('subItems'));
		end if;

		if (section_subitems_w IS NOT NULL AND section_subitems_w::text <> '') then
			for j in 1..section_subitems_w.count loop
				subitem_w	:= philips_json(section_subitems_w.get(j));
	
				-- If we have a folder, we need to read the orders inside
				if (subitem_w.get['type'].get_string() = 'FOLDER') then
					name_w			:= substr(subitem_w.get['name'].get_string(), 1, 250);
					without_folder_w	:= false; -- We found a folder, so we reset this flag
	
					if (subitem_w.exist('guidance')) then
						ds_link_w := subitem_w.get['guidance'].get_string();
						ds_link_w := regexp_replace(ds_link_w, '^http:', 'https:' );
					else
						ds_link_w := null;
					end if;
					
					select	nextval('protocolo_medicacao_seq'),
						nextval('protocolo_guia_inf_seq')
					into STRICT	nr_seq_interna_w,
						nr_seq_guia_inf_w
					;
	
					nr_sequencia_w		:= get_proto_medic_sequencia(cd_protocolo_w);
	
					--SUBGRUPO - S -> IE_TIPO
					insert into protocolo_medicacao(
						cd_protocolo,
						nr_sequencia,
						nr_seq_interna,
						nm_medicacao,
						ie_situacao,
						nr_ciclos,
						nr_seq_apresent,
						dt_atualizacao,
						dt_atualizacao_nrec,
						nm_usuario,
						nm_usuario_nrec
					) values (
						cd_protocolo_w,
						nr_sequencia_w,
						nr_seq_interna_w,
						name_w,
						'A',
						1,
						j,
						clock_timestamp(),
						clock_timestamp(),
						nm_usuario_p,
						nm_usuario_p
					);
	
					-- Add Elsevier data
					insert into protocolo_guia_inf(
						nr_sequencia,
						nr_seq_protocolo,
						nr_seq_protocolo_medic,
						ds_link,
						ie_situacao,
						dt_atualizacao,
						dt_atualizacao_nrec,
						nm_usuario,
						nm_usuario_nrec,
						ie_tipo
					) values (
						nr_seq_guia_inf_w,
						cd_protocolo_w,
						nr_sequencia_w,
						ds_link_w,
						'A',
						clock_timestamp(),
						clock_timestamp(),
						nm_usuario_p,
						nm_usuario_p,
						'S'
					);
	
					folder_subitems_w	:= subitem_w.get('subItems');
	
					-- If we don't find a 'subItems' property, it means we have an empty folder
					if (folder_subitems_w IS NOT NULL AND folder_subitems_w::text <> '') then
						orders_w	:= philips_json_list(subitem_w.get('subItems'));
	
						for k in 1..orders_w.count loop
							order_w	:= philips_json(orders_w.get(k));
	
							-- We expect only orders at this point
							if (order_w.get['type'].get_string() = 'ORDER') then
								if (is_advisory(order_w)) then
									add_advisory(order_w);
								else
                                    exec_elsevier_import_order(substr(order_w.get['name'].get_string(), 1, 250));
								end if;
							end if;
						end loop;
					end if;
				elsif (subitem_w.get['type'].get_string() = 'ORDER') then -- Sometimes we can find orders without a folder
					order_w	:= subitem_w;
	
					if (is_advisory(order_w)) then
						add_advisory(order_w);
					else
						-- If we are not yet working with orders without folder, we create a new protocolo_medicacao to group them within
						if (not without_folder_w) then
							select	nextval('protocolo_medicacao_seq')
							into STRICT	nr_seq_interna_w
							;
						
							nr_sequencia_w		:= get_proto_medic_sequencia(cd_protocolo_w);
							name_w			:= obter_desc_expressao_idioma(342888, null, get_seq_language_establishment(wheb_usuario_pck.get_cd_estabelecimento));
							without_folder_w	:= true;
	
							insert into protocolo_medicacao(
								cd_protocolo,
								nr_sequencia,
								nr_seq_interna,
								nm_medicacao,
								ie_situacao,
								nr_ciclos,
								nr_seq_apresent,
								dt_atualizacao,
								dt_atualizacao_nrec,
								nm_usuario,
								nm_usuario_nrec
							) values (
								cd_protocolo_w,
								nr_sequencia_w,
								nr_seq_interna_w,
								name_w,
								'A',
								1,
								0, -- These must be the first to be shown, the other groups found start from 1, that way coming after this one
								clock_timestamp(),
								clock_timestamp(),
								nm_usuario_p,
								nm_usuario_p
							);
							-- At this point, the subitem_w is our Order
							exec_elsevier_import_order(substr(order_w.get['name'].get_string(), 1, 250));
                        else
                            exec_elsevier_import_order(substr(order_w.get['name'].get_string(), 1, 250));
						end if;
					end if;
				elsif (subitem_w.get['type'].get_string() = 'LINKED_MODULE') then
					nr_sequencia_w	:= get_proto_medic_sequencia(cd_protocolo_w);
	
					--aqui deve inserir na protocolo_modulo
					insert into protocolo_modulo(
						cd_tipo_protocolo,
						ds_titulo,
						nr_sequencia,
						dt_atualizacao,
						nm_usuario,
						dt_atualizacao_nrec,
						nm_usuario_nrec,
						ie_situacao,
						ds_tipo
					) values (
						cd_tipo_protocolo_w,
						subitem_w.get['name'].get_string(),
						nextval('protocolo_modulo_seq'),
						clock_timestamp(),
						nm_usuario_p,
						clock_timestamp(),
						nm_usuario_p,
						'A',
						'P'
					);
				end if;
			end loop;
		end if;
	end if;
end loop;
exception
	when others then
		rollback;
        ie_tipo_erro_p := 'A';
		ds_erro_w := substr(sqlerrm, 1, 255);
        ds_erro_p :=
        '<span class="cad_protocol_erro">'
            || '<span> <b>' || OBTER_DESC_EXPRESSAO(724396) || '</b> ' || title_w            || '</span>'
            || '<span> <b>' || OBTER_DESC_EXPRESSAO(328829) || '</b> ' || ds_protocol_w      || '</span>'
            || '<span> <b>' || OBTER_DESC_EXPRESSAO(310344) || '</b> ' || name_w             || '</span>'
            || '<span> <b>' || OBTER_DESC_EXPRESSAO(606383) || '</b> ' || ds_item_protocol_w || '</span>'
            || '<span> <b>' || ds_erro_w || '</b> </span>'
        || '</span>';
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE elsevier_import_protocol ( ds_json_p text, nm_usuario_p text, ds_erro_p out text, ie_tipo_erro_p out text ) is  ds_protocol_w varchar(255) FROM PUBLIC;

