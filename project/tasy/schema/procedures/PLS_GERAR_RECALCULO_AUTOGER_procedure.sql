-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE table_dados_itens_recalculo AS ( 
	nr_seq_conta		dbms_sql.number_table, 
	nr_seq_conta_proc	dbms_sql.number_table,	 
	qt_item			dbms_sql.number_table, 
	tx_item			dbms_sql.number_table, 
	vl_item			dbms_sql.number_table, 
	vl_item_atual		dbms_sql.number_table, 
	cd_procedimento		dbms_sql.varchar2_table, 
	ie_origem_proced	dbms_sql.number_table, 
	ie_proc_principal	dbms_sql.varchar2_table, 
	nr_sequencia		dbms_sql.number_table, 
	nr_seq_ocorrencia	dbms_sql.number_table, 
	nr_seq_prestador	dbms_sql.number_table 
);


CREATE OR REPLACE PROCEDURE pls_gerar_recalculo_autoger ( nr_sequencia_p pls_lote_recalculo_autoger.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

					
nr_seq_regra_recalc_autoger_w		pls_lote_recalculo_autoger.nr_seq_regra_recalc_autoger%type;
dt_mes_competencia_w			pls_lote_recalculo_autoger.dt_mes_competencia%type;
dt_fim_mes_competencia_w		pls_lote_recalculo_autoger.dt_mes_competencia%type;
tb_itens_recalculo_w			table_dados_itens_recalculo;
tb_atualiza_valor_w			table_dados_itens_recalculo;
ie_tipo_prestador_w			pls_recal_autoger_regra.ie_tipo_prestador%type;
nr_seq_grupo_prest_solic_w		pls_recal_autoger_regra.nr_seq_grupo_prest_solic%type;
cd_procedimento_w			pls_recal_autoger_regra.cd_procedimento%type;
ie_origem_proced_w			pls_recal_autoger_regra.ie_origem_proced%type;
nr_seq_prestador_w			pls_recal_autoger_regra.nr_seq_prestador%type;
nr_seq_prestador_ww			pls_itens_rec_auto.nr_seq_prestador%type;
nr_seq_grupo_prestador_w		pls_recal_autoger_regra.nr_seq_grupo_prestador%type;
cd_especialidade_prest_w		pls_recal_autoger_regra.cd_especialidade_prest%type;		
nr_index_w				integer;
qt_item_princ_executado_w		integer;
cd_procedimento_anterior_w		procedimento.cd_procedimento%type := '';
ie_origem_proced_anterior_w		procedimento.ie_origem_proced%type := -1;
qt_item_exec_w				integer;
tx_aplicar_w				pls_itens_rec_auto.tx_item%type;
ds_sql_w				varchar(4000);		
valor_bind_w				sql_pck.t_dado_bind;
cursor_w				sql_pck.t_cursor;
tb_nr_seq_conta_proc_w			pls_util_cta_pck.t_number_table;
tb_nr_seq_conta_w			pls_util_cta_pck.t_number_table;
tb_qt_item_w				pls_util_cta_pck.t_number_table;
tb_vl_item_w				pls_util_cta_pck.t_number_table;
tb_nr_seq_prestador_w			pls_util_cta_pck.t_number_table;
nr_seq_prest_princ_w			pls_prestador.nr_sequencia%type;
nr_seq_prest_sec_w			pls_prestador.nr_sequencia%type;
nr_seq_prestador_ref_w			pls_prestador.nr_sequencia%type;
ie_principal_w				varchar(1);

c_regras CURSOR(nr_seq_regra_pc		pls_lote_recalculo_autoger.nr_sequencia%type, 
		ie_principal_pc		text) FOR 
	SELECT	cd_procedimento, 
		ie_origem_proced, 
		nr_seq_ocorrencia, 
		max(ie_principal) ie_principal 
	from	pls_regras_recalc_autoger_v 
	where	nr_seq_regra = nr_seq_regra_pc 
	and	ie_principal = ie_principal_pc 
	group by cd_procedimento, ie_origem_proced, nr_seq_ocorrencia 
	
union all
 
	SELECT	cd_procedimento, 
		ie_origem_proced, 
		nr_seq_ocorrencia, 
		max(ie_principal) ie_principal 
	from	pls_regras_recalc_autoger_v 
	where	nr_seq_regra = nr_seq_regra_pc 
	and	coalesce(ie_principal_pc::text, '') = '' 
	group by cd_procedimento, ie_origem_proced, nr_seq_ocorrencia;

c_calculo_valor CURSOR(	nr_seq_lote_pc	pls_lote_recalculo_autoger.nr_sequencia%type, 
			nr_seq_regra_pc pls_lote_recalculo_autoger.nr_seq_regra_recalc_autoger%type) FOR 
	SELECT	nr_sequencia, 
		nr_seq_conta_proc nr_seq_conta_proc, 
		nr_seq_conta, 
		qt_item, 
		cd_procedimento, 
		ie_origem_proced, 
		vl_item_atual, 
		nr_seq_prestador 
	from	pls_itens_rec_auto a 
	where	nr_seq_lote = nr_seq_lote_pc 
	and (	SELECT 	count(1) 
			from 	pls_regras_recalc_autoger_v b 
			where	b.cd_procedimento = a.cd_procedimento 
			and	b.ie_origem_proced = a.ie_origem_proced 
			and	b.ie_principal = 'N' 
			and	b.nr_seq_regra = nr_seq_regra_pc) > 0 
	order by	nr_seq_prestador, cd_procedimento, ie_origem_proced, nr_sequencia;
	
 
c_itens_regra CURSOR( 	nr_seq_regra_pc		pls_regras_recalc_autoger_v.nr_seq_regra%type, 
			cd_procedimento_pc	pls_regras_recalc_autoger_v.cd_procedimento%type, 
			ie_origem_proced_pc	pls_regras_recalc_autoger_v.ie_origem_proced%type) FOR 
	SELECT	tx_item, 
		pr_inicio, 
		pr_fim 
	from	pls_regras_recalc_autoger_v a 
	where	a.nr_seq_regra 		= nr_seq_regra_pc 
	and	a.cd_procedimento	= cd_procedimento_pc 
	and	a.ie_origem_proced 	= ie_origem_proced_pc 
	order by pr_inicio;

c_prest_part CURSOR(	nr_seq_conta_proc_pc		pls_conta_proc.nr_sequencia%type, 
			nr_seq_grupo_prestador_pc	pls_preco_grupo_prestador.nr_sequencia%type) FOR 
	SELECT	a.nr_seq_prestador 
	from	pls_proc_participante a, 
		pls_preco_prestador b 
	where	b.nr_seq_prestador 	= a.nr_seq_prestador 
	and	a.nr_seq_conta_proc 	= nr_seq_conta_proc_pc 
	and	b.nr_seq_grupo 		= nr_seq_grupo_prestador_pc 
	order by nr_seq_prestador;
						
procedure insere_itens_recalculo( 	tb_itens_recalculo_p	in out table_dados_itens_recalculo, 
					nr_sequencia_p		pls_lote_recalculo_autoger.nr_sequencia%type, 
					nm_usuario_p		usuario.nm_usuario%type) is 
;
BEGIN
	if (tb_itens_recalculo_p.nr_seq_conta.count > 0) then	 
		forall i in tb_itens_recalculo_p.nr_seq_conta.first..tb_itens_recalculo_p.nr_seq_conta.last 
			insert into pls_itens_rec_auto(	nr_sequencia, dt_atualizacao, dt_atualizacao_nrec, 
							nm_usuario, nm_usuario_nrec, ie_proc_principal, 
							cd_procedimento, ie_origem_proced, nr_seq_lote, 
							nr_seq_conta, nr_seq_conta_proc, qt_item, 
							tx_item, vl_item, vl_item_atual, 
							nr_seq_ocorrencia, nr_seq_prestador) 
			values (	nextval('pls_itens_rec_auto_seq'), clock_timestamp(), clock_timestamp(), 
				nm_usuario_p, nm_usuario_p, tb_itens_recalculo_p.ie_proc_principal(i), 
				tb_itens_recalculo_p.cd_procedimento(i), tb_itens_recalculo_p.ie_origem_proced(i), nr_sequencia_p, 
				tb_itens_recalculo_p.nr_seq_conta(i), tb_itens_recalculo_p.nr_seq_conta_proc(i), tb_itens_recalculo_p.qt_item(i), 
				tb_itens_recalculo_p.tx_item(i), tb_itens_recalculo_p.vl_item(i), tb_itens_recalculo_p.vl_Item_atual(i), 
				tb_itens_recalculo_p.nr_seq_ocorrencia(i), tb_itens_recalculo_p.nr_seq_prestador(i));
		commit;
		 
		tb_itens_recalculo_p.nr_seq_conta.delete;	
		tb_itens_recalculo_p.nr_seq_conta_proc.delete;
		tb_itens_recalculo_p.qt_item.delete;		
		tb_itens_recalculo_p.tx_item.delete;		
		tb_itens_recalculo_p.vl_item.delete;		
		tb_itens_recalculo_p.vl_item_atual.delete;	
		tb_itens_recalculo_p.cd_procedimento.delete;	
		tb_itens_recalculo_p.ie_origem_proced.delete;
		tb_itens_recalculo_p.ie_proc_principal.delete;
		tb_itens_recalculo_p.nr_seq_ocorrencia.delete;
		tb_itens_recalculo_p.nr_seq_prestador.delete;
	end if;
 
end;
 
function obter_qtde_item_exec(		nr_seq_lote_p		pls_lote_recalculo_autoger.nr_sequencia%type, 
					cd_procedimento_p	procedimento.cd_procedimento%type, 
					ie_origem_proced_p	procedimento.ie_origem_proced%type, 
					nr_seq_prestador_p	pls_itens_rec_auto.nr_seq_prestador%type) 
					return;
					 
begin 
 
select	sum(qt_item) 
into STRICT	qt_proc_exec_w 
from	pls_itens_rec_auto a 
where	a.nr_seq_lote 	 = nr_seq_lote_p 
and	cd_procedimento = cd_procedimento_p 
and	ie_origem_proced = ie_origem_proced_p 
and (nr_seq_prestador = nr_seq_prestador_p or coalesce(nr_seq_prestador_p::text, '') = '');
 
return;
 
end;
 
function obter_taxa_item_recalculo(	cd_procedimento_p		procedimento.cd_procedimento%type, 
					ie_origem_proced_p		procedimento.ie_origem_proced%type, 
					nr_seq_regra_recalc_autoger_p	pls_recal_autoger_regra.nr_sequencia%type, 
					qt_item_princ_executado_p	number, 
					qt_item_exec_p			number, 
					qt_ultimo_item_p		number) 
					return;							
pr_proc_anterior_w		pls_recal_autoger_reg_item.tx_item%type;
pr_proc_atual_w			pls_recal_autoger_reg_item.tx_item%type;
pr_proc_unitario_w		pls_recal_autoger_reg_item.tx_item%type;
pr_perc_fim_anterior_w 	pls_recal_autoger_reg_item.pr_fim%type;
tx_temp_w			pls_recal_autoger_reg_item.tx_item%type;
	 
begin			 
pr_proc_anterior_w 	:= dividir_sem_round(qt_item_exec_p,qt_item_princ_executado_p) * 100;
pr_proc_atual_w	  	:= dividir_sem_round((qt_item_exec_p - qt_ultimo_item_p), qt_item_princ_executado_p) * 100;	
tx_temp_w	  	:= 0;
 
for	r_itens_regra_w in c_itens_regra( nr_seq_regra_recalc_autoger_p, cd_procedimento_p, ie_origem_proced_p) loop 
 
	--Se a quantidade do item que esta sendo verificada é igual a um, então apenas verifica se esta na faiza do item da regra 
	if ( qt_ultimo_item_p = 1) then 
		if ( r_itens_regra_w.pr_inicio <= pr_proc_atual_w and r_itens_regra_w.pr_fim >= pr_proc_atual_w) then 
			 
			tx_aplicar_w := r_itens_regra_w.tx_item;
			exit; -- se obteve a regra, então não prossegue no loop 
		end if;
	else 
		--Verifica em que faixa se encaixaria, caso o item tivesse quantidade =1 
		pr_proc_unitario_w := dividir_sem_round((qt_item_exec_p - qt_ultimo_item_p + 1), qt_item_princ_executado_p) * 100;
 
		 
		--Se o percentual atual esta compreendido na faixa de item de regra atual e caso esse procedimento tivesse quantidade = 1 e mesmo assim ficasse nessa regra, então 
		-- considera essa a taxa válida. 
		if ( r_itens_regra_w.pr_inicio <= pr_proc_atual_w and r_itens_regra_w.pr_fim >= pr_proc_atual_w) then 
 
			--e caso esse procedimento tivesse quantidade = 1 e mesmo assim ficasse nessa regra, então considera essa a taxa válida. 
			if ( r_itens_regra_w.pr_inicio <= pr_proc_unitario_w and r_itens_regra_w.pr_fim >= pr_proc_unitario_w ) then 
			 
				tx_aplicar_w := r_itens_regra_w.tx_item;
				 
			--Nesse caso, verifica aplica o maior percentual entre as duas taxas 
			else 
				if (r_itens_regra_w.tx_item >= tx_temp_w) then 
					tx_aplicar_w := r_itens_regra_w.tx_item;
				else 
					tx_aplicar_w := tx_temp_w;
				end if;
			end if;		
		end if;
	end if;
	tx_temp_w := r_itens_regra_w.tx_item;
end loop;
 
return;
 
end;
 
--Faz update dos itens de recalculo com o valor 
procedure atualiza_valor_itens(	tb_atualiza_valor_p	in out table_dados_itens_recalculo ) is 
 
begin 
 
if ( tb_atualiza_valor_p.nr_sequencia.count > 0) then 
 
	forall i in tb_atualiza_valor_p.nr_sequencia.first..tb_atualiza_valor_p.nr_sequencia.last 
		update 	pls_itens_rec_auto 
		set 	tx_item 	= tb_atualiza_valor_p.tx_item(i), 
			vl_item		= dividir_sem_round((vl_item * tb_atualiza_valor_p.tx_item(i)), 100) 
		where	nr_sequencia 	= tb_atualiza_valor_p.nr_sequencia(i);
	commit;
	 
	tb_atualiza_valor_p.tx_item.delete;
	tb_atualiza_valor_p.nr_sequencia.delete;
 
end if;
 
end;
 
--Realiza delete da tabela pls_itens_rec_auto caso haja contas duplicadas 
procedure deleta_contas_duplicadas(nr_seq_lote_p		pls_lote_recalculo_autoger.nr_sequencia%type) is 
 
C01 CURSOR FOR 
	SELECT 	nr_seq_conta_proc, 
		max(nr_seq_lote) nr_seq_lote, 
		max(nr_sequencia) nr_sequencia, 
		max(nr_seq_prestador) nr_seq_prestador 
	from 	pls_itens_rec_auto 
	where 	nr_seq_lote = nr_seq_lote_p	 
	group by nr_seq_conta_proc 
	having	count(*) > 1;
			 
begin 
for r_C01_w in C01 loop 
	begin	 
	delete	FROM pls_itens_rec_auto 
	where	nr_sequencia 		!= r_C01_w.nr_sequencia 
	and	nr_seq_conta_proc 	= r_c01_w.nr_seq_conta_proc 
	and	nr_seq_lote		= r_c01_w.nr_seq_lote 
	and	nr_seq_prestador	= r_c01_w.nr_seq_prestador;
	end;
end loop;
 
commit;
 
end;
 
function obter_select_autoger(	nr_seq_regra_p			in	pls_recal_autoger_regra.nr_sequencia%type, 
				ie_tipo_prestador_p		in	pls_recal_autoger_regra.ie_tipo_prestador%type, 
				nr_seq_prestador_p		in	pls_recal_autoger_regra.nr_seq_prestador%type, 
				nr_seq_grupo_prestador_p	in	pls_recal_autoger_regra.nr_seq_grupo_prestador%type, 
				cd_especialidade_prest_p	in	pls_recal_autoger_regra.cd_especialidade_prest%type, 
				nr_seq_grupo_prest_solic_p	in	pls_recal_autoger_regra.nr_seq_grupo_prest_solic%type, 
				cd_procedimento_p		in	pls_recal_autoger_regra.cd_procedimento%type, 
				ie_origem_proced_p		in	pls_recal_autoger_regra.ie_origem_proced%type, 
				dt_mes_competencia_p		in	pls_lote_recalculo_autoger.dt_mes_competencia%type, 
				dt_fim_mes_competencia_p	in	pls_lote_recalculo_autoger.dt_mes_competencia%type, 
				valor_bind_p			in out	sql_pck.t_dado_bind)  
				return;
ds_sql_w			varchar2(4000);
ds_tabelas_w			varchar2(1000);
ds_campos_w			varchar2(1000);
dados_restricao_w		pls_util_pck.dados_select;
 
begin 
-- Inicia as variáveis 
ds_campos_w := null;
ds_tabelas_w := null;
ds_sql_w := null;
dados_restricao_w.ds_campos := null;
dados_restricao_w.ds_tabelas := null;
dados_restricao_w.ds_restricao := null;
 
-- Verifica se a regra está vigente 
select	count(1) 
into STRICT	qt_regra_w 
from	pls_recal_autoger_regra 
where	nr_sequencia = nr_seq_regra_p 
and	clock_timestamp() between dt_inicio_vigencia and coalesce(dt_fim_vigencia, clock_timestamp());
 
if (qt_regra_w > 0) then 
	 
	-- Presatdor atendimento 
	if (ie_tipo_prestador_w = 'A') then 
		-- Alimenta o prestador de atendimento (protocolo) 
		ds_campos_w := ' c.nr_seq_prestador ';
		 
		-- Caso tenha informado um grupo de prestadores solicitante 
		-- deve retornar somente as contas que foram solicitadas pelos prestadores desse grupo 
		if (nr_seq_grupo_prest_solic_p IS NOT NULL AND nr_seq_grupo_prest_solic_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_preco_prestador d ' || pls_util_pck.enter_w || 
							'				where	d.nr_seq_prestador = b.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	d.nr_seq_grupo = :nr_seq_grupo_prestador_solic) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_grupo_prestador_solic', nr_seq_grupo_prest_solic_p, valor_bind_p);
		-- Caso não seja informado o grupo de prestador solicitante 
		-- o prestador solicitante da conta deve ser igual ao prestador de atendimento 
		else 
			dados_restricao_w := pls_util_pck.sql_restricao('and c.nr_seq_prestador = b.nr_seq_prestador', dados_restricao_w);
		end if;
		-- Caso informado o prestador na regra, deve retornar 
		-- as contas no qual o prestador de atendimento é igual ao da regra 
		if (nr_seq_prestador_p IS NOT NULL AND nr_seq_prestador_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao('and c.nr_seq_prestador = :nr_seq_prestador', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_prestador', nr_seq_prestador_p, valor_bind_p);
		end if;
		-- Caso informado um grupo de prestadores, deve retornar as contas 
		-- no qual os prestadores desse grupo são prestadores de atendimento 
		if (nr_seq_grupo_prestador_p IS NOT NULL AND nr_seq_grupo_prestador_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_preco_prestador d ' || pls_util_pck.enter_w || 
							'				where	d.nr_seq_prestador = c.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	d.nr_seq_grupo = :nr_seq_grupo_prestador) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_grupo_prestador', nr_seq_grupo_prestador_p, valor_bind_p);
		end if;
		-- Caso iformado uma especialidade, deve retornar todas as contas 
		-- que o prestador de atendimento possui a especialidade informada 
		if (cd_especialidade_prest_p IS NOT NULL AND cd_especialidade_prest_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_prestador_med_espec d ' || pls_util_pck.enter_w || 
							'				where	d.nr_seq_prestador = c.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	d.cd_especialidade = :cd_especialidade_prest) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':cd_especialidade_prest', cd_especialidade_prest_p, valor_bind_p);		
		end if;
	-- Prestador executor 
	elsif (ie_tipo_prestador_w = 'E') then 
		 
		-- Alimenta o prestador executor 
		ds_campos_w := ' b.nr_seq_prestador_exec nr_seq_prestador ';
		 
		-- Caso tenha informado um grupo de prestadores solicitante 
		-- deve retornar somente as contas que foram solicitadas pelos prestadores desse grupo 
		if (nr_seq_grupo_prest_solic_p IS NOT NULL AND nr_seq_grupo_prest_solic_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_preco_prestador d ' || pls_util_pck.enter_w || 
							'				where	d.nr_seq_prestador = b.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	d.nr_seq_grupo = :nr_seq_grupo_prestador_solic) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_grupo_prestador_solic', nr_seq_grupo_prest_solic_p, valor_bind_p);
		-- Caso não seja informado o grupo de prestador solicitante 
		-- o prestador solicitante da conta deve ser igual ao prestador executor 
		else 
			dados_restricao_w := pls_util_pck.sql_restricao('and b.nr_seq_prestador_exec = b.nr_seq_prestador', dados_restricao_w);
		end if;
		-- Caso informado o prestador na regra, deve retornar 
		-- as contas no qual o prestador executor é igual ao da regra 
		if (nr_seq_prestador_p IS NOT NULL AND nr_seq_prestador_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao('and b.nr_seq_prestador_exec = :nr_seq_prestador', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_prestador', nr_seq_prestador_p, valor_bind_p);
		end if;
		-- Caso informado um grupo de prestadores, deve retornar as contas 
		-- que o prestador executor fazem parte do grupo informado 
		if (nr_seq_grupo_prestador_p IS NOT NULL AND nr_seq_grupo_prestador_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_preco_prestador d ' || pls_util_pck.enter_w || 
							'				where	d.nr_seq_prestador = b.nr_seq_prestador_exec ' || pls_util_pck.enter_w || 
							'				and	d.nr_seq_grupo = :nr_seq_grupo_prestador) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_grupo_prestador', nr_seq_grupo_prestador_p, valor_bind_p);
		end if;
		-- Caso iformado uma especialidade, deve retornar todas as contas 
		-- que o prestador executor possui a especialidade informada 
		if (cd_especialidade_prest_p IS NOT NULL AND cd_especialidade_prest_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_prestador_med_espec d ' || pls_util_pck.enter_w || 
							'				where	d.nr_seq_prestador = b.nr_seq_prestador_exec ' || pls_util_pck.enter_w || 
							'				and	d.cd_especialidade = :cd_especialidade_prest) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':cd_especialidade_prest', cd_especialidade_prest_p, valor_bind_p);		
		end if;
	-- Prestador participante 
	elsif (ie_tipo_prestador_w = 'P') then 
		-- Alimenta o prestador poarticipante 
		ds_campos_w := ' d.nr_seq_prestador ';
		-- Adiciona a tabela de participantes ao select 
		ds_tabelas_w := ', pls_proc_participante d ';
		-- Adiciona a restrição devido a nova tabela 
		dados_restricao_w := pls_util_pck.sql_restricao('and d.nr_seq_conta_proc = a.nr_sequencia ', dados_restricao_w);
		-- Caso tenha informado um grupo de prestadores solicitante 
		-- deve retornar somente as contas que foram solicitadas pelos prestadores desse grupo 
		if (nr_seq_grupo_prest_solic_p IS NOT NULL AND nr_seq_grupo_prest_solic_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_preco_prestador e ' || pls_util_pck.enter_w || 
							'				where	e.nr_seq_prestador = b.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	e.nr_seq_grupo = :nr_seq_grupo_prestador_solic) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_grupo_prestador_solic', nr_seq_grupo_prest_solic_p, valor_bind_p);
		-- Caso não seja informado o grupo de prestador solicitante 
		-- o prestador solicitante da conta deve ser igual ao prestador participante 
		else 
			dados_restricao_w := pls_util_pck.sql_restricao('and b.nr_seq_prestador = d.nr_seq_prestador', dados_restricao_w);
		end if;
		-- Caso informado o prestador na regra, deve retornar 
		-- as contas no qual o prestador participante é igual ao da regra		 
		if (nr_seq_prestador_p IS NOT NULL AND nr_seq_prestador_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao('and d.nr_seq_prestador = :nr_seq_prestador', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_prestador', nr_seq_prestador_p, valor_bind_p);
		end if;
		-- Caso informado um grupo de prestadores, deve retornar as contas 
		-- que o prestador participante fazem parte do grupo informado 
		if (nr_seq_grupo_prestador_p IS NOT NULL AND nr_seq_grupo_prestador_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_preco_prestador e ' || pls_util_pck.enter_w || 
							'				where	e.nr_seq_prestador = d.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	e.nr_seq_grupo = :nr_seq_grupo_prestador) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':nr_seq_grupo_prestador', nr_seq_grupo_prestador_p, valor_bind_p);
		end if;
		-- Caso iformado uma especialidade, deve retornar todas as contas 
		-- que o prestador executor possui a especialidade informada 
		if (cd_especialidade_prest_p IS NOT NULL AND cd_especialidade_prest_p::text <> '') then 
			dados_restricao_w := pls_util_pck.sql_restricao(	'	and	exists (	select	1 ' || pls_util_pck.enter_w || 
							'				from	pls_prestador_med_espec e ' || pls_util_pck.enter_w || 
							'				where	e.nr_seq_prestador = d.nr_seq_prestador ' || pls_util_pck.enter_w || 
							'				and	e.cd_especialidade = :cd_especialidade_prest) ', dados_restricao_w);
			valor_bind_p := sql_pck.bind_variable(':cd_especialidade_prest', cd_especialidade_prest_p, valor_bind_p);		
		end if;
	end if;
	-- Concatena o select com os campos, tabelas e restrição 
	ds_sql_w := 	'	select	a.nr_sequencia nr_seq_conta_proc, ' || pls_util_pck.enter_w || 
			'		a.nr_seq_conta nr_seq_conta, ' || pls_util_pck.enter_w || 
			'		a.qt_procedimento, ' || pls_util_pck.enter_w || 
			'		a.vl_liberado, ' || pls_util_pck.enter_w || 
			ds_campos_w || pls_util_pck.enter_w || 
			'	from	pls_conta_proc a, ' || pls_util_pck.enter_w || 
			'		pls_conta b, ' || pls_util_pck.enter_w || 
			'		pls_protocolo_conta c ' || pls_util_pck.enter_w || 
			ds_tabelas_w || pls_util_pck.enter_w || 
			'	where	b.nr_sequencia = a.nr_seq_conta ' || pls_util_pck.enter_w || 
			'	and	c.nr_sequencia = b.nr_seq_protocolo ' || pls_util_pck.enter_w || 
			'	and	c.dt_mes_competencia between :dt_inicio_competencia and :dt_fim_competencia ' || pls_util_pck.enter_w || 
			'	and	c.ie_situacao in (''D'',''T'') ' || pls_util_pck.enter_w || 
			'	and	b.ie_status = ''F'' ' || pls_util_pck.enter_w || 
			'	and	a.ie_status <> ''D'' ' || pls_util_pck.enter_w || 
			'	and	a.qt_procedimento > 0 ' || pls_util_pck.enter_w || 
			'	and	a.cd_procedimento = :cd_procedimento ' || pls_util_pck.enter_w || 
			'	and	a.ie_origem_proced = :ie_origem_proced ' || pls_util_pck.enter_w || 
			dados_restricao_w.ds_restricao;
			 
	valor_bind_p := sql_pck.bind_variable(':dt_inicio_competencia', dt_mes_competencia_p, valor_bind_p);
	valor_bind_p := sql_pck.bind_variable(':dt_fim_competencia', dt_fim_mes_competencia_p, valor_bind_p);
	valor_bind_p := sql_pck.bind_variable(':cd_procedimento', cd_procedimento_p, valor_bind_p);
	valor_bind_p := sql_pck.bind_variable(':ie_origem_proced', ie_origem_proced_p, valor_bind_p);
end if;
 
return;
 
end;
			 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	 
-------------------------------------------------------------------------------INÍCIO DA ROTINA-------------------------------------------------------------------------------- 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	 
begin 
valor_bind_w.delete;
 
--Busca informações do lote de recálculo que esta sendo processado 
select	trunc(dt_mes_competencia,'month') dt_mes_competencia, 
	fim_mes(dt_mes_competencia) dt_fim_mes_competencia, 
	nr_seq_regra_recalc_autoger 
into STRICT	dt_mes_competencia_w, 
	dt_fim_mes_competencia_w, 
	nr_seq_regra_recalc_autoger_w 
from	pls_lote_recalculo_autoger 
where	nr_sequencia = nr_sequencia_p;
 
--Regra de recálculo(Cadastro de regras/OPS - Rede credenciada/Autogerado/Recálculo autogerado) 
begin 
	select	ie_tipo_prestador, 
		cd_procedimento, 
		ie_origem_proced, 
		nr_seq_prestador, 
		nr_seq_grupo_prestador, 
		cd_especialidade_prest, 
		nr_seq_grupo_prest_solic, 
		nr_seq_prest_princ, 
		nr_seq_prest_sec 
	into STRICT	ie_tipo_prestador_w, 
		cd_procedimento_w, 
		ie_origem_proced_w, 
		nr_seq_prestador_w, 
		nr_seq_grupo_prestador_w, 
		cd_especialidade_prest_w, 
		nr_seq_grupo_prest_solic_w, 
		nr_seq_prest_princ_w, 
		nr_seq_prest_sec_w 
	from	pls_recal_autoger_regra 
	where 	nr_sequencia = nr_seq_regra_recalc_autoger_w 
	and	clock_timestamp() between dt_inicio_vigencia and coalesce(dt_fim_vigencia, clock_timestamp());
exception 
when others then 
		ie_tipo_prestador_w 		:= null;
		cd_procedimento_w 		:= null;
		ie_origem_proced_w		:= null;
		nr_seq_prestador_w		:= null;
		nr_seq_grupo_prestador_w	:= null;
		cd_especialidade_prest_w	:= null;
end;
 
nr_index_w := 0;
ie_principal_w := null;
 
if (nr_seq_prest_princ_w IS NOT NULL AND nr_seq_prest_princ_w::text <> '') and (nr_seq_prest_sec_w IS NOT NULL AND nr_seq_prest_sec_w::text <> '') then 
	ie_principal_w := 'N';
	ds_sql_w := obter_select_autoger(	nr_seq_regra_recalc_autoger_w, ie_tipo_prestador_w, nr_seq_prest_princ_w, 
						nr_seq_grupo_prestador_w, cd_especialidade_prest_w, nr_seq_grupo_prest_solic_w, 
						cd_procedimento_w, ie_origem_proced_w, dt_mes_competencia_w, 
						dt_fim_mes_competencia_w, valor_bind_w);
						 
	if (ds_sql_w IS NOT NULL AND ds_sql_w::text <> '') then 
		 
		valor_bind_w := sql_pck.executa_sql_cursor(ds_sql_w, valor_bind_w);	
		 
		loop 
			 
			fetch cursor_w bulk collect into 
				tb_nr_seq_conta_proc_w, tb_nr_seq_conta_w, tb_qt_item_w, 
				tb_vl_item_w, tb_nr_seq_prestador_w		 
			limit pls_util_cta_pck.qt_registro_transacao_w;
			 
			exit when tb_nr_seq_conta_proc_w.count = 0;
			 
			for i in tb_nr_seq_conta_proc_w.first .. tb_nr_seq_conta_proc_w.last loop 
				 
				tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w)	:= tb_nr_seq_conta_proc_w(i);
				tb_itens_recalculo_w.nr_seq_conta(nr_index_w)		:= tb_nr_seq_conta_w(i);
				tb_itens_recalculo_w.qt_item(nr_index_w)		:= tb_qt_item_w(i);
				tb_itens_recalculo_w.tx_item(nr_index_w)		:= 100;
				tb_itens_recalculo_w.vl_item(nr_index_w)		:= tb_vl_item_w(i);
				tb_itens_recalculo_w.vl_item_atual(nr_index_w)		:= tb_vl_item_w(i);
				tb_itens_recalculo_w.nr_seq_prestador(nr_index_w)	:= tb_nr_seq_prestador_w(i);
				tb_itens_recalculo_w.cd_procedimento(nr_index_w)	:= cd_procedimento_w;
				tb_itens_recalculo_w.ie_origem_proced(nr_index_w) 	:= ie_origem_proced_w;
				tb_itens_recalculo_w.ie_proc_principal(nr_index_w) 	:= 'S';
				tb_itens_recalculo_w.nr_seq_ocorrencia(nr_index_w) 	:= null;
				 
				if (ie_tipo_prestador_w = 'P') then 
					 
					for r_prest_part_w in c_prest_part(tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w), nr_seq_grupo_prestador_w) loop 
					 
						tb_itens_recalculo_w.nr_seq_conta(nr_index_w)	  := tb_nr_seq_conta_w(i);	
						tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w) := tb_nr_seq_conta_proc_w(i);	
						tb_itens_recalculo_w.qt_item(nr_index_w)	  := tb_qt_item_w(i);           	
						tb_itens_recalculo_w.tx_item(nr_index_w)	  := 100;            	
						tb_itens_recalculo_w.vl_item(nr_index_w)	  := tb_vl_item_w(i);           	
						tb_itens_recalculo_w.vl_item_atual(nr_index_w)	  := tb_vl_item_w(i);	
						tb_itens_recalculo_w.cd_procedimento(nr_index_w)  := cd_procedimento_w;            	
						tb_itens_recalculo_w.ie_origem_proced(nr_index_w) := ie_origem_proced_w;	
						tb_itens_recalculo_w.ie_proc_principal(nr_index_w) := 'S';	
						tb_itens_recalculo_w.nr_seq_ocorrencia(nr_index_w) := null;
						tb_itens_recalculo_w.nr_seq_prestador(nr_index_w) := r_prest_part_w.nr_seq_prestador;
						 
						if (nr_index_w > pls_util_pck.qt_registro_transacao_w ) then 
							 
							--Faz o insert dos registros na pls_itens_rec_auto 
							insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
							nr_index_w := 0;
						else 
							nr_index_w := nr_index_w + 1;
						end if;
					end loop;
				end if;
				if (nr_index_w >= pls_util_pck.qt_registro_transacao_w) then 
					--Faz o insert dos registros na pls_itens_rec_auto 
					insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
					nr_index_w := 0;
				else 
					nr_index_w := nr_index_w + 1;
				end if;
			end loop;
		end loop;
	end if;
	 
	for r_Regras_w in c_regras( nr_seq_regra_recalc_autoger_w, ie_principal_w ) loop 
		ds_sql_w := obter_select_autoger(	nr_seq_regra_recalc_autoger_w, ie_tipo_prestador_w, nr_seq_prest_sec_w, 
							nr_seq_grupo_prestador_w, cd_especialidade_prest_w, nr_seq_grupo_prest_solic_w, 
							r_Regras_w.cd_procedimento, r_Regras_w.ie_origem_proced, dt_mes_competencia_w, 
							dt_fim_mes_competencia_w, valor_bind_w);
							 
		if (ds_sql_w IS NOT NULL AND ds_sql_w::text <> '') then 
			 
			valor_bind_w := sql_pck.executa_sql_cursor(ds_sql_w, valor_bind_w);	
			 
			loop 
				 
				fetch cursor_w bulk collect into 
					tb_nr_seq_conta_proc_w, tb_nr_seq_conta_w, tb_qt_item_w, 
					tb_vl_item_w, tb_nr_seq_prestador_w		 
				limit pls_util_cta_pck.qt_registro_transacao_w;
				 
				exit when tb_nr_seq_conta_proc_w.count = 0;
				 
				for i in tb_nr_seq_conta_proc_w.first .. tb_nr_seq_conta_proc_w.last loop 
					 
					tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w)	:= tb_nr_seq_conta_proc_w(i);
					tb_itens_recalculo_w.nr_seq_conta(nr_index_w)		:= tb_nr_seq_conta_w(i);
					tb_itens_recalculo_w.qt_item(nr_index_w)		:= tb_qt_item_w(i);
					tb_itens_recalculo_w.tx_item(nr_index_w)		:= 100;
					tb_itens_recalculo_w.vl_item(nr_index_w)		:= tb_vl_item_w(i);
					tb_itens_recalculo_w.vl_item_atual(nr_index_w)		:= tb_vl_item_w(i);
					tb_itens_recalculo_w.nr_seq_prestador(nr_index_w)	:= tb_nr_seq_prestador_w(i);
					tb_itens_recalculo_w.cd_procedimento(nr_index_w)	:= r_Regras_w.cd_procedimento;
					tb_itens_recalculo_w.ie_origem_proced(nr_index_w) 	:= r_Regras_w.ie_origem_proced;
					tb_itens_recalculo_w.ie_proc_principal(nr_index_w) 	:= r_Regras_w.ie_principal;
					tb_itens_recalculo_w.nr_seq_ocorrencia(nr_index_w) 	:= r_Regras_w.nr_seq_ocorrencia;
					 
					if (ie_tipo_prestador_w = 'P') then 
						 
						for r_prest_part_w in c_prest_part(tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w), nr_seq_grupo_prestador_w) loop 
						 
							tb_itens_recalculo_w.nr_seq_conta(nr_index_w)	  := tb_nr_seq_conta_w(i);	
							tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w) := tb_nr_seq_conta_proc_w(i);	
							tb_itens_recalculo_w.qt_item(nr_index_w)	  := tb_qt_item_w(i);           	
							tb_itens_recalculo_w.tx_item(nr_index_w)	  := 100;            	
							tb_itens_recalculo_w.vl_item(nr_index_w)	  := tb_vl_item_w(i);           	
							tb_itens_recalculo_w.vl_item_atual(nr_index_w)	  := tb_vl_item_w(i);	
							tb_itens_recalculo_w.cd_procedimento(nr_index_w)  := r_Regras_w.cd_procedimento;            	
							tb_itens_recalculo_w.ie_origem_proced(nr_index_w) := r_Regras_w.ie_origem_proced;	
							tb_itens_recalculo_w.ie_proc_principal(nr_index_w) := r_Regras_w.ie_principal;	
							tb_itens_recalculo_w.nr_seq_ocorrencia(nr_index_w) := r_Regras_w.nr_seq_ocorrencia;
							tb_itens_recalculo_w.nr_seq_prestador(nr_index_w) := r_prest_part_w.nr_seq_prestador;
							 
							if (nr_index_w > pls_util_pck.qt_registro_transacao_w ) then 
								 
								--Faz o insert dos registros na pls_itens_rec_auto 
								insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
								nr_index_w := 0;
							else 
								nr_index_w := nr_index_w + 1;
							end if;
						end loop;
					end if;
					if (nr_index_w >= pls_util_pck.qt_registro_transacao_w) then 
						--Faz o insert dos registros na pls_itens_rec_auto 
						insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
						nr_index_w := 0;
					else 
						nr_index_w := nr_index_w + 1;
					end if;
				end loop;
			end loop;
		end if;
	end loop;
else 
	--Cursor dos procedimentos, aqui irá levantar as contas/procedimentos que irão para o recalculo 
	for r_Regras_w in c_regras( nr_seq_regra_recalc_autoger_w, ie_principal_w ) loop 
		 
		ds_sql_w := obter_select_autoger(	nr_seq_regra_recalc_autoger_w, ie_tipo_prestador_w, nr_seq_prestador_w, 
							nr_seq_grupo_prestador_w, cd_especialidade_prest_w, nr_seq_grupo_prest_solic_w, 
							r_Regras_w.cd_procedimento, r_Regras_w.ie_origem_proced, dt_mes_competencia_w, 
							dt_fim_mes_competencia_w, valor_bind_w);
		 
		if (ds_sql_w IS NOT NULL AND ds_sql_w::text <> '') then 
		 
			valor_bind_w := sql_pck.executa_sql_cursor(ds_sql_w, valor_bind_w);
				 
			loop	 
				fetch cursor_w bulk collect into 
					tb_nr_seq_conta_proc_w, tb_nr_seq_conta_w, tb_qt_item_w, 
					tb_vl_item_w, tb_nr_seq_prestador_w		 
				limit pls_util_cta_pck.qt_registro_transacao_w;
				 
				exit when tb_nr_seq_conta_proc_w.count = 0;
				 
				for i in tb_nr_seq_conta_proc_w.first .. tb_nr_seq_conta_proc_w.last loop 
				 
					tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w)	:= tb_nr_seq_conta_proc_w(i);
					tb_itens_recalculo_w.nr_seq_conta(nr_index_w)		:= tb_nr_seq_conta_w(i);
					tb_itens_recalculo_w.qt_item(nr_index_w)		:= tb_qt_item_w(i);
					tb_itens_recalculo_w.tx_item(nr_index_w)		:= 100;
					tb_itens_recalculo_w.vl_item(nr_index_w)		:= tb_vl_item_w(i);
					tb_itens_recalculo_w.vl_item_atual(nr_index_w)		:= tb_vl_item_w(i);
					tb_itens_recalculo_w.nr_seq_prestador(nr_index_w)	:= tb_nr_seq_prestador_w(i);
					tb_itens_recalculo_w.cd_procedimento(nr_index_w)	:= r_Regras_w.cd_procedimento;
					tb_itens_recalculo_w.ie_origem_proced(nr_index_w) 	:= r_Regras_w.ie_origem_proced;
					tb_itens_recalculo_w.ie_proc_principal(nr_index_w) 	:= r_Regras_w.ie_principal;
					tb_itens_recalculo_w.nr_seq_ocorrencia(nr_index_w) 	:= r_Regras_w.nr_seq_ocorrencia;
					 
					if (ie_tipo_prestador_w = 'P') then 
				 
						for r_prest_part_w in c_prest_part(tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w), nr_seq_grupo_prestador_w) loop 
						 
							tb_itens_recalculo_w.nr_seq_conta(nr_index_w)	  := tb_nr_seq_conta_w(i);	
							tb_itens_recalculo_w.nr_seq_conta_proc(nr_index_w) := tb_nr_seq_conta_proc_w(i);	
							tb_itens_recalculo_w.qt_item(nr_index_w)	  := tb_qt_item_w(i);           	
							tb_itens_recalculo_w.tx_item(nr_index_w)	  := 100;            	
							tb_itens_recalculo_w.vl_item(nr_index_w)	  := tb_vl_item_w(i);           	
							tb_itens_recalculo_w.vl_item_atual(nr_index_w)	  := tb_vl_item_w(i);	
							tb_itens_recalculo_w.cd_procedimento(nr_index_w)  := r_Regras_w.cd_procedimento;            	
							tb_itens_recalculo_w.ie_origem_proced(nr_index_w) := r_Regras_w.ie_origem_proced;	
							tb_itens_recalculo_w.ie_proc_principal(nr_index_w) := r_Regras_w.ie_principal;	
							tb_itens_recalculo_w.nr_seq_ocorrencia(nr_index_w) := r_Regras_w.nr_seq_ocorrencia;
							tb_itens_recalculo_w.nr_seq_prestador(nr_index_w) := r_prest_part_w.nr_seq_prestador;
							 
							if (nr_index_w > pls_util_pck.qt_registro_transacao_w ) then 
								 
								--Faz o insert dos registros na pls_itens_rec_auto 
								insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
								nr_index_w := 0;
							else 
								nr_index_w := nr_index_w + 1;
							end if;
						end loop;
					end if;
					if (nr_index_w >= pls_util_pck.qt_registro_transacao_w) then 
						--Faz o insert dos registros na pls_itens_rec_auto 
						insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
						nr_index_w := 0;
					else 
						nr_index_w := nr_index_w + 1;
					end if;
				end loop;		
			end loop;
		end if;
	end loop;
end if;
 
--Faz o insert dos registros na pls_itens_rec_auto, pois pode ter sobrado registros para mandar para o banco 
insere_itens_recalculo(tb_itens_recalculo_w, nr_sequencia_p, nm_usuario_p);
 
--Deleta as contas duplicadas devido as configurações de regras 
deleta_contas_duplicadas(nr_sequencia_p);
 
--Obtém a quantidade de execuções do item principal da regra(Utiliza a tabela pls_itens_rec_auto como massa de dados ) 
--qt_item_princ_executado_w	:= obter_qtde_item_exec(nr_sequencia_p, cd_procedimento_w, ie_origem_proced_w); 
 
--Primeiramente, obtém a taxa que será aplicada a cada item de recalculo. 
nr_index_w := 0;
for r_calculo_valor_w in c_calculo_valor( nr_sequencia_p, nr_seq_regra_recalc_autoger_w) loop 
	 
	--Para zerar a totalização de itens. 
	if (r_calculo_valor_w.cd_procedimento <> cd_procedimento_anterior_w or r_calculo_valor_w.ie_origem_proced <> ie_origem_proced_anterior_w) then 
		qt_item_exec_w 			:= 0;
		cd_procedimento_anterior_w 	:= r_calculo_valor_w.cd_procedimento;
		ie_origem_proced_anterior_w 	:= r_calculo_valor_w.ie_origem_proced;
	end if;
	 
	if (nr_seq_grupo_prestador_w IS NOT NULL AND nr_seq_grupo_prestador_w::text <> '') or (cd_especialidade_prest_w IS NOT NULL AND cd_especialidade_prest_w::text <> '') then	 
		--Obtém a quantidade de execuções do item principal da regra(Utiliza a tabela pls_itens_rec_auto como massa de dados ) 
		qt_item_princ_executado_w	:= obter_qtde_item_exec(nr_sequencia_p, cd_procedimento_w, ie_origem_proced_w, 
									r_calculo_valor_w.nr_seq_prestador);
		 
		if (nr_seq_prestador_ww <> r_calculo_valor_w.nr_seq_prestador or coalesce(nr_seq_prestador_ww::text, '') = '') then 
			qt_item_exec_w := 1;
		else 
			qt_item_exec_w 	:= qt_item_exec_w + r_calculo_valor_w.qt_item;
		end if;
		 
		tx_aplicar_w 	:= obter_taxa_item_recalculo(r_calculo_valor_w.cd_procedimento, r_calculo_valor_w.ie_origem_proced, nr_seq_regra_recalc_autoger_w, 
							qt_item_princ_executado_w, qt_item_exec_w, r_calculo_valor_w.qt_item);
		 
		tb_atualiza_valor_w.nr_sequencia(nr_index_w) 	:= r_calculo_valor_w.nr_sequencia;
		tb_atualiza_valor_w.tx_item(nr_index_w)		:= tx_aplicar_w;
 
		if (nr_index_w > pls_util_pck.qt_registro_transacao_w ) then 
			atualiza_valor_itens(tb_atualiza_valor_w);
			nr_index_w := 0;
		end if;
		 
		nr_index_w := nr_index_w + 1;
		nr_seq_prestador_ww := r_calculo_valor_w.nr_seq_prestador;
	else 
		if (nr_seq_prest_princ_w IS NOT NULL AND nr_seq_prest_princ_w::text <> '') then 
			nr_seq_prestador_ref_w := nr_seq_prest_princ_w;
		else 
			nr_seq_prestador_ref_w := r_calculo_valor_w.nr_seq_prestador;
		end if;
		--Obtém a quantidade de execuções do item principal da regra(Utiliza a tabela pls_itens_rec_auto como massa de dados ) 
		qt_item_princ_executado_w	:= obter_qtde_item_exec(nr_sequencia_p, cd_procedimento_w, ie_origem_proced_w, 
									r_calculo_valor_w.nr_seq_prestador);
									 
		qt_item_exec_w 	:= qt_item_exec_w + r_calculo_valor_w.qt_item;
 
		tx_aplicar_w 	:= obter_taxa_item_recalculo(r_calculo_valor_w.cd_procedimento, r_calculo_valor_w.ie_origem_proced, nr_seq_regra_recalc_autoger_w, 
							qt_item_princ_executado_w, qt_item_exec_w, r_calculo_valor_w.qt_item);
			 
		tb_atualiza_valor_w.nr_sequencia(nr_index_w) 	:= r_calculo_valor_w.nr_sequencia;
		tb_atualiza_valor_w.tx_item(nr_index_w)		:= tx_aplicar_w;
 
		if (nr_index_w > pls_util_pck.qt_registro_transacao_w ) then 
			 
			atualiza_valor_itens(tb_atualiza_valor_w);
			nr_index_w := 0;
		end if;
 
		nr_index_w := nr_index_w + 1;
	end if;
end loop;
 
atualiza_valor_itens(tb_atualiza_valor_w);
 
--Para impedir a reexecução da geração antes de desfazer execução anterior.	 
update pls_lote_recalculo_autoger set dt_geracao_lote = clock_timestamp() where nr_sequencia = nr_sequencia_p;
commit;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_recalculo_autoger ( nr_sequencia_p pls_lote_recalculo_autoger.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

