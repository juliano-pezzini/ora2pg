-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE reg_inco_benef_conf AS (nr_seq_segurado bigint, cd_inconsistencia bigint);


CREATE OR REPLACE PROCEDURE pls_consistir_lote_sib_conf ( nr_seq_lote_sib_p bigint, cd_estabelecimento_p bigint, nm_usuario_p text) AS $body$
DECLARE


nr_cpf_w			varchar(20);
dt_cancelamento_w		timestamp;
dt_reinclusao_w			timestamp;
nr_seq_segurado_w		bigint;
cd_usuario_plano_w		varchar(30);
cd_plano_ans_w			varchar(30);
cd_plano_ans_pre_w		varchar(30);
ie_tipo_reg_w			bigint;
nr_cco_w			bigint;
ie_digito_cco_w			bigint;
CD_CGC_ESTIPULANTE_w		varchar(30);
CD_USUARIO_PLANO_SUP_w		varchar(30);
cd_motivo_cancelamento_w	bigint;
------------------------------------------------------------------------------
nr_seq_retorno_sib_w		bigint;
nr_seq_motivo_cancelamento_w	bigint;
dt_exclusao_w			timestamp;
ie_tipo_registro_w		bigint;

nr_seq_lote_conf_w		bigint;
qt_registros_w			bigint;

nr_vetor_w			bigint;
j				bigint;
qt_benef_inco_w			bigint;
qt_registros_inconsistentes_w	bigint;
nr_sequencia_w			bigint;
type vetor is table of reg_inco_benef_conf index by integer;
vetor_w				vetor;

C01 CURSOR FOR
	SELECT	nr_cpf,
		dt_cancelamento,
		dt_reinclusao,
		nr_seq_segurado,
		cd_usuario_plano,
		cd_plano_ans,
		cd_plano_ans_pre,
		ie_tipo_reg,
		nr_cco,
		ie_digito_cco,
		CD_CGC_ESTIPULANTE,
		CD_USUARIO_PLANO_SUP,
		cd_motivo_cancelamento
	from	pls_interf_sib
	where	nr_seq_lote_sib = nr_seq_lote_sib_p
	and	ie_tipo_reg in (1,2,5,7,8)
	and	(nr_seq_segurado IS NOT NULL AND nr_seq_segurado::text <> '');

c02 CURSOR FOR
	SELECT	nr_sequencia,
		nr_seq_segurado
	from	pls_interf_sib
	where	nr_seq_lote_sib = nr_seq_lote_sib_p
	and	ie_tipo_reg in (1,2,5,7,8);

type 		fetch_array is table of c02%rowtype;
s_array 	fetch_array;
i		integer := 1;
type vetor2 is table of fetch_array index by integer;
vetor_c02_w			vetor2;

BEGIN

select	nr_seq_lote_conferencia
into STRICT	nr_seq_lote_conf_w
from	pls_lote_sib
where	nr_sequencia	= nr_seq_lote_sib_p;

delete	FROM PLS_INCONSIST_CONF_SIB
where	nr_seq_lote_sib	= nr_seq_lote_sib_p;

IF (nr_seq_lote_conf_w IS NOT NULL AND nr_seq_lote_conf_w::text <> '') THEN
	open C01;
	loop
	fetch C01 into
		nr_cpf_w,
		dt_cancelamento_w,
		dt_reinclusao_w,
		nr_seq_segurado_w,
		cd_usuario_plano_w,
		cd_plano_ans_w,
		cd_plano_ans_pre_w,
		ie_tipo_reg_w,
		nr_cco_w,
		ie_digito_cco_w,
		CD_CGC_ESTIPULANTE_w,
		CD_USUARIO_PLANO_SUP_w,
		cd_motivo_cancelamento_w;
	EXIT WHEN NOT FOUND; /* apply on C01 */
		begin

		if (ie_tipo_reg_w = 1) then
			if (CD_USUARIO_PLANO_SUP_w IS NOT NULL AND CD_USUARIO_PLANO_SUP_w::text <> '') then
				select	count(1)
				into STRICT	qt_registros_w
				from	pls_retorno_sib
				where	nr_seq_lote_sib		= nr_seq_lote_conf_w
				and	cd_usuario_plano	= CD_USUARIO_PLANO_SUP_w  LIMIT 1;

				/*1 - Código de identificação do beneficiário titular inexistente na base da ANS*/

				if (qt_registros_w = 0) then

					select	count(1)
					into STRICT	qt_registros_w
					from	pls_interf_sib
					where	nr_seq_lote_sib		= nr_seq_lote_sib_p
					and	cd_usuario_plano	= CD_USUARIO_PLANO_SUP_w
					and	ie_tipo_reg		= 1;

					if (qt_registros_w = 0) then
						nr_vetor_w	:= vetor_w.count+1;
						vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
						vetor_w[nr_vetor_w].cd_inconsistencia	:= 1;
					end if;
				else
					select	count(1)
					into STRICT	qt_registros_w
					from	pls_retorno_sib
					where	nr_seq_lote_sib		= nr_seq_lote_conf_w
					and	cd_usuario_plano	= CD_USUARIO_PLANO_SUP_w
					and	ie_tipo_registro	= 1  LIMIT 1;

					/* 4 - Beneficiário titular inativo na base da ANS*/

					if (qt_registros_w = 0) then
						nr_vetor_w	:= vetor_w.count+1;
						vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
						vetor_w[nr_vetor_w].cd_inconsistencia	:= 4;
					end if;
				end if;
			end if;

			select	count(1)
			into STRICT	qt_registros_w
			from	pls_retorno_sib
			where	nr_seq_lote_sib		= nr_seq_lote_conf_w
			and	cd_usuario_plano	= cd_usuario_plano_w  LIMIT 1;

			/*2 - Código de identificação do beneficiário ja é existente na base da ANS*/

			if (qt_registros_w > 0) then
				nr_vetor_w	:= vetor_w.count+1;
				vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
				vetor_w[nr_vetor_w].cd_inconsistencia	:= 2;
			end if;

			if (CD_CGC_ESTIPULANTE_w IS NOT NULL AND CD_CGC_ESTIPULANTE_w::text <> '') then
				qt_registros_w	:= 0;

				if (cd_plano_ans_w IS NOT NULL AND cd_plano_ans_w::text <> '') then
					select	count(1)
					into STRICT	qt_registros_w
					from	pls_retorno_sib
					where	nr_seq_lote_sib		= nr_seq_lote_conf_w
					and	nr_cpf			= nr_cpf_w
					and	nr_plano_ans		= cd_plano_ans_w
					and	cd_cgc			= CD_CGC_ESTIPULANTE_w  LIMIT 1;
				elsif (cd_plano_ans_pre_w IS NOT NULL AND cd_plano_ans_pre_w::text <> '') then
					select	count(1)
					into STRICT	qt_registros_w
					from	pls_retorno_sib
					where	nr_seq_lote_sib		= nr_seq_lote_conf_w
					and	nr_cpf			= nr_cpf_w
					and	cd_plano_anterior	= cd_plano_ans_pre_w
					and	cd_cgc			= CD_CGC_ESTIPULANTE_w  LIMIT 1;
				end if;

				/*3 - Existente registro ativo com o mesmo CPF, Plano e Empresa contratante*/

				if (qt_registros_w > 0) then
					nr_vetor_w	:= vetor_w.count+1;
					vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
					vetor_w[nr_vetor_w].cd_inconsistencia	:= 3;
				end if;
			end if;
		else
			select	max(nr_sequencia)
			into STRICT	nr_seq_retorno_sib_w
			from	pls_retorno_sib
			where	nr_seq_lote_sib		= nr_seq_lote_conf_w
			and	nr_cco			= nr_cco_w
			and	ie_digito_cco		= ie_digito_cco_w  LIMIT 1;

			/*10 - Não existe informação desse CCO na base da ANS*/

			if (coalesce(nr_seq_retorno_sib_w::text, '') = '') then
				nr_vetor_w	:= vetor_w.count+1;
				vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
				vetor_w[nr_vetor_w].cd_inconsistencia	:= 10;
			else
				select	NR_SEQ_MOTIVO_CANCELAMENTO,
					DT_EXCLUSAO,
					ie_tipo_registro
				into STRICT	nr_seq_motivo_cancelamento_w,
					dt_exclusao_w,
					ie_tipo_registro_w
				from	pls_retorno_sib
				where	nr_sequencia	= nr_seq_retorno_sib_w;

				/*5 - Beneficiário está ativo na base da ANS, não deve ser enviado da data de rescisão ou motivo de cancelamento*/

				if (ie_tipo_reg_w = 2) and (cd_motivo_cancelamento_w IS NOT NULL AND cd_motivo_cancelamento_w::text <> '') and (dt_cancelamento_w IS NOT NULL AND dt_cancelamento_w::text <> '') and (ie_tipo_registro_w = 1) then
					nr_vetor_w	:= vetor_w.count+1;
					vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
					vetor_w[nr_vetor_w].cd_inconsistencia	:= 5;
				end if;

				/*6 - Beneficiário está inativo na base da ANS, não deve ser enviado informação da data de reativação*/

				if (ie_tipo_reg_w = 2) and (dt_reinclusao_w IS NOT NULL AND dt_reinclusao_w::text <> '') and (ie_tipo_registro_w = 2) then
					nr_vetor_w	:= vetor_w.count+1;
					vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
					vetor_w[nr_vetor_w].cd_inconsistencia	:= 6;
				end if;

				/*7 - Beneficiário já se encontra inativo na base da ANS*/

				if (ie_tipo_reg_w	= 7) and (ie_tipo_registro_w = 2) then
					nr_vetor_w	:= vetor_w.count+1;
					vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
					vetor_w[nr_vetor_w].cd_inconsistencia	:= 7;
				end if;

				/*8 - Beneficiário já se encontra ativo na base da ANS*/

				if (ie_tipo_reg_w	= 8) and (ie_tipo_registro_w = 1) then
					nr_vetor_w	:= vetor_w.count+1;
					vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
					vetor_w[nr_vetor_w].cd_inconsistencia	:= 8;
				end if;

				/*9 - Motivo de cancelamento não permite reativação do beneficiário*/

				if (ie_tipo_reg_w	= 8) and (nr_seq_motivo_cancelamento_w in (44,45,46,47,48)) then
					nr_vetor_w	:= vetor_w.count+1;
					vetor_w[nr_vetor_w].nr_seq_segurado	:= nr_seq_segurado_w;
					vetor_w[nr_vetor_w].cd_inconsistencia	:= 9;
				end if;
			end if;
		end if;

		end;
	end loop;
	close C01;
end if;

for j in 1..vetor_w.count loop
	begin

	CALL pls_gravar_consist_conf_sib(nr_seq_lote_sib_p,vetor_w[j].nr_seq_segurado,vetor_w[j].cd_inconsistencia,nm_usuario_p);

	end;
end loop;

open c02;
loop
fetch c02 bulk collect into s_array limit 1000;
	vetor_c02_w(i) := s_array;
	i := i + 1;
EXIT WHEN NOT FOUND; /* apply on c02 */
end loop;
close c02;

qt_registros_inconsistentes_w	:= 0;

for i in 1..vetor_c02_w.count loop
	s_array := vetor_c02_w(i);
	for z in 1..s_array.count loop
		begin

		nr_sequencia_w		:= s_array[z].nr_sequencia;
		nr_seq_segurado_w	:= s_array[z].nr_seq_segurado;

		select	count(1)
		into STRICT	qt_benef_inco_w
		from	PLS_INCONSIST_CONF_SIB	b,
			pls_lote_sib			a
		where	b.nr_seq_lote_sib	= a.nr_sequencia
		and	a.nr_sequencia		= nr_seq_lote_sib_p
		and	b.nr_seq_segurado	= nr_seq_segurado_w;

		if (qt_benef_inco_w > 0) then
			qt_registros_inconsistentes_w	:= qt_registros_inconsistentes_w + 1;
		end if;

		end;
	end loop;
end loop;

update	pls_interf_sib
set	QT_REG_INCONSIST_CONF	= qt_registros_inconsistentes_w
where	nr_seq_lote_sib		= nr_seq_lote_sib_p
and	ie_tipo_reg		= 9;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_consistir_lote_sib_conf ( nr_seq_lote_sib_p bigint, cd_estabelecimento_p bigint, nm_usuario_p text) FROM PUBLIC;

