-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_recalculo_valor_fixo ( nr_seq_lote_p bigint, nm_usuario_p text) AS $body$
DECLARE


nr_seq_conta_recalculo_w	bigint;
nr_seq_prestador_exec_w		bigint;
cd_cgc_w				varchar(14);
cd_medico_executor_w	varchar(10);
nr_seq_conta_w			bigint;
qt_registro_w			bigint	:= 0;
vl_fixo_w				double precision	:= 0;
vl_item_w				double precision	:= 0;
vl_item_ww				double precision	:= 0;
vl_base_w				double precision	:= 0;
nr_seq_ultimo_proc_w	bigint;
vl_total_itens_w		double precision;
dt_mes_competencia_w	timestamp;
nr_seq_regra_w			bigint;
vl_arredondamento_w		double precision	:=0;

nr_seq_conta_arredondamento_w	bigint;
nr_seq_item_w			bigint;
vl_item_atual_w			double precision;
tx_item_w				double precision;
vl_arredondamento2_w	double precision;
vl_conta_w				double precision;
arredondou_w			varchar(1) := 'N';
vl_divergencia_w		double precision := 0;
ie_valor_total_maior_w	varchar(1) := 'N';
ie_tipo_regra_w			pls_regra_lote_recalculo.ie_tipo_regra%type;
nr_seq_regra_lote_w		pls_lote_recalculo.nr_seq_regra%type;
vl_fixo_regra_w			pls_criterio_recalculo_val.vl_fixo_regra%type;
vl_total_itens_lote_w	pls_criterio_recalculo_val.vl_fixo_regra%type;
vl_proporcao_w			double precision;
tb_nr_seq_w				pls_util_cta_pck.t_number_table;
tb_vl_novo_item_w		pls_util_cta_pck.t_number_table;

C01 CURSOR FOR
	/* Buscar os médicos e prestadores do lote */

	SELECT	nr_seq_regra_fixo
	from	pls_conta_recalculo
	where	nr_seq_lote	= nr_seq_lote_p
	group by nr_seq_regra_fixo;

C02 CURSOR FOR
	SELECT	a.nr_sequencia,
			a.vl_item_atual,
			b.vl_base
	from	pls_conta_recalculo	b,
			pls_item_recalculo	a
	where	b.nr_sequencia		= a.nr_seq_conta
	and		b.nr_seq_lote		= nr_seq_lote_p
	and		b.nr_seq_regra_fixo	= nr_seq_regra_w;

C03 CURSOR FOR
	SELECT	a.nr_sequencia,
			vl_proporcao_w * a.vl_item_atual vl_novo_valor_item
	from	pls_conta_recalculo	b,
			pls_item_recalculo	a
	where	b.nr_sequencia		= a.nr_seq_conta
	and		b.nr_seq_lote		= nr_seq_lote_p;	
	
C04 CURSOR FOR
	SELECT	b.nr_sequencia nr_seq_conta_recalc,
			sum(a.vl_item) vl_total_conta
	from	pls_conta_recalculo	b,
			pls_item_recalculo	a
	where	b.nr_sequencia		= a.nr_seq_conta
	and		b.nr_seq_lote		= nr_seq_lote_p
	group by b.nr_sequencia;
	

BEGIN

/* Obter dados do lote */

select	trunc(a.dt_mes_competencia, 'month'),
		a.nr_seq_regra
into STRICT	dt_mes_competencia_w,
		nr_seq_regra_lote_w
from	pls_lote_recalculo a
where	a.nr_sequencia	= nr_seq_lote_p;

--Para verificação de vigência dos valores utiliza o mês competência truncado mesmo, estando esse dentro do período de datas da regra de valor a mesma é valida. Se tiver

--duas datas dentro da vigência, pega o valor da regra com maior sequência.
select 	max(vl_fixo_regra)
into STRICT	vl_fixo_regra_w
from	pls_criterio_recalculo_val
where 	nr_sequencia in (	SELECT max(nr_sequencia)
			from	pls_criterio_recalculo_val
			where 	nr_seq_regra_recalculo = nr_seq_regra_lote_w
			and 	dt_mes_competencia_w between dt_ini_vigencia and dt_fim_vigencia);

--Se existe regra de valor para Pagamento proporcional elo valor fixo, então esse será o valor base e não os valores obtidos para cada prestador
if (vl_fixo_regra_w IS NOT NULL AND vl_fixo_regra_w::text <> '') then

	select	sum(vl_item_atual)
	into STRICT	vl_total_itens_lote_w
	from	pls_conta_recalculo	b,
			pls_item_recalculo	a
	where	b.nr_sequencia		= a.nr_seq_conta
	and		b.nr_seq_lote		= nr_seq_lote_p;
	
	vl_proporcao_w := dividir( vl_fixo_regra_w, vl_total_itens_lote_w);
	
	open C03;
	loop			
	tb_vl_novo_item_w.delete;
	tb_nr_seq_w.delete;
	fetch C03 bulk collect into	tb_nr_seq_w, tb_vl_novo_item_w
	limit pls_util_pck.qt_registro_transacao_w;
	exit when tb_nr_seq_w.count = 0;
	
		forall i in tb_nr_seq_w.first..tb_nr_seq_w.last
			update 	pls_item_recalculo
			set		vl_item = tb_vl_novo_item_w(i)
			where	nr_sequencia = tb_nr_seq_w(i);
		commit;
		
	end loop;
	close C03;

	
	/*	Aqui é para verificar se ocorre alguma diferença entre a totalização de novos valores dos itens e o valor fixo da regra. Devido a proporcionalização, existe boas chances de ter que ocorrer
		ajustes aqui para o valor fechar
		O loop é feito pois a divergência pode ser maior que o maior valor de conta, então o mesmo é rateado entre os maiores valores
	*/
	arredondou_w := 'N';
	while( arredondou_w = 'N') loop

		/*Conforme solicitado por Alex Lisboa foi alterado para realizar o arredondamento na conta com maior valor, para que não ocorra valor negativo  OS418084*/


		/*Arredondamento na última conta com a diferença entre o que foi pago e o que deve ser pago*/

		select	sum(a.vl_item),
				max(a.vl_item)
		into STRICT	vl_total_itens_w,
				vl_arredondamento_w
		from	pls_conta_recalculo	b,
				pls_item_recalculo	a
		where	a.nr_seq_conta		= b.nr_sequencia
		and		b.nr_seq_lote		= nr_seq_lote_p;

		if ( vl_fixo_regra_w > vl_total_itens_w ) then
			vl_divergencia_w := vl_fixo_regra_w - vl_total_itens_w;
			ie_valor_total_maior_w := 'N'; -- então deve somar ao valor do item recalculo para equiparar com o valor fixo do prestador
		else
			vl_divergencia_w := vl_total_itens_w - vl_fixo_regra_w;
			ie_valor_total_maior_w := 'S'; --então deve subtrair do valor do item recalculo para equiparar com o valor fixo do prestador
		end if;
		--Primeiro verifica se existe diferença entre o total dos itens com o valor fixo do lote, se não tiver, então fechou
		if ( vl_divergencia_w <> 0) then

			--Nesse caso, subtrairá do total do item, então deve controlar para n~ão subtrair mais do que o valor do próprio item
			if (ie_valor_total_maior_w = 'S') then

				if (vl_arredondamento_w  < vl_divergencia_w) then
				 --Nesse caso o valor do item ficará com 1 centavo e no próximo loop o resto da diferença será aplicado a um próximo item
					vl_divergencia_w := vl_arredondamento_w - 0.01;
				end if;
			end if;

			--Apenas para pegar qual a sequência do item de recalculo que deve pegar.
			select	max(a.nr_sequencia)
			into STRICT	nr_seq_conta_arredondamento_w
			from	pls_conta_recalculo	b,
					pls_item_recalculo	a
			where	a.nr_seq_conta		= b.nr_sequencia
			and		b.nr_seq_lote		= nr_seq_lote_p
			and		a.vl_item		= vl_arredondamento_w;

			if ( ie_valor_total_maior_w = 'S') then
				
				update	pls_item_recalculo
				set		vl_item = vl_item - vl_divergencia_w
				where	nr_sequencia	= 	nr_seq_conta_arredondamento_w;
				
			else
				
				update	pls_item_recalculo
				set		vl_item = vl_item + vl_divergencia_w
				where	nr_sequencia	= 	nr_seq_conta_arredondamento_w;
				
			end if;
		else
			--Como não existe mais divergência entre o valor do fixo e o valor total

			--dos itens dentro do lote pode sair do laço de verificação.
			arredondou_w := 'S';
		end if;

	end loop;
	
	--Após reprocessar valor dos itens e tratar eventuais diferenças causadas por proporcionalização, atualizo valor total conta(Como não é valor fixo por prestador aqui, apenas é totalizado o valor item agrupado por conta recálculo)
	open C04;
	loop			
	tb_vl_novo_item_w.delete;
	tb_nr_seq_w.delete;
	fetch C04 bulk collect into	tb_nr_seq_w, tb_vl_novo_item_w
	limit pls_util_pck.qt_registro_transacao_w;
	exit when tb_nr_seq_w.count = 0;
		forall i in tb_nr_seq_w.first..tb_nr_seq_w.last
			update 	pls_item_recalculo
			set		vl_total_conta = tb_vl_novo_item_w(i)
			where	nr_seq_conta = tb_nr_seq_w(i);
		commit;
	end loop;
	close C04;
	
--Se não tiver regra de valor para preço fixo, mantém o que já fazia, que era reajustar valor conforme proporção do valor base obtido para cada prestador
else
	open C01;
	loop
	fetch C01 into
		nr_seq_regra_w;
	EXIT WHEN NOT FOUND; /* apply on C01 */
		begin
		select	count(1)
		into STRICT	qt_registro_w
		from	pls_conta_recalculo	b,
				pls_item_recalculo	a
		where	a.nr_seq_conta		= b.nr_sequencia
		and		b.nr_seq_lote		= nr_seq_lote_p
		and		b.nr_seq_regra_fixo	= nr_seq_regra_w;

		select	sum(a.vl_item_atual)
		into STRICT	vl_conta_w
		from	pls_conta_recalculo	b,
				pls_item_recalculo	a
		where	b.nr_sequencia		= a.nr_seq_conta
		and		b.nr_seq_lote		= nr_seq_lote_p
		and		b.nr_seq_regra_fixo	= nr_seq_regra_w;

		/* Realizar o cálculo proporcional conforme o valor do ítem na conta */

		open C02;
		loop
		fetch C02 into
			nr_seq_item_w,
			vl_item_atual_w,
			vl_fixo_w;
		EXIT WHEN NOT FOUND; /* apply on C02 */
			begin
			vl_item_w	:= (vl_fixo_w * vl_item_atual_w)/vl_conta_w;
			update	pls_item_recalculo
			set	vl_item		= vl_item_w,
				vl_total_conta	= vl_conta_w
			where	nr_sequencia	= nr_seq_item_w;
			commit;
			end;
		end loop;
		close C02;

		--Realizado um loop pois a divergência pode ser maior que o maior valor de conta, então é preciso ir rateando entre os maiores valores
		arredondou_w := 'N';
		while(arredondou_w = 'N') loop

			/*Conforme solicitado por Alex Lisboa foi alterado para realizar o arredondamento na conta com maior valor, para que não ocorra valor negativo  OS418084*/


			/*Arredondamento na última conta com a diferença entre o que foi pago e o que deve ser pago*/

			select	sum(a.vl_item),
				max(a.vl_item)
			into STRICT	vl_total_itens_w,
				vl_arredondamento_w
			from	pls_conta_recalculo	b,
				pls_item_recalculo	a
			where	a.nr_seq_conta		= b.nr_sequencia
			and	b.nr_seq_lote		= nr_seq_lote_p
			and	b.nr_seq_regra_fixo	= nr_seq_regra_w;

			if (vl_fixo_w > vl_total_itens_w) then
				vl_divergencia_w := vl_fixo_w - vl_total_itens_w;
				ie_valor_total_maior_w := 'N'; -- então deve somar ao valor do item recalculo para equiparar com o valor fixo do prestador
			else
				vl_divergencia_w := vl_total_itens_w - vl_fixo_w;
				ie_valor_total_maior_w := 'S'; --então deve subtrair do valor do item recalculo para equiparar com o valor fixo do prestador
			end if;
			--Primeiro verifica se existe diferença entre o total dos itens com o valor fixo do lote, se não tiver, então fechou
			if (vl_divergencia_w <> 0) then

				--Nesse caso, subtrairá do total do item, então deve controlar para n~ão subtrair mais do que o valor do próprio item
				if (ie_valor_total_maior_w = 'S') then

					if (vl_arredondamento_w  < vl_divergencia_w) then
					 --Nesse caso o valor do item ficará com 1 centavo e no próximo loop o resto da diferença será aplicado a um próximo item
						vl_divergencia_w := vl_arredondamento_w - 0.01;
					end if;
				end if;

				--Apenas para pegar qual a sequência do item de recalculo que deve pegar.
				select	max(a.nr_sequencia)
				into STRICT	nr_seq_conta_arredondamento_w
				from	pls_conta_recalculo	b,
					pls_item_recalculo	a
				where	a.nr_seq_conta		= b.nr_sequencia
				and	b.nr_seq_lote		= nr_seq_lote_p
				and	b.nr_seq_regra_fixo	= nr_seq_regra_w
				and	a.vl_item		= vl_arredondamento_w;

				if (ie_valor_total_maior_w = 'S') then
					update	pls_item_recalculo
					set	vl_item = vl_item - vl_divergencia_w
					where	nr_sequencia	= 	nr_seq_conta_arredondamento_w;
				else
					update	pls_item_recalculo
					set	vl_item = vl_item + vl_divergencia_w
					where	nr_sequencia	= 	nr_seq_conta_arredondamento_w;
				end if;
			else
				--Como não existe mais divergência entre o valor do fixo e o valor total

				--dos itens dentro do lote pode sair do laço de verificação.
				arredondou_w := 'S';
			end if;

		end loop;

		end;
	end loop;
	close C01;
end if;
	
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_recalculo_valor_fixo ( nr_seq_lote_p bigint, nm_usuario_p text) FROM PUBLIC;

