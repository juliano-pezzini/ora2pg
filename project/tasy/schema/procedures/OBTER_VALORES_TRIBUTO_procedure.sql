-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE obter_valores_tributo (ie_acumulativo_p text, pr_aliquota_p INOUT bigint, vl_minimo_base_p bigint, vl_minimo_tributo_p bigint, vl_soma_trib_nao_retido_p bigint, vl_soma_trib_adic_p bigint, vl_soma_base_nao_retido_p bigint, vl_soma_base_adic_p bigint, vl_base_calculo_p INOUT bigint, vl_tributo_p INOUT bigint, vl_trib_nao_retido_p INOUT bigint, vl_trib_adic_p INOUT bigint, vl_base_nao_retido_p INOUT bigint, vl_base_adic_p INOUT bigint, vl_teto_base_p bigint, vl_trib_anterior_p bigint, ie_irpf_p text, vl_base_anterior_p bigint, vl_reducao_p INOUT bigint, vl_desc_dependente_p INOUT bigint, qt_dependente_p bigint, vl_base_pago_p bigint, vl_base_pago_adic_base_p bigint, vl_base_retido_outro_p bigint, vl_outras_red_irpf_p bigint, dt_competencia_p timestamp, nr_seq_regra_irpf_p INOUT bigint, cd_tributo_p bigint default 0, ie_irpj_p text default 'N', ie_nao_zerar_tributo_p text default 'N') AS $body$
DECLARE


-- vl_reducao_p = entra o valor que ja foi reduzido, retorna o valor que deve ser reduzido
-- vl_base_pago_p = vl_base pago em outro em outro sistema
vl_tributo_a_reter_w		double precision;
vl_tributo_w			double precision;
vl_trib_adic_w			double precision;
vl_trib_nao_retido_w		double precision;
vl_base_adic_w			double precision;
vl_base_nao_retido_w		double precision;
vl_base_a_reter_w		double precision;
vl_base_calculo_w		double precision;
pr_aliquota_w			double precision;
vl_base_anterior_w		double precision;
pr_aliquota_anterior_w		double precision;
vl_reducao_w			double precision := 0;
vl_reducao_calculo_w		double precision := 0;
vl_trib_anterior_irpf_w		double precision := 0;
vl_desc_dependente_w		double precision := 0;
vl_teto_base_w			double precision := 0;
dt_competencia_w		timestamp;
cd_cgc_w			varchar(14);
ie_tipo_tributo_w		varchar(20);
nr_seq_regra_irpf_w		regra_calculo_irpf.nr_sequencia%type;


BEGIN
-- Edgar 24/04/2008, Os 86933, fiz o tratamento do vl_base_pago_adic_base_p
vl_base_calculo_w		:= coalesce(vl_base_calculo_p,0) - coalesce(vl_base_pago_p,0) + coalesce(vl_base_pago_adic_base_p,0);
vl_base_anterior_w		:= coalesce(vl_base_anterior_p,0);
pr_aliquota_w			:= pr_aliquota_p;
vl_trib_nao_retido_w		:= 0;
vl_trib_adic_w			:= 0;
vl_base_nao_retido_w		:= 0;
vl_base_adic_w			:= 0;
vl_teto_base_w			:= vl_teto_base_p - coalesce(vl_base_pago_p,0);
dt_competencia_w		:= coalesce(dt_competencia_p,clock_timestamp());

if (upper(ie_irpf_p) = 'S') then

	-- calcular desconto por dependente
	vl_desc_dependente_w		:= (coalesce(qt_dependente_p,0) * coalesce(vl_desc_dependente_p,0)) + coalesce(vl_outras_red_irpf_p, 0);
	if (coalesce(vl_trib_anterior_p,0) > 0) then	-- se ja foi gerado tributo, entao ja foi descontado os dependentes
		vl_desc_dependente_w	:= 0;		-- nao deve mais gerar
	end if;

	SELECT * FROM obter_dados_irpf(vl_base_calculo_w + vl_base_anterior_w - vl_soma_base_adic_p - vl_desc_dependente_w, pr_aliquota_w, vl_reducao_calculo_w, vl_base_anterior_p, dt_competencia_w, nr_seq_regra_irpf_w) INTO STRICT pr_aliquota_w, vl_reducao_calculo_w, nr_seq_regra_irpf_w;	-- Edgar 02/06/2005, OS 18096
	-- calcular diferenca da reducao ja executada
	vl_reducao_w		:= vl_reducao_calculo_w - coalesce(vl_reducao_p,0);

	-- diminuir o tributo ja calculado anteriormente
	vl_trib_anterior_irpf_w	:= coalesce(vl_trib_anterior_p,0) + coalesce(vl_reducao_p,0);

	-- William Kreuch, 31/07/2019, OS 1940272, o tratamento abaixo e feito para os casos em que ainda nao foi retido IRPF por ser menor que o minimo (R$ 10,00)
	-- nestes casos este valor que e menor que R$ 10,00 deve ser considerado como tributo anterior, uma vez que a acumulatividade sera em cima da base de calculo
	if (coalesce(vl_trib_anterior_irpf_w,0) = 0) then
		vl_trib_anterior_irpf_w := vl_soma_trib_nao_retido_p - vl_soma_trib_adic_p;
	end if;

	vl_base_calculo_w	:= vl_base_calculo_w + vl_base_anterior_w - vl_soma_base_adic_p - vl_desc_dependente_w;
	VL_BASE_ADIC_w		:= vl_base_anterior_w - vl_soma_base_adic_p;

end if;

vl_tributo_w			:= vl_base_calculo_w * (pr_aliquota_w / 100);

if (coalesce(pr_aliquota_w,0) > 0) then
	begin
	select (cd_cgc),
		substr(coalesce(obter_tipo_tributo(coalesce(cd_tributo_p,0)),'X'),1,20)
	into STRICT	cd_cgc_w,
		ie_tipo_tributo_w
	from	estabelecimento
	where	cd_estabelecimento = wheb_usuario_pck.get_cd_estabelecimento;
	exception
	when others then
		cd_cgc_w := '0';
		ie_tipo_tributo_w := 'X';
	end;

	-- sempre testar o vl_teto_base_p para verificar se tem tratamento de teto base, se tiver, continuar o processo com vl_teto_base_w
	if (coalesce(vl_teto_base_p,0) > 0) and
		(
			(coalesce(vl_teto_base_p,0) <= coalesce(vl_base_retido_outro_p,0)) or			-- Edgar 14/03/2011, OS 296798, caso o base pago em outra empresa supere o teto, enao nao deve mais gerar tributo
			((coalesce(vl_base_anterior_w,0)  >= coalesce(vl_teto_base_w,0)) and			-- Edgar 16/03/2006, OS 28084, se ja atingiu o teto,
			 ((coalesce(vl_base_anterior_w,0) <> 0) and (coalesce(vl_teto_base_w,0) <> 0)))		-- entao nao deva mais gerar nada...
		) then
		vl_base_calculo_w	:= 0;
		vl_tributo_w		:= 0;
	else

		if (vl_minimo_tributo_p > 0) then

			-- if	(nvl(vl_teto_base_p,0) > 0) and			Edgar 13/12/2006 OS 46532
			--	(vl_base_calculo_w > vl_teto_base_w) then	Qdo tiver valor teto base, deve calcular somente sobre a diferenca
			--	vl_base_calculo_w	:= vl_teto_base_w;	entre teto e e total base
			if (coalesce(vl_teto_base_p,0) > 0) and
				((vl_base_calculo_w + vl_base_anterior_w + coalesce(vl_base_retido_outro_p, 0)) > vl_teto_base_w) then

				vl_base_calculo_w	:= vl_teto_base_w - vl_base_anterior_w - coalesce(vl_base_retido_outro_p, 0);

				if (vl_base_calculo_w > 0) then
					vl_tributo_w		:= vl_base_calculo_w * (pr_aliquota_w / 100);
				else
					vl_tributo_w		:= 0;
				end if;
			end if;

			if (ie_acumulativo_p in ('S', 'D')) then

				vl_tributo_a_reter_w		:= vl_soma_trib_nao_retido_p - vl_soma_trib_adic_p;

				if	((vl_tributo_a_reter_w + vl_tributo_w - vl_reducao_w + coalesce(vl_trib_anterior_p,0)) >= vl_minimo_tributo_p) then /* Edgar 01/03/2011, OS 288307, incluido o vl_trib_anterior_p, caso o tributo ja tenha sido retido anteriormente, entao e porque ja ultrapassou o valor minimo */
					vl_tributo_w		:= vl_tributo_a_reter_w + vl_tributo_w;
					VL_TRIB_ADIC_w		:= vl_tributo_a_reter_w;
					VL_TRIB_NAO_RETIDO_w	:= 0;
				else
					if (coalesce(ie_nao_zerar_tributo_p, 'N') = 'N') then
						VL_TRIB_NAO_RETIDO_w	:= vl_tributo_w - vl_reducao_w;
						vl_tributo_w		:= 0;
					else
						VL_TRIB_NAO_RETIDO_w	:= 0;
					end if;

					VL_TRIB_ADIC_w		:= 0;
					vl_reducao_w		:= 0;
				end if;
			else
				if	((vl_tributo_w < vl_minimo_tributo_p) and coalesce(ie_nao_zerar_tributo_p, 'N') = 'N') then
					vl_tributo_w	:= 0;
				end if;
			end if;

		elsif (vl_minimo_base_p > 0) then

			if (ie_acumulativo_p in ('S', 'D')) then

				vl_base_a_reter_w		:= vl_soma_base_nao_retido_p - vl_soma_base_adic_p;

				if (vl_trib_anterior_p = 0) then  -- Se ja foi gerado um tributo anterios, entao ja atingiu a base de calculo
								-- Se ja atingiu a base de calculo, sempre deve gerar o tributo
					-- Se o tributo for IRPF e o hospital for Hospital Vera Cruz S/A
					if (coalesce(ie_tipo_tributo_w,'X') = 'IR') and (coalesce(cd_cgc_w,'0') = '46009718000140') then

						if	((vl_base_a_reter_w + vl_base_calculo_w) >= vl_minimo_base_p) then

							if (coalesce(vl_teto_base_p,0) > 0) and
								((vl_base_a_reter_w + vl_base_calculo_w) > vl_teto_base_w) then
								vl_base_calculo_w		:= vl_teto_base_w;
							end if;

							vl_tributo_w		:= (vl_base_a_reter_w + vl_base_calculo_w) * (pr_aliquota_w / 100);

							if (upper(ie_irpf_p) = 'S') then
								VL_BASE_ADIC_w		:= vl_base_calculo_w - vl_base_calculo_p - vl_soma_base_adic_p;
							else
								VL_BASE_ADIC_w		:= vl_base_a_reter_w;
							end if;

							vl_base_nao_retido_w	:= 0;
						else
							vl_base_nao_retido_w	:= vl_base_calculo_w;
							vl_tributo_w		:= 0;
							vl_base_adic_w		:= 0;
						end if;

					else -- se nao for IRPF ou nao for o Hospital Vera Cruz S/A
						if	((vl_base_a_reter_w + vl_base_calculo_w) >= vl_minimo_base_p) then
							begin
							if (coalesce(vl_teto_base_p,0) > 0) and
								((vl_base_a_reter_w + vl_base_calculo_w) > vl_teto_base_w) then
								begin
								vl_base_calculo_w	:= vl_teto_base_w;
								vl_base_a_reter_w	:= 0;
								end;
							end if;
							if	((coalesce(vl_teto_base_p,0) > 0) and
								((vl_base_a_reter_w + vl_base_calculo_w + vl_base_retido_outro_p) > vl_teto_base_w)) then
								begin
								vl_base_calculo_w	:= vl_teto_base_w - (vl_base_retido_outro_p + vl_base_a_reter_w);
								vl_base_a_reter_w	:= 0;
								end;
							end if;
							if (coalesce(ie_tipo_tributo_w,'X') = 'IR') then
								vl_tributo_w		:= vl_base_calculo_w * (pr_aliquota_w / 100);
								VL_BASE_ADIC_w		:= vl_base_calculo_w - vl_base_calculo_p;
							else
								vl_tributo_w		:= (vl_base_a_reter_w + vl_base_calculo_w) * (pr_aliquota_w / 100);
								VL_BASE_ADIC_w		:= vl_base_a_reter_w;
							end if;
							vl_base_nao_retido_w	:= 0;

							end;
						else
							begin
							vl_base_nao_retido_w	:= vl_base_calculo_w;
							vl_tributo_w		:= 0;
							vl_base_adic_w		:= 0;
							end;
						end if;

					end if;

				elsif (coalesce(vl_teto_base_p,0) > 0) and
					((vl_base_anterior_w + vl_base_calculo_w + vl_base_a_reter_w) > vl_teto_base_w) then

					if	((vl_base_calculo_w + vl_base_a_reter_w) > vl_teto_base_w) then

						vl_base_calculo_w	:= vl_teto_base_w - vl_base_anterior_w;
					elsif (ie_tipo_tributo_w = 'INSS') and -- Se o tributo for INSS e o hospital for Hospital Vera Cruz S/A
						(cd_cgc_w = '46009718000140') then

						vl_base_calculo_w := vl_teto_base_w - (vl_base_anterior_w + vl_base_a_reter_w);
					elsif (ie_tipo_tributo_w = 'INSS') and -- Se o tributo for INSS e o hospital for Hospital Ponpeia
						(cd_cgc_w = '88633227000115') then
						vl_base_calculo_w := vl_teto_base_w - (vl_base_anterior_w + vl_base_a_reter_w);
					end if;

					vl_tributo_w		:= vl_base_calculo_w * (pr_aliquota_w / 100);
					VL_BASE_ADIC_w		:= vl_base_a_reter_w;
					vl_base_nao_retido_w	:= 0;

				end if;
			else
				if (coalesce(vl_teto_base_p,0) > 0) and (vl_base_calculo_w > vl_teto_base_w) then
					vl_base_calculo_w	:= vl_teto_base_w;
					vl_tributo_w		:= vl_base_calculo_w * (pr_aliquota_w / 100);
				end if;

				if (vl_base_calculo_w < vl_minimo_base_p) then
					vl_tributo_w	:= 0;
				end if;
			end if;
		else
			vl_tributo_w			:= vl_base_calculo_w * (pr_aliquota_w / 100);

			if (coalesce(vl_teto_base_p,0) > 0) and
				((vl_base_calculo_w + vl_base_anterior_w) > vl_teto_base_w) then

				vl_base_calculo_w	:= vl_teto_base_w - vl_base_anterior_w;
				vl_tributo_w		:= vl_base_calculo_w * (pr_aliquota_w / 100);

			end if;

		end if;
	end if;

end if;

vl_tributo_p			:= vl_tributo_w - vl_reducao_w - vl_trib_anterior_irpf_w;
vl_trib_nao_retido_p		:= vl_trib_nao_retido_w;
vl_trib_adic_p			:= vl_trib_adic_w;
vl_base_nao_retido_p		:= vl_base_nao_retido_w;
vl_base_adic_p			:= vl_base_adic_w;
vl_reducao_p			:= vl_reducao_w;
vl_base_calculo_p		:= vl_base_calculo_w  + coalesce(vl_base_pago_p,0);

vl_desc_dependente_p			:= 0;
if (vl_tributo_p > 0) then	-- Atualizar o valor de desconto por dependente
	vl_desc_dependente_p		:= vl_desc_dependente_w;
else				-- se nao foi gerado tributo, repor o valor de desconto por dependente sobre a base de calculo
	vl_base_calculo_p		:= vl_base_calculo_w + vl_desc_dependente_w + coalesce(vl_base_pago_p,0);
end if;

nr_seq_regra_irpf_p		:= nr_seq_regra_irpf_w;
pr_aliquota_p			:= pr_aliquota_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE obter_valores_tributo (ie_acumulativo_p text, pr_aliquota_p INOUT bigint, vl_minimo_base_p bigint, vl_minimo_tributo_p bigint, vl_soma_trib_nao_retido_p bigint, vl_soma_trib_adic_p bigint, vl_soma_base_nao_retido_p bigint, vl_soma_base_adic_p bigint, vl_base_calculo_p INOUT bigint, vl_tributo_p INOUT bigint, vl_trib_nao_retido_p INOUT bigint, vl_trib_adic_p INOUT bigint, vl_base_nao_retido_p INOUT bigint, vl_base_adic_p INOUT bigint, vl_teto_base_p bigint, vl_trib_anterior_p bigint, ie_irpf_p text, vl_base_anterior_p bigint, vl_reducao_p INOUT bigint, vl_desc_dependente_p INOUT bigint, qt_dependente_p bigint, vl_base_pago_p bigint, vl_base_pago_adic_base_p bigint, vl_base_retido_outro_p bigint, vl_outras_red_irpf_p bigint, dt_competencia_p timestamp, nr_seq_regra_irpf_p INOUT bigint, cd_tributo_p bigint default 0, ie_irpj_p text default 'N', ie_nao_zerar_tributo_p text default 'N') FROM PUBLIC;

