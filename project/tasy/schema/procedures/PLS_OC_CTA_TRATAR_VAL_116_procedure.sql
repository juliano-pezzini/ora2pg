-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_116 (( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) is /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Aplicar a validacao de participacao em apresentacao x execucao cirurgica
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
*/
 i integer) RETURNS varchar AS $body$
DECLARE


ie_retorno_w	varchar(1) := 'N';
qt_comum_w	integer := 0;

C04 CURSOR(	dt_ini_pc	timestamp,
		dt_fim_pc	timestamp,
		cd_medico_pc	pls_proc_participante.cd_medico%type)FOR
	SELECT  a.nr_sequencia,
		e.dt_check_in,
		coalesce(e.dt_check_out, clock_timestamp()) dt_check_out
	from	pls_execucao_cirurgica a,
		pls_exec_cirurgica_guia b,
		pls_exec_cirurgica_proc c,
		pls_exec_cirurg_bio_partic d,
		pls_exec_cirurg_biometria e
	where	b.nr_seq_exec_cirurgica = a.nr_sequencia
	and 	c.nr_seq_execucao_guia = b.nr_sequencia
	and 	d.nr_seq_exec_cirurg_proc = c.nr_sequencia
	and 	d.nr_seq_exec_cirurg_bio = e.nr_sequencia
	and 	a.dt_primeira_execucao_proc < dt_fim_pc   --compara se exec comecou antes de o proc comparado terminar
	and 	a.dt_ultima_execucao_proc > dt_ini_pc   --compara se exec terminou depois de  o proc comparado comecar
	and 	e.cd_medico = cd_medico_pc
	and 	d.ie_status <> 'C'
	and 	c.ie_situacao_item <> 'C';
BEGIN

	for r_c04_w in c04(dt_ini_p, dt_fim_p, cd_medico_p ) loop
		
		select 	count(1)
		into STRICT	qt_comum_w
		from (
			SELECT	dt_retorno
			from	table(pls_manipulacao_datas_pck.obter_intervalo_datas( dt_ini_proc_p, dt_fim_proc_p,'MI', 'S')) dt_proc
			intersect
			SELECT	dt_retorno 
			from	table(pls_manipulacao_datas_pck.obter_intervalo_datas( r_c04_w.dt_check_in, r_c04_w.dt_check_out, 'MI','S'))) alias6;

		if (qt_comum_w > 0) then			
			ie_retorno_w := 'S';
			exit;
		end if;
					
	end loop;
	
	return ie_retorno_w;
	
end;	
	
begin

-- Deve existir informacao da regra para aplicar a validacao
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') and (nr_id_transacao_p is not  null) then
	
	-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
	CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);
	
	for	r_C01_w in C01(dados_regra_p.nr_sequencia) loop					
			
		--se tem alguma regra cadastrada para essa validacao, entao verifica se tem algum registro na tabela de execucao cirurgica, caso retornar zero, nao faz sentido processar essa
		--vaidacao
		select 	count(1)
		into STRICT	qt_reg_exec_w
		from 	pls_execucao_cirurgica LIMIT 1;
		
		if (qt_reg_exec_w > 0) then
				
			nr_seq_selecao_w	:= pls_tipos_ocor_pck.num_table_vazia;
			ie_valido_w		:= pls_tipos_ocor_pck.vchr2_table_vazia;
			ds_observacao_w		:= pls_tipos_ocor_pck.vchr2_table_vazia;
			
			i := 0;		
			for	r_C02_w in C02(nr_id_transacao_p) loop
							
				ie_gera_ocorrencia_w := 'N';							
							
				--aqui verifica se tem uma execucao cirurgica especifica para a conta que esta sendo processada
				select 	count(1)
				into STRICT	qt_reg_exec_conta_w
				from 	pls_execucao_cirurgica x 
				where 	x.nr_seq_guia = r_C02_w.nr_seq_guia
				and 	x.nr_seq_segurado = r_C02_w.nr_seq_segurado
				and 	x.nr_seq_prestador_exec = r_C02_w.nr_seq_prestador_exec;
				
				--Se tem execucao cirurgica vinculada a conta, nao devera processar a validacao.
				if ( qt_reg_exec_conta_w = 0 ) then
			
					--percorre as execucoes cirurgicas executadas no periodo do procedimento sendo processado e compara com o medico executor da conta
					ie_gera_ocorrencia_w := compara_conta_execucoes(r_C02_w.dt_ini_trunc, r_C02_w.dt_fim_limite, r_C02_w.dt_inicio,
						r_C02_w.dt_fim, r_C02_w.cd_medico_executor);
										
					--Se gerar ocorrencia devido ao medico da conta, nem necessita percorrer os participantes, 
					-- pois a ocorrencia ja deve ser lancada e vai evitar processamento desnecessario
					if (ie_gera_ocorrencia_w = 'N') then
						for r_c03_w in C03(r_C02_w.nr_seq_conta_proc) loop
						
							--percorre as execucoes cirurgicas executadas no periodo do procedimento sendo processado 
							--e compara com as informacoes de medico do participante
							ie_gera_ocorrencia_w := compara_conta_execucoes(r_C02_w.dt_ini_trunc, r_C02_w.dt_fim_limite, r_C02_w.dt_inicio,
										r_C02_w.dt_fim, r_C03_w.cd_medico);
															
							--se encotrar um participante que acaba tendo sobreposicao de horarios, ja nao precisa mais verificar os demais.
							if (ie_gera_ocorrencia_w = 'S') then
								exit;
							end if;
								
						end loop;
					end if;
						
					nr_seq_selecao_w(i) := r_C02_w.nr_seq_selecao;
					ie_valido_w(i) := 'N';
					ds_observacao_w(i) := '';
					if ( ie_gera_ocorrencia_w = 'S') then
						ds_observacao_w(i) 	:= 'Encontrada execucao cirurgica realizada no periodo do procedimento, que nao
							tem vinculo com essa conta.';
						ie_valido_w(i) := 'S';
					end if;
																						
					-- Quando a quantidade de itens da lista tiver chegado ao maximo definido na PLS_CTA_CONSISTIR_PCK, entao os registros sao levados para 
					-- o BD e gravados todos de uma vez, pela procedure GERENCIA_SELECAO_VALIDACAO, que atualiza os registros conforme passado por 
					-- parametro, o indice e as listas sao reiniciados para carregar os novos registros e para que os registros atuais nao sejam atualizados novamente em 
					-- na proxima carga.
					if (i = pls_cta_consistir_pck.qt_registro_transacao_w) then
											
						CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	nr_seq_selecao_w, pls_tipos_ocor_pck.clob_table_vazia,
												'SEQ', ds_observacao_w, ie_valido_w, nm_usuario_p);
											
						i := 0;
						
						ie_valido_w		:= pls_tipos_ocor_pck.vchr2_table_vazia;
						nr_seq_selecao_w	:= pls_tipos_ocor_pck.num_table_vazia;				
					else
						i := i + 1;
					end if;	
				else
					nr_seq_selecao_w(i) := r_C02_w.nr_seq_selecao;
					ds_observacao_w(i) 	:= '';									
					ie_valido_w(i) := 'N';
				end if;

			end loop; -- fim cursor C02
		end if;
		
	end loop; -- fim cursor c01
	
	-- se sobrou alguma coisa nas listas, processa.
	if (nr_seq_selecao_w.count > 0) then
		
		CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	nr_seq_selecao_w, pls_tipos_ocor_pck.clob_table_vazia,
								'SEQ', ds_observacao_w, ie_valido_w, nm_usuario_p);
	end if;
	
	-- seta os registros que serao validos ou invalidos apos o processamento 
	CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
	
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_116 (( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) is  i integer) FROM PUBLIC;

