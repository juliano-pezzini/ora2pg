-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_oc_cta_tratar_val_43 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) is /* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Aplicar a validacao para gerar a ocorrencia em itens que nao foram autorizados.
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[ X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------

Pontos de atencao:


Alteracoes:
 ------------------------------------------------------------------------------------------------------------------

 jjung OS 639937 04/09/2013 - Criacao da Rotina
------------------------------------------------------------------------------------------------------------------

jjung 17/09/2013 - 	Documentado a function de tratamento dos campos de senha
		pois foi identificado que a parametrizacao por senha externa
		nao deveria ser feita nesta validacao, e que na verdade ela deveria ser verificada
		na validacao 22 - Validar senha informada diferente da liberada. Portanto os tratamentos
		por senha foram removidos desta validacao, ficando apenas o tratamento por itens
		nao autorizados da PLS_CONTA_AUTOR_PCK.
------------------------------------------------------------------------------------------------------------------

jjung OS 629123 -  20/02/2014 - 

Alteracao:	Realizado ajustes na rotina para considerar o campo  "Validar quantidade apresentada" 
	da regra e melhorias no objeto
	
Motivo:	O cliente Rio Preto lavantou a necessidade de nao validar a quantidade e simplesmente
	validar se o item esta na autorizacao por que alguns de seus prestadores nao enviam guia
	de prorrogacao de internacao corretamente e nestes casos eles simplesmente validariam
	se o item esta autorizado.
------------------------------------------------------------------------------------------------------------------

dlehmkuhl OS 688483 - 14/04/2014 -

Alteracao:	Modificada a forma de trabalho em relacao a atualizacao dos campos de controle
	que basicamente decidem se a ocorrencia sera ou nao gerada. Foi feita tambem a 
	substituicao da rotina obterX_seX_geraX.

Motivo:	Necessario realizar essas alteracoes para corrigir bugs principalmente no que se
	refere a questao de aplicacao de filtros (passo anterior ao da validacao). Tambem
	tivemos um foco especial em performance, visto que a mesma precisou ser melhorada
	para nao inviabilizar a nova solicitacao que diz que a excecao deve verificar todo
	o atendimento.
------------------------------------------------------------------------------------------------------------------

grjunior OS  940238 - 25/02/2016 -

Alteracao:	Adicionado a opcao de verificar os itens que nao estao autorizados, se possuem
	algum item semelhante autorizado. Essa alteracao e aplicada somente nos itens 
	nao autorizados, que a guia possua uma autorizacao valida e que nao sejam negados
	pela quantidade a mais do que autorizado (neste caso nao importa se e semelhante ou nao,
	ele nao sera autorizado de qualquer forma)
	
Motivo:	A unimed Maringa foi a solicitante, onde ocorre com seus prestadores, que solicitaram 
	autorizacao para uma endoscopia, no momento do procedimento acabam percebendo que
	precisam de uma endosopia com urease, e o beneficiario nao esta com os documentos em 
	mao para fazer uma nova autorizacao. Por isso devera ser possivel a entrega precisa facilitar para o prestador entregar as contas com itens
	semelhantes, 
------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 ds_sql_w varchar(4000) RETURNS varchar AS $body$
BEGIN

-- Se nao tive informacao na regra retorna nulo.
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then
	
	-- Se nao deve ser verificado o evento da regra a ser verificado em que momento a ocorrencia sera gerada,

	-- se for gerada durante a importacao do XML entao deve ser verificados  os campos IMP caso contrario olha para os campos "quentes".

	-- Importacao XML
	if (dados_regra_p.ie_evento = 'IMP') then
		
		return 'dt_item_imp';
	else
		return 'dt_item';
	end if;
end if;

return '';

end;

-- Obtem a quantidade minima por procedimento da tabela de baixo risco
function obter_qt_tabela_baixo_risco(	cd_procedimento_p	pls_conta_proc.cd_procedimento%type,
					ie_origem_proced_p	pls_conta_proc.ie_origem_proced%type,
					nr_seq_regra_P		pls_tab_baixo_risco_cta.nr_sequencia%type,
					dt_referencia_p		date) return number is
					
qt_maxima_w		pls_tab_baixo_risco_proc.qt_maxima%type;
dt_referencia_w		date := coalesce(dt_referencia_p,clock_timestamp());

begin

select	min(a.qt_maxima)
into STRICT	qt_maxima_w
from	pls_tab_baixo_risco_proc	a,
	pls_tab_baixo_risco_cta		b
where	b.nr_sequencia		= a.nr_seq_tab_baixo_risco
and	a.cd_procedimento	= cd_procedimento_p
and	a.ie_origem_proced	= ie_origem_proced_p
and	b.nr_sequencia		= nr_seq_regra_p
and	dt_referencia_w	between trunc(b.dt_inicio_vigencia) and fim_dia(coalesce(b.dt_fim_vigencia, clock_timestamp()))
and	dt_referencia_w between a.dt_inicio_vigencia_ref and a.dt_fim_vigencia_ref;

return	qt_maxima_w;

end;

-- Obtem a quantidade de importacao (apresentada) do procedimento no atendimento ( guia de referencia e segurado)
function obter_qt_proc_imp_atend(	cd_procedimento_p	pls_conta_proc.cd_procedimento%type,
					ie_origem_proced_p	pls_conta_proc.ie_origem_proced%type,
					nr_seq_segurado_p	pls_conta.nr_seq_segurado%type,
					cd_guia_ok_p		pls_conta.cd_guia_ok%type,
					nr_seq_grau_partic_p	pls_proc_participante.nr_seq_grau_partic%type) return number is
					
qt_proc_imp_atend_w	pls_conta_proc.qt_procedimento_imp%type;
qt_utilizada_soma_w 	pls_integer;
dt_procedimento_ww		date;
ie_analise_cm_nova_w		pls_parametros.ie_analise_cm_nova%type;

C01 CURSOR(cd_guia_pc	pls_conta.cd_guia%type,
	    cd_procedimento_pc	pls_conta_proc.cd_procedimento%type,
	    ie_origem_proced_pc	pls_conta_proc.ie_origem_proced%type,
		nr_seq_segurado_pc	pls_segurado.nr_sequencia%type) FOR
	SELECT
		nr_seq_grau_partic,
		ie_glosa,
		ie_estagio_complemento,
		ie_status,
		dt_procedimento dt_item,
		sum(qt_procedimento) qt_procedimento
	from (
	  SELECT (	select 	max(nr_seq_grau_partic) 
					from 	pls_proc_participante 
					where 	nr_seq_conta_proc = a.nr_sequencia) nr_seq_grau_partic,
		  a.ie_glosa,
		  a.ie_estagio_complemento,
		  a.ie_status,
		  a.dt_procedimento,
		  a.qt_procedimento_imp qt_procedimento
	  from    	pls_conta_proc_v a
	  where   	a.cd_guia = cd_guia_pc
	  and		a.ie_status not in ('L','S','D')
	  and     	a.ie_origem_proced = ie_origem_proced_pc
	  and    	a.cd_procedimento  = cd_procedimento_pc
	  and   	a.nr_seq_segurado = nr_seq_segurado_pc
	  
union all

	  select (	select 	max(nr_seq_grau_partic) 
					from 	pls_proc_participante 
					where 	nr_seq_conta_proc = a.nr_sequencia) nr_seq_grau_partic,
		  a.ie_glosa,
		  a.ie_estagio_complemento,
		  a.ie_status,
		  a.dt_procedimento,
		  a.qt_procedimento qt_procedimento
	  from    	pls_conta_proc_v a
	  where   	a.cd_guia = cd_guia_pc
	  and		a.ie_status  in ('L','S')
	  and     	a.ie_origem_proced = ie_origem_proced_pc
	  and    	a.cd_procedimento  = cd_procedimento_pc
	  and   	a.nr_seq_segurado = nr_seq_segurado_pc
	  
	  ) alias8
	group by nr_seq_grau_partic,
			  ie_glosa,
			  ie_estagio_complemento,
			  ie_status,
			  dt_procedimento
	  order by qt_procedimento desc,
		 ie_status,
		 dt_procedimento;

begin
	
	select	coalesce(max(ie_analise_cm_nova),'S')
	into STRICT	ie_analise_cm_nova_w
	from	pls_parametros;
	
	qt_utilizada_soma_w := 0;
	dt_procedimento_ww := null;
			
	for r_c01_w in C01(cd_guia_ok_p, cd_procedimento_p, ie_origem_proced_p, nr_seq_segurado_p) loop
			begin
			
			/* tratamento para atualizar a quantidade utilizada das guias no geral*/

			if	((coalesce(r_c01_w.nr_seq_grau_partic::text, '') = '') or
				((r_c01_w.nr_seq_grau_partic IS NOT NULL AND r_c01_w.nr_seq_grau_partic::text <> '' AND qt_utilizada_soma_w = 0) or (trunc(r_c01_w.dt_item) <> trunc(dt_procedimento_ww)))) and
				((r_c01_w.ie_glosa = 'N') or (coalesce(r_c01_w.ie_glosa::text, '') = '') or (ie_analise_cm_nova_w = 'N')) and
				((r_c01_w.ie_status != 'U') or (r_c01_w.ie_estagio_complemento != '3' AND r_c01_w.ie_estagio_complemento IS NOT NULL AND r_c01_w.ie_estagio_complemento::text <> '')) and
				( (coalesce(r_c01_w.nr_seq_grau_partic::text, '') = '') or (nr_seq_grau_partic_p = r_c01_w.nr_seq_grau_partic))then
				
				qt_utilizada_soma_w := qt_utilizada_soma_w + coalesce(r_c01_w.qt_procedimento, 0);
				dt_procedimento_ww:= r_c01_w.dt_item;
				
			end if;
			end;
		end loop;
			
return	qt_utilizada_soma_w;

end;

begin

-- So aplicar a validacao se existir informacao da regra.
if (dados_regra_p.nr_sequencia IS NOT NULL AND dados_regra_p.nr_sequencia::text <> '') then
	
	-- Informacoes da regra de validacao da carteira.
	for	r_c_regra_w in c_regra(dados_regra_p.nr_sequencia) loop
		-- Verificar se a regra ira validar os itens nao autorizados ou a quantidade.
		if (r_c_regra_w.ie_valida_aut_item = 'S') then
		
			-- tratamento em campo auxiliar para identificar posteriormente os registros que foram alterados
			CALL pls_tipos_ocor_pck.atualiza_campo_auxiliar('V', nr_id_transacao_p, null, dados_regra_p);
			
			-- Monta o select principal para buscar as guias que estao autorizadas. Para esta validacao, se nao for encontrado uma guia para a conta, entao sera gerada a ocorrencia em todos 

			-- os itens da regra.

			-- Quando a regra tiver que prever a tabela de baixo risco da unimed, e incluso o ie_origem_conta, caso contrario ele fica como padrao null

			--  E feito dinamicamente para evitar joins desnecessarios
			ds_sql_w := 		'select	proc.ie_status_guia				ie_status_guia, ' || pls_tipos_ocor_pck.enter_w ||
						'	sel.ie_tipo_registro				ie_tipo_registro, ' || pls_tipos_ocor_pck.enter_w ||
						'	nvl(proc.nr_seq_guia_proc,proc.nr_seq_guia)	nr_seq_guia, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.ie_tipo_despesa				ie_tipo_despesa, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.ie_origem_proced				ie_origem_proced, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.cd_procedimento				cd_procedimento, ' || pls_tipos_ocor_pck.enter_w ||
						'	null						nr_seq_material, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.dt_procedimento_imp			dt_item, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.dt_procedimento				dt_item_imp, ' || pls_tipos_ocor_pck.enter_w ||
						'	sel.nr_sequencia				nr_seq_selecao, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.cd_procedimento_imp			cd_procedimento_imp, ' || pls_tipos_ocor_pck.enter_w ||
						'	null 						ds_itens_util_mat, ' || pls_tipos_ocor_pck.enter_w ||
						'	pls_util_cta_pck.obter_ds_itens_utilizados( ' || pls_tipos_ocor_pck.enter_w ||	
						'		nvl(proc.nr_seq_guia_proc,proc.nr_seq_guia), proc.nr_seq_conta, ' || pls_tipos_ocor_pck.enter_w ||
						'		proc.ie_origem_proced, proc.cd_procedimento, ' || pls_tipos_ocor_pck.enter_w ||
						'		null, ''P'', chr(13) || chr(10)) ds_itens_util_proc, ' || pls_tipos_ocor_pck.enter_w ||
						'	pls_util_cta_pck.obter_ds_itens_utilizados( ' || pls_tipos_ocor_pck.enter_w ||	
						'		nvl(proc.nr_seq_guia_proc,proc.nr_seq_guia), proc.nr_seq_conta, ' || pls_tipos_ocor_pck.enter_w ||
						'		null, null, ' || pls_tipos_ocor_pck.enter_w ||
						'		null, ''D'', chr(13) || chr(10)) ds_itens_util_dia, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.nr_seq_segurado		nr_seq_segurado, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.cd_guia_referencia		cd_guia_ok, ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.qt_procedimento_imp	qt_procedimento_imp,  ' || pls_tipos_ocor_pck.enter_w ||
						'	proc.nr_sequencia		nr_seq_item,  ' || pls_tipos_ocor_pck.enter_w ||
						'		(select 	max(nr_seq_grau_partic) '|| pls_tipos_ocor_pck.enter_w ||
						'		from 	pls_proc_participante  '|| pls_tipos_ocor_pck.enter_w ||
						'		where 	nr_seq_conta_proc = proc.nr_sequencia)		nr_seq_grau_partic,  ' || pls_tipos_ocor_pck.enter_w;
						
						if (coalesce(r_c_regra_w.nr_seq_tab_baixo_risco::text, '') = '') then
							
							ds_sql_w :=	ds_sql_w || '	null 						ie_origem_conta ' || pls_tipos_ocor_pck.enter_w;
						else
							ds_sql_w :=	ds_sql_w || '	conta.ie_origem_conta				ie_origem_conta ' || pls_tipos_ocor_pck.enter_w;
						end if;
						
						ds_sql_w :=	ds_sql_w ||
					
						'from	pls_oc_cta_selecao_ocor_v	sel, ' || pls_tipos_ocor_pck.enter_w ||
						'	pls_conta_proc_ocor_v		proc ' || pls_tipos_ocor_pck.enter_w;
						
						if (r_c_regra_w.nr_seq_tab_baixo_risco IS NOT NULL AND r_c_regra_w.nr_seq_tab_baixo_risco::text <> '') then
						
							ds_sql_w :=	ds_sql_w || '	,pls_conta_v			conta ' || pls_tipos_ocor_pck.enter_w;
						end if;
						
						ds_sql_w :=	ds_sql_w ||
						'where	sel.nr_id_transacao		= :nr_id_transacao '|| pls_tipos_ocor_pck.enter_w ||
						'and	sel.ie_valido			= ''S'' ' || pls_tipos_ocor_pck.enter_w ||
						'and	proc.nr_sequencia		= sel.nr_seq_conta_proc ' || pls_tipos_ocor_pck.enter_w;
						
						if (r_c_regra_w.nr_seq_tab_baixo_risco IS NOT NULL AND r_c_regra_w.nr_seq_tab_baixo_risco::text <> '') then
						
							ds_sql_w :=	ds_sql_w || 'and	conta.nr_sequencia		 = proc.nr_seq_conta ' || pls_tipos_ocor_pck.enter_w;
						end if;
						
						ds_sql_w :=	ds_sql_w ||	
						
						'union all ' || pls_tipos_ocor_pck.enter_w ||
						'select	mat.ie_status_guia		ie_status_guia, ' || pls_tipos_ocor_pck.enter_w ||
						'	sel.ie_tipo_registro	ie_tipo_registro, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.nr_seq_guia		nr_seq_guia, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.ie_tipo_despesa	ie_tipo_despesa, ' || pls_tipos_ocor_pck.enter_w ||
						'	null			ie_origem_proced, ' || pls_tipos_ocor_pck.enter_w ||
						'	null			cd_procedimento, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.nr_seq_material	nr_seq_material, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.dt_atendimento_imp	dt_item, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.dt_atendimento	dt_item_imp, ' || pls_tipos_ocor_pck.enter_w ||
						'	sel.nr_sequencia	nr_seq_selecao, ' || pls_tipos_ocor_pck.enter_w ||
						'	null			cd_procedimento_imp, ' || pls_tipos_ocor_pck.enter_w ||
						'	pls_util_cta_pck.obter_ds_itens_utilizados( ' || pls_tipos_ocor_pck.enter_w ||	
						'		mat.nr_seq_guia, mat.nr_seq_conta, ' || pls_tipos_ocor_pck.enter_w ||
						'		null, null, mat.nr_seq_material, ' || pls_tipos_ocor_pck.enter_w ||
						'		''M'', chr(13) || chr(10)) ds_itens_util_mat, ' || pls_tipos_ocor_pck.enter_w ||
						'	null			ds_itens_util_proc, ' || pls_tipos_ocor_pck.enter_w ||
						'	null			ds_itens_util_dia, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.nr_seq_segurado		nr_seq_segurado, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.cd_guia_referencia		cd_guia_ok, ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.qt_material_imp	qt_material_imp,  ' || pls_tipos_ocor_pck.enter_w ||
						'	mat.nr_sequencia	nr_seq_item,  ' || pls_tipos_ocor_pck.enter_w ||
						'	null	nr_seq_grau_partic,  ' || pls_tipos_ocor_pck.enter_w;
						
						if (coalesce(r_c_regra_w.nr_seq_tab_baixo_risco::text, '') = '') then
							
							ds_sql_w :=	ds_sql_w || '	null 						ie_origem_conta ' || pls_tipos_ocor_pck.enter_w;
						else
							ds_sql_w :=	ds_sql_w || '	conta.ie_origem_conta				ie_origem_conta ' || pls_tipos_ocor_pck.enter_w;
						end if;
						
						ds_sql_w :=	ds_sql_w ||	
						'from	pls_oc_cta_selecao_ocor_v	sel, ' || pls_tipos_ocor_pck.enter_w ||
						'	pls_conta_mat_ocor_v		mat ' || pls_tipos_ocor_pck.enter_w;
						
						if (r_c_regra_w.nr_seq_tab_baixo_risco IS NOT NULL AND r_c_regra_w.nr_seq_tab_baixo_risco::text <> '') then
						
							ds_sql_w :=	ds_sql_w || '	,pls_conta_v			conta ' || pls_tipos_ocor_pck.enter_w;
						end if;
						
						ds_sql_w :=	ds_sql_w ||
						'where	sel.nr_id_transacao		= :nr_id_transacao ' || pls_tipos_ocor_pck.enter_w ||
						'and	sel.ie_valido			= ''S'' ' || pls_tipos_ocor_pck.enter_w ||
						'and	mat.nr_sequencia		= sel.nr_seq_conta_mat ' || pls_tipos_ocor_pck.enter_w;
						
						if (r_c_regra_w.nr_seq_tab_baixo_risco IS NOT NULL AND r_c_regra_w.nr_seq_tab_baixo_risco::text <> '') then
						
							ds_sql_w :=	ds_sql_w || 'and	conta.nr_sequencia		 = mat.nr_seq_conta ' || pls_tipos_ocor_pck.enter_w;
						end if;
						
						ds_sql_w :=	ds_sql_w ||
						'order by ' || obter_order_by(dados_regra_p);
						
			begin
				-- Inicializar as listas para cada regra.
				pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_sel_w);
				
				-- Iniciar o indice para preenchimento da tabela.
				i := 0;
				
				-- Ira abrir um novo cursor e prepara-lo para ser executado com o sql montado acima.
				var_cur_w := dbms_sql.open_cursor;
				dbms_sql.parse(var_cur_w, ds_sql_w, dbms_sql.native);
			
				dbms_sql.bind_variable(var_cur_w, ':nr_id_transacao', nr_id_transacao_p);
				
				-- Preparar o retorno da execucao do select.
				dbms_sql.define_column(var_cur_w, 1, ie_status_guia_w, 1);
				dbms_sql.define_column(var_cur_w, 2, ie_tipo_item_w, 1);
				dbms_sql.define_column(var_cur_w, 3, nr_seq_guia_w);
				dbms_sql.define_column(var_cur_w, 4, ie_tipo_despesa_w, 1);
				dbms_sql.define_column(var_cur_w, 5, ie_origem_proced_w);
				dbms_sql.define_column(var_cur_w, 6, cd_procedimento_w);
				dbms_sql.define_column(var_cur_w, 7, nr_seq_material_w);
				dbms_sql.define_column(var_cur_w, 8, dt_item_imp_w);
				dbms_sql.define_column(var_cur_w, 9, dt_item_w);
				dbms_sql.define_column(var_cur_w, 10, nr_seq_selecao_w);
				dbms_sql.define_column(var_cur_w, 11, cd_procedimento_imp_w);
				dbms_sql.define_column(var_cur_w, 12, ds_itens_util_mat_w, 4000);
				dbms_sql.define_column(var_cur_w, 13, ds_itens_util_proc_w, 4000);
				dbms_sql.define_column(var_cur_w, 14, ds_itens_util_dia_w, 4000);
				dbms_sql.define_column(var_cur_w, 15, nr_seq_segurado_w);
				dbms_sql.define_column(var_cur_w, 16, cd_guia_ok_w, 20);
				dbms_sql.define_column(var_cur_w, 17, qt_procedimento_imp_w);
				dbms_sql.define_column(var_cur_w, 18, nr_seq_item_w);
				dbms_sql.define_column(var_cur_w, 19, nr_seq_grau_partic_w);
				dbms_sql.define_column(var_cur_w, 20, ie_origem_conta_w, 1);
				
				-- Executar o select
				var_exec_w := dbms_sql.execute(var_cur_w);
				
				-- Varrer o retorno enquanto for encontrado um resutaldo valido.
				loop
				-- Realizar o fetch da linha atual na variavel, se nao houver mais linhas para realizar o fecth e retornado zero, e o exit when trata de encerrar o loop.
				var_retorno_w := dbms_sql.fetch_rows(var_cur_w);
				exit when var_retorno_w = 0;

					-- Pegar a sequencia  da conta do SQL dinamico
					dbms_sql.column_value(var_cur_w, 1, ie_status_guia_w);
					dbms_sql.column_value(var_cur_w, 2, ie_tipo_item_w);
					dbms_sql.column_value(var_cur_w, 3, nr_seq_guia_w);
					dbms_sql.column_value(var_cur_w, 4, ie_tipo_despesa_w);
					dbms_sql.column_value(var_cur_w, 5, ie_origem_proced_w);
					dbms_sql.column_value(var_cur_w, 6, cd_procedimento_w);
					dbms_sql.column_value(var_cur_w, 7, nr_seq_material_w);
					dbms_sql.column_value(var_cur_w, 8, dt_item_imp_w);
					dbms_sql.column_value(var_cur_w, 9, dt_item_w);
					dbms_sql.column_value(var_cur_w, 10, nr_seq_selecao_w);
					dbms_sql.column_value(var_cur_w, 11, cd_procedimento_imp_w);
					dbms_sql.column_value(var_cur_w, 12, ds_itens_util_mat_w);
					dbms_sql.column_value(var_cur_w, 13, ds_itens_util_proc_w);
					dbms_sql.column_value(var_cur_w, 14, ds_itens_util_dia_w);
					dbms_sql.column_value(var_cur_w, 15, nr_seq_segurado_w);
					dbms_sql.column_value(var_cur_w, 16, cd_guia_ok_w);
					dbms_sql.column_value(var_cur_w, 17, qt_procedimento_imp_w);
					dbms_sql.column_value(var_cur_w, 18, nr_seq_item_w);
					dbms_sql.column_value(var_cur_w, 19, nr_seq_grau_partic_w);
					dbms_sql.column_value(var_cur_w, 20, ie_origem_conta_w);
					-- Sempre que for durante a importacao usa os campos imp
					if (dados_regra_p.ie_evento = 'IMP') then
						
						cd_procedimento_w	:= cd_procedimento_imp_w;
					end if;
					
					-- Sempre que um item for filtrado por este select quer dizer que a sua conta tem uma autorizacao. Porem ainda nao sabemos se este 

					-- item em especifico faz parte da autorizacao ou nao, portanto deixamos para que seja gerada a ocorrencia por padrao, e o que pode fazer isto mudar 

					-- e apenas o item ter sido autorizado e ainda ter saldo disponivel para utilizacao.
					dados_tb_sel_w.ie_valido(i)	:= 'S';
					dados_tb_sel_w.ds_observacao(i)	:= null;
					
					-- Usada para a opcao de itens semelhantes , que no caso nao deve ser efetuada quando o item foi considerado sem saldo.

					-- por questoes de performance e utilizada essa flag.
					ie_item_sem_saldo_w 		:= 'N';
					ie_gerar_ocor_sem_aut_w		:= 'S';
					
					-- Essa variaveis serao utilizadas apra definir a quantidade excedida

					-- do item que esta sendo validado no momento, para cada passagem 

					-- no cursor elas precisam ser zeradas, no final sera verificado

					-- a quantidade excedida
					qt_autorizada_w	:= 0;
					qt_utilizada_w 	:= 0;
					qt_excedido_w 	:= 0;
					
					-- Inicializar os valores que serao atualizados na tabela de selecao.
					dados_tb_sel_w.nr_seq_selecao(i)	:= nr_seq_selecao_w;
					dados_tb_sel_w.qt_excedido(i)		:= 0; -- A quantidade excedida inicia 0
					
					-- Como isto e uma normativa da Unimed Brasil, so deve ser aplicado as contas com origem de A500, e atualmente  esta previsto apenas procedimentos.
					if	((r_c_regra_w.nr_seq_tab_baixo_risco IS NOT NULL AND r_c_regra_w.nr_seq_tab_baixo_risco::text <> '') and (cd_procedimento_w IS NOT NULL AND cd_procedimento_w::text <> '') and (ie_origem_proced_w IS NOT NULL AND ie_origem_proced_w::text <> '')) then
						
						qt_maxima_proc_w	:= obter_qt_tabela_baixo_risco(cd_procedimento_w, ie_origem_proced_w, r_c_regra_w.nr_seq_tab_baixo_risco, coalesce(dt_item_w, dt_item_imp_w));
						qt_proc_imp_atend_w	:= obter_qt_proc_imp_atend(cd_procedimento_w, ie_origem_proced_w, nr_seq_segurado_w, cd_guia_ok_w, nr_seq_grau_partic_w);						
						
						-- Se foi encontrada uma limitacao
						if (qt_maxima_proc_w IS NOT NULL AND qt_maxima_proc_w::text <> '') then
						
							-- se passou a limitacao
							if (qt_proc_imp_atend_w > qt_maxima_proc_w) then
								
								ie_gerar_ocor_sem_aut_w := 'S';
							else -- se nao passou a mesma, nao gera
								
								ie_gerar_ocor_sem_aut_w := 'N';
								
							end if;
						
						else -- se nao achou limitacao, entao gera a ocorrencia (padrao antes da alteracao)
							ie_gerar_ocor_sem_aut_w := 'S';								
						end if;
					end if; -- fim se tem tabela de baixo risco e a conta e de origem A500		
				
					-- Verificar se a conta em questao teve uma guia vailida, se nao tiver a ocorrencia sera gerada					
					if (ie_gerar_ocor_sem_aut_w = 'N') then
						dados_tb_sel_w.ie_valido(i)	:= 'N';
						dados_tb_sel_w.ds_observacao(i)	:= null;
					elsif (coalesce(nr_seq_guia_w::text, '') = '') and (coalesce(r_c_regra_w.ie_somente_item_autor,'N') = 'N') and (ie_gerar_ocor_sem_aut_w = 'S') then
						
						ie_gerar_ocor_sem_aut_w := 'S';
						-- Caso a regra tenha um grupo de baixo risco configurado, antes de gerar a ocorrencia por nao encontrar

						-- uma autorizacao tem que verificar se a quantidade utilizada no procedimento ultrapassa a quantidade da tabela

						-- de baixo risco.

						
					
						
						-- Se e para gerar a ocorrencia,
						if (ie_gerar_ocor_sem_aut_w = 'S') then
							
							dados_tb_sel_w.ie_valido(i) := 'S';
							dados_tb_sel_w.ds_observacao(i) := 'Nao foi encontrada uma autorizacao para este atendimento.';
						
						else
							-- se nao foi marcado para gerar a ocorrencia, e necessario desmarcar o ie_valido, porque antes desta alteracao, sempre era gerado quando entrava no if da guia valida

							-- agora nem sempre deve ser gerada
							dados_tb_sel_w.ie_valido(i) := 'N';
							dados_tb_sel_w.ds_observacao(i) := null;
						end if;
						
					elsif (coalesce(nr_seq_guia_w::text, '') = '') and (r_c_regra_w.ie_somente_item_autor = 'S')and (ie_gerar_ocor_sem_aut_w = 'S') then	
						
						dados_tb_sel_w.ie_valido(i)	:= 'N';
					
					-- Se a guia nao estiver autorizada tambem gera ocorrencia.
					elsif (ie_status_guia_w <> '1') and (coalesce(r_c_regra_w.ie_somente_item_autor,'N') = 'N') and (ie_gerar_ocor_sem_aut_w = 'S') then
						
						dados_tb_sel_w.ie_valido(i) := 'S';
						dados_tb_sel_w.ds_observacao(i) :=
								'A solicitacao de autorizacao para este atendimento ' ||
								'nao foi autorizada pela operadora.' || pls_util_pck.enter_w ||
								'Status da solicitacao: ' ||
								obter_valor_dominio(1747, ie_status_guia_w);
								
					elsif (ie_status_guia_w <> '1') and (r_c_regra_w.ie_somente_item_autor = 'S') and (ie_gerar_ocor_sem_aut_w = 'S') then	
						
						dados_tb_sel_w.ie_valido(i)	:= 'N';					
					-- Verificar o tipo de item que deve ser buscado da PLS_CONTA_AUTOR_PCK. 

					-- Procedimentos 
					elsif (ie_tipo_item_w = 'P') and (ie_gerar_ocor_sem_aut_w = 'S') then						
						-- Quando for procedimentos deve ser verificado o tipo de despesa, pois devido a estrutura criada para as diarias 

						-- a quantidade autorizada pode estar informada na PLS_GUIA_PLANO ou na PLS_GUIA_PLANO_PROC.  A

						-- PLS_CONTA_AUTOR_PCK ja trata esta situacao e portanto precisamos apenas identificar para ela que sao diarias que estamos buscando.

						-- Diariais
						if (ie_tipo_despesa_w = '3') then
							
							-- Buscar o saldo para diarias existente nesta guia.
							for dados_conta_autor_w in c_conta_autor_dia(nr_seq_guia_w, ie_origem_proced_w, cd_procedimento_w, cd_estabelecimento_p) loop
								
								-- A partir do momento em que o item esta na atuorizacao 

								-- consideramos que a ocorrencia nao deva ser gerada.

								-- A ocorrencia portanto so sera gerada caso seja para validar tambem a quantidade

								-- e o item em questao ja ultrapassou a quantidade autorizada.
							
								if (dados_conta_autor_w.qt_registro = 1) then
								
									dados_tb_sel_w.ie_valido(i)	:= 'N';
									
									-- Verificar se deve ser verificada a quantidade apresentada para geracao da ocorrencia.
									if (r_c_regra_w.ie_valida_qtd_util = 'S') then
									
										-- Se o saldo ja tive sido esgotado entao sera gerada a ocorrencia, caso contrario nao, entao 

										-- e setado como invalido para a tabela de selecao.
										if (dados_conta_autor_w.qt_saldo < 0) then
										
											dados_tb_sel_w.ie_valido(i) 	:= 'S';
											ie_item_sem_saldo_w		:= 'S';
											
											-- Montar a observacao que deve ser montada para este item. A observacao so e montada para os itens que ira ser gerada a 

											-- ocorrencia, para evitar comandos SQL desnecessarios.
											dados_tb_sel_w.ds_observacao(i) :=	
												substr('A quantidade de diarias utilizadas ultrapassa a quantidade de diarias autorizadas para esta guia. ' || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w ||
												'Quantidade autorizada: ' || dados_conta_autor_w.qt_autorizada || ' | Quantidade utilizada: ' || dados_conta_autor_w.qt_utilizada || ' | Saldo: ' || dados_conta_autor_w.qt_saldo || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w || 
												'Contas deste atendimento que utilizaram diarias: ' || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w || 
												ds_itens_util_dia_w, 1, 2000);
												
											qt_autorizada_w := qt_autorizada_w + dados_conta_autor_w.qt_autorizada;
											qt_utilizada_w := qt_utilizada_w + dados_conta_autor_w.qt_utilizada;
										end if;
									end if;
									
								elsif (coalesce(r_c_regra_w.ie_somente_item_autor,'N') = 'N') and (r_c_regra_w.ie_solic_aut_nega = 'N') then
								
									dados_tb_sel_w.ie_valido(i)	:= 'S';
									dados_tb_sel_w.ds_observacao(i) :=	
										substr('Existe uma autorizacao valida para esta guia, porem a cobranca ' ||
											'desta diaria nao foi autorizada.',1,2000);
								else
									dados_tb_sel_w.ie_valido(i)	:= 'N';
								end if;
							end loop; -- dados_conta_autor_w 
							
						-- Quando for qualquer outro tipo de despesa entao temos que buscar como sendo um procedimento.
						else
							-- Buscar o saldo para este proceidmento para esta guia.
							for dados_conta_autor_w in c_conta_autor_proc(	nr_seq_guia_w,
													ie_origem_proced_w,
													cd_procedimento_w,
													cd_estabelecimento_p) loop
								-- A partir do momento em que o item esta na atuorizacao 

								-- consideramos que a ocorrencia nao deva ser gerada.

								-- A ocorrencia portanto so sera gerada caso seja para validar tambem a quantidade

								-- e o item em questao ja ultrapassou a quantidade autorizada.								
								if (dados_conta_autor_w.qt_registro = 1) then
								
									dados_tb_sel_w.ie_valido(i)	:= 'N';
								
									-- Verificar se deve ser verificada a quantidade apresentada para geracao da ocorrencia.
									if (r_c_regra_w.ie_valida_qtd_util = 'S') then
									
										-- Se o saldo ja tive sido esgotado entao sera gerada a ocorrencia, caso contrario nao, entao 

										-- e setado como invalido para a tabela de selecao.
										if (dados_conta_autor_w.qt_saldo < 0) then
										
											dados_tb_sel_w.ie_valido(i) 	:= 'S';
											ie_item_sem_saldo_w		:= 'S';
											
											-- Montar a observacao que deve ser montada para este item. A observacao so e montada para os itens que ira ser gerada a 

											-- ocorrencia, para evitar comandos SQL desnecessarios.
											dados_tb_sel_w.ds_observacao(i) :=	
												substr('A quantidade utilizada deste procedimento ultrapassa a quantidade autorizada para esta guia. ' || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w ||
												'Quantidade autorizada: ' || dados_conta_autor_w.qt_autorizada || ' | Quantidade utilizada: ' || dados_conta_autor_w.qt_utilizada || ' | Saldo: ' || dados_conta_autor_w.qt_saldo || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w || 
												'Contas deste atendimento que utilizaram este mesmo procedimento: ' || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w || 
												ds_itens_util_proc_w, 1, 2000);
												
											qt_autorizada_w := qt_autorizada_w + dados_conta_autor_w.qt_autorizada;
											qt_utilizada_w := qt_utilizada_w + dados_conta_autor_w.qt_utilizada;												
										end if;
									end if;
								elsif (coalesce(r_c_regra_w.ie_somente_item_autor,'N') = 'N') and (r_c_regra_w.ie_solic_aut_nega = 'N') then
								
									dados_tb_sel_w.ie_valido(i)	:= 'S';
									-- Montar a observacao que deve ser montada para este item.
									dados_tb_sel_w.ds_observacao(i) :=
										substr('Existe uma autorizacao valida para esta guia, porem a cobranca ' ||
										'deste procedimento nao foi autorizada.',1, 2000);
								else
									dados_tb_sel_w.ie_valido(i)	:= 'N';
								end if;
							end loop; -- dados_conta_autor_w 
						end if;
					-- Materiais
					elsif (ie_tipo_item_w = 'M') and (ie_gerar_ocor_sem_aut_w = 'S')then
						
						-- Buscar o saldo para este proceidmento para esta guia.
						for dados_conta_autor_w in c_conta_autor_mat(	nr_seq_guia_w, 
												nr_seq_material_w,
												cd_estabelecimento_p) loop
							
							-- A partir do momento em que o item esta na atuorizacao 

							-- consideramos que a ocorrencia nao deva ser gerada.

							-- A ocorrencia portanto so sera gerada caso seja para validar tambem a quantidade

							-- e o item em questao ja ultrapassou a quantidade autorizada.
							if (dados_conta_autor_w.qt_registro = 1) then
							
								dados_tb_sel_w.ie_valido(i)	:= 'N';
								
								-- Verificar se deve ser verificada a quantidade apresentada para geracao da ocorrencia.
								if (r_c_regra_w.ie_valida_qtd_util = 'S') then
								
									-- Se o saldo ja tive sido esgotado entao sera gerada a ocorrencia, caso contrario nao, entao 

									-- e setado como invalido para a tabela de selecao.
									if (dados_conta_autor_w.qt_saldo < 0) then
									
										dados_tb_sel_w.ie_valido(i) 	:= 'S';
										ie_item_sem_saldo_w		:= 'S';
										
										-- Montar a observacao que deve ser montada para este item. A observacao so e montada para os itens que ira ser gerada a 

										-- ocorrencia, para evitar comandos SQL desnecessarios.
										dados_tb_sel_w.ds_observacao(i) := 	
											substr('A quantidade utilizada deste material ultrapassa a quantidade autorizada para esta guia. ' || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w ||
											'Quantidade autorizada: ' || dados_conta_autor_w.qt_autorizada || ' | Quantidade utilizada: ' || dados_conta_autor_w.qt_utilizada || ' | Saldo: ' || dados_conta_autor_w.qt_saldo || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w || 
											'Contas deste atendimento que utilizaram este mesmo material: ' || pls_tipos_ocor_pck.enter_w || pls_tipos_ocor_pck.enter_w || 
											ds_itens_util_mat_w, 1, 2000);
											
										qt_autorizada_w := qt_autorizada_w + dados_conta_autor_w.qt_autorizada;
										qt_utilizada_w := qt_utilizada_w + dados_conta_autor_w.qt_utilizada;
									end if;
								end if;
							elsif (coalesce(r_c_regra_w.ie_somente_item_autor,'N') = 'N') and (r_c_regra_w.ie_solic_aut_nega = 'N') then
								dados_tb_sel_w.ie_valido(i)	:= 'S';
								-- Montar a observacao que deve ser montada para este item.
								dados_tb_sel_w.ds_observacao(i) :=
									substr('Existe uma autorizacao valida para esta guia, porem a cobranca ' ||
									'deste material nao foi autorizada.',1, 2000);
							else
								dados_tb_sel_w.ie_valido(i)	:= 'N';
							end if;
						end loop; -- dados_conta_autor_w 
					end if;
					
					-- Se essa variavel tiver valor, significa que a glosa foi aplicada por

					-- exceder a quantidade autorizada. E realizado uma analise para identificar

					-- qual a quantidade excedida desse item em especifico
					if (qt_utilizada_w > 0) then
					
						qt_excedido_w := qt_autorizada_w;

						
						dados_tb_sel_w.qt_excedido(i) := qt_excedido_w;
					end if;
					
					if (r_c_regra_w.ie_solic_aut_nega = 'S') and (dados_tb_sel_w.ie_valido(i) = 'N') then
						
						ie_status_item_auto_w := null;
						
						if (ie_tipo_item_w = 'P') then
							select	max(ie_status)
							into STRICT	ie_status_item_auto_w
							from	pls_guia_plano_proc
							where	nr_seq_guia = nr_seq_guia_w
							and	cd_procedimento = cd_procedimento_w
							and	ie_origem_proced = ie_origem_proced_w;
						elsif (ie_tipo_item_w = 'M') then
							select	max(ie_status)
							into STRICT	ie_status_item_auto_w
							from	pls_guia_plano_mat
							where	nr_seq_guia = nr_seq_guia_w
							and	nr_seq_material = nr_seq_material_w;
						end if;
						
						if (ie_status_item_auto_w in ('K', 'M', 'N')) then
							dados_tb_sel_w.ie_valido(i)	:= 'S';
							dados_tb_sel_w.ds_observacao(i) :=
								'Item presente na autorizacao porem negado. Status do item na autorizacao: ' || obter_valor_dominio(1832, ie_status_item_auto_w);
						end if;	
					end if;
					
					--aaschlote 15/04/2015 OS 842080 - Valida a quantidade minima do procedimento para ser gerada a ocorrencia
					if (r_c_regra_w.qt_minima IS NOT NULL AND r_c_regra_w.qt_minima::text <> '') then
						if (ie_tipo_item_w = 'P') then
							if (nr_seq_guia_w IS NOT NULL AND nr_seq_guia_w::text <> '') then
								select	sum(qt_procedimento)
								into STRICT	qt_conta_dif_w
								from	pls_conta_autor_utilizada_v
								where	nr_seq_guia		= nr_seq_guia_w
								and	cd_procedimento 	= cd_procedimento_w
								and	ie_origem_proced	= ie_origem_proced_w;
							else
								--Procedimentos que estao liberados
								select	sum(coalesce(qt_procedimento,0))
								into STRICT	qt_conta_dif_w
								from	pls_conta_proc_v
								where	cd_guia_referencia	= cd_guia_ok_w
								and	nr_seq_segurado		= nr_seq_segurado_w
								and	cd_procedimento 	= cd_procedimento_w
								and	ie_origem_proced	= ie_origem_proced_w
								and	nr_sequencia		<> nr_seq_item_w
								and	((ie_status	 in ('S','L'))
								and (coalesce(ie_glosa::text, '') = '' or ie_glosa = 'N'));
								
								--Procedimentos que estao pendentes e nao tem glosa
								select	sum(coalesce(a.qt_procedimento_imp,0))
								into STRICT	qt_conta_dif_2_w
								from	pls_conta_proc_v	a
								where	a.cd_guia_referencia	= cd_guia_ok_w
								and	a.nr_seq_segurado		= nr_seq_segurado_w
								and	a.cd_procedimento 	= cd_procedimento_w
								and	a.ie_origem_proced	= ie_origem_proced_w
								and (a.ie_status in ('P','C','A')
								and (coalesce(a.ie_glosa::text, '') = '' or a.ie_glosa = 'N'))
								and	a.nr_sequencia		<> nr_seq_item_w;
								
								qt_conta_dif_w	:= coalesce(qt_conta_dif_w,0) + coalesce(qt_conta_dif_2_w,0) + qt_procedimento_imp_w;
								
								
							end if;
						elsif (ie_tipo_item_w = 'M') then
							if (nr_seq_guia_w IS NOT NULL AND nr_seq_guia_w::text <> '') then
								select	sum(qt_procedimento)
								into STRICT	qt_conta_dif_w
								from	pls_conta_autor_utilizada_v
								where	nr_seq_guia		= nr_seq_guia_w
								and	nr_seq_material		= nr_seq_material_w;
							else
							
								--Materiais que estao liberados
								select	sum(coalesce(qt_material,0))
								into STRICT	qt_conta_dif_w
								from	pls_conta_mat_v
								where	cd_guia_referencia	= cd_guia_ok_w
								and	nr_seq_segurado		= nr_seq_segurado_w
								and	nr_seq_material		= nr_seq_material_w
								and	nr_sequencia		<> nr_seq_item_w
								and	((ie_status	 in ('S','L')) and (coalesce(ie_glosa::text, '') = '' or ie_glosa = 'N'));
								
								--Materiais que estao pendentes  e nao tem glosa
								select	sum(coalesce(a.qt_material_imp,0))
								into STRICT	qt_conta_dif_2_w
								from	pls_conta_mat_v		a
								where	a.cd_guia_referencia	= cd_guia_ok_w
								and	a.nr_seq_segurado	= nr_seq_segurado_w
								and	a.nr_seq_material	= nr_seq_material_w
								and (a.ie_status in ('P','C','A')
								and (coalesce(a.ie_glosa::text, '') = '' or a.ie_glosa = 'N'))
								and	a.nr_sequencia		<> nr_seq_item_w;
								
								qt_conta_dif_w	:= coalesce(qt_conta_dif_w,0) + coalesce(qt_conta_dif_2_w,0) + qt_procedimento_imp_w;
								
							end if;
						end if;
						
						--Caso a quantidade minima seja maior que a quantidade, entao nao gera a ocorrencia
						if (qt_conta_dif_w IS NOT NULL AND qt_conta_dif_w::text <> '') and (r_c_regra_w.qt_minima > qt_conta_dif_w) then
							
							dados_tb_sel_w.ie_valido(i)	:= 'N';
							dados_tb_sel_w.ds_observacao(i) := '';
							dados_tb_sel_w.qt_excedido(i)	:= 0;
						end if;
					
					end if;
					
					-- Quando um item for marcado para gerar ocorrencia, e a regra considerar os semelhantes, 

					-- sera ainda buscado na autorizacao se existe algum item semelhante ao que esta recebendo a ocorrencia.

					-- E importante que isto seja feito somente no final do processo, pois assim apenas aplicamos a verificacao da semelhanca 

					-- apenas nos itens que realmente precisam, ganhando performance.

					-- Tem que possuir uma autorizacao valida tambem para entrar nos testes
					
					if (r_c_regra_w.ie_considerar_semelhante = 'S') and (dados_tb_sel_w.ie_valido(i) = 'S') and (ie_tipo_item_w = 'P') and (nr_seq_guia_w IS NOT NULL AND nr_seq_guia_w::text <> '') and (coalesce(r_c_regra_w.ie_somente_item_autor,'N') = 'N') and (ie_status_guia_w = '1') then
						--and (ie_item_sem_saldo_w = 'N') 

						--A restricao acima foi retirada para que nao haja impacto caso o item nao esteja na autorizacao
						
						select	count(1)
						into STRICT	qt_item_semelhante_w
						from	table(pls_conta_autor_pck.obter_dados(nr_seq_guia_w, 'P', cd_estabelecimento_p, null, null)) a
						where	pls_obter_proc_semelhante(null, cd_estabelecimento_p, ie_origem_proced_w, cd_procedimento_w, a.ie_origem_proced, a.cd_procedimento) = 'S';
						
						-- Se encontoru um semelhante, entao nao gera a ocorrencia
						if (qt_item_semelhante_w > 0) then
						
							dados_tb_sel_w.ie_valido(i)	:= 'N';
							dados_tb_sel_w.ds_observacao(i) := '';
							dados_tb_sel_w.qt_excedido(i)	:= 0;
						end if;						
					end if; -- Fim verificar semelhantes
						 
					-- Quando a quantidade de itens da lista tiver chegado ao maximo definido na PLS_CTA_CONSISTIR_PCK, entao os registros sao levados para 

					-- o BD e gravados todos de uma vez, pela procedure GERENCIAL_SELECAO_VALIDACAO, que atualiza os registros conforme passado por 

					-- parametro, o indice e as listas sao reiniciados para carregar os novos registros e para que os registros atuais nao sejam atualizados novamente em 

					-- na proxima carga.
					if (i = pls_cta_consistir_pck.qt_registro_transacao_w) then
						
						-- Sera passado uma lista com todas a sequencias da selecao para a conta e para seus itens, estas sequencias serao atualizadas com os mesmos dados da conta, 

						-- conforme passado por parametro,
						CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(	
							dados_tb_sel_w.nr_seq_selecao, pls_tipos_ocor_pck.clob_table_vazia,
							'SEQ', dados_tb_sel_w.ds_observacao, dados_tb_sel_w.ie_valido, nm_usuario_p,
							null, dados_tb_sel_w.qt_excedido);
						
						-- Zerar o indice
						i := 0;
						
						-- Zerar as listas.
						pls_tipos_ocor_pck.limpar_nested_tables(dados_tb_sel_w);
					-- Enquanto os registros nao tiverem atingido a carga para gravar na selecao incrementa o indice para armazenar os proximos registros.
					else
						i := i + 1;
					end if;
					
				end loop; -- Itens filtrados
				-- Fechar o cursor que foi aberto para filtrar os itens
				dbms_sql.close_cursor(var_cur_w);
				
				-- Quando tiver sobrado algo na lista ira gravar o que restou apos a execucao do loop.
				if (dados_tb_sel_w.nr_seq_selecao.count > 0) then
					-- Sera passado uma lista com todas a sequencias da selecao para a conta e para seus itens, estas sequencias serao atualizadas com os mesmos dados da conta, 

					-- conforme passado por parametro,
					CALL pls_tipos_ocor_pck.gerencia_selecao_validacao(
						dados_tb_sel_w.nr_seq_selecao, pls_tipos_ocor_pck.clob_table_vazia,
						'SEQ', dados_tb_sel_w.ds_observacao, dados_tb_sel_w.ie_valido, nm_usuario_p,
						null, dados_tb_sel_w.qt_excedido);
				end if;
			exception
				when others then
					-- Fechar o cursor se o mesmo continua aberto
					if (dbms_sql.is_open(var_cur_w)) then
						
						dbms_sql.close_cursor(var_cur_w);
					end if;
					-- Insere o log na tabela e aborta a operacao
					CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(	dados_regra_p, ds_sql_w,
											nr_id_transacao_p, nm_usuario_p);
			end;
		end if;
		
		-- seta os registros que serao validos ou invalidos apos o processamento 
		CALL pls_tipos_ocor_pck.atualiza_campo_valido('V', nr_id_transacao_p, null, dados_regra_p);
		
	end loop; -- c_regra 
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_oc_cta_tratar_val_43 ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) is  ds_sql_w varchar(4000) FROM PUBLIC;

