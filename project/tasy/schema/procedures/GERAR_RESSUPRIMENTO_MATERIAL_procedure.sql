-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE gerar_ressuprimento_material ( cd_estabelecimento_p bigint, dt_inicio_pendente_p timestamp, dt_final_pendente_p timestamp, ie_tipo_problema_p bigint, qt_dia_fixo_p bigint, cd_cgc_p text, ie_desconsidera_pend_p text, cd_grupo_material_p bigint default null, cd_subgrupo_material_p bigint default null, cd_local_estoque_p bigint default null, nm_usuario_p text default 'Tasy', qt_dias_cons_p bigint default 30) AS $body$
DECLARE

			
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Tornar possivel visualizar estatisticas sobre estagios atuais de compra dos materiais parametrizados para geracao de ressuprimento. 
			Alem disso, a geracao de ressuprimento tambem fornece a quantidade que necessita ser comprada para cada material, tornando possivel 
			gerar solicitacao de compras de forma automatica de acordo com a quantidade necessaria.
			As informacoes sao inseridas na tabela "material_ressuprimento", visualizadas atraves da funcao "Solicitacao de compra" > aba "Gerar solicitacao".
-------------------------------------------------------------------------------------------------------------------

Parametros: 
cd_estabelecimento_p:   Estabelecimento do usuario
dt_inicio_pendente_p:	Filtro: Data "Ate"
dt_final_pendente_p:	Filtro: Data "De"
ie_tipo_problema_p:		Filtro: "Forma de calculo"
qt_dia_fixo_p:			Filtro: "Dias Fixos" (oculto de acordo com a forma de calculo)
cd_cgc_p:               Filtro: Fornecedor
ie_desconsidera_pend_p: Aba filtros adicionais: "Desconsiderar itens com entregas pendentes"
cd_grupo_material_p:  	Fitro: "Grupo"
cd_subgrupo_material_p: Filtro: "Subgrupo"
cd_local_estoque_p: 	Filtro: "Local est:"
nm_usuario_p:			Usuario
qt_dias_cons_p: 		Filtro: "Dias considerar" (oculto de acordo com a forma de calculo)
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[ x ]  Objetos do dicionario [ x ] Tasy (Delphi/Java/HTML5) [  ] Portal [  ]  Relatorios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------

Lugares mapeados (Caso encontre outro lugar que nao esta no mapeamento abaixo, favor incluir o mesmo):
-Consistencias:
	-Solcitacao de compra
-Pastas:
	-Gera solicitacao [Solicitacao de compra]
	
Abreviacoes:
PE: Parametros de estoque
PC: Parametros de compras
PM: Parametros do material

Conceitos:
	-Valores:
		-Quantidade a comprar = Verificando todas as transacoes de saida e entrada pendentes, o estoque atual e a quantidade maxima permitida em estoque, calcula a quantidade a ser comprada para o material.
	
Alteracoes impactantes necessarias :
	Criacao da documentacao por Giovani Jose Favero [gjfavero] OS 1744348 - 03/01/2019
	
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */


-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>++++++++++ DECLARACAO DE VARIAVEIS  ++++++++++<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--
dt_mesano_referencia_w	    	timestamp;
cd_material_w               		integer    := 0;
cd_material_generico_w		integer;
qt_estoque_maximo_w		double precision := 0;
qt_dia_interv_ressup_w		smallint;
qt_dia_ressup_forn_w		smallint;
qt_dia_estoque_minimo_w		smallint;
qt_estoque_minimo_w		double precision;
qt_consumo_mensal_w		double precision;
qt_desvio_padrao_cons_w		double precision;
qt_coefic_variacao_w		double precision;
qt_ponto_pedido_w			double precision;
qt_estoque_w			double precision := 0;
qt_estoque_ww			double precision := 0;
qt_estoque_ressup_w		double precision := 0;
qt_solic_compra_w			double precision := 0;
qt_solic_compra_ww		double precision := 0;
qt_emprestimo_w			double precision := 0;
qt_ordem_compra_w		double precision := 0;
qt_Cot_compra_w           		double precision := 0;
qt_Cot_compra_ww           		double precision := 0;
qt_pend_req_consumo_w		double precision := 0;
qt_pend_req_transf_saida_w	double precision := 0;
qt_pend_req_transf_entrada_w	double precision := 0;
qt_pend_transf_w			double precision := 0;
vl_excedente_w			double precision := 0;
qt_excedente_w			double precision := 0;
vl_custo_medio_w			double precision := 0;
dt_entrega_ordem_w		timestamp;
dt_entrega_item_w			timestamp;
nr_ordem_compra_w		bigint;
qt_conversao_w			double precision := 0;
qt_conv_divisao_w		double precision := 0;
cd_unid_med_compra_regra_w	varchar(30);
cd_unid_med_estoque_w		varchar(30);
cd_unid_med_movto_w		varchar(30);
qt_dia_w				integer	:= 180;
nr_dia_w				smallint;
nr_solic_compra_w			bigint;
nr_cot_compra_w			bigint;
nr_item_cot_compra_w		bigint;
qt_material_w			double precision;
qt_reg_w				integer;
qt_cons_prev_mes_w		double precision;
dt_inicio_pendente_w		timestamp;
dt_final_pendente_w		timestamp;
ie_periodo_entrega_w		varchar(1);
ie_data_base_compra_pend_w	varchar(80);
ie_material_saldo_ressup_w		varchar(1);
qt_existe_w			integer;
ds_sql_w				varchar(255);
qt_retorno_w			double precision;
qt_compra_w			double precision;
ie_controlado_w			varchar(1);
ie_temperatura_w			varchar(1);
ie_padronizado_w			varchar(1);
ie_situacao_w			varchar(1);
ie_saldo_requisicao_w		varchar(1);
ie_arredond_ressup_w		varchar(1);
mod_w				double precision;
ie_cons_ordem_reprov_ressup_w	varchar(1);
ie_campo_base_ressup_w		varchar(1);
ie_conv_unid_estoque_ressup_w	varchar(1);
ie_cons_solic_ressup_w		varchar(1);
ie_cons_cot_ressup_w		varchar(1);
ie_cons_req_pend_ressup_w		varchar(1);
ie_cons_trans_pend_ressup_w	varchar(1);
ie_coeficiente_variacao_w		varchar(1);
cd_local_estoque_w		bigint;
dt_proxima_entrega_w		timestamp;
ie_consumo_ressup_w		varchar(15);
qt_altura_mat_cm_w		double precision;
qt_largura_mat_cm_w		double precision;
qt_comprimento_mat_cm_w		double precision;
qt_volume_mat_cm_w		double precision;
qt_volume_local_cm_w		double precision;
qt_volume_ocupado_cm_w		double precision;
qt_volume_disponivel_cm_w		double precision;
qt_material_estocavel_w		double precision;
ie_cons_req_etapa_ressup_w		parametro_compras.ie_cons_req_etapa_ressup%type;
qt_itens_nuvem_w			item_requisicao_material.qt_material_requisitada%type := 0;
ie_duas_etapas_req_consumo_w	parametro_estoque.ie_duas_etapas_req_consumo%type;
qt_dias_cons_w  			bigint;
cd_grupo_material_w		grupo_material.cd_grupo_material%type;
cd_subgrupo_material_w		subgrupo_material.cd_subgrupo_material%type;
ie_cons_req_trans_ressup_w	parametro_compras.ie_cons_req_trans_ressup%type;
cd_local_estoque_ww		local_estoque.cd_local_estoque%type;
ie_unid_med_req_ressup_w	parametro_compras.ie_unid_med_req_ressup%type;
qt_conv_compra_estoque_w	material.qt_conv_compra_estoque%type;
qt_conv_estoque_consumo_w	material.qt_conv_estoque_consumo%type;
cd_unidade_medida_compra_w	material.cd_unidade_medida_compra%type;
cd_unidade_medida_estoque_w	material.cd_unidade_medida_estoque%type;
ie_consid_oc_ressup_w		parametro_compras.ie_consid_oc_ressup%type;

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>++++++++++ CURSORES  ++++++++++<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--


-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Cursor 01 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Objetivo: Verificar os materiais ativos configurados para geracao de ressuprimento, de acordo com os filtros preenchidos na funcao.
*/
c01 CURSOR FOR
SELECT	a.cd_material,
	coalesce(a.cd_material_generico, a.cd_material),
	c.qt_estoque_maximo,
	c.qt_dia_interv_ressup,
	c.qt_dia_ressup_forn,
	c.qt_dia_estoque_minimo,
	c.qt_estoque_minimo,
	CASE WHEN ie_consumo_ressup_w='N' THEN c.qt_consumo_mensal_ressup  ELSE c.qt_consumo_mensal END ,
	c.qt_desvio_padrao_cons,
	c.qt_ponto_pedido,
	obter_med_conversao_compra(a.cd_material,cd_cgc_p,'Q',cd_estabelecimento_p),
	coalesce(c.cd_unidade_medida_estoque, a.cd_unidade_medida_estoque),
	obter_med_conversao_compra(a.cd_material,cd_cgc_p,'U',cd_estabelecimento_p),
	substr(coalesce(obter_se_material_temperatura(cd_estabelecimento_p, a.cd_material),'N'),1,1),
	c.ie_padronizado,
	coalesce(a.qt_altura_cm,0),
	coalesce(a.qt_largura_cm,0),
	coalesce(a.qt_comprimento_cm,0)
from	material_estab c,
	material a,
	estrutura_material_v e
where	c.cd_material		= a.cd_material
and	e.cd_material		= a.cd_material
and	((cd_grupo_material_w = 0) or (e.cd_grupo_material = cd_grupo_material_w))
and	((cd_subgrupo_material_w = 0) or (e.cd_subgrupo_material = cd_subgrupo_material_w))
and	c.cd_estabelecimento	= cd_estabelecimento_p
and	a.ie_situacao   	= 'A'
and (coalesce(c.ie_ressuprimento, 'S') = 'S')
and	a.cd_material = coalesce(a.cd_material_estoque, a.cd_material)
and	((	exists (
		SELECT	1
		from	saldo_estoque b
		where	a.cd_material	= b.cd_material
		and	b.dt_mesano_referencia >= PKG_DATE_UTILS.ADD_MONTH(dt_mesano_referencia_w, -3, 0)
		and	b.cd_estabelecimento	= cd_estabelecimento_p  LIMIT 1)
	and	ie_material_saldo_ressup_w = 'N') or (ie_material_saldo_ressup_w = 'S'));

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Cursor 02 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Objetivo: Verificar as solicitacoes de compra pendentes para o material, identificando tambem as cotacoes de compra existentes.
*/
c02 CURSOR FOR
SELECT	a.nr_solic_compra,
	max(obter_cotacao_item_solic(a.nr_solic_compra, a.nr_item_solic_compra)) nr_cot_compra,
	a.nr_item_cot_compra,
	sum(CASE WHEN a.cd_unidade_medida_compra=cd_unid_med_compra_regra_w THEN  b.qt_entrega_solicitada * qt_conversao_w  ELSE b.qt_entrega_solicitada END )
from	Solic_compra_item_entrega b,
	Solic_compra_item a
where 	a.nr_solic_compra = b.nr_solic_compra
and     a.nr_item_solic_compra = b.nr_item_solic_compra
and	coalesce(a.dt_baixa::text, '') = ''
and	a.cd_material	in (
		SELECT	cd_material
		from	material
		where	cd_material_estoque = cd_material_w)
and	b.dt_entrega_solicitada between dt_inicio_pendente_w and dt_final_pendente_w
and	ie_periodo_entrega_w = 'S'
group by
	a.nr_solic_compra,
	a.nr_item_cot_compra,
	a.cd_unidade_medida_compra

union all

select	nr_solic_compra,
	obter_cotacao_item_solic(a.nr_solic_compra, a.nr_item_solic_compra) nr_cot_compra,
	nr_item_cot_compra,
	CASE WHEN a.cd_unidade_medida_compra=cd_unid_med_compra_regra_w THEN  qt_material * qt_conversao_w  ELSE qt_material END
from	Solic_compra_item a
where	coalesce(a.dt_baixa::text, '') = ''
and	a.cd_material	in (
		select	cd_material
		from	material
		where	cd_material_estoque = cd_material_w)
		and	a.dt_atualizacao > clock_timestamp() - qt_dia_w
and	ie_periodo_entrega_w = 'N';

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Cursor 03 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Objetivo: Verificar os materiais ativos configurados para geracao de ressuprimento.
*/
c03 CURSOR FOR
SELECT	distinct b.cd_local_estoque
from 	local_estoque b,
	saldo_estoque a
where	cd_material		= cd_material_w
and	dt_mesano_referencia	>= dt_mesano_referencia_w
and	a.cd_local_estoque	= b.cd_local_estoque
and	a.cd_estabelecimento	= cd_estabelecimento_p
and	b.ie_proprio		= 'S'
and (substr(obter_se_considera_ressup(a.cd_estabelecimento,a.cd_local_estoque, a.cd_material),1,1) = 'S')
and not exists (	SELECT	1
			from	w_loc_estoque_ressup x
			where	x.cd_local_estoque = a.cd_local_estoque
			and	x.nm_usuario = nm_usuario_p  LIMIT 1)
and	dt_mesano_referencia	= (
	select	max(c.dt_mesano_referencia)
	from	saldo_estoque c
	where	c.cd_material		= a.cd_material
	and	c.cd_estabelecimento	= a.cd_estabelecimento
	and	c.cd_local_estoque	= a.cd_local_estoque
	and	dt_mesano_referencia	>= dt_mesano_referencia_w);

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Cursor 04 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Objetivo: Verificar as ordens de compra pendentes para o material.
*/
c04 CURSOR FOR
SELECT	a.dt_entrega
from	data_ordem_compra_pend_v a
where	a.cd_material_estoque   = cd_material_w
and	a.cd_estabelecimento    = cd_estabelecimento_p
and	PKG_DATE_UTILS.start_of(a.dt_entrega,'dd',0) >= PKG_DATE_UTILS.start_of(clock_timestamp(),'dd',0)
order by a.dt_entrega desc;

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Inicio da execucao <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--
BEGIN

cd_grupo_material_w		:= coalesce(cd_grupo_material_p,0);
cd_subgrupo_material_w		:= coalesce(cd_subgrupo_material_p,0);
cd_local_estoque_ww		:= coalesce(cd_local_estoque_p,0);

qt_dias_cons_w := coalesce(qt_dias_cons_p,30);

/* Armazena a quantidade total de dias no mes atual */

select	PKG_DATE_UTILS.extract_field('DAY', PKG_DATE_UTILS.END_OF(clock_timestamp(), 'MONTH', 0))
into STRICT	nr_dia_w
;

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> LIMPEZA DOS DADOS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Objetivo: Realizar a limpeza das informacoes de ressuprimento. Serao limpos os registros dos materiais que terao ressuprimento gerado novamente.
*/
if (cd_grupo_material_w > 0) then

	delete
	from	material_ressuprimento a
	where	cd_estabelecimento	= cd_estabelecimento_p
	and exists (	SELECT	1
			from	estrutura_material_v e
			where	a.cd_material = e.cd_material
			and	e.cd_grupo_material = cd_grupo_material_w);
end if;


if (cd_subgrupo_material_w > 0) then

	delete
	from	material_ressuprimento a
	where	cd_estabelecimento	= cd_estabelecimento_p
	and exists (	SELECT	1
			from	estrutura_material_v e
			where	a.cd_material = e.cd_material
			and	e.cd_subgrupo_material = cd_subgrupo_material_w);
end if;

if (cd_grupo_material_w = 0) and (cd_subgrupo_material_w = 0) then

	delete
	from	material_ressuprimento a
	where	cd_estabelecimento	= cd_estabelecimento_p;
end if;

delete
from	prog_entregra_mat_ressup
where	cd_estabelecimento	= cd_estabelecimento_p;

--PE>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Parametros de estoque <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/* 
Armazena parametrizacoes de estoque para o estabalecimento.
dt_mesano_vigente: Mes vigente. O sistema atualiza automaticamente na virada do mes.
ie_saldo_requisicao: Saldo a ser considerado no ressuprimento.
					 D: Saldo disponivel: considera a soma dos saldos existentes em todos os locais do estabelecimento.
					 E: Saldo contabil: Emprestimo saida: considera o saldo disponivel em estoque, menos a quantidade em emprestimos de saida.
ie_duas_etapas_req_consumo: Define se as requisicoes de consumo devem ser atendidas em duas etapas: a primeira e feita na retirada da mercadoria 
				            do local de estoque, baixando o saldo de estoque do local. 
 */
begin
select	PKG_DATE_UTILS.start_of(dt_mesano_vigente,'month',0),
	coalesce(ie_saldo_requisicao,'C'),
	coalesce(ie_duas_etapas_req_consumo,'N')
into STRICT	dt_mesano_referencia_w,
	ie_saldo_requisicao_w,
	ie_duas_etapas_req_consumo_w
from	parametro_estoque
where	cd_estabelecimento	= cd_estabelecimento_p
and	ie_situacao 		= 'A';
exception
when others then
	CALL wheb_mensagem_pck.exibir_mensagem_abort(337378);
	/*Ocorreu uma restricao ao buscar as informacoes dos parametros de estoques.
	- Verificar se existe o cadastro dos parametros de estoque nesse estabelecimento;
	- Verificar se existe 2 ou mais registros nos parametros de estoque para esse estabelecimento.*/
end;

--PC>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Parametros de compras <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Armazena parametrizacoes de compras para o estabalecimento.
qt_dia_compra_pend:          Dias que o sistema deve considerar para compras pendentes. Acima deste periodo o sistema considera as ordens como nao recebiveis.
ie_data_base_compra_pend:    Selecione qual sera a data usada como base para a pesquisa de compras pendentes no sistema.
ie_material_saldo_ressup:    Considerar material sem saldo no ressuprimento.
ie_cons_ordem_reprov_ressup: Marque se o ressuprimento deve considerar as compras reprovadas como uma compra pendente.
ie_campo_base_ressup:        A formula do ressuprimento. Se for M: Qt maximo. Se for P: Qt. Ponto Pedido.
ie_conv_unid_estoque_ressup: Se o sistema deve converter as colunas (Qt. Solic, Qt. Cotacao e Qt. Ordem) em unidade de estoque na tela de ressuprimento.
ie_cons_solic_ressup:        Selecionar ou nao as solicitacoes de compras como pendentes.
ie_cons_cot_ressup:          Considerar ou nao as cotacoes de compra como pendentes.
ie_consumo_ressup:           A Philips nao recomenda alterar esse parametro. O correto e utilizar a opcao "Consumo geral". Esse campo serve para escolher qual sera o consumo utilizado no calculo do ressuprimento.
ie_cons_req_pend_ressup:     Define se no ressuprimento, e para considerar a quantidade pendente de atendimento das requisicoes de consumo (considera somente as requisicoes cujo a operacao de estoque seja de Requisicao consumo).
ie_cons_trans_pend_ressup:   Define se no ressuprimento,e para considerar a quantidade pendente de atendimento das transferencias de estoque de saida deste estabelecimento.
ie_coeficiente_variacao:     Define se deve adicionar o coeficiente de variacao na quantidade a comprar sugerida pelo ressuprimento. 
ie_cons_req_etapa_ressup:    Define se deve ser considerado os itens que estao pendente de atendimento nas requisicoes de duas etapas. Ou seja, os itens que sairam de um local de estoque mas ainda nao entraram no outro local de estoque.
ie_cons_req_trans_ressup:    Define se deve ser considerado as requisicoes de transferencia no ressuprimento. Essas requisicoes de transferencias serao consideradas somente se o ressuprimento for gerado para um determinado local de estoque (selecionando o filtro por local de estoque.
ie_unid_med_req_ressup:      Qual unidade de medida que deve ser considerada para obter a quantidade requisitada no ressuprimento (a quantidade de requisicoes e considerada no ressuprimento).
ie_consid_oc_ressup:         Quais ordens de compra devem ser consideradas no calculo do ressuprimento. A: Aprovadas. L: Liberadas.
*/
begin
select	coalesce(qt_dia_compra_pend,180),
	coalesce(ie_data_base_compra_pend, 'DT_ATUALIZACAO'),
	coalesce(ie_material_saldo_ressup, 'N'),
	coalesce(ie_cons_ordem_reprov_ressup, 'N'),
	coalesce(ie_campo_base_ressup,'M'),
	coalesce(ie_conv_unid_estoque_ressup,'N'),
	coalesce(ie_cons_solic_ressup, 'S'),
	coalesce(ie_cons_cot_ressup, 'S'),
	coalesce(ie_consumo_ressup,'S'),
	coalesce(ie_cons_req_pend_ressup,'N'),
	coalesce(ie_cons_trans_pend_ressup,'N'),
	coalesce(ie_coeficiente_variacao,'N'),
	coalesce(ie_cons_req_etapa_ressup,'N'),
	coalesce(ie_cons_req_trans_ressup,'N'),
	coalesce(ie_unid_med_req_ressup,'UMC'),
	coalesce(ie_consid_oc_ressup,'X')
into STRICT	qt_dia_w,
	ie_data_base_compra_pend_w,
	ie_material_saldo_ressup_w,
	ie_cons_ordem_reprov_ressup_w,
	ie_campo_base_ressup_w,
	ie_conv_unid_estoque_ressup_w,
	ie_cons_solic_ressup_w,
	ie_cons_cot_ressup_w,
	ie_consumo_ressup_w,
	ie_cons_req_pend_ressup_w,
	ie_cons_trans_pend_ressup_w,
	ie_coeficiente_variacao_w,
	ie_cons_req_etapa_ressup_w,
	ie_cons_req_trans_ressup_w,
	ie_unid_med_req_ressup_w,
	ie_consid_oc_ressup_w
from	parametro_compras
where	cd_estabelecimento	= cd_estabelecimento_p;
exception
when others then
	CALL wheb_mensagem_pck.exibir_mensagem_abort(337380);
	/*Ocorreu uma restricao ao buscar as informacoes dos parametros de compras.
	- Verificar se existe o cadastro dos parametros de compras nesse estabelecimento;
	- Verificar se existe 2 ou mais registros nos parametros de compras para esse estabelecimento.*/
end;

/*
Se os parametros "Data Inicial" e "Data Final" foram preenchidos, entao armazena o valor 'S' na variavel ie_periodo_entrega_w 
e armazena o primeiro dia do mes de cada data.
*/
ie_periodo_entrega_w	:= 'N';
if (dt_inicio_pendente_p IS NOT NULL AND dt_inicio_pendente_p::text <> '') and (dt_final_pendente_p IS NOT NULL AND dt_final_pendente_p::text <> '') then
	begin
	ie_periodo_entrega_w	:= 'S';
	dt_inicio_pendente_w	:= PKG_DATE_UTILS.start_of(dt_inicio_pendente_p, 'dd',0);
	dt_final_pendente_w	:= PKG_DATE_UTILS.start_of(dt_final_pendente_p, 'dd',0);
	end;
end if;

-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Abertura cursor 01 <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/* Inicia a execucao para cada material a gerar ressuprimento */

OPEN C01;
LOOP
FETCH	C01 into
	cd_material_w,
	cd_material_generico_w,
	qt_estoque_maximo_w,
	qt_dia_interv_ressup_w,
	qt_dia_ressup_forn_w,
	qt_dia_estoque_minimo_w,
	qt_estoque_minimo_w,
	qt_consumo_mensal_w,
	qt_desvio_padrao_cons_w,
	qt_ponto_pedido_w,
	qt_conversao_w,
	cd_unid_med_estoque_w,
	cd_unid_med_compra_regra_w,
	ie_temperatura_w,
	ie_padronizado_w,
	qt_altura_mat_cm_w,
	qt_largura_mat_cm_w,
	qt_comprimento_mat_cm_w;
EXIT WHEN NOT FOUND; /* apply on C01 */
	begin
	
	/* Identifica se o material e controlado para armazenar na tabela de ressuprimento */
	
	ie_controlado_w := 'N';

	select	count(*)
	into STRICT	qt_reg_w
	from	medic_controlado
	where	cd_material = cd_material_w
	and	ie_situacao = 'A'
	and	coalesce(cd_estabelecimento,cd_estabelecimento_p) = cd_estabelecimento_p  LIMIT 1;

	if (qt_reg_w > 0) then
		ie_controlado_w	:= 'S';
	end if;

	/* Armazena a quantidade em estoque e valor de custo medio para os locais que nao sao desconsiderados. 
	   Os locais desconsiderados estao presentes na view w_loc_estoque_ressup. Alem disso sao considerados somente locais proprios. */
	select	coalesce(sum(qt_estoque),0),
		coalesce(max(vl_custo_medio),0)
	into STRICT	qt_estoque_w,
		    vl_custo_medio_w
	from 	local_estoque b,
		    saldo_estoque a
	where	a.cd_estabelecimento	= cd_estabelecimento_p
	and	cd_material		= cd_material_w
	and	dt_mesano_referencia	>= dt_mesano_referencia_w
	and	a.cd_local_estoque	= b.cd_local_estoque
	and	b.ie_proprio		= 'S'
	and (substr(obter_se_considera_ressup(a.cd_estabelecimento,a.cd_local_estoque, a.cd_material),1,1) = 'S')
	and not exists (	SELECT	1
			          from	w_loc_estoque_ressup x
			         where	x.cd_local_estoque = a.cd_local_estoque
			           and	x.nm_usuario = nm_usuario_p  LIMIT 1)
	and	dt_mesano_referencia	= (select	max(c.dt_mesano_referencia)
									 from	saldo_estoque c
									where	c.cd_material		= a.cd_material
								      and	c.cd_estabelecimento	= a.cd_estabelecimento
									  and	c.cd_local_estoque	= a.cd_local_estoque
									  and	dt_mesano_referencia	>= dt_mesano_referencia_w);

	
	begin
	select	sum(coalesce(qt_altura_cm,0) * coalesce(qt_largura_cm,0) * coalesce(qt_comprimento_cm,0))
	into STRICT	qt_volume_local_cm_w
	from	localizacao_estoque_local
	where	cd_material = cd_material_w
	and	cd_local_estoque = obter_local_estoque_setor(wheb_usuario_pck.get_cd_setor_atendimento,cd_estabelecimento_p)
	and	cd_estabelecimento = cd_estabelecimento_p;
	exception when others then
		null;
	end;
	
	qt_pend_req_consumo_w := 0;
	
	/*
	De acordo com o parametro de compra, se necessario armazena quantidade pendente de atendimento nas requisicoes de consumo.
	*/
	if (ie_cons_req_pend_ressup_w = 'S') then

		select	coalesce(sum(c.qt_material_requisitada),0)
		into STRICT	qt_pend_req_consumo_w
		from	material a ,
			operacao_estoque o ,
			requisicao_material b,
			item_requisicao_material c,
			sup_motivo_baixa_req e
		where	b.nr_requisicao		= c.nr_requisicao
		and	a.cd_material		= c.cd_material
		and	b.cd_operacao_estoque	= o.cd_operacao_estoque
		and	c.cd_motivo_baixa	= e.nr_sequencia
		and	e.cd_motivo_baixa	= 0
		and	o.ie_tipo_requisicao	= '1'
		and	a.cd_material		= cd_material_w
		and	(b.dt_liberacao IS NOT NULL AND b.dt_liberacao::text <> '');

	end if;

	qt_pend_req_transf_entrada_w	:= 0;
	qt_pend_req_transf_saida_w	:= 0;

	/*
	De acordo com o parametro de compra, e se o local de estoque estiver preenchido, armazena a quantidade pendente em requisicoes de transferencia.
	As transferencias de saida sao acrescentadas a quantidade pendente de requisicao de consumo, ja as de entrada sao subtraidas.
	*/
	if (cd_local_estoque_ww > 0) and (ie_cons_req_trans_ressup_w = 'S') then

		select	coalesce(sum(c.qt_material_requisitada),0)
		into STRICT	qt_pend_req_transf_saida_w
		from	material a ,
			operacao_estoque o ,
			requisicao_material b,
			item_requisicao_material c,
			sup_motivo_baixa_req e
		where	b.nr_requisicao		= c.nr_requisicao
		and	a.cd_material		= c.cd_material
		and	b.cd_operacao_estoque	= o.cd_operacao_estoque
		and	c.cd_motivo_baixa	= e.nr_sequencia
		and	e.cd_motivo_baixa	= 0
		and	o.ie_tipo_requisicao	= '2'
		and	a.cd_material		= cd_material_w
		and	(b.dt_liberacao IS NOT NULL AND b.dt_liberacao::text <> '')
		and	b.cd_local_estoque	= cd_local_estoque_ww
		and	o.ie_entrada_saida	= 'S';

		if (qt_pend_req_transf_saida_w > 0) then
			qt_pend_req_consumo_w := qt_pend_req_consumo_w + qt_pend_req_transf_saida_w;
		end if;


		select	coalesce(sum(c.qt_material_requisitada),0)
		into STRICT	qt_pend_req_transf_entrada_w
		from	material a ,
			operacao_estoque o ,
			requisicao_material b,
			item_requisicao_material c,
			sup_motivo_baixa_req e
		where	b.nr_requisicao		= c.nr_requisicao
		and	a.cd_material		= c.cd_material
		and	b.cd_operacao_estoque	= o.cd_operacao_estoque
		and	c.cd_motivo_baixa	= e.nr_sequencia
		and	e.cd_motivo_baixa	= 0
		and	o.ie_tipo_requisicao	= '2'
		and	a.cd_material		= cd_material_w
		and	(b.dt_liberacao IS NOT NULL AND b.dt_liberacao::text <> '')
		and	b.cd_local_estoque	= cd_local_estoque_ww
		and	o.ie_entrada_saida	= 'E';

		if (qt_pend_req_transf_entrada_w > 0) then
			qt_pend_req_consumo_w := qt_pend_req_consumo_w - qt_pend_req_transf_entrada_w;
		end if;
	end if;

    /* De acordo com o parametro de compra, se necessario armazena a quantidade pendente em transferencias de estoque de saida para o material. */

	if (ie_cons_trans_pend_ressup_w = 'S') then
		qt_pend_transf_w := obter_qt_pend_transf_etq_estab(cd_estabelecimento_p, cd_material_w, cd_local_estoque_p);
	end if;

	/*
	De acordo com o parametro de compra ie_saldo_requisicao, armazena a quantidade em estoque. 
	Se necessario, desconta a quantidade em emprestimos vigentes.
	*/
	if (coalesce(ie_saldo_requisicao_w, 'C') = 'D') then

		qt_estoque_w	:= 0;
		qt_estoque_ww	:= 0;

		open C03;
		loop
		fetch C03 into
			cd_local_estoque_w;
		EXIT WHEN NOT FOUND; /* apply on C03 */
			begin
			qt_estoque_ww	:= obter_saldo_disp_estoque(
						cd_estabelecimento_p,
						cd_material_w,
						cd_local_estoque_w,
						PKG_DATE_UTILS.start_of(clock_timestamp(),'mm',0));

			qt_estoque_w := qt_estoque_w + qt_estoque_ww;
			end;
		end loop;
		close C03;
	end if;


	if (coalesce(ie_saldo_requisicao_w, 'C') = 'E') then
		begin
		select	coalesce(sum(qt_material),0)
		into STRICT	qt_emprestimo_w
		from	emprestimo c,
			emprestimo_material b
		where	b.nr_emprestimo	= c.nr_emprestimo
		and	c.ie_tipo		= 'S'
		and	c.ie_situacao		<> 'I'
		and	(c.dt_liberacao IS NOT NULL AND c.dt_liberacao::text <> '')
		and	b.qt_material	> 0
		and	exists (
			SELECT 1 from material a
			where	a.cd_material_estoque	= cd_material_w
		  	and	a.cd_material 		= b.cd_material);

		qt_estoque_w	:= qt_estoque_w	- qt_emprestimo_w;
		end;
	end if;

	
	if (coalesce(ie_cons_req_etapa_ressup_w,'N') = 'S') then

		select 	coalesce(sum(i.qt_material_atendida),0)
		into STRICT	qt_itens_nuvem_w
		from	requisicao_material b,
			operacao_estoque o,
			item_requisicao_material i
		where	b.cd_operacao_estoque = o.cd_operacao_estoque
		and	i.nr_requisicao = b.nr_requisicao
		and	i.cd_material = cd_material_w
		and	o.ie_tipo_requisicao = 21
		and	coalesce(i.dt_recebimento::text, '') = ''
		and	exists (SELECT 	1
				from 	sup_motivo_baixa_req e
				where	i.cd_motivo_baixa	= e.nr_sequencia
				and	e.cd_motivo_baixa	in (1,4)  LIMIT 1);

		--qt_estoque_w	:= qt_estoque_w	+ qt_itens_nuvem_w;
	end if;
	
	/* Armazena data de proxima entrega para o material. */

	open C04;
	loop
	fetch C04 into
		dt_proxima_entrega_w;
	EXIT WHEN NOT FOUND; /* apply on C04 */
		begin
		dt_proxima_entrega_w := dt_proxima_entrega_w;
		end;
	end loop;
	close C04;

	/* Obter quantidade em ordens de compra pendentes */


	/* Caso os filtros "Data inicial" e "Data final" nao estiverem preenchidos. */

	if (ie_periodo_entrega_w = 'N') then
		begin
		
		/* 
		De acordo com o campo parametrizado para ser utilizado como base para consulta de ordens, realiza a consulta de ordens pendentes.
		O campo deve estar vigente com o periodo maximo definido no parametro de compra qt_dia_compra_pend (armazenado na variavel qt_dia_w).
		*/
		
		if (ie_data_base_compra_pend_w = 'DT_ATUALIZACAO') then

			select	coalesce(sum(CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  obter_qt_pend_ordem_entrega(a.nr_ordem_compra, a.nr_item_oci) * m.qt_conv_compra_estoque  ELSE obter_qt_pend_ordem_entrega(a.nr_ordem_compra, a.nr_item_oci) END ),0) qt_ordem
			  into STRICT 	qt_ordem_compra_w
			  from 	ordem_compra_item a,
				    material m
			 where 	a.cd_material = m.cd_material
			   and	a.qt_material > coalesce(obter_qt_entregue_oci(a.nr_ordem_compra, a.nr_item_oci),0)
			   and	a.dt_atualizacao > clock_timestamp() - qt_dia_w
			   and	((ie_cons_ordem_reprov_ressup_w = 'S') or
				((ie_cons_ordem_reprov_ressup_w = 'N') and (coalesce(a.dt_reprovacao::text, '') = '')))
			   and	a.cd_material 	in (SELECT cd_material
										  from material
										 where cd_material_estoque	= cd_material_w)
			   and	exists(select	1
						     from	ordem_compra b
							where	a.nr_ordem_compra	= b.nr_ordem_compra
							  and	coalesce(b.dt_baixa::text, '') = ''
							  and	b.cd_estabelecimento	= cd_estabelecimento_p
  							  and ((ie_consid_oc_ressup_w = 'X') or
								  (ie_consid_oc_ressup_w = 'L' AND b.dt_liberacao IS NOT NULL AND b.dt_liberacao::text <> '') or
								  (ie_consid_oc_ressup_w = 'A' AND b.dt_aprovacao IS NOT NULL AND b.dt_aprovacao::text <> ''))  LIMIT 1);
		elsif (ie_data_base_compra_pend_w = 'DT_ORDEM_COMPRA') then

			select	coalesce(sum(CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  obter_qt_pend_ordem_entrega(a.nr_ordem_compra, a.nr_item_oci) * m.qt_conv_compra_estoque  ELSE obter_qt_pend_ordem_entrega(a.nr_ordem_compra, a.nr_item_oci) END ),0) qt_ordem
			into STRICT 	qt_ordem_compra_w
			from 	ordem_compra_item a,
				material m
			where 	a.cd_material = m.cd_material
			and	a.qt_material > coalesce(obter_qt_entregue_oci(a.nr_ordem_compra, a.nr_item_oci),0)
			and	((ie_cons_ordem_reprov_ressup_w = 'S') or
				((ie_cons_ordem_reprov_ressup_w = 'N') and (coalesce(a.dt_reprovacao::text, '') = '')))
			and	a.cd_material 	in (
				SELECT cd_material
				from material
				where cd_material_estoque	= cd_material_w)
			  and	exists(
				SELECT	1
				from	ordem_compra b
				where	a.nr_ordem_compra		= b.nr_ordem_compra
		  		and	coalesce(b.dt_baixa::text, '') = ''
				and	b.cd_estabelecimento	= cd_estabelecimento_p
				and	b.dt_ordem_compra > clock_timestamp() - qt_dia_w
				and ((ie_consid_oc_ressup_w = 'X') or
					(ie_consid_oc_ressup_w = 'L' AND b.dt_liberacao IS NOT NULL AND b.dt_liberacao::text <> '') or
					(ie_consid_oc_ressup_w = 'A' AND b.dt_aprovacao IS NOT NULL AND b.dt_aprovacao::text <> ''))  LIMIT 1);
		elsif (ie_data_base_compra_pend_w = 'DT_ENTREGA') then

			select	coalesce(sum(CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  obter_qt_pend_ordem_entrega(a.nr_ordem_compra, a.nr_item_oci) * m.qt_conv_compra_estoque  ELSE obter_qt_pend_ordem_entrega(a.nr_ordem_compra, a.nr_item_oci) END ),0) qt_ordem
			into STRICT 	qt_ordem_compra_w
			from 	ordem_compra_item a,
				material m
			where 	a.cd_material = m.cd_material
			and	a.qt_material > coalesce(obter_qt_entregue_oci(a.nr_ordem_compra, a.nr_item_oci),0)
			and	((ie_cons_ordem_reprov_ressup_w = 'S') or
				((ie_cons_ordem_reprov_ressup_w = 'N') and (coalesce(a.dt_reprovacao::text, '') = '')))
			and	a.cd_material 	in (
				SELECT cd_material
				from material
				where cd_material_estoque	= cd_material_w)
			  and	exists(
				SELECT	1
				from	ordem_compra b
				where	a.nr_ordem_compra		= b.nr_ordem_compra
		  		and	coalesce(b.dt_baixa::text, '') = ''
				and	b.cd_estabelecimento	= cd_estabelecimento_p
				and	b.dt_entrega > clock_timestamp() - qt_dia_w
				and ((ie_consid_oc_ressup_w = 'X') or
					(ie_consid_oc_ressup_w = 'L' AND b.dt_liberacao IS NOT NULL AND b.dt_liberacao::text <> '') or
					(ie_consid_oc_ressup_w = 'A' AND b.dt_aprovacao IS NOT NULL AND b.dt_aprovacao::text <> ''))  LIMIT 1);
		end if;
		end;
	
	/* Caso os filtros "Data inicial" e "Data final" estiverem preenchidos, o periodo selecionado e validado com a data prevista de entrega para o material. */

	
	elsif (ie_periodo_entrega_w = 'S') then
		begin
		if (ie_data_base_compra_pend_w = 'DT_ATUALIZACAO') then
			select	coalesce(sum(
				CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  coalesce(b.qt_prevista_entrega,0) * m.qt_conv_compra_estoque  ELSE coalesce(b.qt_prevista_entrega,0) END  -
				CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  coalesce(b.qt_real_entrega,0) * m.qt_conv_compra_estoque  ELSE coalesce(b.qt_real_entrega,0) END
				), 0)
			into STRICT 	qt_ordem_compra_w
			from	material m,
				ordem_compra o,
				ordem_compra_item a,
				ordem_compra_item_entrega b
			where	PKG_DATE_UTILS.start_of(b.dt_prevista_entrega,'dd',0) between PKG_DATE_UTILS.start_of(dt_inicio_pendente_w,'dd',0) and PKG_DATE_UTILS.start_of(dt_final_pendente_w,'dd',0)
			and	coalesce(b.dt_cancelamento::text, '') = ''
			and	b.nr_ordem_compra	= a.nr_ordem_compra
			and	b.nr_item_oci	= a.nr_item_oci
			and	a.dt_atualizacao > clock_timestamp() - qt_dia_w
			and	((ie_cons_ordem_reprov_ressup_w = 'S') or
				((ie_cons_ordem_reprov_ressup_w = 'N') and (coalesce(a.dt_reprovacao::text, '') = '')))
			and	a.qt_material		> coalesce(obter_qt_entregue_oci(a.nr_ordem_compra, a.nr_item_oci),0)
			/*
			and	a.cd_material		= m.cd_material_estoque
			and	a.cd_material		= cd_material_w
			Alterado para que seja buscado pelo controlador de estoque, como demais consultas
			*/
			and	a.cd_material		= m.cd_material
			and	m.cd_material_estoque	= cd_material_w
			and	a.nr_ordem_compra	= o.nr_ordem_compra
			and	coalesce(o.dt_baixa::text, '') = ''
			and	o.cd_estabelecimento	= cd_estabelecimento_p
			and ((ie_consid_oc_ressup_w = 'X') or
					(ie_consid_oc_ressup_w = 'L' AND o.dt_liberacao IS NOT NULL AND o.dt_liberacao::text <> '') or
					(ie_consid_oc_ressup_w = 'A' AND o.dt_aprovacao IS NOT NULL AND o.dt_aprovacao::text <> ''))
			and	((ie_desconsidera_pend_p = 'N') or
				((ie_desconsidera_pend_p = 'S') and ((b.dt_inicio_pendencia IS NOT NULL AND b.dt_inicio_pendencia::text <> '') and (coalesce(b.dt_fim_pendencia::text, '') = ''))));


		elsif (ie_data_base_compra_pend_w = 'DT_ORDEM_COMPRA') then
			select	coalesce(sum(
				CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  coalesce(b.qt_prevista_entrega,0) * m.qt_conv_compra_estoque  ELSE coalesce(b.qt_prevista_entrega,0) END  -
				CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  coalesce(b.qt_real_entrega,0) * m.qt_conv_compra_estoque  ELSE coalesce(b.qt_real_entrega,0) END
				), 0)
			into STRICT 	qt_ordem_compra_w
			from	material m,
				ordem_compra o,
				ordem_compra_item a,
				ordem_compra_item_entrega b
			where	PKG_DATE_UTILS.start_of(b.dt_prevista_entrega,'dd',0) between PKG_DATE_UTILS.start_of(dt_inicio_pendente_w,'dd',0) and PKG_DATE_UTILS.start_of(dt_final_pendente_w,'dd',0)
			and	coalesce(b.dt_cancelamento::text, '') = ''
			and	b.nr_ordem_compra	= a.nr_ordem_compra
			and	b.nr_item_oci	= a.nr_item_oci
			and	((ie_cons_ordem_reprov_ressup_w = 'S') or
				((ie_cons_ordem_reprov_ressup_w = 'N') and (coalesce(a.dt_reprovacao::text, '') = '')))
			and	a.qt_material	> coalesce(obter_qt_entregue_oci(a.nr_ordem_compra, a.nr_item_oci),0)
			/*
			and	a.cd_material		= m.cd_material_estoque
			and	a.cd_material		= cd_material_w
			Alterado para que seja buscado pelo controlador de estoque, como demais consultas
			*/
			and	a.cd_material		= m.cd_material
			and	m.cd_material_estoque	= cd_material_w
			and	a.nr_ordem_compra	= o.nr_ordem_compra
			and	coalesce(o.dt_baixa::text, '') = ''
			and	o.cd_estabelecimento = cd_estabelecimento_p
			and	o.dt_ordem_compra > clock_timestamp() - qt_dia_w
			and ((ie_consid_oc_ressup_w = 'X') or
					(ie_consid_oc_ressup_w = 'L' AND o.dt_liberacao IS NOT NULL AND o.dt_liberacao::text <> '') or
					(ie_consid_oc_ressup_w = 'A' AND o.dt_aprovacao IS NOT NULL AND o.dt_aprovacao::text <> ''))
			and	((ie_desconsidera_pend_p = 'N') or
				((ie_desconsidera_pend_p = 'S') and ((b.dt_inicio_pendencia IS NOT NULL AND b.dt_inicio_pendencia::text <> '') and (coalesce(b.dt_fim_pendencia::text, '') = ''))));
		elsif (ie_data_base_compra_pend_w = 'DT_ENTREGA') then
			select	coalesce(sum(
				CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  coalesce(b.qt_prevista_entrega,0) * m.qt_conv_compra_estoque  ELSE coalesce(b.qt_prevista_entrega,0) END  -
				CASE WHEN a.cd_unidade_medida_compra=m.cd_unidade_medida_compra THEN  coalesce(b.qt_real_entrega,0) * m.qt_conv_compra_estoque  ELSE coalesce(b.qt_real_entrega,0) END
				), 0)
			into STRICT 	qt_ordem_compra_w
			from	material m,
				ordem_compra o,
				ordem_compra_item a,
				ordem_compra_item_entrega b
			where	PKG_DATE_UTILS.start_of(b.dt_prevista_entrega,'dd',0) between PKG_DATE_UTILS.start_of(dt_inicio_pendente_w,'dd',0) and PKG_DATE_UTILS.start_of(dt_final_pendente_w,'dd',0)
			and	coalesce(b.dt_cancelamento::text, '') = ''
			and	b.nr_ordem_compra	= a.nr_ordem_compra
			and	b.nr_item_oci	= a.nr_item_oci
			and	((ie_cons_ordem_reprov_ressup_w = 'S') or
				((ie_cons_ordem_reprov_ressup_w = 'N') and (coalesce(a.dt_reprovacao::text, '') = '')))
			and	a.qt_material	> coalesce(obter_qt_entregue_oci(a.nr_ordem_compra, a.nr_item_oci),0)
			/*
			and	a.cd_material		= m.cd_material_estoque
			and	a.cd_material		= cd_material_w
			Alterado para que seja buscado pelo controlador de estoque, como demais consultas
			*/
			and	a.cd_material		= m.cd_material
			and	m.cd_material_estoque	= cd_material_w
			and	a.nr_ordem_compra	= o.nr_ordem_compra
			and	coalesce(o.dt_baixa::text, '') = ''
			and	o.cd_estabelecimento = cd_estabelecimento_p
			and	o.dt_entrega > clock_timestamp() - qt_dia_w
			and ((ie_consid_oc_ressup_w = 'X') or
					(ie_consid_oc_ressup_w = 'L' AND o.dt_liberacao IS NOT NULL AND o.dt_liberacao::text <> '') or
					(ie_consid_oc_ressup_w = 'A' AND o.dt_aprovacao IS NOT NULL AND o.dt_aprovacao::text <> ''))
			and	((ie_desconsidera_pend_p = 'N') or
				((ie_desconsidera_pend_p = 'S') and ((b.dt_inicio_pendencia IS NOT NULL AND b.dt_inicio_pendencia::text <> '') and (coalesce(b.dt_fim_pendencia::text, '') = ''))));
		end if;
		end;
	end if;

	qt_solic_compra_w	:= 0;
	qt_cot_compra_w		:= 0;
	
	
	/* Armazena a quantidade pendente em solicitacoes e cotacoes de compra para o material. */

	OPEN C02;
	LOOP
	FETCH C02 into
		nr_solic_compra_w,
		nr_cot_compra_w,
		nr_item_cot_compra_w,
		qt_material_w;
	EXIT WHEN NOT FOUND; /* apply on C02 */

		select	coalesce(sum(qt_material_w),0)
		  into STRICT	qt_material_w
		  from	solic_compra
		 where	nr_solic_compra 	= nr_solic_compra_w
		   and	(dt_liberacao IS NOT NULL AND dt_liberacao::text <> '')
		   and	cd_estabelecimento	= cd_estabelecimento_p
		   and	coalesce(dt_baixa::text, '') = '';

		if (coalesce(nr_cot_compra_w::text, '') = '') then
			qt_solic_compra_w := qt_solic_compra_w + qt_material_w;
		else	
			begin
				select	count(*)
				  into STRICT	qt_reg_w
				  from	ordem_compra a,
						ordem_compra_item b
				 where a.nr_ordem_compra    = b.nr_ordem_compra
				   and a.cd_estabelecimento = cd_estabelecimento_p
				   and b.nr_cot_compra	    = nr_cot_compra_w
				   and b.nr_item_cot_compra = nr_item_cot_compra_w  LIMIT 1;

				if (qt_reg_w = 0) then
					select	coalesce(max(b.ie_situacao),'A')
					  into STRICT	ie_situacao_w
					  from	cot_compra a,
						    cot_compra_item b
					 where a.nr_cot_compra      = b.nr_cot_compra
					   and a.cd_estabelecimento = cd_estabelecimento_p
					   and b.nr_cot_compra      = nr_cot_compra_w
					   and b.nr_item_cot_compra	= nr_item_cot_compra_w;

					if (ie_situacao_w = 'A') then

						select	coalesce(sum(CASE WHEN b.cd_unidade_medida_compra=cd_unid_med_compra_regra_w THEN  b.qt_material * qt_conversao_w  ELSE b.qt_material END ),0)
						  into STRICT	qt_material_w
						  from	cot_compra a,
								cot_compra_item b
						 where a.nr_cot_compra      = b.nr_cot_compra
						   and a.cd_estabelecimento = cd_estabelecimento_p
						   and b.nr_cot_compra      = nr_cot_compra_w
						   and b.nr_item_cot_compra = nr_item_cot_compra_w;

						qt_cot_compra_w := qt_cot_compra_w + qt_material_w;
					end if;
				end if;
			end;
		end if;
	END LOOP;
	CLOSE C02;

	/*
	Armazena a ordem de compra mais antiga com quantidade pendente. 
	*/
	dt_entrega_ordem_w		:= null;
	dt_entrega_item_w		:= null;
	nr_ordem_compra_w		:= null;
	if (qt_ordem_compra_w > 0) then
		begin
		select	min(c.nr_ordem_compra),
			min(c.dt_prevista_entrega),
			min(a.dt_entrega)
		into STRICT	nr_ordem_compra_w,
			dt_entrega_item_w,
			dt_entrega_ordem_w
		from	ordem_compra a,
			ordem_compra_item b,
			ordem_compra_item_entrega c
		where	coalesce(c.qt_real_entrega,0)	< c.qt_prevista_entrega
		and	coalesce(c.dt_cancelamento::text, '') = ''
		and	b.dt_atualizacao	> clock_timestamp() - qt_dia_w
		and	b.nr_ordem_compra	= c.nr_ordem_compra
		and	b.nr_item_oci		= c.nr_item_oci
		and	b.nr_ordem_compra	= a.nr_ordem_compra
		and	coalesce(a.dt_baixa::text, '') = ''
		and	a.cd_estabelecimento	= cd_estabelecimento_p
		and	b.cd_material in (
			SELECT	cd_material
			from	material
			where	cd_material_estoque	= cd_material_w);

		end;
	end if;
	
	vl_excedente_w			:= 0;
	qt_excedente_w			:= 0;

	/* Armazena a quantidade de consumo em movimentacoes de estoque, para o mes atual. */

	if (ie_consumo_ressup_w = 'N') then
		select	sum(coalesce(a.qt_consumo,0))
		into STRICT	qt_cons_prev_mes_w
		from	movto_estoque_operacao_v a,
			operacao_estoque o
		where	a.cd_material		= cd_material_w
		and	a.cd_operacao_estoque	= o.cd_operacao_estoque
		and	a.dt_mesano_referencia	= PKG_DATE_UTILS.start_of(clock_timestamp(), 'month', 0)
		and	a.cd_estabelecimento	= cd_estabelecimento_p
		and	(a.cd_centro_custo IS NOT NULL AND a.cd_centro_custo::text <> '');
	else
		select	sum(coalesce(qt_consumo,0))
		into STRICT	qt_cons_prev_mes_w
		from	movto_estoque_operacao_v
		where	cd_material		= cd_material_w
		and	dt_mesano_referencia	= PKG_DATE_UTILS.start_of(clock_timestamp(), 'month', 0)
		and	cd_estabelecimento	= cd_estabelecimento_p
		and	(cd_centro_custo IS NOT NULL AND cd_centro_custo::text <> '');
	end if;

--PM>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Parametros do material <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Armazena parametrizacoes do cadastro do material.
qt_conv_compra_estoque:    Quantidade que contem em uma unidade de compra com relacao a unidade de estoque.
qt_conv_estoque_consumo:   Quantidade contida em uma unidade de estoque em relacao a unidade de consumo.
cd_unidade_medida_compra:  Unidade de medida de compra.
cd_unidade_medida_estoque: Unidade de medida de estoque. Ex.: Bloco, Ampola, Caixa.
*/
	select	qt_conv_compra_estoque,
		    qt_conv_estoque_consumo,
		    cd_unidade_medida_compra,
		    cd_unidade_medida_estoque
	into STRICT	qt_conv_compra_estoque_w,
		qt_conv_estoque_consumo_w,
		cd_unidade_medida_compra_w,
		cd_unidade_medida_estoque_w
	from	material
	where	cd_material = cd_material_w;

	/*
	Conversao da quantidade pendente em requisicao de consumo. 
	UME: Unidade medida de estoque
	UMP: Unidade medida de compra
	*/
	if (ie_unid_med_req_ressup_w = 'UME') then
		qt_pend_req_consumo_w := dividir(qt_pend_req_consumo_w,qt_conv_estoque_consumo_w);
	elsif (ie_unid_med_req_ressup_w = 'UMP') then
		qt_pend_req_consumo_w := dividir(qt_pend_req_consumo_w,qt_conv_estoque_consumo_w);
		qt_pend_req_consumo_w := dividir(qt_pend_req_consumo_w,qt_conv_compra_estoque_w);
	end if;


	/* Armazena a previsao da quantidade de consumo em movimentacoes de estoque para o mes atual, de acordo com a quantidade ate o dia atual */

	qt_cons_prev_mes_w := nr_dia_w * dividir(coalesce(qt_cons_prev_mes_w, 0), PKG_DATE_UTILS.extract_field('DAY', clock_timestamp()));
	
	/* 
	Se a quantidade real em estoque (subtraindo pendencias de requisicoes de consumo e transferencias) for maior que 
	o estoque maximo para o material, entao armazena a quantidade e valor excedente em estoque.
	*/
	if  	((qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) > qt_estoque_maximo_w) then
		vl_excedente_w		:= vl_custo_medio_w * ((qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) - qt_estoque_maximo_w);
		qt_excedente_w		:= ((qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) - qt_estoque_maximo_w);
	end if;


	/* Rotina para buscar as quantidades pendentes de compras de outros sistemas - INTEGRACAO */

	select	count(*)
	into STRICT	qt_existe_w
	from	sup_integracao_compras
	where	cd_estabelecimento		= cd_estabelecimento_p  LIMIT 1;

	if (qt_existe_w > 0) then
		select	coalesce(max(ds_rotina) ,'X')
		into STRICT	ds_sql_w
		from	sup_integracao_compras
		where	cd_estabelecimento		= cd_estabelecimento_p
		and	ie_tipo_rotina		= 'OC';
		if (ds_sql_w <> 'X') then
			ds_sql_w	:= replace(ds_sql_w, ':cd_material', cd_material_w);
			qt_retorno_w := obter_valor_dinamico(ds_sql_w, qt_retorno_w);
			qt_ordem_compra_w	:= qt_retorno_w;
		end if;

		select	coalesce(max(ds_rotina) ,'X')
		into STRICT	ds_sql_w
		from	sup_integracao_compras
		where	cd_estabelecimento		= cd_estabelecimento_p
		and	ie_tipo_rotina		= 'CC';
		if (ds_sql_w <> 'X') then
			ds_sql_w	:= replace(ds_sql_w, ':cd_material', cd_material_w);
			qt_retorno_w := obter_valor_dinamico(ds_sql_w, qt_retorno_w);
			qt_cot_compra_w		:= qt_retorno_w;
		end if;


		select	coalesce(max(ds_rotina) ,'X')
		into STRICT	ds_sql_w
		from	sup_integracao_compras
		where	cd_estabelecimento		= cd_estabelecimento_p
		and	ie_tipo_rotina		= 'SC';
		if (ds_sql_w <> 'X') then
			ds_sql_w	:= replace(ds_sql_w, ':cd_material', cd_material_w);
			qt_retorno_w := obter_valor_dinamico(ds_sql_w, qt_retorno_w);
			qt_solic_compra_w		:= qt_retorno_w;
		end if;
	end if;

	
	/* 
	De acordo com os parametros de compra, desconsidera as quantidades pendentes em solicitacoes e cotacoes de compra.
	*/
	qt_solic_compra_ww	:= qt_solic_compra_w;
	if (ie_cons_solic_ressup_w in ('N','M')) then
		qt_solic_compra_ww	:= 0;
	end if;

	qt_cot_compra_ww	:= qt_cot_compra_w;
	if (ie_cons_cot_ressup_w in ('N','M')) then
		qt_cot_compra_ww	:= 0;
	end if;


-->>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Quantidade a comprar <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<--

/*
Objetivo: Armazenar a quantidade a comprar do material para ressuprimento. 
*/
	qt_compra_w		:= 0;
	
	/* Forma de calculo: Consumo medio diario */

	if (ie_tipo_problema_p = 4) then
		qt_compra_w	:=	(dividir(coalesce(qt_consumo_mensal_w,0), qt_dias_cons_w) * qt_dia_fixo_p) -
					(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) -
					(qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w);
					
	/* 
	Forma de calculo: Consumo mensal atual 
	Se o parametro de compra Tipo consumo ressuprimento (parametro_compras.ie_consumo_ressup) estiver com o valor 
	N (Consumo restringido por operacao de estoque), para soma do consumo mensal serao desconsiderados as operacoes 
	de estoque que possuem o campo Desconsiderar o consumo no calculo do ressuprimento (operacao_estoque.ie_desconsidera_cons_ressup) 
	com valor S.
	*/
	elsif (ie_tipo_problema_p = 5) then

		if (ie_consumo_ressup_w = 'N') then
			qt_compra_w	:=	dividir(coalesce(OBTER_CONS_MENSAL_MAT_RESSUP('Q', cd_estabelecimento_p, cd_material_w, null), 0),
							PKG_DATE_UTILS.extract_field('DAY', clock_timestamp()) * qt_dia_fixo_p) -
						(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) - (qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w);
		else
			qt_compra_w	:=	dividir(coalesce(obter_consumo_mensal_material('Q', cd_estabelecimento_p, cd_material_w, null), 0),
							PKG_DATE_UTILS.extract_field('DAY', clock_timestamp()) * qt_dia_fixo_p) -
						(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) - (qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w);
		end if;
		
	/* Forma de calculo: Consumo medio mensal */

	elsif (ie_tipo_problema_p = 6) then

		if (ie_consumo_ressup_w = 'N') then
			qt_compra_w	:=	dividir(coalesce(Obter_mat_estabelecimento(cd_estabelecimento_p, cd_estabelecimento_p, cd_material_w, 'CMR'), 0),
							PKG_DATE_UTILS.extract_field('DAY', clock_timestamp()) * qt_dia_fixo_p) -
						(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) - (qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w);
		else

			qt_compra_w	:=	dividir(coalesce(Obter_mat_estabelecimento(cd_estabelecimento_p, cd_estabelecimento_p, cd_material_w, 'CM'), 0),
							PKG_DATE_UTILS.extract_field('DAY', clock_timestamp()) * qt_dia_fixo_p) -
						(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) - (qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w);
		end if;
	else
	
	/* Qualquer outra forma de calculo */

		begin



		if (ie_campo_base_ressup_w = 'M') then


		qt_compra_w	:=	(qt_estoque_maximo_w -
					(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) -
					(qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w));



		end if;

		if (ie_campo_base_ressup_w = 'P') then
			qt_compra_w	:=	qt_ponto_pedido_w -
						(qt_estoque_w - qt_pend_req_consumo_w - qt_pend_transf_w) -
						(qt_ordem_compra_w + qt_solic_compra_ww + qt_cot_compra_ww + qt_itens_nuvem_w);
		end if;
		end;
	end if;

	if (ie_coeficiente_variacao_w = 'S') and (qt_desvio_padrao_cons_w > 0) and (qt_consumo_mensal_w > 0) and (qt_compra_w > 0) then
		qt_coefic_variacao_w := dividir(qt_desvio_padrao_cons_w,qt_consumo_mensal_w) * 100;
		qt_compra_w := qt_compra_w + (qt_compra_w * qt_coefic_variacao_w / 100);


	end if;

	begin
	
	/*
	Atraves das medidas obtidas do cadastro do material, e calculado o volume por unidade. 
	E calculado tambem atraves dos dados da tabela localizacao_estoque_local o volume ja 
	ocupado no local de estoque do estabelecimento do usuario. Com isso e calculado o volume 
	disponivel no estoque. Dividindo o volume disponivel pelo volume do material, obtem-se a 
	quantidade de material estocavel. Se esta quantidade for maior que a quantidade a comprar ja 
	armazenada, entao a quantidade a comprar e substituida por essa. 	
	*/
	
	qt_volume_mat_cm_w := qt_altura_mat_cm_w * qt_largura_mat_cm_w * qt_comprimento_mat_cm_w;
	qt_volume_ocupado_cm_w := qt_estoque_w * qt_volume_mat_cm_w;
	qt_volume_disponivel_cm_w := qt_volume_local_cm_w - qt_volume_ocupado_cm_w;
	qt_material_estocavel_w	:= dividir(qt_volume_disponivel_cm_w,qt_volume_mat_cm_w);


	if (qt_material_estocavel_w < 0) then
		qt_material_estocavel_w := 0;
	end if;

	if (qt_volume_mat_cm_w > 0) and (qt_volume_local_cm_w > 0) and (qt_compra_w > 0) and (qt_material_estocavel_w < qt_compra_w) then
		qt_compra_w := qt_material_estocavel_w;
	end if;
	exception when others then
		null;
	end;

	/* Calculo de conversao da quantidade a comprar - Sidnei - 04-05-10 */

	select 	ie_arredond_ressup
	into STRICT	ie_arredond_ressup_w
	from 	parametro_compras
	where 	cd_estabelecimento = cd_estabelecimento_p;

	mod_w := round((mod(qt_compra_w, qt_conversao_w))::numeric,4);

	if (cd_unid_med_compra_regra_w IS NOT NULL AND cd_unid_med_compra_regra_w::text <> '') and /* OS 980038  Foi colocado esse IF para nao efetuar a divisao da conversao quando houver regra de conversao por fornecedor, e que as unidades de medidas fossem todas iguais */
		(cd_unidade_medida_compra_w = cd_unid_med_compra_regra_w) and (cd_unidade_medida_estoque_w = cd_unid_med_compra_regra_w) and (qt_conv_compra_estoque_w = 1) then
		qt_conv_divisao_w := 1;
	else
		qt_conv_divisao_w := qt_conversao_w;
	end if;


	if (qt_compra_w	<= 0) then
		qt_compra_w	:= 0;

	elsif (ie_arredond_ressup_w = 'C') and (mod_w <> 0) then

		qt_compra_w 	:= qt_compra_w - mod_w;
		qt_compra_w 	:= qt_compra_w + qt_conversao_w;
		qt_compra_w	:= round((dividir(qt_compra_w, qt_conv_divisao_w))::numeric,0);

	elsif (ie_arredond_ressup_w = 'C') and (mod_w = 0) then

		qt_compra_w := round((dividir(qt_compra_w, qt_conv_divisao_w))::numeric,0);

	elsif (ie_arredond_ressup_w = 'B') and (mod_w <> 0) then

		qt_compra_w := qt_compra_w - mod_w;
		qt_compra_w := round((dividir(qt_compra_w, qt_conv_divisao_w))::numeric,0);

	elsif (ie_arredond_ressup_w = 'B') and (mod_w = 0) then
		qt_compra_w := qt_compra_w;
		qt_compra_w := round((dividir(qt_compra_w, qt_conv_divisao_w))::numeric,0);

	else
		begin
		if (qt_compra_w	< qt_conversao_w) then
			qt_compra_w	:= 1;
		else
			qt_compra_w	:= round((dividir(qt_compra_w, qt_conv_divisao_w))::numeric,0);
		end if;
		end;
	end if;

	/*Converte somente para mostrar no grid, ou seja, faz o insert abaixo */

	if (ie_conv_unid_estoque_ressup_w = 'N') then
		qt_solic_compra_w	:=	round((dividir(qt_solic_compra_w, qt_conversao_w))::numeric,4);
		qt_ordem_compra_w	:=	round((dividir(qt_ordem_compra_w, qt_conversao_w))::numeric,4);
		qt_cot_compra_w		:=	round((dividir(qt_Cot_compra_w, qt_conversao_w))::numeric,4);
	end if;

	if (ie_cons_solic_ressup_w = 'M') then
		qt_solic_compra_w	:= 0;
	end if;

	if (ie_cons_cot_ressup_w  = 'M') then
		qt_cot_compra_w	:= 0;
	end if;

	qt_estoque_ressup_w := qt_estoque_w + qt_itens_nuvem_w;

	insert into material_ressuprimento(
		cd_material,
		cd_material_generico,
		qt_estoque,
		qt_ordem_compra,
		qt_solic_compra,
		qt_cotacao_compra,
		dt_atualizacao, nm_usuario,
		dt_entrega_ordem,
		dt_entrega_ordem_item,
		vl_excedente,
		qt_excedente,
		nr_ordem_compra,
		qt_cons_prev_mes,
		cd_estabelecimento,
		qt_compra,
		qt_consumo_mensal,
		qt_estoque_maximo,
		qt_estoque_minimo,
		qt_dia_interv_ressup,
		qt_dia_ressup_forn,
		qt_dia_estoque_minimo,
		qt_ponto_pedido,
		ie_controlado,
		ie_temperatura,
		ie_padronizado,
		ds_observacao,
		dt_proxima_entrega,
		qt_pend_req_consumo,
		qt_pend_transf)
	values (	cd_material_w,
		cd_material_generico_w,
		coalesce(qt_estoque_ressup_w,0),
		coalesce(qt_ordem_compra_w,0),
		coalesce(qt_solic_compra_w,0),
		coalesce(qt_cot_compra_w,0),
		clock_timestamp(),
		'Tasy',
		dt_entrega_ordem_w,
		dt_entrega_item_w,
		vl_excedente_w,
		qt_excedente_w,
		nr_ordem_compra_w,
		qt_cons_prev_mes_w,
		cd_estabelecimento_p,
		qt_compra_w,
		qt_consumo_mensal_w,
		qt_estoque_maximo_w,
		qt_estoque_minimo_w,
		qt_dia_interv_ressup_w,
		qt_dia_ressup_forn_w,
		qt_dia_estoque_minimo_w,
		qt_ponto_pedido_w,
		ie_controlado_w,
		ie_temperatura_w,
		ie_padronizado_w,
		null,
		dt_proxima_entrega_w,
		qt_pend_req_consumo_w,
		qt_pend_transf_w);
	end;
end loop;
close c01;

commit;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE gerar_ressuprimento_material ( cd_estabelecimento_p bigint, dt_inicio_pendente_p timestamp, dt_final_pendente_p timestamp, ie_tipo_problema_p bigint, qt_dia_fixo_p bigint, cd_cgc_p text, ie_desconsidera_pend_p text, cd_grupo_material_p bigint default null, cd_subgrupo_material_p bigint default null, cd_local_estoque_p bigint default null, nm_usuario_p text default 'Tasy', qt_dias_cons_p bigint default 30) FROM PUBLIC;

