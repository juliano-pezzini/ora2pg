-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE pls_gerar_analise_lote ( nr_seq_lote_p bigint, ie_consiste_valor_p text, ie_consiste_quantidade_p text, cd_estabelecimento_p bigint, nm_usuario_p text, ie_origem_regra_p text, ie_xml_p text, ie_tipo_importacao_p text) AS $body$
DECLARE


ds_erro_w			varchar(4000);
ie_consiste_valor_w		varchar(255);
dt_geracao_analise_w		varchar(20);
ie_gerar_analise_audit_w	varchar(2);
ie_status_w			varchar(1);
ie_forma_imp_w			varchar(1);
ie_commit_w			varchar(1)	:= 'N';
vl_cobrado_manual_w		double precision;
vl_retorno_w			double precision;
vl_procedimento_imp_w		double precision;
vl_material_imp_w		double precision;
qt_beneficiario_w		bigint;
nr_seq_conta_w			bigint;
nr_seq_protocolo_gerado_w	bigint;
nr_seq_segurado_w		bigint;
ie_origem_analise_w		bigint;
nr_seq_contest_disc_w		bigint;
nr_seq_analise_w		bigint;
nr_seq_conta_disc_w		bigint;
nr_seq_sip_aux_w		bigint;
nr_seq_protocolo_w		bigint;
nr_seq_conta_proc_w		bigint;
qt_retorno_w			bigint;
qt_min_conta_w			bigint;
qt_max_conta_w			bigint;
qt_contas_informadas_w		integer;
ie_analise_cm_nova_w		varchar(10);
qt_contas_nao_consistidas_w	integer;
qt_ocorrencia_w			integer;
qt_prot_nao_encerrados_w	integer;
nr_seq_recurso_w		pls_rec_glosa_conta.nr_sequencia%type;
nr_seq_conta_rec_w		pls_rec_glosa_conta.nr_seq_conta%type;
qt_conta_aberta_w		integer;
ie_lib_protocolo_w		pls_regra_lib_protocolo.ie_lib_protocolo%type;
ie_origem_protocolo_w		pls_protocolo_conta.ie_origem_protocolo%type;
ie_novo_pos_w			pls_visible_false.ie_novo_pos_estab%type;
qt_contas_fechadas_w	integer;
ie_internado_w			pls_tipo_atendimento.ie_internado%type;
	
/* Cursor para os protocolos */

C00 CURSOR FOR
	SELECT	a.nr_sequencia,
		(SELECT	count(1)
		 from	pls_conta x
		 where	x.nr_seq_protocolo = a.nr_sequencia
		 and	x.ie_status not in ('F', 'C', 'S')) qt_conta_aberta,
		a.ie_origem_protocolo
	from	pls_protocolo_conta	a
	where	a.nr_seq_lote_conta	= nr_seq_lote_p
	and	ie_status		<> '4';

/* Cursores para contas medicas */
				
C01 CURSOR FOR
	SELECT	b.nr_sequencia,
		b.nr_seq_segurado
	from	pls_conta		b
	where	b.nr_seq_protocolo	= nr_seq_protocolo_w
	and	coalesce(b.nr_seq_analise::text, '') = ''
	order by coalesce(b.dt_atendimento_referencia,coalesce(b.dt_atendimento,clock_timestamp()));
	
C02 CURSOR FOR
	SELECT	b.nr_sequencia
	from	pls_conta		b
	where	b.nr_seq_protocolo	= nr_seq_protocolo_gerado_w;
	
/* Cursores para discussao de contestacao */

C03 CURSOR FOR
	SELECT	b.nr_sequencia,
		d.nr_sequencia
	from	pls_contestacao_discussao	b,
		pls_contestacao			c,
		pls_conta			d,
		pls_lote_discussao		a
	where	a.nr_sequencia		= b.nr_seq_lote
	and	c.nr_sequencia		= b.nr_seq_contestacao
	and	d.nr_sequencia		= c.nr_seq_conta
	and	a.nr_seq_lote_conta	= nr_seq_lote_p;

/*Verificar as analises geradas para consistir quais ja podem ser liberadas.*/

C04 CURSOR FOR
	SELECT	nr_sequencia
	from	pls_analise_conta
	where	nr_seq_lote_protocolo	= nr_seq_lote_p
	order by 1;

C05 CURSOR FOR	
	SELECT	a.nr_sequencia,
		coalesce(a.vl_cobrado_manual, 0),
		coalesce(a.qt_contas_informadas, 0)
	from	pls_protocolo_conta	a
	where	a.nr_seq_lote_conta 	= nr_seq_lote_p
	and	a.ie_origem_protocolo 	= 'D'
	and	a.ie_status		<> '4';
	
C06 CURSOR FOR
	SELECT	nr_sequencia
	from	pls_conta_proc
	where	nr_seq_conta = nr_seq_conta_w
	order by 1;
	
C07 CURSOR(nr_seq_lote_pc	pls_protocolo_conta.nr_seq_lote_conta%type) FOR	
	SELECT	a.nr_sequencia nr_seq_protocolo,
		coalesce(a.vl_cobrado_manual, 0) vl_cobrado_manual,
		a.ie_origem_protocolo,
		a.ie_tipo_guia,
		coalesce(ie_apresentacao,'A') ie_apresentacao
	from	pls_protocolo_conta	a
	where	a.nr_seq_lote_conta 	= nr_seq_lote_pc
	and	a.ie_status		<> '4';
	
-- Cursores para recurso de glosa
C08 CURSOR FOR
	SELECT	c.nr_sequencia,
		c.nr_seq_conta
	from	pls_rec_glosa_conta	c,
		pls_rec_glosa_protocolo	p
	where	p.nr_sequencia		= c.nr_seq_protocolo
	and	p.nr_seq_lote_conta	= nr_seq_lote_p
	and	coalesce(c.nr_seq_analise::text, '') = ''
	and	c.ie_status		!= '3';
	
C09 CURSOR(	nr_seq_lote_pc	pls_protocolo_conta.nr_seq_lote_conta%type,
		ie_novo_pos_pc	pls_visible_false.ie_novo_pos_estab%type) FOR
	SELECT	b.nr_sequencia nr_seq_conta,
		-- qualquer pos, independente do status

		-- comeca com o pos a nivel de analise, e depois soma ainda a nivel de conta

		-- necessario para os casos onde e desfeito o lote de analise, para nao duplicar o pos de A520
		sum(	-- nivel analise
			(	SELECT	count(1) qt
				from	pls_conta_pos_estabelecido	x,
					pls_conta_proc			y,
					pls_conta			z
				where	x.nr_seq_conta_proc		= y.nr_sequencia
				and	z.nr_sequencia			= y.nr_seq_conta
				and	z.nr_seq_analise		= b.nr_seq_analise
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'N')
			+
			(	select	count(1) qt
				from	pls_conta_pos_estabelecido	x,
					pls_conta_mat			y,
					pls_conta			z
				where	x.nr_seq_conta_mat		= y.nr_sequencia
				and	z.nr_sequencia			= y.nr_seq_conta
				and	z.nr_seq_analise		= b.nr_seq_analise
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'N')
			+
			(	select	count(1) qt
				from	pls_conta_pos_proc		x,
					pls_conta_proc			y,
					pls_conta			z
				where	x.nr_seq_conta_proc		= y.nr_sequencia
				and	z.nr_sequencia			= y.nr_seq_conta
				and	z.nr_seq_analise		= b.nr_seq_analise
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'S')
			+
			(	select	count(1) qt
				from	pls_conta_pos_mat		x,
					pls_conta_mat			y,
					pls_conta			z
				where	x.nr_seq_conta_mat		= y.nr_sequencia
				and	z.nr_sequencia			= y.nr_seq_conta
				and	z.nr_seq_analise		= b.nr_seq_analise
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'S')
			-- nivel conta
			+
			(	select	count(1) qt
				from	pls_conta_pos_estabelecido	x,
					pls_conta_proc			y
				where	x.nr_seq_conta_proc		= y.nr_sequencia
				and	b.nr_sequencia			= y.nr_seq_conta
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'N')
			+
			(	select	count(1) qt
				from	pls_conta_pos_estabelecido	x,
					pls_conta_mat			y
				where	x.nr_seq_conta_mat		= y.nr_sequencia
				and	b.nr_sequencia			= y.nr_seq_conta
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'N')
			+
			(	select	count(1) qt
				from	pls_conta_pos_proc		x,
					pls_conta_proc			y
				where	x.nr_seq_conta_proc		= y.nr_sequencia
				and	b.nr_sequencia			= y.nr_seq_conta
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'S')
			+
			(	select	count(1) qt
				from	pls_conta_pos_mat		x,
					pls_conta_mat			y
				where	x.nr_seq_conta_mat		= y.nr_sequencia
				and	b.nr_sequencia			= y.nr_seq_conta
				and	x.ie_status_faturamento		= 'A'
				and	ie_novo_pos_pc			= 'S')) qt_pos_aviso,
		-- levanta a quantidade de itens de faturamento manual
		sum(
			(	select	count(1)
				from	pls_conta_proc	x
				where	x.nr_seq_conta	= b.nr_sequencia
				and	x.ie_status	= 'M')
			+
			(	select	count(1)
				from	pls_conta_mat	x
				where	x.nr_seq_conta	= b.nr_sequencia
				and	x.ie_status	= 'M')) qt_fat_manual,
		max(( 	select	count(1)
			from	pls_conta_mat x
			where	x.nr_seq_conta = b.nr_sequencia
			and 	x.ie_tipo_despesa = '7'
			and 	b.nr_seq_prestador_exec = x.nr_seq_prest_fornec
			and 	b.ie_tipo_guia = '4'			
		)) qt_opme_fornec_sadt
	from	pls_protocolo_conta	a,
		pls_conta		b,
		pls_segurado		d,
		pls_congenere		e
	where	b.nr_seq_protocolo	= a.nr_sequencia
	and	d.nr_sequencia		= b.nr_seq_segurado
	and	e.nr_sequencia		= d.nr_seq_congenere
	and	e.ie_tipo_congenere	= 'CO'
	and	coalesce(d.nr_seq_ops_congenere::text, '') = ''
	and	a.nr_seq_lote_conta	= nr_seq_lote_pc
	group by b.nr_sequencia;
	
BEGIN

select 	count(1)
into STRICT 	qt_contas_fechadas_w
from	pls_conta_v
where	nr_seq_lote_conta	 = nr_seq_lote_p
and	ie_status	=	 'F';

if ( qt_contas_fechadas_w > 0 ) then
	CALL wheb_mensagem_pck.exibir_mensagem_abort(1061386);
end if;


	begin
	
	select	coalesce(max(ie_analise_cm_nova),'N')
	into STRICT	ie_analise_cm_nova_w
	from	pls_parametros a
	where	a.cd_estabelecimento	= cd_estabelecimento_p;
	
	select	coalesce(max(a.ie_novo_pos_estab), 'N')
	into STRICT	ie_novo_pos_w
	from	pls_visible_false	a
	where	a.cd_estabelecimento	= cd_estabelecimento_p;
	
	ie_consiste_valor_w	:= coalesce(ie_consiste_valor_p, 'N');

	if (ie_xml_p = 'S') then /* Francisco - 09/08/2012 - Se for por XML, tem que commitar, devido a quantidade de processos simultaneos */
		ie_commit_w	:= 'S';
	end if;
	/*Inicio consistencia valor e quantidade*/

	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303799), 'geracao_analise', nm_usuario_p);

	/* Verifica se a quantidade maxima de contas do protocolo e igual ou menor que esta cadastrada atualmente */

	if (ie_consiste_quantidade_p = 'S') then
		open C05;
		loop
		fetch C05 into	
			nr_seq_protocolo_w,
			vl_cobrado_manual_w,
			qt_contas_informadas_w;
		EXIT WHEN NOT FOUND; /* apply on C05 */
			begin
			select	count(1)
			into STRICT	qt_retorno_w
			from	pls_conta
			where	nr_seq_protocolo	= nr_seq_protocolo_w;
			
			if (qt_contas_informadas_w <> qt_retorno_w) and (qt_contas_informadas_w > 0) then
				CALL wheb_mensagem_pck.exibir_mensagem_abort(203427,';QT_PROTOCOLO=' ||qt_contas_informadas_w|| ';' || 'QT_CONTA=' ||qt_retorno_w);
			end if;
			
			end;
		end loop;
		close C05;
	end if;

	/* Verifica se o valor apresentado do protocolo e igual ao valor apresentado da conta OS 444066 Diogo */

	for r_c07_w in  C07(nr_seq_lote_p) loop
		begin
		
		ie_consiste_valor_w	:= pls_obter_se_cons_vl_apre_prot(r_c07_w.ie_origem_protocolo, r_c07_w.ie_tipo_guia, r_c07_w.ie_apresentacao);
		
		if (ie_consiste_valor_w = 'S') then
			select	coalesce(sum(a.vl_procedimento_imp), 0) -- Ajustado para verificar o mat tambem pois e nao era verificado
			into STRICT	vl_procedimento_imp_w		
			from	pls_conta_proc	a,
				pls_conta	b
			where	a.nr_seq_conta		= b.nr_sequencia
			and	b.nr_seq_protocolo	= r_c07_w.nr_seq_protocolo;
			
			select	coalesce(sum(a.vl_material_imp), 0)
			into STRICT	vl_material_imp_w
			from 	pls_conta_mat	a,
				pls_conta	b
			where	a.nr_seq_conta		= b.nr_sequencia
			and	b.nr_seq_protocolo	= r_c07_w.nr_seq_protocolo;
			
			vl_retorno_w	:= coalesce(vl_procedimento_imp_w,0) + coalesce(vl_material_imp_w,0);	
			
			if (vl_retorno_w <> r_c07_w.vl_cobrado_manual) and (r_c07_w.vl_cobrado_manual > 0 )then
				CALL wheb_mensagem_pck.exibir_mensagem_abort(682603,'VL_PROCOLO=' || r_c07_w.vl_cobrado_manual || ';' || 'VL_CONTA=' || vl_retorno_w || ';' || 'NR_SEQ_PROT=' || r_c07_w.nr_seq_protocolo || ';' || 'NR_SEQ_LOTE=' || nr_seq_lote_p);
			end if;
		end if;
		end;				
	end loop;

	/*Inicio geracao analise contas #@NR_SEQ_LOTE_P#@*/

	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303802, 'NR_SEQ_LOTE_P=' || nr_seq_lote_p), 'geracao_analise_origem', nm_usuario_p);
	select	max(dt_geracao_analise),
		max(ie_origem_analise)
	into STRICT	dt_geracao_analise_w,
		ie_origem_analise_w
	from	pls_lote_protocolo_conta
	where	nr_sequencia	= nr_seq_lote_p;

	if (dt_geracao_analise_w IS NOT NULL AND dt_geracao_analise_w::text <> '') then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(179899);
	end if;
	/*Fim consistencia valor e quantidade*/

	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303803), 'geracao_analise', nm_usuario_p);

	/*Geracao das analises*/

	CALL gravar_processo_longo(wheb_mensagem_pck.get_texto(303804), 'PLS_GERAR_ANALISE_LOTE', 0);

	/* Origem 4 e recurso de glosa */

	if (ie_origem_analise_w = 4) then
		open C08;
		loop
		fetch C08 into	
			nr_seq_recurso_w,
			nr_seq_conta_rec_w;
		EXIT WHEN NOT FOUND; /* apply on C08 */
			begin
			CALL pls_gerar_analise_recurso( nr_seq_recurso_w, nm_usuario_p, cd_estabelecimento_p);
			
			/*Beneficiario - #@DS_CONTA_REC_W#@, Conta - #@NR_SEQ_CONTA_REC_W#@*/

			CALL gravar_processo_longo(wheb_mensagem_pck.get_texto(390539, 	'DS_CONTA_REC_W=' || substr(pls_obter_dados_conta(nr_seq_conta_rec_w,'NB'),1,40) ||
											';NR_SEQ_CONTA_REC_W=' || nr_seq_conta_rec_w),'PLS_GERAR_ANALISE_LOTE',-1);
			end;
		end loop;
		close C08;
		
	/* Origem 5 e discussao de contestacao */

	elsif (ie_origem_analise_w = 5) then
		open C03;
		loop
		fetch C03 into	
			nr_seq_contest_disc_w,
			nr_seq_conta_disc_w;
		EXIT WHEN NOT FOUND; /* apply on C03 */
			begin
			CALL pls_gerar_analise_discussao(nr_seq_contest_disc_w, nm_usuario_p, cd_estabelecimento_p);
			
			/*Beneficiario - #@DS_CONTA_DISC_W#@, Conta - #@NR_SEQ_CONTA_DISC_W#@*/

			CALL gravar_processo_longo(wheb_mensagem_pck.get_texto(303807, 	'DS_CONTA_DISC_W=' || substr(pls_obter_dados_conta(nr_seq_conta_disc_w,'NB'),1,40) ||
											';NR_SEQ_CONTA_DISC_W=' || nr_seq_conta_disc_w),'PLS_GERAR_ANALISE_LOTE',-1);
			end;
		end loop;
		close C03;
	else 		
		select 	count(1)
		into STRICT 	qt_prot_nao_encerrados_w
		from	pls_protocolo_conta a
		where	a.nr_seq_lote_conta = nr_seq_lote_p
		and	ie_status		<> '4';
		
		if (qt_prot_nao_encerrados_w = 0) then
			CALL wheb_mensagem_pck.exibir_mensagem_abort(338016);
		end if;
		
		if (ie_analise_cm_nova_w = 'S') and
			((coalesce(ie_tipo_importacao_p,'UP') = 'UP' ) or (coalesce(ie_tipo_importacao_p,'UP') = 'A500') or (coalesce(ie_tipo_importacao_p,'WE') = 'WE')) then
			/*Inicio da geracao da analise*/

			CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303810), 'geracao_analise', nm_usuario_p);
			CALL pls_gerar_analise_lote_nova(nr_seq_lote_p,cd_estabelecimento_p,nm_usuario_p,ie_xml_p,ie_origem_regra_p);
			/*Fim da geracao da analise*/

			CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303811), 'geracao_analise', nm_usuario_p);
		else
			
			select	count(1)
			into STRICT	qt_ocorrencia_w
			from	pls_ocorrencia
			where	ie_auditoria_conta != 'N';
					
			open C00;
			loop
			fetch C00 into	
				nr_seq_protocolo_w,
				qt_conta_aberta_w,
				ie_origem_protocolo_w;
			EXIT WHEN NOT FOUND; /* apply on C00 */
				begin
				select	coalesce(a.ie_forma_imp, 'T') -- Diether - OS 447488 - Alterei para ca pois esta pegando informacao da pls_protocolo_conta, e o cursor C01 so vai trazer as contas do protocolo que vier no cursor C00
				into STRICT	ie_forma_imp_w
				from	pls_protocolo_conta	a
				where	a.nr_sequencia	= nr_seq_protocolo_w;
				
				if (coalesce(ie_tipo_importacao_p,'UP') = 'UP' )and
					((qt_ocorrencia_w > 0) or (ie_forma_imp_w = 'D'))then
					open C01;
					loop
					fetch C01 into	
						nr_seq_conta_w,
						nr_seq_segurado_w;
					EXIT WHEN NOT FOUND; /* apply on C01 */
						begin
						nr_seq_protocolo_gerado_w	:= null;
						
						select	max(ie_status)
						into STRICT	ie_status_w
						from	pls_conta
						where	nr_sequencia	= nr_seq_conta_w;
						
						if (nr_seq_segurado_w IS NOT NULL AND nr_seq_segurado_w::text <> '') then
							if (ie_status_w = 'U') then
								CALL pls_consistir_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p, 'S', 'S', ie_xml_p, ie_origem_regra_p,'N');
							elsif (ie_status_w = 'P') and (coalesce(ie_forma_imp_w,'X') = 'D') then /*gerado a nova verificacao para que caso seja conta digitada no portal e ainda nao tenha sido
								gerado a consistencia segundo a contas medicas o seja feito OS 415921 Diogo*/
								CALL pls_desfazer_consistir_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p);
								
								CALL pls_consistir_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p,'S','S',ie_xml_p,ie_origem_regra_p,'N');
							end if;
						else					
							open C06;
							loop
							fetch C06 into	
								nr_seq_conta_proc_w;
							EXIT WHEN NOT FOUND; /* apply on C06 */
								begin
								CALL pls_atualizar_proc_ref(nr_seq_conta_proc_w, cd_estabelecimento_p, nm_usuario_p);
								end;
							end loop;
							close C06;
							
							/*Beneficiario nao encontrado.*/

							CALL pls_gravar_conta_glosa('1001', nr_seq_conta_w, null, null, 'N', wheb_mensagem_pck.get_texto(303813), nm_usuario_p, 'A', 'I5', null, cd_estabelecimento_p, '', null);
						end if;
						
						CALL pls_atualizar_estagio_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p);
						
						begin
						select	max(nr_seq_protocolo)
						into STRICT	nr_seq_protocolo_gerado_w
						from	pls_conta
						where	nr_seq_conta_referencia	= nr_seq_conta_w;
						exception
						when others then
							nr_seq_protocolo_gerado_w	:= null;
						end;
						
						/*Beneficiario - #@DS_CONTA_DISC_W#@, Conta - #@NR_SEQ_CONTA_DISC_W#@*/

						CALL gravar_processo_longo(wheb_mensagem_pck.get_texto(303807, 	'DS_CONTA_DISC_W=' || substr(pls_obter_dados_conta(nr_seq_conta_w,'NB'),1,40) ||
														';NR_SEQ_CONTA_DISC_W=' || nr_seq_conta_w),'PLS_GERAR_ANALISE_LOTE',-1);
						if (nr_seq_protocolo_gerado_w IS NOT NULL AND nr_seq_protocolo_gerado_w::text <> '') then
							open C02;
							loop
							fetch C02 into	
								nr_seq_conta_w;
							EXIT WHEN NOT FOUND; /* apply on C02 */
								begin
								CALL pls_consistir_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p, 'S', 'S', ie_xml_p, ie_origem_regra_p,'N');
								
								CALL pls_atualizar_estagio_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p);
								
								/*Beneficiario - #@DS_CONTA_DISC_W#@, Conta - #@NR_SEQ_CONTA_DISC_W#@*/

								CALL gravar_processo_longo(wheb_mensagem_pck.get_texto(303807, 	'DS_CONTA_DISC_W=' || substr(pls_obter_dados_conta(nr_seq_conta_w,'NB'),1,40) ||
																';NR_SEQ_CONTA_DISC_W=' || nr_seq_conta_w),'PLS_GERAR_ANALISE_LOTE',-1);
								end;
							end loop;
							close C02;
						end if;
						end;
					end loop;
					close C01;
				else
					open C01;
					loop
					fetch C01 into	
						nr_seq_conta_w,
						nr_seq_segurado_w;
					EXIT WHEN NOT FOUND; /* apply on C01 */
						begin
								
						CALL pls_consistir_conta(nr_seq_conta_w, cd_estabelecimento_p, nm_usuario_p,'S','S',ie_xml_p,ie_origem_regra_p,'N');
			
						end;
					end loop;
					close C01;
				end if;
				/* Francisco - 21/05/2012 - Criei esse campo, para identificar quando terminou de gerar a analise, para so dai atualizar o status do protocolo */

				update	pls_protocolo_conta
				set	dt_fim_analise	= clock_timestamp()
				where	nr_sequencia	= nr_seq_protocolo_w;

				CALL pls_gerar_valores_protocolo(nr_seq_protocolo_w, nm_usuario_p);
				CALL pls_altera_status_protocolo(nr_seq_protocolo_w, 'L', 'N', cd_estabelecimento_p, nm_usuario_p);
				end;
			end loop;
			close C00;
		end if;
	end if;	
	
	update	pls_lote_protocolo_conta
	set	ie_status		= 'X'
	where	nr_sequencia		= nr_seq_lote_p;
	
	select	count(1)
	into STRICT	qt_contas_nao_consistidas_w
	from	pls_conta	conta
	where	conta.ie_status	 	= 'U'
	and	conta.nr_seq_analise	in (	SELECT 	analise.nr_sequencia
						from	pls_analise_conta	analise
						where	nr_seq_lote_protocolo	= nr_seq_lote_p);

	if (qt_contas_nao_consistidas_w > 0) then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(283578);
	end if;
	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303825,'NR_SEQ_LOTE_P=' || nr_seq_lote_p), 'geracao_analise_origem', nm_usuario_p);
	for r_c04_w in C04() loop
		begin
		CALL pls_gerar_justif_automatica(r_c04_w.nr_sequencia, nm_usuario_p, 'S');
		CALL pls_gerar_lib_analise(r_c04_w.nr_sequencia, cd_estabelecimento_p, nm_usuario_p);
		end;
	end loop;
	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303826,'NR_SEQ_LOTE_P=' || nr_seq_lote_p), 'geracao_analise_origem', nm_usuario_p);
	-- Inicio geracao pos A520 no lote #@NR_SEQ_LOTE_P#@
	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(1048348,'NR_SEQ_LOTE_P=' || nr_seq_lote_p), 'geracao_analise_origem', nm_usuario_p);
	
	-- carrega as contas e itens, com uma coluna indicando a quantidade de pos por item.
	for r_c09_w in C09(nr_seq_lote_p, ie_novo_pos_w) loop
	
		-- se NAO tiver pos de aviso
		if (r_c09_w.qt_pos_aviso = 0) then
		
			-- se nao possuir nenhum item de faturamento manual, entao pode chamar a rotina, se tiver nao deve chamar para evitar duplicidade
			if (r_c09_w.qt_fat_manual = 0) then
			
				-- Primeiro lanca os itens de faturamento manual para o pos, como abertura de pacotes por exemplo
				CALL pls_lancar_item_proc_pos(r_c09_w.nr_seq_conta, nm_usuario_p);
			end if;
			
			-- Gera o pos(aviso)

			--Se conta for sadt  e tiver algum OPME cujo fornec seja igual ao executor da conta
			if (r_c09_w.qt_opme_fornec_sadt > 0) then			

				-- vejo se eh do tipo internado apenas aqui, para nao chamar a funcion para itens desnecessarios,

				--pois na maioria dos casos nao se enquadra reduzindo o custo que essa chamada traria ao cursor,

				--ja que a quantidade de execucoes desnecessarias seria bem pior que a troca de contexto
				ie_internado_w := pls_obter_se_internado( r_c09_w.nr_seq_conta, 'C');
				
				if ( ie_internado_w = 'N') then				
					CALL pls_gerar_valor_pos_estab(r_c09_w.nr_seq_conta, nm_usuario_p, 'C', null, null, 'CA');

				end if;
			else -- se nao for guia sadt e ter algum opme cujo fornec seja igual ao executor da conta
				CALL pls_gerar_valor_pos_estab(r_c09_w.nr_seq_conta, nm_usuario_p, 'C', null, null, 'CA');
			end if;
		end if; -- fim se nao tiver pos
	
	end loop; -- fim itens
	
	
	
	-- Fim geracao pos A520 no lote #@NR_SEQ_LOTE_P#@
	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(1048349,'NR_SEQ_LOTE_P=' || nr_seq_lote_p), 'geracao_analise_origem', nm_usuario_p);
	-- Fim geracao analise contas #@NR_SEQ_LOTE_P#@
	CALL pls_grava_log_execucao_temp(wheb_mensagem_pck.get_texto(303827,'NR_SEQ_LOTE_P=' || nr_seq_lote_p), 'geracao_analise_origem', nm_usuario_p);
	
	
	
	for r_C00_w in C00 loop
	
		ie_lib_protocolo_w := pls_se_lib_protocolo(r_C00_w.ie_origem_protocolo, cd_estabelecimento_p);
	
		if (ie_lib_protocolo_w = 'S') and (r_C00_w.qt_conta_aberta = 0) then
			CALL pls_gerar_resumo_conta_prot(r_C00_w.nr_sequencia, nm_usuario_p, cd_estabelecimento_p, ie_lib_protocolo_w);
		end if;
	end loop;
	
	update	pls_lote_protocolo_conta
	set	dt_geracao_analise	= clock_timestamp(),
		ie_status		= 'A'
	where	nr_sequencia		= nr_seq_lote_p;

	update	pls_xml_lote
	set	dt_finalizacao_confirmacao = clock_timestamp()
	where	nr_seq_lote = nr_seq_lote_p;

exception
when others then
	rollback;
	
	CALL pls_desfazer_analise_lote(nr_seq_lote_p,cd_estabelecimento_p, nm_usuario_p );
	
	ds_erro_w	:= sqlerrm || ' ' || DBMS_UTILITY.FORMAT_ERROR_BACKTRACE; /* Traz a lista de rotinas a ate a rotina que causou a interrupcao */
	
	update	pls_xml_lote
	set	ie_status			= 'ERR',
		dt_finalizacao_confirmacao	= clock_timestamp()
	where	nr_seq_lote			= nr_seq_lote_p;
	
	update	pls_lote_protocolo_conta
	set	dt_geracao_analise	 = NULL,
		ie_status		= 'X',
		ds_mensagem_erro	= ds_erro_w
	where	nr_sequencia		= nr_seq_lote_p;
	
	update	pls_cta_lt_ger_lote_compl
	set	ds_falha		= ds_erro_w,
		ie_status		= 'X',
		dt_fim_geracao  	= clock_timestamp()
	where	nr_seq_lote_protocolo	= nr_seq_lote_p;
	
	commit;
	
	if (coalesce(ie_xml_p, 'N') <> 'S') then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(223084,'DS_ERRO=' || ds_erro_w);
	end if;
end;

commit;

insert into pls_log_lote_prot_conta(	nr_sequencia, dt_atualizacao, nm_usuario, dt_atualizacao_nrec,
					nm_usuario_nrec, ds_log, nr_seq_lote_protocolo)
		values (	nextval('pls_log_lote_prot_conta_seq'), clock_timestamp(), nm_usuario_p, clock_timestamp(),
					nm_usuario_p,' Gerar analise',nr_seq_lote_p);

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerar_analise_lote ( nr_seq_lote_p bigint, ie_consiste_valor_p text, ie_consiste_quantidade_p text, cd_estabelecimento_p bigint, nm_usuario_p text, ie_origem_regra_p text, ie_xml_p text, ie_tipo_importacao_p text) FROM PUBLIC;

