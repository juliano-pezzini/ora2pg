-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE PROCEDURE chamar_senha_paciente (nm_maquina_atual_p text, cd_estabelecimento_p bigint, nm_usuario_p text, nr_senha_p INOUT text, nr_seq_senha_p INOUT bigint, cd_agenda_p text DEFAULT '0', nr_seq_local_chamada_p bigint DEFAULT 0, ie_rechamada_ciclo_p text DEFAULT 'N', nr_seq_fila_senha_p bigint DEFAULT 0) AS $body$
DECLARE


nr_sequencia_w			bigint;
nr_seq_fila_espera_w		bigint;
ie_chamou_senha_w		varchar(2) := 'N';
cd_senha_chamada_w		varchar(30);
nr_seq_senha_w			bigint;
nr_seq_prioridade_w		bigint;
ds_seq_fila_w			varchar(255);
qt_existe_fila_igual_w		bigint;
qt_chamadas_atual_w		bigint;
qt_max_chamadas_w		bigint;
cd_perfil_w			bigint;
ie_utiliza_oracle_alert_w	varchar(2);
ie_regra_chamada_w		smallint;
nr_prioridade_w			integer;
nr_seq_config_ciclo_w		bigint;
nr_seq_ciclo_chamada_ativo_w	bigint;
nr_seq_ordem_w			bigint;
qt_senhas_w			bigint;
nr_seq_config_ciclo_item_w	bigint;
nr_seq_ciclo_chamada_item_w	bigint;
qt_itens_pendente_ciclo_w	bigint;
ie_regra_tempo_espera_w		varchar(1);
nr_seq_local_senha_w		bigint;
ds_estrategia_chamada_w		varchar(255);
nr_seq_estrategia_senha_w	bigint;
ds_Texto_w			varchar(255);
ds_Filas_w			dbms_sql.varchar2_table;
ds_Filas_aux_w			dbms_sql.varchar2_table;
ds_Fila_w			varchar(255);
ds_fila_aux_w			varchar(255);
ie_Acao_w			varchar(255);
qt_Caracteres_w			integer;
ie_Parentese_Aberto_w		varchar(1);
ie_Encerramento_w		varchar(1);
ie_Caracter_Fila_w		varchar(1);
ds_caracter_atual_w		varchar(1);
qt_registros_w			varchar(10);
nr_seq_chamada_inter_w		bigint;
nr_seq_chamada_inter_item_w	bigint;
ie_existe_senha_restante_w	smallint;
ie_achou_ciclo_w		varchar(1);
nr_ciclo_regra_w		bigint;
ie_considerar_senha_atend_w	varchar(2);
nr_seq_fila_agenda_w		bigint;
qt_seg_temp_w			bigint;
qt_seg_temp_char_w		varchar(10);
nr_seq_fila_senha_w		paciente_senha_fila.nr_seq_fila_senha%type;
ds_erro_w				varchar(2000);
ie_status_agenda_w		varchar(255);
dt_data_atraso_w		timestamp;



c01 CURSOR FOR
	SELECT	a.nr_seq_fila_espera,
		b.nr_prioridade
	FROM	regra_liberacao_fila a,
		fila_espera_senha b
	WHERE	coalesce(a.nr_seq_local_senha,nr_seq_local_senha_w)	= nr_seq_local_senha_w
	AND	coalesce(a.cd_perfil,cd_perfil_w)			= cd_perfil_w
	AND	b.nr_sequencia 					= a.nr_seq_fila_espera
	AND	a.cd_estabelecimento				= cd_estabelecimento_p
	AND	coalesce(b.ie_permite_chamada, 'S') 			= 'S'
	ORDER BY nr_prioridade,
		obter_qt_atraso_senha(a.nr_seq_fila_espera,'MAX', 0, dt_data_atraso_w) desc, 
		obter_qt_atraso_senha(a.nr_seq_fila_espera,'MIN', 0, dt_data_atraso_w) desc;

c02 CURSOR FOR
	SELECT	a.nr_sequencia
	FROM	paciente_senha_fila a
	WHERE	ie_chamou_senha_w = 'N'
	AND	coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem) = nr_seq_fila_espera_w
	AND (coalesce(a.ie_rechamada,'N') = 'N')
	--and	a.dt_primeira_chamada is null
	AND	coalesce(a.dt_utilizacao::text, '') = ''
	AND	coalesce(a.dt_inutilizacao::text, '') = ''
	AND	a.cd_estabelecimento = cd_estabelecimento_p
	AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
	AND	coalesce(a.dt_fim_atendimento::text, '') = ''
	AND	coalesce(a.dt_chamada, clock_timestamp() - interval '1 days') < coalesce(a.dt_entrada_fila, clock_timestamp())
	AND	a.dt_geracao_senha > clock_timestamp() - interval '2 days'
	AND	((ie_considerar_senha_atend_w = 'S') OR ((coalesce(a.dt_primeira_chamada::text, '') = '') AND (coalesce(a.dt_vinculacao_senha::text, '') = '')))
	AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
	AND	((obter_tempo_espera_fila(a.nr_seq_fila_senha) = 0) OR ((obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1)) >= (obter_tempo_espera_fila(a.nr_seq_fila_senha))))
	AND	((coalesce(trim(both ie_status_agenda_w)::text, '') = '') or (not exists (	SELECT	1
				from	agenda_consulta ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N') or
		not exists (	select	1
				from	agenda_paciente ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N')))
	ORDER BY coalesce(a.nr_prioridade,99999),
		obter_qt_atraso_senha(coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem),'MAX', a.nr_sequencia, dt_data_atraso_w) desc,
		obter_qt_atraso_senha(coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem),'MIN', a.nr_sequencia, dt_data_atraso_w) desc,
		GREATEST(coalesce(a.dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(a.dt_entrada_fila, a.dt_geracao_senha)  ELSE a.dt_geracao_senha END ),
		a.cd_senha_gerada;

c04 CURSOR FOR
	SELECT	a.nr_sequencia
	FROM	paciente_senha_fila a
	WHERE	coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem) IN (	SELECT	y.nr_sequencia
										FROM	regra_liberacao_fila x,
											fila_espera_senha y
										WHERE	y.nr_sequencia 	= x.nr_seq_fila_espera
										AND	y.nr_prioridade = nr_prioridade_w
										AND	y.cd_estabelecimento = cd_estabelecimento_p
										AND	coalesce(x.nr_seq_local_senha,nr_seq_local_senha_w)	= nr_seq_local_senha_w
										AND	coalesce(x.cd_perfil,cd_perfil_w)			= cd_perfil_w
										AND	coalesce(y.ie_permite_chamada, 'S') 			= 'S')
	AND (coalesce(a.ie_rechamada,'N') = 'N')
	--and	dt_primeira_chamada is null
	AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
	AND	coalesce(a.dt_fim_atendimento::text, '') = ''
	AND	coalesce(a.dt_utilizacao::text, '') = ''
	AND	coalesce(a.dt_inutilizacao::text, '') = ''
	AND	ie_chamou_senha_w = 'N'
	AND	a.cd_estabelecimento = cd_estabelecimento_p
	AND	coalesce(a.dt_chamada, clock_timestamp() - interval '1 days') < coalesce(a.dt_entrada_fila, clock_timestamp())
	AND	a.dt_geracao_senha > clock_timestamp() - interval '2 days'
	AND	((ie_considerar_senha_atend_w = 'S') OR ((coalesce(a.dt_vinculacao_senha::text, '') = '') AND (coalesce(a.dt_primeira_chamada::text, '') = '')))
	AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
	AND	(((obter_tempo_espera_fila(a.nr_seq_fila_senha)) = 0) OR ((obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1))>= (obter_tempo_espera_fila(a.nr_seq_fila_senha))))
	AND	((coalesce(trim(both ie_status_agenda_w)::text, '') = '') or (not exists (	select	1
				from	agenda_consulta ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N') or
		not exists (	select	1
				from	agenda_paciente ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N')))
	ORDER BY coalesce(a.nr_prioridade,99999),
		obter_qt_atraso_senha(coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem),'MAX', a.nr_sequencia, dt_data_atraso_w) desc, 
		obter_qt_atraso_senha(coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem),'MIN', a.nr_sequencia, dt_data_atraso_w) desc,
		GREATEST(coalesce(a.dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(a.dt_entrada_fila, a.dt_geracao_senha)  ELSE a.dt_geracao_senha END ),
		a.cd_senha_gerada;

c05 CURSOR FOR
	SELECT	a.nr_sequencia
	FROM	triagem_classif_risco a
	WHERE	coalesce(a.cd_estabelecimento,cd_estabelecimento_p)  = cd_estabelecimento_p
	AND	coalesce(ie_situacao,'A') = 'A'
	ORDER BY nr_seq_prioridade;

c06 CURSOR FOR
	SELECT	a.nr_sequencia,
		a.nr_seq_fila_senha
	FROM	paciente_senha_fila a,
		triagem_pronto_atend b
	WHERE	b.nr_seq_fila_senha = a.nr_sequencia
	AND	ie_chamou_senha_w = 'N'
	AND (coalesce(ie_rechamada,'N') = 'N')
	AND	a.cd_estabelecimento = cd_estabelecimento_p
	AND	coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp())
	AND	dt_geracao_senha > clock_timestamp() - interval '2 days'
	AND	coalesce(a.dt_inutilizacao::text, '') = ''
	AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
	AND	coalesce(a.dt_fim_atendimento::text, '') = ''
	AND	coalesce(a.dt_utilizacao::text, '') = ''
	AND	b.nr_seq_classif = nr_seq_prioridade_w
	AND	((ie_considerar_senha_atend_w = 'S') OR (coalesce(dt_vinculacao_senha::text, '') = ''))
	AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
	AND	(((obter_tempo_espera_fila(a.nr_seq_fila_senha)) = 0) OR ((obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1)) >= (obter_tempo_espera_fila(a.nr_seq_fila_senha))))
	AND	a.nr_seq_fila_senha IN (	SELECT	y.nr_sequencia
						FROM	regra_liberacao_fila x,
							fila_espera_senha y
						WHERE	y.nr_sequencia 	= x.nr_seq_fila_espera
						AND	y.cd_estabelecimento = cd_estabelecimento_p
						AND	coalesce(x.nr_seq_local_senha,nr_seq_local_senha_w)	= nr_seq_local_senha_w
						AND	coalesce(x.cd_perfil,cd_perfil_w)			= cd_perfil_w
						AND	coalesce(y.ie_permite_chamada, 'S') 			= 'S')
	AND	((coalesce(trim(both ie_status_agenda_w)::text, '') = '') or (not exists (	select	1
				from	agenda_consulta ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N') or
		not exists (	select	1
				from	agenda_paciente ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N')))
	ORDER BY coalesce(nr_prioridade,99999),
		GREATEST(coalesce(dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(dt_entrada_fila, dt_geracao_senha)  ELSE dt_geracao_senha END ),
		a.cd_senha_gerada;

C07 CURSOR FOR
	SELECT	nr_sequencia,
		nr_seq_ordem,
		nr_seq_fila_espera,
		qt_senhas
	FROM	config_ciclo_chamada_item
	WHERE	nr_seq_config_ciclo = nr_seq_config_ciclo_w
	ORDER BY nr_seq_ordem;

C08 CURSOR FOR
	SELECT	b.nr_seq_fila_espera,
		a.nr_sequencia
	FROM	ciclo_chamada_senha_item a,
		config_ciclo_chamada_item b,
		config_ciclo_chamada c,
		fila_espera_senha d,
		regra_liberacao_fila e
	WHERE	b.nr_seq_config_ciclo = nr_seq_config_ciclo_w
	AND	b.nr_sequencia = a.nr_seq_config_ciclo_item
	AND	d.nr_sequencia = b.nr_seq_fila_espera
	AND	coalesce(d.ie_permite_chamada, 'S') 			= 'S'
	AND	coalesce(a.dt_chamada::text, '') = ''
	AND	ie_chamou_senha_w = 'N'
	AND	coalesce(e.nr_seq_local_senha,nr_seq_local_senha_w)	= nr_seq_local_senha_w
	AND	coalesce(e.cd_perfil,cd_perfil_w)			= cd_perfil_w
	AND	d.nr_sequencia 					= e.nr_seq_fila_espera
	AND	e.cd_estabelecimento				= cd_estabelecimento_p
	ORDER BY b.nr_seq_ordem, a.nr_sequencia;

c09 CURSOR FOR
	SELECT	a.nr_sequencia
	FROM	paciente_senha_fila a
	WHERE	position(TO_CHAR(',' || coalesce(a.nr_seq_fila_senha, a.nr_seq_fila_senha_origem) || ',') in ',' || ds_Fila_w || ',') > 0
	AND (coalesce(a.ie_rechamada,'N') = 'N')
	--and	dt_primeira_chamada is null
	AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
	AND	coalesce(a.dt_fim_atendimento::text, '') = ''
	AND	coalesce(a.dt_utilizacao::text, '') = ''
	AND	coalesce(a.dt_inutilizacao::text, '') = ''
	AND	ie_chamou_senha_w = 'N'
	AND	a.cd_estabelecimento = cd_estabelecimento_p
	AND	coalesce(a.dt_chamada, clock_timestamp() - interval '1 days') < coalesce(a.dt_entrada_fila, clock_timestamp())
	AND	a.dt_geracao_senha > clock_timestamp() - interval '2 days'
	AND	((ie_considerar_senha_atend_w = 'S') OR ((coalesce(a.dt_vinculacao_senha::text, '') = '') AND (coalesce(a.dt_primeira_chamada::text, '') = '')))
	AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
	AND	(((obter_tempo_espera_fila(nr_seq_fila_senha)) = 0) OR ((obter_segundo_entre_datas(dt_geracao_senha, clock_timestamp(),1))>= (obter_tempo_espera_fila(nr_seq_fila_senha))))
	AND	((coalesce(trim(both ie_status_agenda_w)::text, '') = '') or (not exists (	SELECT	1
				from	agenda_consulta ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N') or
		not exists (	select	1
				from	agenda_paciente ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N')))
	ORDER BY coalesce(nr_prioridade,99999),
		obter_qt_atraso_senha(coalesce(nr_seq_fila_senha,nr_seq_fila_senha_origem),'MAX', nr_sequencia, dt_data_atraso_w) desc,
		obter_qt_atraso_senha(coalesce(nr_seq_fila_senha,nr_seq_fila_senha_origem),'MIN', nr_sequencia, dt_data_atraso_w) desc,
		GREATEST(coalesce(dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(dt_entrada_fila, dt_geracao_senha)  ELSE dt_geracao_senha END ),
		a.cd_senha_gerada;
		
C10 CURSOR FOR
	SELECT	a.nr_sequencia
	FROM	chamada_inter_senha_item a,
		chamada_intercalada_senha b
	WHERE	a.nr_seq_chamada_inter = b.nr_sequencia
	AND	b.ie_situacao = 'A'
	AND	b.ds_filas = ds_fila_aux_w
	AND	b.nr_seq_estrategia_chamada = nr_seq_estrategia_senha_w
	AND	b.nr_seq_local_chamada = nr_seq_local_senha_w
	ORDER BY coalesce(a.qt_chamada, 0) ASC,
		  a.nr_sequencia;

c11 CURSOR FOR
	SELECT	a.nr_seq_fila_espera,
		b.nr_prioridade
	FROM	regra_liberacao_fila a,
		fila_espera_senha b,
		agendas_lib_fila_senha c
	WHERE	coalesce(a.nr_seq_local_senha,nr_seq_local_senha_w)	= nr_seq_local_senha_w
	AND	coalesce(a.cd_perfil,cd_perfil_w)			= cd_perfil_w
	AND	b.nr_sequencia 					= a.nr_seq_fila_espera
	AND	b.nr_sequencia					= c.nr_seq_fila_espera
	AND	a.cd_estabelecimento				= cd_estabelecimento_p
	AND	coalesce(b.ie_permite_chamada, 'S') 			= 'S'
	AND	c.nr_seq_agenda 				= cd_agenda_p
	ORDER BY nr_prioridade;

c12 CURSOR FOR
	SELECT nr_sequencia
	FROM (	SELECT*	FROM (	SELECT	a.nr_sequencia,
					b.dt_agenda, 
					nr_prioridade, 
					dt_nova_chamada, 
					dt_entrada_fila, 
					dt_geracao_senha
				FROM	paciente_senha_fila a,
					agenda_consulta b
				WHERE	coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem) = nr_seq_fila_espera_w
				AND	b.nr_seq_pac_senha_fila = a.nr_sequencia
				AND	b.cd_agenda = cd_agenda_p
				AND	coalesce(a.ie_rechamada,'N') = 'N'
				--and	a.dt_primeira_chamada is null
				AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
				AND	coalesce(a.dt_fim_atendimento::text, '') = ''
				AND	coalesce(a.dt_utilizacao::text, '') = ''
				AND	coalesce(a.dt_inutilizacao::text, '') = ''
				AND	ie_chamou_senha_w = 'N'
				AND	a.cd_estabelecimento = cd_estabelecimento_p
				AND	coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp())
				AND	dt_geracao_senha > clock_timestamp() - interval '2 days'
				AND	((ie_considerar_senha_atend_w = 'S') OR ((coalesce(dt_vinculacao_senha::text, '') = '')AND (coalesce(a.dt_primeira_chamada::text, '') = '')))
				AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
				AND	(((obter_tempo_espera_fila(nr_seq_fila_senha)) = 0) OR ((obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1))>= (obter_tempo_espera_fila(nr_seq_fila_senha))))
				AND (coalesce(ie_status_agenda_w::text, '') = '' or obter_se_contido_char(b.ie_status_agenda, ie_status_agenda_w) = 'S')
				ORDER BY
					b.dt_agenda,
					coalesce(nr_prioridade,99999), GREATEST(coalesce(dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(dt_entrada_fila, dt_geracao_senha)  ELSE dt_geracao_senha END ),
					a.cd_senha_gerada) alias41
		
UNION

		SELECT*	FROM (	SELECT	a.nr_sequencia, 
					b.dt_agenda, 
					nr_prioridade, 
					dt_nova_chamada, 
					dt_entrada_fila, 
					dt_geracao_senha
				FROM	paciente_senha_fila a,
					agenda_paciente b
				WHERE	coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem) = nr_seq_fila_espera_w
				AND	b.nr_seq_pac_senha_fila = a.nr_sequencia
				AND	b.cd_agenda = cd_agenda_p
				AND	coalesce(a.ie_rechamada,'N') = 'N'
				--and	a.dt_primeira_chamada is null
				AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
				AND	coalesce(a.dt_fim_atendimento::text, '') = ''
				AND	coalesce(a.dt_utilizacao::text, '') = ''
				AND	coalesce(a.dt_inutilizacao::text, '') = ''
				AND	ie_chamou_senha_w = 'N'
				AND	a.cd_estabelecimento = cd_estabelecimento_p
				AND	coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp())
				AND	dt_geracao_senha > clock_timestamp() - interval '2 days'
				AND	((ie_considerar_senha_atend_w = 'S') OR ((coalesce(dt_vinculacao_senha::text, '') = '')AND (coalesce(a.dt_primeira_chamada::text, '') = '')))
				AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
				AND	(((obter_tempo_espera_fila(nr_seq_fila_senha)) = 0) OR ((obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1))>= (obter_tempo_espera_fila(nr_seq_fila_senha))))
				AND (coalesce(ie_status_agenda_w::text, '') = '' or obter_se_contido_char(b.ie_status_agenda, ie_status_agenda_w) = 'S')
				ORDER BY
					b.dt_agenda,
					coalesce(nr_prioridade,99999), GREATEST(coalesce(dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(dt_entrada_fila, dt_geracao_senha)  ELSE dt_geracao_senha END ),
					a.cd_senha_gerada) alias83) alias84;

c13 CURSOR FOR
	SELECT	a.nr_sequencia
	FROM	paciente_senha_fila a
	WHERE	coalesce(a.nr_seq_fila_senha,a.nr_seq_fila_senha_origem) = nr_seq_fila_espera_w
	AND	coalesce(a.dt_vinculacao_senha::text, '') = ''
	AND (coalesce(a.ie_rechamada,'N') = 'N')
	AND	coalesce(a.dt_primeira_chamada::text, '') = ''
	AND	coalesce(a.dt_utilizacao::text, '') = ''
	AND	coalesce(a.dt_inutilizacao::text, '') = ''
	AND	a.cd_estabelecimento = cd_estabelecimento_p
	AND	coalesce(a.dt_chamada, clock_timestamp() - interval '1 days') < coalesce(a.dt_entrada_fila, clock_timestamp())
	AND	a.dt_geracao_senha > clock_timestamp() - interval '2 days'
	AND	coalesce(a.dt_inicio_atendimento::text, '') = ''
	AND	coalesce(a.dt_fim_atendimento::text, '') = ''
	AND	ie_chamou_senha_w = 'N'
	AND	((qt_seg_temp_w = 0) OR (obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1) >= qt_seg_temp_w))
	AND	(((obter_tempo_espera_fila(a.nr_seq_fila_senha)) = 0) OR
		 ((obter_segundo_entre_datas(a.dt_geracao_senha, clock_timestamp(),1)) >= (obter_tempo_espera_fila(a.nr_seq_fila_senha))))
	AND	((coalesce(trim(both ie_status_agenda_w)::text, '') = '') or (not exists (	SELECT	1
				from	agenda_consulta ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N') or
		not exists (	select	1
				from	agenda_paciente ag
				where	ag.nr_seq_pac_senha_fila = a.nr_sequencia
				and	obter_se_contido_char(ag.ie_status_agenda, ie_status_agenda_w) = 'N')))
	ORDER BY coalesce(a.nr_prioridade,99999),
		GREATEST(coalesce(a.dt_nova_chamada, clock_timestamp() - interval '10 days'), CASE WHEN ie_regra_tempo_espera_w='F' THEN  coalesce(a.dt_entrada_fila, a.dt_geracao_senha)  ELSE a.dt_geracao_senha END ),
		a.cd_senha_gerada;

c14 CURSOR FOR
	SELECT	nr_sequencia
	FROM	config_ciclo_chamada
	WHERE	coalesce(cd_estabelecimento, coalesce(cd_estabelecimento_p, 0)) = coalesce(cd_estabelecimento_p, 0)
	AND	coalesce(cd_perfil, coalesce(cd_perfil_w, 0)) = coalesce(cd_perfil_w, 0)
	AND	ie_situacao = 'A'
	ORDER BY cd_perfil, cd_estabelecimento;
BEGIN

dt_data_atraso_w := clock_timestamp();
cd_perfil_w := obter_perfil_ativo;

qt_max_chamadas_w := Obter_param_Usuario(10021, 24, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, qt_max_chamadas_w);
ie_utiliza_oracle_alert_w := Obter_param_Usuario(10021, 56, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, ie_utiliza_oracle_alert_w);
ie_regra_chamada_w := Obter_param_Usuario(10021, 58, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, ie_regra_chamada_w);
ie_regra_tempo_espera_w := Obter_param_Usuario(10021, 77, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, ie_regra_tempo_espera_w);
ie_considerar_senha_atend_w := Obter_param_Usuario(10021, 92, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, ie_considerar_senha_atend_w);

qt_seg_temp_char_w := Obter_param_Usuario(10021, 117, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, qt_seg_temp_char_w);
qt_seg_temp_w	:= somente_numero(qt_seg_temp_char_w);

ie_status_agenda_w := null;
if (Obter_Funcao_Ativa = 281) then -- o parametro 144 deveria ser aplicado somente quando chamar a senha pelo PEP.
	ie_status_agenda_w := Obter_param_Usuario(10021, 144, obter_perfil_ativo, nm_usuario_p, cd_estabelecimento_p, ie_status_agenda_w);
end if;


IF (coalesce(nr_seq_local_chamada_p,0) > 0) THEN

	SELECT	coalesce(MAX(a.nr_sequencia),0),
		MAX(nr_seq_estrategia_senha)
	INTO STRICT	nr_seq_local_senha_w,
		nr_seq_estrategia_senha_w
	FROM	maquina_local_senha a,
		computador b
	WHERE	a.nr_seq_computador	= b.nr_sequencia
	AND	b.cd_estabelecimento 	= cd_estabelecimento_p
	AND	nm_computador_pesquisa 	= padronizar_nome(UPPER(nm_maquina_atual_p))
	AND	a.nr_sequencia		= nr_seq_local_chamada_p
	AND	coalesce(a.ie_situacao, 'A') = 'A';


ELSE
	SELECT	coalesce(MAX(a.nr_sequencia),0),
		MAX(nr_seq_estrategia_senha)
	INTO STRICT	nr_seq_local_senha_w,
		nr_seq_estrategia_senha_w
	FROM	maquina_local_senha a,
		computador b
	WHERE	a.nr_seq_computador	= b.nr_sequencia
	AND	b.cd_estabelecimento 	= cd_estabelecimento_p
	AND	nm_computador_pesquisa	= padronizar_nome(UPPER(nm_maquina_atual_p))
	AND	coalesce(a.ie_situacao, 'A') = 'A';

END IF;

IF (ie_regra_chamada_w in (1))THEN

	OPEN c01;
	LOOP
	FETCH c01 INTO
		nr_seq_fila_espera_w,
		nr_prioridade_w;
	EXIT WHEN NOT FOUND; /* apply on c01 */
		BEGIN

		BEGIN	/* Verificar se existe fila com a mesma prioridade */
			SELECT	1
			INTO STRICT	qt_existe_fila_igual_w
			FROM	regra_liberacao_fila a,
				fila_espera_senha b
			WHERE	b.nr_sequencia 	= a.nr_seq_fila_espera
			AND	b.nr_sequencia <> nr_seq_fila_espera_w
			AND	b.nr_prioridade = nr_prioridade_w
			AND	b.cd_estabelecimento = cd_estabelecimento_p
			AND	coalesce(a.nr_seq_local_senha,nr_seq_local_senha_w)	= nr_seq_local_senha_w
			AND	coalesce(a.cd_perfil,cd_perfil_w)			= cd_perfil_w
			AND	coalesce(b.ie_permite_chamada, 'S') 			= 'S'  LIMIT 1;
		EXCEPTION
			WHEN	no_data_found THEN
				qt_existe_fila_igual_w := 0;
		END;

		IF (qt_existe_fila_igual_w > 0) THEN

			OPEN c04;
			LOOP
			FETCH c04 INTO
				nr_seq_senha_w;
			EXIT WHEN NOT FOUND; /* apply on c04 */
				BEGIN

				IF (ie_chamou_senha_w = 'N') THEN

					SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
					INTO STRICT	cd_senha_chamada_w
					FROM	paciente_senha_fila
					WHERE	nr_sequencia = nr_seq_senha_w;

					IF (cd_senha_chamada_w > '0') THEN
						begin
							UPDATE	paciente_senha_fila
							SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
								dt_chamada		= clock_timestamp(),
								ds_maquina_chamada	= nm_maquina_atual_p,
								nm_usuario		= nm_usuario_p,
								nm_usuario_chamada	= nm_usuario_p,
								nr_seq_local_senha	= nr_seq_local_senha_w,
								qt_chamadas		= coalesce(qt_chamadas,0) + 1,
								ie_forma_chamada	= 'P'
							WHERE 	nr_sequencia		= nr_seq_senha_w
							AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
							
							if (SQL%ROWCOUNT > 0) then
								ie_chamou_senha_w	:= 'S';
								nr_senha_p			:= cd_senha_chamada_w;
								nr_seq_senha_p		:= nr_seq_senha_w;
                CALL bifrost_integracao_senhas(nr_seq_senha_p      =>nr_seq_senha_p);
							else
								nr_senha_p		:= null;
								nr_seq_senha_p	:= null;
							end if;
							
							COMMIT;
						exception
							when	others then --Colocado esta excessao para evitar casos onde eh clicado sobre o botao proximo em mais de uma maquina simultaneamente!
									begin
									rollback;
									ie_chamou_senha_w 	:= 'N';
									nr_senha_p			:= null;
									nr_seq_senha_p		:= null;
									end;
						end;

						IF (ie_utiliza_oracle_alert_w = 'S') THEN
							CALL verificar_senha_nova_signal(nm_usuario_p);
						END IF;
					END IF;
				END IF;
				END;
			END LOOP;
			CLOSE c04;
		END IF;

		IF (ie_chamou_senha_w = 'N') THEN
			BEGIN
			
			OPEN c02;
			LOOP
			FETCH c02 INTO
				nr_seq_senha_w;
			EXIT WHEN NOT FOUND; /* apply on c02 */
				BEGIN

				IF (ie_chamou_senha_w = 'N') THEN

					SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
					INTO STRICT	cd_senha_chamada_w
					FROM	paciente_senha_fila
					WHERE	nr_sequencia	= nr_seq_senha_w;

					IF (cd_senha_chamada_w > '0') THEN
						begin
							UPDATE	paciente_senha_fila
							SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
								dt_chamada		= clock_timestamp(),
								ds_maquina_chamada	= nm_maquina_atual_p,
								nm_usuario		= nm_usuario_p,
								nm_usuario_chamada	= nm_usuario_p,
								nr_seq_local_senha	= nr_seq_local_senha_w,
								qt_chamadas		= coalesce(qt_chamadas,0) + 1,
								ie_forma_chamada	= 'P'
							WHERE 	nr_sequencia		= nr_seq_senha_w
							AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
							
							if (SQL%ROWCOUNT > 0) then
								ie_chamou_senha_w	:= 'S';
								nr_senha_p			:= cd_senha_chamada_w;
								nr_seq_senha_p		:= nr_seq_senha_w;
                CALL bifrost_integracao_senhas(nr_seq_senha_p      =>nr_seq_senha_p);
							else
								nr_senha_p		:= null;
								nr_seq_senha_p	:= null;
							end if;
							
							COMMIT;
						exception
							when	others then --Colocado esta excessao para evitar casos onde eh clicado sobre o botao proximo em mais de uma maquina simultaneamente!
									begin
									rollback;
									ie_chamou_senha_w 	:= 'N';
									nr_senha_p			:= null;
									nr_seq_senha_p		:= null;
									end;
						end;

						IF (ie_utiliza_oracle_alert_w = 'S') THEN
							CALL verificar_senha_nova_signal(nm_usuario_p);
						END IF;
					END IF;
				END IF;
				END;
			END LOOP;
			CLOSE c02;

			END;
		END IF;

		END;
	END LOOP;
	CLOSE c01;

ELSIF (ie_regra_chamada_w = 2) THEN
	OPEN c05;
	LOOP
	FETCH c05 INTO
		nr_seq_prioridade_w;
	EXIT WHEN NOT FOUND; /* apply on c05 */
		BEGIN		
		IF (ie_chamou_senha_w = 'N') THEN
			OPEN c06;
			LOOP
			FETCH c06 INTO
				nr_seq_senha_w,
				nr_seq_fila_senha_w;
			EXIT WHEN NOT FOUND; /* apply on c06 */
				BEGIN			
				IF (ie_chamou_senha_w = 'N') THEN
					SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
					INTO STRICT	cd_senha_chamada_w
					FROM	paciente_senha_fila
					WHERE	nr_sequencia	=	nr_seq_senha_w;
					
					IF (cd_senha_chamada_w > '0') THEN					
						nr_senha_p		:= cd_senha_chamada_w;
						nr_seq_senha_p		:= nr_seq_senha_w;
						ie_chamou_senha_w	:= 'S';

						CALL chamar_senha_pac_avulsa(nr_seq_senha_w,nm_maquina_atual_p,nr_seq_fila_senha_w,cd_senha_chamada_w,nm_usuario_p,0,null,cd_agenda_p);
					END IF;

				END IF;
				END;
			END LOOP;
			CLOSE c06;

		END IF;
		END;
	END LOOP;
	CLOSE c05;
ELSIF (ie_regra_chamada_w = 3) THEN
	/* Ciclo de chamadas */



	/* Verificar se ha ciclo de chamada para a configuracao atual */

	ie_achou_ciclo_w := 'N';
	OPEN C14;
	LOOP
	FETCH C14 INTO
		nr_ciclo_regra_w;
	EXIT WHEN NOT FOUND; /* apply on C14 */
		IF (ie_achou_ciclo_w = 'N') THEN
			ie_achou_ciclo_w := 'S';
			nr_seq_config_ciclo_w := nr_ciclo_regra_w;
		END IF;
	END LOOP;
	CLOSE C14;

	IF (nr_seq_config_ciclo_w IS NOT NULL AND nr_seq_config_ciclo_w::text <> '') THEN

		/* Verificar se ha ciclo ativo */

		BEGIN
			SELECT	nr_sequencia
			INTO STRICT	nr_seq_ciclo_chamada_ativo_w
			FROM	ciclo_chamada_senha
			WHERE	nr_seq_config_ciclo = nr_seq_config_ciclo_w
			AND	(dt_inicio IS NOT NULL AND dt_inicio::text <> '')
			AND	coalesce(dt_fim::text, '') = ''  LIMIT 1;
		EXCEPTION
			WHEN	no_data_found THEN
				nr_seq_ciclo_chamada_ativo_w := 0;
			WHEN	OTHERS THEN
				nr_seq_ciclo_chamada_ativo_w := 1;
		END;


		/* Caso nao haja ciclo ativo */

		IF (nr_seq_ciclo_chamada_ativo_w = 0) THEN

			SELECT	nextval('ciclo_chamada_senha_seq')
			INTO STRICT	nr_seq_ciclo_chamada_ativo_w
			;

			/* Cria novo ciclo de chamadas */

			INSERT INTO ciclo_chamada_senha(
				nr_sequencia,
				dt_inicio,
				dt_fim,
				nr_seq_config_ciclo)
			VALUES (nr_seq_ciclo_chamada_ativo_w,
				clock_timestamp(),
				NULL,
				nr_seq_config_ciclo_w);

			/* Criando os itens do ciclo de chamada */

			OPEN C07;
			LOOP
			FETCH C07 INTO
				nr_seq_config_ciclo_item_w,
				nr_seq_ordem_w,
				nr_seq_fila_espera_w,
				qt_senhas_w;
			EXIT WHEN NOT FOUND; /* apply on C07 */


				FOR i IN 1..qt_senhas_w LOOP
					INSERT INTO ciclo_chamada_senha_item(
						nr_sequencia,
						nr_seq_ciclo_chamada,
						dt_chamada,
						nr_seq_config_ciclo_item,
						nr_seq_pac_senha_fila)
					VALUES (nextval('ciclo_chamada_senha_item_seq'),
						nr_seq_ciclo_chamada_ativo_w,
						NULL,
						nr_seq_config_ciclo_item_w,
						NULL);
				END LOOP;


			END LOOP;
			CLOSE C07;
			commit; -- para nao ocorrer erro ORA-01002 caso do rollback exception abaixo
		END IF;

		/* Chamar proxima senha do ciclo */

		ie_chamou_senha_w := 'N';

		/* Filas restantes conforme os itens do ciclo atual */

		OPEN C08;
		LOOP
		FETCH C08 INTO
			nr_seq_fila_espera_w,
			nr_seq_ciclo_chamada_item_w;
		EXIT WHEN NOT FOUND; /* apply on C08 */

			IF (ie_chamou_senha_w = 'N') THEN
				/* Chamar proxima senha da fila */

				OPEN c02;
				LOOP
				FETCH c02 INTO
					nr_seq_senha_w;
				EXIT WHEN(ie_chamou_senha_w = 'S') OR c02%NOTFOUND;

					IF (ie_chamou_senha_w = 'N') THEN

						SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
						INTO STRICT	cd_senha_chamada_w
						FROM	paciente_senha_fila
						WHERE	nr_sequencia	= nr_seq_senha_w;


						IF (cd_senha_chamada_w > '0') THEN
							/* Chamada da senha */

							begin
								UPDATE	paciente_senha_fila
								SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
									ds_maquina_chamada	= nm_maquina_atual_p,
									nm_usuario		= nm_usuario_p,
									nm_usuario_chamada	= nm_usuario_p,
									nr_seq_local_senha	= nr_seq_local_senha_w,
									qt_chamadas		= coalesce(qt_chamadas,0) + 1,
									dt_chamada		= clock_timestamp(),
									ie_forma_chamada	= 'P'
								WHERE 	nr_sequencia		= nr_seq_senha_w
								AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
								
								if (SQL%ROWCOUNT > 0) then
									ie_chamou_senha_w	:= 'S';
									nr_senha_p			:= cd_senha_chamada_w;
									nr_seq_senha_p		:= nr_seq_senha_w;
                  CALL bifrost_integracao_senhas(nr_seq_senha_p      =>nr_seq_senha_p);
								else
									nr_senha_p		:= null;
									nr_seq_senha_p	:= null;
								end if;
							
								COMMIT;
							exception
								when	others then --Colocado esta excessao para evitar casos onde eh clicado sobre o botao proximo em mais de uma maquina simultaneamente!
										begin
										rollback;
										ie_chamou_senha_w 	:= 'N';
										nr_senha_p			:= null;
										nr_seq_senha_p		:= null;
										end;
							end;



							/* Vincula a senha chamada com o item do ciclo ativo */

							UPDATE	ciclo_chamada_senha_item
							SET	nr_seq_pac_senha_fila = nr_seq_senha_w,
								dt_chamada = clock_timestamp()
							WHERE	nr_sequencia = nr_seq_ciclo_chamada_item_w;
							commit; -- para nao ocorrer erro ORA-01002 caso do rollback exception abaixo
							IF (ie_utiliza_oracle_alert_w = 'S') THEN
								CALL verificar_senha_nova_signal(nm_usuario_p);
							END IF;
						END IF;
					END IF;
				END LOOP;
				CLOSE c02;
			END IF;
		END LOOP;
		CLOSE C08;

		ie_existe_senha_restante_w := 0;
		/* Caso nao tenha encontrado nenhuma senha das filas restantes do ciclo, encerra os itens ciclo atual */

		IF (ie_chamou_senha_w = 'N') THEN

			UPDATE	ciclo_chamada_senha_item
			SET	dt_chamada = clock_timestamp()
			WHERE	coalesce(nr_seq_pac_senha_fila::text, '') = ''
			AND	nr_seq_config_ciclo_item IN (	SELECT	b.nr_sequencia
								FROM	config_ciclo_chamada_item b
								WHERE	b.nr_seq_config_ciclo = nr_seq_config_ciclo_w);

			commit; -- para nao ocorrer erro ORA-01002 caso do rollback exception abaixo
			ie_existe_senha_restante_w := 0;
		END IF;

		/* Verifica se o ciclo atual ainda possui itens pendentes */

		BEGIN
			SELECT	1
			INTO STRICT	qt_itens_pendente_ciclo_w
			FROM	ciclo_chamada_senha_item
			WHERE	nr_seq_config_ciclo_item IN (	SELECT	b.nr_sequencia
								FROM	config_ciclo_chamada_item b
								WHERE	b.nr_seq_config_ciclo = nr_seq_config_ciclo_w)
			AND	coalesce(dt_chamada::text, '') = ''  LIMIT 1;
		EXCEPTION
			WHEN 	no_data_found THEN
				qt_itens_pendente_ciclo_w := 0;
			WHEN	OTHERS THEN
				qt_itens_pendente_ciclo_w := 1;
		END;

		/* Finaliza ciclo ativo */

		IF (qt_itens_pendente_ciclo_w = 0) THEN
			DELETE	FROM ciclo_chamada_senha_item
			WHERE	nr_seq_ciclo_chamada = nr_seq_ciclo_chamada_ativo_w;

			DELETE	FROM ciclo_chamada_senha
			WHERE	nr_sequencia = nr_seq_ciclo_chamada_ativo_w;
		END IF;

		/* Se nao chamou nenhuma senha, e encerrou o ciclo atual, chama a propria procedure para criar um novo ciclo */

		IF (ie_chamou_senha_w = 'N') AND (qt_itens_pendente_ciclo_w = 0) AND (coalesce(ie_rechamada_ciclo_p, 'N') = 'N') AND (nr_seq_config_ciclo_w IS NOT NULL AND nr_seq_config_ciclo_w::text <> '') THEN
			SELECT * FROM chamar_senha_paciente(	nm_maquina_atual_p, cd_estabelecimento_p, nm_usuario_p, nr_senha_p, nr_seq_senha_p, '0', 0, 'S') INTO STRICT nr_senha_p, nr_seq_senha_p;

		END IF;
	END IF;
ELSIF (ie_regra_chamada_w = 4) THEN /* Estrategia de chamadas de senha */
	IF (nr_seq_estrategia_senha_w IS NOT NULL AND nr_seq_estrategia_senha_w::text <> '')THEN

		SELECT	MAX(ds_estrategia)
		INTO STRICT	ds_estrategia_chamada_w
		FROM	estrategia_chamada_senha
		WHERE	nr_sequencia = nr_seq_estrategia_senha_w;

		UPDATE	chamada_intercalada_senha
		SET	ie_situacao = 'N'
		WHERE	nr_seq_estrategia_chamada <> nr_seq_estrategia_senha_w
		AND	nr_seq_local_chamada = nr_seq_local_senha_w;

		UPDATE	chamada_intercalada_senha
		SET	ie_situacao = 'A'
		WHERE	nr_seq_estrategia_chamada = nr_seq_estrategia_senha_w
		AND	nr_seq_local_chamada = nr_seq_local_senha_w;

		UPDATE	chamada_inter_senha_item
		SET	qt_chamada = 0
		WHERE	nr_seq_chamada_inter IN (SELECT	b.nr_sequencia
						FROM	chamada_intercalada_senha b
						WHERE	b.nr_seq_local_chamada = nr_seq_local_senha_w
						AND	b.ie_situacao = 'N');
		COMMIT;

		IF (ds_estrategia_chamada_w IS NOT NULL AND ds_estrategia_chamada_w::text <> '') THEN

			-- inicializar variaveis
			ie_Parentese_Aberto_w	:= 'N';
			ds_Texto_w 		:= ds_estrategia_chamada_w;
			ds_Fila_w  		:= '';
			ie_Acao_w  		:= '';
			ie_Encerramento_w 	:= 'N';
			qt_caracteres_w		:= 1;
			qt_registros_w		:= 1;
			ds_filas_w.DELETE;

			WHILE(qt_Caracteres_w <= LENGTH(ds_Texto_w)) LOOP

				ds_caracter_atual_w := SUBSTR(ds_Texto_w, qt_Caracteres_w, 1);

				-- inicio e fim do parenteses
				IF (ds_caracter_atual_w = '(') THEN
					ie_Parentese_Aberto_w := 'S';
				ELSIF (ds_caracter_atual_w = ')') THEN
					ie_Parentese_Aberto_w := 'N';
				END IF;

				-- montar o codigo da fila
				IF (ie_Parentese_Aberto_w = 'S') AND (ds_caracter_atual_w <> ')') AND (ds_caracter_atual_w <> '(') AND (ds_caracter_atual_w <> '/') THEN
					ds_Fila_w := ds_Fila_w || ds_caracter_atual_w;
				END IF;

				-- separar codigo da fila
				IF (ie_Parentese_Aberto_w = 'N') AND (ds_caracter_atual_w <> '/') AND (ds_caracter_atual_w <> '!') AND (ds_Fila_w IS NOT NULL AND ds_Fila_w::text <> '') THEN
					ds_Fila_w := ds_Fila_w || ',';
				END IF;

				-- identificar qual a acao - chamar ou intercalar
				IF (ie_Parentese_Aberto_w = 'N') AND (ds_caracter_atual_w <> ')') AND (ds_caracter_atual_w <> '(') AND (ds_caracter_atual_w <> '/') AND (qt_Caracteres_w <> LENGTH(ds_Texto_w)) THEN
					ie_Acao_w := ds_caracter_atual_w;
				END IF;

				-- identificar se chegou ao fim da estrategia, ou de uma parte dela
				IF (ds_caracter_atual_w = '/') OR (qt_Caracteres_w = LENGTH(ds_Texto_w)) THEN
					ie_Encerramento_w := 'S';
				END IF;

				IF (ie_encerramento_w = 'S') THEN

					-- garantir que nao ficara uma virgula no final da string
					<<limpar_virgula>>
					WHILE(SUBSTR(ds_Fila_w, LENGTH(ds_Fila_w), 1) = ',') LOOP
						ds_fila_w := SUBSTR(ds_Fila_w, 1, LENGTH(ds_Fila_w) -1);
					END LOOP limpar_virgula;

					-- Guarda o registro na lista de string, com o formato

					-- ; + acao + ; + codigo das filas (separados por virgula)
					ds_filas_w(qt_registros_w) := ie_acao_w || ';' ||ds_fila_w;
					qt_registros_w  := qt_registros_w + 1;

					-- reinicializar as variaveis
					ds_fila_w  		:= '';
					ie_acao_w  		:= '';
					ie_encerramento_w 	:= 'N';
					ie_parentese_aberto_w	:= 'N';
				END IF;

				qt_Caracteres_w := qt_Caracteres_w + 1;
			END LOOP;

			FOR 	i IN ds_filas_w.first..ds_filas_w.last LOOP

				IF (ie_chamou_senha_w = 'N') THEN

					IF (SUBSTR(ds_filas_w(i), 1, 1) = ';') THEN
						ie_acao_w := '';
						ds_filas_w(i) := SUBSTR(ds_filas_w(i), 2, 2000);
					ELSE
						ie_acao_w := SUBSTR(ds_filas_w(i), 1, 1);
						ds_filas_w(i) := SUBSTR(ds_filas_w(i), 3, 2000);
					END IF;

					IF (coalesce(ie_acao_w::text, '') = '') THEN
						ds_Fila_w := ds_filas_w(i);
						-- Apos definir as filas, chamar a senha
						<<Cursor9>>
						OPEN c09;
						LOOP
						FETCH c09 INTO
							nr_seq_senha_w;
						EXIT WHEN NOT FOUND; /* apply on c09 */
							IF (ie_chamou_senha_w = 'N') THEN
								SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
								INTO STRICT	cd_senha_chamada_w
								FROM	paciente_senha_fila
								WHERE	nr_sequencia = nr_seq_senha_w
								AND	coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp());
								
								
								IF (cd_senha_chamada_w > '0') THEN
									-- Tratamento para nao permitir chamar a mesma senha ao mesmo tempo
									begin
										UPDATE	paciente_senha_fila
										SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
											dt_chamada		= clock_timestamp(),
											ds_maquina_chamada	= nm_maquina_atual_p,
											nm_usuario		= nm_usuario_p,
											nm_usuario_chamada	= nm_usuario_p,
											nr_seq_local_senha	= nr_seq_local_senha_w,
											qt_chamadas		= coalesce(qt_chamadas,0) + 1,
											ie_forma_chamada	= 'P'
										WHERE 	nr_sequencia		= nr_seq_senha_w
										AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
										
										if (SQL%ROWCOUNT > 0) then
											ie_chamou_senha_w	:= 'S';
											nr_senha_p			:= cd_senha_chamada_w;
											nr_seq_senha_p		:= nr_seq_senha_w;
                      CALL bifrost_integracao_senhas(nr_seq_senha_p      =>nr_seq_senha_p);
										else
											nr_senha_p		:= null;
											nr_seq_senha_p	:= null;
										end if;
							
										COMMIT;
									exception
										when	others then --Colocado esta excessao para evitar casos onde eh clicado sobre o botao proximo em mais de uma maquina simultaneamente!
												begin
												rollback;
												ie_chamou_senha_w 	:= 'N';
												nr_senha_p			:= null;
												nr_seq_senha_p		:= null;
												end;
									end;

									IF (ie_utiliza_oracle_alert_w = 'S') THEN
										CALL verificar_senha_nova_signal(nm_usuario_p);
									END IF;
								END IF;
							END IF;
						END LOOP Cursor9;
						CLOSE c09;

					ELSIF (ie_acao_w = '!') THEN

						ds_Fila_w := ds_filas_w(i);

						BEGIN
							SELECT	1
							INTO STRICT	nr_seq_chamada_inter_w
							FROM	chamada_intercalada_senha
							WHERE	nr_seq_local_chamada = nr_seq_local_senha_w
							AND	nr_seq_estrategia_chamada = nr_seq_estrategia_senha_w
							and	ds_filas = ds_Fila_w
							AND	ie_situacao = 'A'  LIMIT 1;
						EXCEPTION
							WHEN	no_data_found THEN
								nr_seq_chamada_inter_w := 0;
							WHEN	OTHERS THEN
								nr_seq_chamada_inter_w := 1;
						END;

						-- Se nao existir ainda registro de chamada intercalada
						IF (nr_seq_chamada_inter_w = 0) THEN

							SELECT	nextval('chamada_intercalada_senha_seq')
							INTO STRICT	nr_seq_chamada_inter_w
							;

							INSERT INTO chamada_intercalada_senha(
								nr_sequencia,
								dt_atualizacao_nrec,
								nm_usuario_nrec,
								dt_atualizacao,
								nm_usuario,
								ie_situacao,
								ds_filas,
								nr_seq_local_chamada,
								nr_seq_estrategia_chamada)
							VALUES (nr_seq_chamada_inter_w,
								clock_timestamp(),
								nm_usuario_p,
								clock_timestamp(),
								nm_usuario_p,
								'A',
								ds_fila_w,
								nr_seq_local_senha_w,
								nr_seq_estrategia_senha_w);

							ds_Filas_aux_w := obter_lista_string(ds_fila_w, ',');

							FOR i IN ds_Filas_aux_w.first..ds_Filas_aux_w.last LOOP

								IF ((ds_Filas_aux_w(i) IS NOT NULL AND (ds_Filas_aux_w(i))::text <> '')) THEN

									SELECT	nextval('chamada_intercalada_senha_seq')
									INTO STRICT	nr_seq_chamada_inter_item_w
									;

									INSERT INTO chamada_inter_senha_item(
										nr_sequencia,
										dt_atualizacao_nrec,
										nm_usuario_nrec,
										dt_atualizacao,
										nm_usuario,
										ie_situacao,
										nr_seq_chamada_inter,
										nr_seq_fila_espera,
										qt_chamada)
									VALUES (nr_seq_chamada_inter_item_w,
										clock_timestamp(),
										nm_usuario_p,
										clock_timestamp(),
										nm_usuario_p,
										'A',
										nr_seq_chamada_inter_w,
										ds_Filas_aux_w(i),
										0);
								END IF;
							END LOOP;
						END IF;

						ds_fila_aux_w := ds_fila_w;

						OPEN C10;
						LOOP
						FETCH C10 INTO
							nr_seq_chamada_inter_item_w;
						EXIT WHEN NOT FOUND; /* apply on C10 */
							IF (ie_chamou_senha_w = 'N') THEN

								SELECT	MAX(nr_seq_fila_espera)
								INTO STRICT	nr_seq_fila_espera_w
								FROM	chamada_inter_senha_item
								WHERE	nr_sequencia = nr_seq_chamada_inter_item_w;

								ds_fila_w := nr_seq_fila_espera_w;

								-- Apos definir as filas, chamar a senha
								<<Cursor9>>
								OPEN c09;
								LOOP
								FETCH c09 INTO
									nr_seq_senha_w;
								EXIT WHEN NOT FOUND; /* apply on c09 */
									IF (ie_chamou_senha_w = 'N') THEN
										SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
										INTO STRICT	cd_senha_chamada_w
										FROM	paciente_senha_fila
										WHERE	nr_sequencia = nr_seq_senha_w;

										IF (cd_senha_chamada_w > '0') THEN
											begin
												UPDATE	paciente_senha_fila
												SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
													dt_chamada		= clock_timestamp(),
													ds_maquina_chamada	= nm_maquina_atual_p,
													nm_usuario		= nm_usuario_p,
													nm_usuario_chamada	= nm_usuario_p,
													nr_seq_local_senha	= nr_seq_local_senha_w,
													qt_chamadas		= coalesce(qt_chamadas,0) + 1,
													ie_forma_chamada	= 'P'
												WHERE 	nr_sequencia		= nr_seq_senha_w
												AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
												
												if (SQL%ROWCOUNT > 0) then
													ie_chamou_senha_w	:= 'S';
													nr_senha_p			:= cd_senha_chamada_w;
													nr_seq_senha_p		:= nr_seq_senha_w;
                          CALL bifrost_integracao_senhas(nr_seq_senha_p      =>nr_seq_senha_p);
												else
													nr_senha_p		:= null;
													nr_seq_senha_p	:= null;
												end if;
												
												COMMIT;
											exception
												when	others then --Colocado esta excessao para evitar casos onde o clicado sobre o botao proximo em mais de uma maquina simultaneamente!
														begin
														rollback;
														ie_chamou_senha_w 	:= 'N';
														nr_senha_p			:= null;
														nr_seq_senha_p		:= null;
														end;
											end;

											IF (ie_utiliza_oracle_alert_w = 'S') THEN
												CALL verificar_senha_nova_signal(nm_usuario_p);
											END IF;
										END IF;
									END IF;
								END LOOP Cursor9;
								CLOSE c09;

								IF (ie_chamou_senha_w = 'S') THEN
									UPDATE	chamada_inter_senha_item
									SET	qt_chamada = qt_chamada + 1
									WHERE	nr_sequencia = nr_seq_chamada_inter_item_w;
								END IF;

							END IF;
						END LOOP;
						CLOSE C10;
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;
ELSIF (ie_regra_chamada_w = 5) THEN /* Agenda liberadas para a fila (prioridade da fila) */
	ie_chamou_senha_w := 'N';

	OPEN c11;
	LOOP
	FETCH c11 INTO
		nr_seq_fila_espera_w,
		nr_prioridade_w;
	EXIT WHEN NOT FOUND; /* apply on c11 */

		nr_seq_fila_agenda_w := nr_seq_fila_espera_w;

		OPEN c12;
		LOOP
		FETCH c12 INTO
			nr_seq_senha_w;
		EXIT WHEN NOT FOUND; /* apply on c12 */

			IF (ie_chamou_senha_w = 'N') THEN

				SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
				INTO STRICT	cd_senha_chamada_w
				FROM	paciente_senha_fila
				WHERE	nr_sequencia = nr_seq_senha_w;

				IF (cd_senha_chamada_w > '0') THEN
					begin
						UPDATE	paciente_senha_fila
						SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
							dt_chamada		= clock_timestamp(),
							ds_maquina_chamada	= nm_maquina_atual_p,
							nm_usuario		= nm_usuario_p,
							nm_usuario_chamada	= nm_usuario_p,
							nr_seq_local_senha	= nr_seq_local_senha_w,
							qt_chamadas		= coalesce(qt_chamadas,0) + 1,
							ie_forma_chamada	= 'P'
						WHERE 	nr_sequencia		= nr_seq_senha_w
						AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
						
						if (SQL%ROWCOUNT > 0) then
							ie_chamou_senha_w	:= 'S';
							nr_senha_p			:= cd_senha_chamada_w;
							nr_seq_senha_p		:= nr_seq_senha_w;
              CALL bifrost_integracao_senhas(nr_seq_senha_p      =>nr_seq_senha_p);
						else
							nr_senha_p		:= null;
							nr_seq_senha_p	:= null;
						end if;
						
						COMMIT;
					exception
						when	others then --Colocado esta excessao para evitar casos onde eh clicado sobre o botao proximo em mais de uma maquina simultaneamente!
								begin
								rollback;
								ie_chamou_senha_w 	:= 'N';
								nr_senha_p			:= null;
								nr_seq_senha_p		:= null;
								end;
					end;

					IF (ie_utiliza_oracle_alert_w = 'S') THEN
						CALL verificar_senha_nova_signal(nm_usuario_p);
					END IF;
				END IF;
			END IF;
		END LOOP;
		CLOSE c12;
	END LOOP;
	CLOSE c11;

ELSIF (ie_regra_chamada_w = 6) THEN /* Fila selecionada*/
	nr_seq_fila_espera_w := nr_seq_fila_senha_p;

	IF (ie_chamou_senha_w = 'N') THEN
		BEGIN

		OPEN c02;
		LOOP
		FETCH c02 INTO
			nr_seq_senha_w;
		EXIT WHEN NOT FOUND; /* apply on c02 */
			BEGIN

			IF (ie_chamou_senha_w = 'N') THEN

				SELECT	coalesce(max(SUBSTR(obter_letra_verifacao_senha(coalesce(nr_seq_fila_senha_origem, nr_seq_fila_senha)) || cd_senha_gerada,1,30)),'0')
				INTO STRICT	cd_senha_chamada_w
				FROM	paciente_senha_fila
				WHERE	nr_sequencia	= nr_seq_senha_w;

				IF (cd_senha_chamada_w > '0') THEN
					begin
						UPDATE	paciente_senha_fila
						SET	dt_primeira_chamada	= coalesce(dt_primeira_chamada, clock_timestamp()),
							dt_chamada		= clock_timestamp(),
							ds_maquina_chamada	= nm_maquina_atual_p,
							nm_usuario		= nm_usuario_p,
							nm_usuario_chamada	= nm_usuario_p,
							nr_seq_local_senha	= nr_seq_local_senha_w,
							qt_chamadas		= coalesce(qt_chamadas,0) + 1,
							ie_forma_chamada	= 'P'
						WHERE 	nr_sequencia		= nr_seq_senha_w
						AND		coalesce(dt_chamada, clock_timestamp() - interval '1 days') < coalesce(dt_entrada_fila, clock_timestamp()); -- tratamento para chamada de duas maquinas ao mesmo tempo.
						
						if (SQL%ROWCOUNT > 0) then
							ie_chamou_senha_w	:= 'S';
							nr_senha_p			:= cd_senha_chamada_w;
							nr_seq_senha_p		:= nr_seq_senha_w;
              CALL bifrost_integracao_senhas(nr_seq_senha_p => nr_seq_senha_p);
						else
							nr_senha_p		:= null;
							nr_seq_senha_p	:= null;
						end if;
							
						COMMIT;
					exception
						when	others then --Colocado esta excessao para evitar casos onde o clicado sobre o botao proximo em mais de uma maquina simultaneamente!
								begin
								rollback;
								ie_chamou_senha_w 	:= 'N';
								nr_senha_p			:= null;
								nr_seq_senha_p		:= null;
								end;
					end;

					IF (ie_utiliza_oracle_alert_w = 'S') THEN
						CALL verificar_senha_nova_signal(nm_usuario_p);
					END IF;
				END IF;
			END IF;
			END;
		END LOOP;
		CLOSE c02;

		END;
	END IF;

END IF;

IF (ie_chamou_senha_w = 'S') THEN
	SELECT 	coalesce(MAX(qt_chamadas),0)
	INTO STRICT	qt_chamadas_atual_w
	FROM 	paciente_senha_fila
	WHERE 	nr_sequencia = nr_seq_senha_w;

	IF (qt_chamadas_atual_w > qt_max_chamadas_w) AND (qt_max_chamadas_w > 0) THEN

		UPDATE	paciente_senha_fila
		SET	dt_inutilizacao 	= clock_timestamp(),
			nm_usuario_inutilizacao = wheb_usuario_pck.get_nm_usuario,
			ds_maquina_inutilizacao = wheb_usuario_pck.get_nm_maquina,
			ie_forma_chamada	= 'P'
		WHERE	nr_sequencia  = nr_seq_senha_w;

		UPDATE	atendimento_paciente
		SET 	ie_chamado = 'X',
			dt_atualizacao = clock_timestamp(),
			nm_usuario = nm_usuario_p
		WHERE	nr_seq_pac_senha_fila = nr_seq_senha_p;
    CALL bifrost_integracao_senhas(nr_seq_senha_p => nr_seq_senha_w);
	END IF;
END IF;
COMMIT;

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE chamar_senha_paciente (nm_maquina_atual_p text, cd_estabelecimento_p bigint, nm_usuario_p text, nr_senha_p INOUT text, nr_seq_senha_p INOUT bigint, cd_agenda_p text DEFAULT '0', nr_seq_local_chamada_p bigint DEFAULT 0, ie_rechamada_ciclo_p text DEFAULT 'N', nr_seq_fila_senha_p bigint DEFAULT 0) FROM PUBLIC;

