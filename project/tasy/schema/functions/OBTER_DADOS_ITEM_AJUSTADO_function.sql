-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION obter_dados_item_ajustado ( nr_seq_propaci_p bigint, nr_seq_matpaci_p bigint, ie_opcao_p text) RETURNS varchar AS $body$
DECLARE


/*	Obtém os dados de um determinado item de acordo com os ajustes de quantidade da conta paciente (devoluções e estornos)

ie_opcao_p

Q	Quantidade
V	Valor

*/
ds_retorno_w		varchar(255);
qt_item_w		double precision;
qt_item_oposto_w	double precision;
qt_item_anterior_w	double precision;
vl_item_w		double precision;
vl_item_oposto_w	double precision;
vl_item_anterior_w	double precision;
cd_procedimento_w	bigint;
ie_origem_proced_w	bigint;
nr_interno_conta_w	bigint;
cd_material_w		integer;
qt_audit_w		double precision;
nr_seq_orig_audit_w	bigint;


BEGIN

if (nr_seq_propaci_p IS NOT NULL AND nr_seq_propaci_p::text <> '') then

	select	coalesce(max(a.qt_procedimento),0),
		coalesce(max(obter_saldo_conpaci_item(a.nr_sequencia,null)),0),
		max(a.cd_procedimento),
		max(a.ie_origem_proced),
		max(a.nr_interno_conta),
		coalesce(max(nr_seq_orig_audit),0)
	into STRICT	qt_item_w,
		vl_item_w,
		cd_procedimento_w,
		ie_origem_proced_w,
		nr_interno_conta_w,
		nr_seq_orig_audit_w
	from	procedimento_paciente a
	where	a.nr_sequencia	= nr_seq_propaci_p;

	select	count(1)
	into STRICT	qt_audit_w
	from	procedimento_paciente
	where	nr_interno_conta	= nr_interno_conta_w
	and	nr_seq_orig_audit	= nr_seq_propaci_p;

	/* se o item for positivo */

	if (qt_item_w	> 0) and (qt_audit_w	= 0) and (nr_seq_orig_audit_w = 0) then

		/* obter a quantidade de itens negativos iguais ao item filtrado */

		select	coalesce(sum(a.qt_procedimento),0),
			coalesce(sum(obter_saldo_conpaci_item(a.nr_sequencia,null)),0)
		into STRICT	qt_item_oposto_w,
			vl_item_oposto_w
		from	procedimento_paciente a
		where	a.qt_procedimento	< 0
		and	a.ie_origem_proced	= ie_origem_proced_w
		and	a.cd_procedimento	= cd_procedimento_w
		and	a.nr_interno_conta	= nr_interno_conta_w
		and	coalesce(nr_seq_orig_audit,0) = 0
		and	not exists (	SELECT	1
					from	procedimento_paciente x
					where	x.nr_seq_orig_audit 	= a.nr_sequencia
					and	x.ie_origem_proced	= a.ie_origem_proced
					and	x.cd_procedimento	= a.cd_procedimento
					and	x.nr_interno_conta	= a.nr_interno_conta);

		if (qt_item_oposto_w	< 0) then

			/* obter a quantidade de itens positivos anteriores que já abateram com os negativos */

			select	coalesce(sum(a.qt_procedimento),0),
				coalesce(sum(obter_saldo_conpaci_item(a.nr_sequencia,null)),0)
			into STRICT	qt_item_anterior_w,
				vl_item_anterior_w
			from	procedimento_paciente a
			where	a.nr_sequencia		< nr_seq_propaci_p
			and	a.qt_procedimento	> 0
			and	a.ie_origem_proced	= ie_origem_proced_w
			and	a.cd_procedimento	= cd_procedimento_w
			and	a.nr_interno_conta	= nr_interno_conta_w;

			qt_item_oposto_w	:= qt_item_oposto_w + qt_item_anterior_w;

			/* se houver itens negativos, faz a dedução, senão mantém a quantidade e valor originais */

			if (qt_item_oposto_w	< 0) then

				vl_item_oposto_w	:= vl_item_oposto_w + vl_item_anterior_w;
				qt_item_w		:= qt_item_w + qt_item_oposto_w;
				vl_item_w		:= vl_item_w + vl_item_oposto_w;

				/* se tiver mais itens negativos do que o positivo, retorna zero */

				if (qt_item_w	< 0) then

					qt_item_w	:= 0;
					vl_item_w	:= 0;

				end if;

			end if;

		end if;

	/* se o item for negativo */

	elsif (qt_item_w	< 0) and (qt_audit_w	= 0) and (nr_seq_orig_audit_w = 0) then

		/* obter a quantidade de itens positivos iguais ao item filtrado */

		select	coalesce(sum(a.qt_procedimento),0),
			coalesce(sum(obter_saldo_conpaci_item(a.nr_sequencia,null)),0)
		into STRICT	qt_item_oposto_w,
			vl_item_oposto_w
		from	procedimento_paciente a
		where	a.qt_procedimento	> 0
		and	a.ie_origem_proced	= ie_origem_proced_w
		and	a.cd_procedimento	= cd_procedimento_w
		and	a.nr_interno_conta	= nr_interno_conta_w;

		/* se houver itens positivos, faz a dedução, senão mantém a quantidade e valor originais */

		if (qt_item_oposto_w	> 0) then

			qt_item_w	:= qt_item_w + qt_item_oposto_w;
			vl_item_w	:= vl_item_w + vl_item_oposto_w;

			/* se tiver mais itens positivos do que o negativo, retorna zero */

			if (qt_item_w	> 0) then

				qt_item_w	:= 0;
				vl_item_w	:= 0;

			end if;

		end if;

	elsif (qt_audit_w > 0) or (nr_seq_orig_audit_w > 0) then

		select	coalesce(sum(a.qt_procedimento),0),
			coalesce(sum(obter_saldo_conpaci_item(a.nr_sequencia,null)),0)
		into STRICT	qt_item_oposto_w,
			vl_item_oposto_w
		from	procedimento_paciente a
		where	a.nr_interno_conta	= nr_interno_conta_w
		and	a.nr_seq_orig_audit	= nr_seq_propaci_p;

		if (nr_seq_orig_audit_w > 0) then
			begin
			select	coalesce(sum(a.qt_procedimento),0),
				coalesce(sum(obter_saldo_conpaci_item(a.nr_sequencia,null)),0)
			into STRICT	qt_item_oposto_w,
				vl_item_oposto_w
			from	procedimento_paciente a
			where	a.nr_interno_conta	= nr_interno_conta_w
			and	a.nr_sequencia		= nr_seq_orig_audit_w;
			end;
		end if;

		/* se houver itens negativos, faz a dedução, senão mantém a quantidade e valor originais */

		if (qt_item_oposto_w	<> 0) then

			qt_item_w		:= qt_item_w + qt_item_oposto_w;
			vl_item_w		:= vl_item_w + vl_item_oposto_w;

			/* se tiver mais itens negativos do que o positivo, retorna zero */

			if (qt_item_w	< 0) then

				qt_item_w	:= 0;
				vl_item_w	:= 0;

			end if;

		end if;

	end if;
elsif (nr_seq_matpaci_p IS NOT NULL AND nr_seq_matpaci_p::text <> '') then

	select	coalesce(max(a.qt_material),0),
		coalesce(max(obter_saldo_conpaci_item(null,a.nr_sequencia)),0),
		max(a.cd_material),
		max(a.nr_interno_conta)
	into STRICT	qt_item_w,
		vl_item_w,
		cd_material_w,
		nr_interno_conta_w
	from	material_atend_paciente a
	where	a.nr_sequencia	= nr_seq_matpaci_p;

	/* se o item for positivo */

	if (qt_item_w	> 0) then

		/* obter a quantidade de itens negativos iguais ao item filtrado */

		select	coalesce(sum(a.qt_material),0),
			coalesce(sum(obter_saldo_conpaci_item(null,a.nr_sequencia)),0)
		into STRICT	qt_item_oposto_w,
			vl_item_oposto_w
		from	material_atend_paciente a
		where	a.qt_material		< 0
		and	a.cd_material		= cd_material_w
		and	a.nr_interno_conta	= nr_interno_conta_w;

		if (qt_item_oposto_w	< 0) then

			/* obter a quantidade de itens positivos anteriores que já abateram com os negativos */

			select	coalesce(sum(a.qt_material),0),
				coalesce(sum(obter_saldo_conpaci_item(null,a.nr_sequencia)),0)
			into STRICT	qt_item_anterior_w,
				vl_item_anterior_w
			from	material_atend_paciente a
			where	a.nr_sequencia		< nr_seq_matpaci_p
			and	a.qt_material		> 0
			and	a.cd_material		= cd_material_w
			and	a.nr_interno_conta	= nr_interno_conta_w;

			qt_item_oposto_w	:= qt_item_oposto_w + qt_item_anterior_w;

			/* se houver itens negativos, faz a dedução, senão mantém a quantidade e valor originais */

			if (qt_item_oposto_w	< 0) then

				vl_item_oposto_w	:= vl_item_oposto_w + vl_item_anterior_w;
				qt_item_w		:= qt_item_w + qt_item_oposto_w;
				vl_item_w		:= vl_item_w + vl_item_oposto_w;

				/* se tiver mais itens negativos do que o positivo, retorna zero */

				if (qt_item_w	< 0) then

					qt_item_w	:= 0;
					vl_item_w	:= 0;

				end if;

			end if;

		end if;

	/* se o item for negativo */

	elsif (qt_item_w	< 0) then

		/* obter a quantidade de itens positivos iguais ao item filtrado */

		select	coalesce(sum(a.qt_material),0),
			coalesce(sum(obter_saldo_conpaci_item(null,a.nr_sequencia)),0)
		into STRICT	qt_item_oposto_w,
			vl_item_oposto_w
		from	material_atend_paciente a
		where	a.qt_material		> 0
		and	a.cd_material		= cd_material_w
		and	a.nr_interno_conta	= nr_interno_conta_w;

		/* se houver itens positivos, faz a dedução, senão mantém a quantidade e valor originais */

		if (qt_item_oposto_w	> 0) then

			qt_item_w	:= qt_item_w + qt_item_oposto_w;
			vl_item_w	:= vl_item_w + vl_item_oposto_w;

			/* se tiver mais itens positivos do que o negativo, retorna zero */

			if (qt_item_w	> 0) then

				qt_item_w	:= 0;
				vl_item_w	:= 0;

			end if;

		end if;

	end if;

end if;

if (ie_opcao_p	= 'Q') then

	ds_retorno_w	:= qt_item_w;

elsif (ie_opcao_p	= 'V') then

	ds_retorno_w	:= vl_item_w;

end if;

return	ds_retorno_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION obter_dados_item_ajustado ( nr_seq_propaci_p bigint, nr_seq_matpaci_p bigint, ie_opcao_p text) FROM PUBLIC;

