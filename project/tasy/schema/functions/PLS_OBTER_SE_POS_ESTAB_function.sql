-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_obter_se_pos_estab ( nr_seq_segurado_p bigint, cd_estabelecimento_p bigint, dt_procedimento_p timestamp) RETURNS varchar AS $body$
DECLARE

			
ds_retorno_w		varchar(1)	:= 'N';
dt_rescisao_w		timestamp;
dt_limite_util_w	timestamp;
ie_preco_plano_w	varchar(2);
nr_seq_plano_w		bigint;
cd_usuario_plano_w	varchar(30);
qt_devolucao_carteira_w	bigint;
dt_validade_carteira_w	pls_segurado_carteira.dt_validade_carteira%type;
nr_via_solicitacao_w	pls_segurado_carteira.nr_via_solicitacao%type;
dt_procedimento_w	pls_conta_proc.dt_procedimento%type;
ie_horario_rescisao_w	pls_parametros.ie_horario_rescisao%type;
ie_copart_prod_co_w pls_plano.ie_copart_prod_co%type;
ie_coparticipacao_w pls_plano.ie_coparticipacao%type;


BEGIN

cd_usuario_plano_w	:= pls_obter_carteira_segurado(nr_seq_segurado_p);

select	max(nr_seq_plano),
	max(dt_rescisao),
	max(dt_limite_utilizacao)
into STRICT	nr_seq_plano_w,
	dt_rescisao_w,
	dt_limite_util_w
from	pls_segurado
where	nr_sequencia	= nr_seq_segurado_p;

select	MAX(ie_preco)
into STRICT	ie_preco_plano_w
from	pls_plano
where	nr_sequencia	= nr_seq_plano_w;

select	ie_copart_prod_co, ie_coparticipacao
into STRICT	ie_copart_prod_co_w, ie_coparticipacao_w
from	pls_plano
where	nr_sequencia	= nr_seq_plano_w;

if (ie_preco_plano_w	= '1') and (dt_rescisao_w IS NOT NULL AND dt_rescisao_w::text <> '') then
	select	coalesce(max(ie_cobranca_pos),'N'),
		coalesce(max(ie_horario_rescisao), 'N')
	into STRICT	ds_retorno_w,
		ie_horario_rescisao_w
	from	pls_parametros
	where	cd_estabelecimento	= cd_estabelecimento_p;
	
	-- Buscar a validade e via da carteira do segurado.
	select	max(dt_validade_carteira),
		max(nr_via_solicitacao)
	into STRICT	dt_validade_carteira_w,
		nr_via_solicitacao_w
	from	pls_segurado_carteira
	where	nr_seq_segurado		= nr_seq_segurado_p;
	
	if (ds_retorno_w	= 'S') then
		ds_retorno_w	:= 'N';
		
		if (ie_horario_rescisao_w = 'N') then
			dt_procedimento_w := trunc(dt_procedimento_p);
			dt_rescisao_w := trunc(dt_rescisao_w);
		else
			dt_procedimento_w := dt_procedimento_p;
		end if;
		
		select	count(1)
		into STRICT	qt_devolucao_carteira_w
		from	pls_carteira_devolucao	a,
			pls_cart_lote_devolucao	b
		where	b.nr_sequencia			= a.nr_seq_lote
		and	a.cd_usuario_plano		= cd_usuario_plano_w
		and	a.nr_via 			= nr_via_solicitacao_w
		and	a.dt_validade_carteira 		= dt_validade_carteira_w
		and	trunc(b.dt_devolucao,'dd')	< dt_procedimento_w;
		
		if (qt_devolucao_carteira_w	= 0) and (dt_procedimento_w > dt_rescisao_w) then
			
			--Se existir um limite de utilizacao, esse deve ser comparado com a data do procedimento e apenas s for inferior, sinalizara para cobranca de pos, caso nao

			--existir a data entao tambem sinaliza como 'S' pois aqui a rescisao ja foi avaliada como inferior a data do procedimento.
			if (dt_limite_util_w IS NOT NULL AND dt_limite_util_w::text <> '') then
				
				--se a data do procedimento for posterior ao limite de utilizacao, devera sinalizar para cobranca de pos-estabelecido
				if (dt_procedimento_w > dt_limite_util_w) then
					ds_retorno_w	:= 'S';
				end if;
			else
				ds_retorno_w	:= 'S';
			end if;
		end if;
	end if;
elsif (ie_preco_plano_w in ('2','3') and (coalesce(ie_coparticipacao_w,'N') <> 'S' or coalesce(ie_copart_prod_co_w,'N') <> 'S')) then
	ds_retorno_w := 'S';
end if;

return	ds_retorno_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_obter_se_pos_estab ( nr_seq_segurado_p bigint, cd_estabelecimento_p bigint, dt_procedimento_p timestamp) FROM PUBLIC;

