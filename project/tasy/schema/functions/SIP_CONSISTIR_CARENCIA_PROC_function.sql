-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION sip_consistir_carencia_proc ( nr_seq_segurado_p bigint, cd_procedimento_p bigint, ie_origem_proced_p bigint, cd_grupo_p bigint, cd_especialidade_p bigint, cd_area_p bigint, qt_carencia_segurado_p bigint, qt_carencia_contrato_p bigint, dt_inclusao_operadora_p timestamp, nr_seq_contrato_p bigint, nr_seq_plano_p bigint) RETURNS timestamp AS $body$
DECLARE


ie_cpt_w			varchar(255);
ie_liberado_w			varchar(10);
ie_mes_posterior_w		varchar(1);
cd_area_w			bigint;
cd_especialidade_w		bigint;
cd_grupo_w			bigint;
nr_seq_plano_w			bigint;
nr_seq_contrato_w		bigint;
nr_seq_carencia_w		bigint;
ie_origem_proced_w		bigint;
ie_cursor_w			bigint;
nr_seq_tipo_carencia_w		bigint;
qt_dias_w			integer	:= 0;
dt_inclusao_operadora_w		timestamp;
dt_inicio_vigencia_w		timestamp;
dt_exposto_w			timestamp;

C01 CURSOR FOR
	SELECT	x.nr_sequencia,
		coalesce(x.ie_mes_posterior,'N') ie_mes_anterior
	from	pls_carencia	x
	where	x.nr_seq_segurado	= nr_seq_segurado_p;

C03 CURSOR FOR
	SELECT	x.nr_sequencia,
		coalesce(x.ie_mes_posterior,'N')
	from	pls_carencia	x
	where	x.nr_seq_contrato	= nr_seq_contrato_w;

C04 CURSOR FOR
	SELECT	x.nr_sequencia,
		coalesce(x.ie_mes_posterior,'N') ie_mes_posterior
	from	pls_carencia	x
	where	nr_seq_plano	= nr_seq_plano_w;

C02 CURSOR FOR
	SELECT	/* +CHOOSE */
		c.qt_dias,
		c.dt_inicio_vigencia
	from	pls_carencia_proc a,
		pls_carencia c
	where	c.nr_sequencia		= nr_seq_carencia_w
	and	c.nr_seq_tipo_carencia	= a.nr_seq_tipo_carencia
	and	c.ie_cpt		= 'N'
	and	a.ie_liberado		= 'S'
	and	coalesce(a.nr_seq_tipo_acomodacao::text, '') = ''
	and	coalesce(a.ie_tipo_guia::text, '') = ''
	and	((coalesce(a.cd_procedimento::text, '') = '')		or (a.cd_procedimento	= cd_procedimento_p))
	and	((coalesce(a.ie_origem_proced::text, '') = '')		or (a.ie_origem_proced	= ie_origem_proced_p))
	and	((coalesce(a.cd_grupo_proc::text, '') = '')		or (a.cd_grupo_proc	= cd_grupo_p))
	and	((coalesce(a.cd_especialidade::text, '') = '')		or (a.cd_especialidade	= cd_especialidade_p))
	and	((coalesce(a.cd_area_procedimento::text, '') = '')	or (a.cd_area_procedimento	= cd_area_p))
	order by a.cd_area_procedimento,
		a.cd_especialidade,
		a.cd_grupo_proc,
		a.cd_procedimento;

TYPE 		fetch_array1 IS TABLE OF C01%ROWTYPE;
s_array1	fetch_array1;
i1		integer := 1;
type Vetor1 is table of fetch_array1 index by integer;
Vetor_C01_w			Vetor1;

TYPE 		fetch_array4 IS TABLE OF C04%ROWTYPE;
s_array4 	fetch_array4;
i4		integer := 1;
type Vetor4 is table of fetch_array4 index by integer;
Vetor_C04_w			Vetor4;

TYPE 		fetch_array2 IS TABLE OF C02%ROWTYPE;
s_array2 	fetch_array2;
i2		integer := 1;
type Vetor2 is table of fetch_array2 index by integer;
Vetor_C02_w			Vetor2;
BEGIN
dt_inclusao_operadora_w	:= dt_inclusao_operadora_p;
nr_seq_contrato_w	:= nr_seq_contrato_p;
nr_seq_plano_w		:= nr_seq_plano_p;

if (qt_carencia_segurado_p	= 0) and (qt_carencia_contrato_p	= 0) then
	ie_cursor_w	:= 4;
elsif (qt_carencia_segurado_p	= 0) then
	ie_cursor_w	:= 3;
else
	ie_cursor_w	:= 1;
end if;

if (ie_cursor_w = 3) then
	open C03;
	loop
	fetch C03 into
		nr_seq_carencia_w,
		ie_mes_posterior_w;
	EXIT WHEN NOT FOUND; /* apply on C03 */
		begin
		if (ie_mes_posterior_w	= 'S') then
			dt_inclusao_operadora_w	:= PKG_DATE_UTILS.ADD_MONTH(PKG_DATE_UTILS.start_of(dt_inclusao_operadora_w,'month',0),1,0);
		end if;

		open C02;
		loop
		FETCH C02 BULK COLLECT INTO s_array2 LIMIT 1000;
			Vetor_C02_w(i2) := s_array2;
			i2 := i2 + 1;
		EXIT WHEN NOT FOUND; /* apply on C02 */
		END LOOP;
		CLOSE C02;

		for j in 1..Vetor_C02_w.COUNT loop
			s_array2 := Vetor_C02_w(j);
			for k in 1..s_array2.COUNT loop
				begin
				qt_dias_w		:= s_array2[k].qt_dias;
				dt_inicio_vigencia_w	:= s_array2[k].dt_inicio_vigencia;
				end;
			end loop;
		end loop;

		dt_exposto_w	:= (coalesce(dt_inicio_vigencia_w,dt_inclusao_operadora_w) + qt_dias_w);
		end;
	end loop;
	close C03;
elsif (ie_cursor_w	= 4) then
	open C04;
	loop
	FETCH C04 BULK COLLECT INTO s_array4 LIMIT 1000;
		Vetor_C04_w(i4) := s_array4;
		i4 := i4 + 1;
	EXIT WHEN NOT FOUND; /* apply on C04 */
	END LOOP;
	CLOSE C04;

	for i in 1..Vetor_C04_w.COUNT loop
		s_array4 := Vetor_C04_w(i);
		for z in 1..s_array4.COUNT loop
			begin
			nr_seq_carencia_w		:= s_array4[z].nr_sequencia;
			ie_mes_posterior_w		:= s_array4[z].ie_mes_posterior;

			if (ie_mes_posterior_w = 'S') then
				dt_inclusao_operadora_w	:= PKG_DATE_UTILS.ADD_MONTH(PKG_DATE_UTILS.start_of(dt_inclusao_operadora_w,'month',0),1,0);
			end if;

			open C02;
			loop
			FETCH C02 BULK COLLECT INTO s_array2 LIMIT 1000;
				Vetor_C02_w(i2) := s_array2;
				i2 := i2 + 1;
			EXIT WHEN NOT FOUND; /* apply on C02 */
			END LOOP;
			CLOSE C02;

			for j in 1..Vetor_C02_w.COUNT loop
				s_array2 := Vetor_C02_w(j);
				for k in 1..s_array2.COUNT loop
					begin
					qt_dias_w		:= s_array2[k].qt_dias;
					dt_inicio_vigencia_w	:= s_array2[k].dt_inicio_vigencia;
					end;
				end loop;
			end loop;

			dt_exposto_w	:= (coalesce(dt_inicio_vigencia_w,dt_inclusao_operadora_w) + qt_dias_w);
			end;
		end loop;
	end loop;
else
	open C01;
	loop
	FETCH C01 BULK COLLECT INTO s_array1 LIMIT 1000;
		Vetor_C01_w(i1) := s_array1;
		i1 := i1 + 1;
	EXIT WHEN NOT FOUND; /* apply on C01 */
	END LOOP;
	CLOSE C01;

	for i in 1..Vetor_C01_w.COUNT loop
		s_array1 := Vetor_C01_w(i);
		for z in 1..s_array1.COUNT loop
			begin
			nr_seq_carencia_w	:= s_array1[z].nr_sequencia;
			ie_mes_posterior_w	:= s_array1[z].ie_mes_anterior;

			if (ie_mes_posterior_w	= 'S') then
				dt_inclusao_operadora_w	:= PKG_DATE_UTILS.ADD_MONTH(PKG_DATE_UTILS.start_of(dt_inclusao_operadora_w,'month',0),1,0);
			end if;

			open C02;
			loop
			FETCH C02 BULK COLLECT INTO s_array2 LIMIT 1000;
				Vetor_C02_w(i2) := s_array2;
				i2 := i2 + 1;
			EXIT WHEN NOT FOUND; /* apply on C02 */
			END LOOP;
			CLOSE C02;

			for j in 1..Vetor_C02_w.COUNT loop
				s_array2 := Vetor_C02_w(j);
				for k in 1..s_array2.COUNT loop
					begin
					qt_dias_w		:= s_array2[k].qt_dias;
					dt_inicio_vigencia_w	:= s_array2[k].dt_inicio_vigencia;
					end;
				end loop;
			end loop;

			dt_exposto_w	:= (coalesce(dt_inicio_vigencia_w,dt_inclusao_operadora_w) + qt_dias_w);
			end;
		end loop;
	end loop;
end if;

return	dt_exposto_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION sip_consistir_carencia_proc ( nr_seq_segurado_p bigint, cd_procedimento_p bigint, ie_origem_proced_p bigint, cd_grupo_p bigint, cd_especialidade_p bigint, cd_area_p bigint, qt_carencia_segurado_p bigint, qt_carencia_contrato_p bigint, dt_inclusao_operadora_p timestamp, nr_seq_contrato_p bigint, nr_seq_plano_p bigint) FROM PUBLIC;

