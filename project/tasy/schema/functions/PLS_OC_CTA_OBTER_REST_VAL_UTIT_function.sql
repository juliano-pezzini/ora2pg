-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_oc_cta_obter_rest_val_utit (ie_opcao_p text, nr_cursor_p integer, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, dados_validacao_p pls_tipos_ocor_pck.dados_regra_val_util_item, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_conta_proc_p pls_tipos_ocor_pck.dados_conta_proc, dados_conta_mat_p pls_tipos_ocor_pck.dados_conta_mat, ie_proc_mat_p text) RETURNS PLS_TIPOS_OCOR_PCK.DADOS_RESTRICAO_SELECT AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Obter a restrição a ser aplicada na validação 23 - Utilização de itens. Esta function
	retorna um PL\SQL Record com a restrição de material e procedimento em separado para
	que possa ser aplicado no select dinâmico de forma correta.
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[  X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------
Pontos de atenção:

Para executar as verificações favor tentar respeitar a ordem de execução. Tratamentos que forem
colocados para dados da conta devem ser executados antes de tratamentos que serão executados
para os itens das contas, pois desta forma estamos controlando a verificação de forma mais acertiva
controlando o acesso as tabelas de itens, pois estas contém muito mais registros que a tabela da conta
e assim evitamos que estas sejam acessadas desnecessáriamente, tornando a pesquisa nas views
pls_procedimento_contas_ocor_v e pls_material_contas_ocor_v mais performática, acertiva e menos custosa.

Alterações:
-------------------------------------------------------------------------------------------------------------------
jjung OS 615456 - Criação da function.
-------------------------------------------------------------------------------------------------------------------
jjung OS 644933 - 18/09/2013 -

Alteração:	Alterado os alias das restrições dos selects.

Motivo:	Após o tratamento dos participantes ter sido removido das views
	PLS_PROCEDIMENTO_CONTAS_OCOR_V e
	PLS_MATERIAL_CONTAS_OCOR_V, estas views se tornaram desnecessárias
	e foram removidas da validação.
-------------------------------------------------------------------------------------------------------------------
jjung OS 659951 - 22/10/2013 -

Alteração:	Alterado o alias das restrições do select para sempre usar o OUTRO_PROC

Motivo:	Após a inclusão da view PLS_CONTA_V na view PLS_CONTA_PROC_V, se torna desnecessário
	fazer a ligação entre estas duas views para obter algum campo da tabela.
-------------------------------------------------------------------------------------------------------------------
jjung OS 29/01/2014 -

Alteração:	Corrigidos os alias da regra de tipo pessoa quando selecionado prestador executor.

Motivo:	Em testes internos foi identificado que os mesmos estavam trocados PROC e MAT.
-------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
retorno_w	pls_tipos_ocor_pck.dados_restricao_select;



BEGIN

-- Aqui verifica aonde será e o quão longe serão busacados os itens a serem comparados com o item que está sendo consistido
-- Esta informação será informada pelo usuário no campo IE_TIPO_QTDE. Esta informação pode conter informações de período
-- ou do atendimento. Será buscado as contas que se encaixem na regra informada comparando com o item a ser consistido no momento
-- para somar as quantidades liberadas e verificar o número de incidências encontradas. Para isto foi criado as views pls_procedimento_contas_ocor_v
-- e pls_material_contas_ocor_v que trazem as informações necessárias para buscar os itens conforme a regra montada. Qualquer campo novo informado na regra
-- deve ser colocado nas views para que seja possível filtrar apenas os itens desejados.
------------------------------------------------------------------------  IE_TIPO_QTDE ------------------------------------------------------------------------
-- Quando for para verificar atendimentos na mesma guia deve ser buscado as contas pertencentes ou que referenciam aquela guia e buscar
-- os itens que foram lançados para ela e se encaixam na regra informada.
-- Guia
if (dados_validacao_p.ie_tipo_qtde = 'G') then

	if (ie_opcao_p = 'RESTRICAO') then

		-- Quando for durante a importação deve ser olhado a informação que está sendo informada no campo IMP, caso contrário
		-- olha os campos quentes.
		if (dados_regra_p.ie_evento = 'IMP') then

			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.cd_guia_referencia = :cd_guia_proc_imp ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.cd_guia_referencia = :cd_guia_mat_imp ';
		else
			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.cd_guia_referencia = :cd_guia_referencia_proc ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.cd_guia_referencia = :cd_guia_referencia_mat ';
		end if;
	else
		-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
		if (dados_regra_p.ie_evento = 'IMP') then


			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_guia_proc_imp', dados_conta_proc_p.cd_guia_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_guia_mat_imp', dados_conta_mat_p.cd_guia_imp);
			end if;
		else

			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_guia_referencia_proc', dados_conta_proc_p.cd_guia_referencia);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_guia_referencia_mat', dados_conta_mat_p.cd_guia_referencia);
			end if;
		end if;
	end if;

-- Aqui busca apenas os itens da mesma conta.
-- Conta
elsif (dados_validacao_p.ie_tipo_qtde = 'C') then

	if (ie_opcao_p = 'RESTRICAO') then
		retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.nr_seq_conta = :nr_seq_proc_conta ';

		retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.nr_seq_conta = :nr_seq_mat_conta ';
	else
		-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
		if (ie_proc_mat_p = 'P') then

			dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_proc_conta', dados_conta_proc_p.nr_seq_conta);

		elsif (ie_proc_mat_p = 'M') then

			dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_mat_conta', dados_conta_mat_p.nr_seq_conta);
		end if;
	end if;

-- Aqui verifica os itens lançados em um período de X Anos conforme definido pelo usuário no campo QT_TIPO_QUANTIDADE, deve se ter informação neste campo
-- para que o filtro seja aplicado. Para verificar períodos de datas em anos está sendo usado BETWEEN e a function add_months(date, (qt_months * 12)), no add_moths é informado
-- a data do item sendo consistido e a quantidade de meses multiplicado por 12 para que seja convertida em anos.
-- Anos
elsif (dados_validacao_p.ie_tipo_qtde = 'A') then

	if (ie_opcao_p = 'RESTRICAO') then

		-- Se for para contar atendimentos posteriores ao que está sendo consistido no momento então deve considerar atendimentos que foram lançados
		-- após o procedimento dentro do período informado na regra no campo QT_TIPO_QUANTIDADE. Se não considerar lançamentos posteriores
		-- então busca os procedimentos executados até a data do procedimento.
		if (dados_validacao_p.ie_qt_lib_posterior = 'S') then

			-- Quando for a consistência no processo de importação verifica a data apresentada pelo prestador.
			if (dados_regra_p.ie_evento = 'IMP') then

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento_imp, - (:qt_periodo * 12))) and (add_months(:dt_procedimento_imp, (:qt_periodo * 12))) ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento_imp, - (:qt_periodo * 12))) and (add_months(:dt_atendimento_imp, (:qt_periodo * 12))) ';
			else

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento, - (:qt_periodo * 12))) and (add_months(:dt_procedimento, (:qt_periodo * 12))) ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento, - (:qt_periodo * 12))) and (add_months(:dt_atendimento, (:qt_periodo * 12))) ';
			end if;
		else

			if (dados_regra_p.ie_evento = 'IMP') then

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento_imp, - (:qt_periodo * 12))) and :dt_procedimento_imp ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento_imp, - (:qt_periodo * 12))) and :dt_atendimento_imp ';
			else

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento, - (:qt_periodo * 12))) and :dt_procedimento ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento, - (:qt_periodo * 12))) and :dt_atendimento ';
			end if;
		end if;
	else
		dbms_sql.bind_variable(nr_cursor_p, ':qt_periodo', dados_validacao_p.qt_tipo_quantidade);

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_procedimento_imp', dados_conta_proc_p.dt_procedimento_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_atendimento_imp', dados_conta_mat_p.dt_atendimento_imp);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_procedimento', dados_conta_proc_p.dt_procedimento);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_atendimento', dados_conta_mat_p.dt_atendimento);
			end if;
		end if;
	end if;

-- Aqui verifica o período em meses na qual a ocorrência busca os itens lançados. Quando for informado esta opção está sendo usado o BETWEEN e a funciton nativa add_months(date, qt_months)
-- usando a data do item sendo consistido e a quantidade informada pelo usuário no campo QT_TIPO_QUANTIDADE.
-- Meses
elsif (dados_validacao_p.ie_tipo_qtde = 'M') then

	if (ie_opcao_p = 'RESTRICAO') then

		-- Se for para contar atendimentos posteriores ao que está sendo consistido no momento então deve considerar atendimentos que foram lançados
		-- após o procedimento dentro do período informado na regra no campo QT_TIPO_QUANTIDADE. Se não considerar lançamentos posteriores
		-- então busca os procedimentos executados até a data do procedimento.
		if (dados_validacao_p.ie_qt_lib_posterior = 'S') then

			if (dados_regra_p.ie_evento = 'IMP') then

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento_imp, - (:qt_periodo))) and (add_months(:dt_procedimento_imp, (:qt_periodo))) ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento_imp, - (:qt_periodo))) and (add_months(:dt_atendimento_imp, (:qt_periodo))) ';
			else

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento, - (:qt_periodo))) and (add_months(:dt_procedimento, (:qt_periodo))) ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento, - (:qt_periodo))) and (add_months(:dt_atendimento, (:qt_periodo))) ';
			end if;
		else

			if (dados_regra_p.ie_evento = 'IMP') then

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento_imp, - (:qt_periodo))) and :dt_procedimento_imp ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento_imp, - (:qt_periodo))) and :dt_atendimento_imp ';
			else

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (add_months(:dt_procedimento, - (:qt_periodo))) and :dt_procedimento ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (add_months(:dt_atendimento, - (:qt_periodo))) and :dt_atendimento ';
			end if;
		end if;
	else
		dbms_sql.bind_variable(nr_cursor_p, ':qt_periodo', dados_validacao_p.qt_tipo_quantidade);

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_procedimento_imp', dados_conta_proc_p.dt_procedimento_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_atendimento_imp', dados_conta_mat_p.dt_atendimento_imp);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_procedimento', dados_conta_proc_p.dt_procedimento);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_atendimento', dados_conta_mat_p.dt_atendimento);
			end if;
		end if;
	end if;

-- Aqui é verificado o período que será buscado os itens por dia. Está sendo verificado a data do item diminuindo ou adicionando a quantidade de dias informados no campo
-- QT_TIPO_QUANTIDADE.
-- Dias
elsif (dados_validacao_p.ie_tipo_qtde = 'D') then

	if (ie_opcao_p = 'RESTRICAO') then

		-- Se for para contar atendimentos posteriores ao que está sendo consistido no momento então deve considerar atendimentos que foram lançados
		-- após o item dentro do período informado na regra no campo QT_TIPO_QUANTIDADE. Se não considerar lançamentos posteriores
		-- então busca os itens executados até a data do item.
		if (dados_validacao_p.ie_qt_lib_posterior = 'S') then

			if (dados_regra_p.ie_evento = 'IMP') then

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (:dt_procedimento_imp - (:qt_periodo)) and (:dt_procedimento_imp + (:qt_periodo)) ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (:dt_atendimento_imp - (:qt_periodo)) and (:dt_atendimento_imp + (:qt_periodo)) ';
			else

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (:dt_procedimento - (:qt_periodo)) and (:dt_procedimento + (:qt_periodo)) ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (:dt_atendimento - (:qt_periodo)) and (:dt_atendimento + (:qt_periodo)) ';
			end if;
		else

			if (dados_regra_p.ie_evento = 'IMP') then

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (:dt_procedimento_imp - (:qt_periodo)) and :dt_procedimento_imp ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (:dt_atendimento_imp - (:qt_periodo)) and :dt_atendimento_imp ';
			else

				retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.dt_procedimento between (:dt_procedimento - (:qt_periodo)) and :dt_procedimento ';

				retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.dt_atendimento between (:dt_atendimento - (:qt_periodo)) and :dt_atendimento ';
			end if;
		end if;
	else
		dbms_sql.bind_variable(nr_cursor_p, ':qt_periodo', dados_validacao_p.qt_tipo_quantidade);

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_procedimento_imp', dados_conta_proc_p.dt_procedimento_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_atendimento_imp', dados_conta_mat_p.dt_atendimento_imp);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_procedimento', dados_conta_proc_p.dt_procedimento);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':dt_atendimento', dados_conta_mat_p.dt_atendimento);
			end if;
		end if;
	end if;
end if;

------------------------------------------------------------------------  IE_TIPO_PESSOA_QTDE  ------------------------------------------------------------------------
-- Aqui verifica o tipo de pessoa que deve ser verificado para buscar os itens antigos apenas que contém informações desta(s) pessoas.
-- Quando for par verificar Todos os tipos de pessoa possíveis na regra então só deve ser verificado os itens que tenham as mesmas informações de tais pessoas que o item que
-- está sendo consistido. Por ex: Se for para verificar Beneficiário  e Mesmo prestador executor então só podem ser contados os itens que forem de contas do mesmo beneficiário
-- executadas pelo mesmo prestador.
-- Ambos.
if (dados_validacao_p.ie_tipo_pessoa_qtde = 'A') then

	if (ie_opcao_p = 'RESTRICAO') then

		if (dados_regra_p.ie_evento = 'IMP') then

			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.nr_seq_prestador_exec = :nr_seq_prestador_exec_imp ' || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.nr_seq_segurado = :nr_seq_segurado ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.nr_seq_prestador_exec = :nr_seq_prestador_exec_imp ' || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.nr_seq_segurado = :nr_seq_segurado ';
		else
			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.nr_seq_segurado = :nr_seq_segurado ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.nr_seq_prestador_exec = :nr_seq_prestador_exec ' || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.nr_seq_segurado = :nr_seq_segurado ';
		end if;
	else

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec_imp', dados_conta_proc_p.nr_seq_prestador_exec_imp);
				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_segurado', dados_conta_proc_p.nr_seq_segurado);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec_imp', dados_conta_mat_p.nr_seq_prestador_exec_imp);
				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_segurado', dados_conta_mat_p.nr_seq_segurado);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec', dados_conta_proc_p.nr_seq_prestador_exec);
				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_segurado', dados_conta_proc_p.nr_seq_segurado);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec', dados_conta_mat_p.nr_seq_prestador_exec);
				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_segurado', dados_conta_mat_p.nr_seq_segurado);
			end if;
		end if;
	end if;

-- Quando for selecionado para verificar apenas itens do mesmo beneficiário então só olha os itens que foram lançados para o beneficiário da conta do item que está sendo consistido.
-- Beneficiário
elsif (dados_validacao_p.ie_tipo_pessoa_qtde = 'B') then

	if (ie_opcao_p = 'RESTRICAO') then

		retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	outro_proc.nr_seq_segurado = :nr_seq_segurado ';

		retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.nr_seq_segurado = :nr_seq_segurado ';
	else

		-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
		if (ie_proc_mat_p = 'P') then

			dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_segurado', dados_conta_proc_p.nr_seq_segurado);

		elsif (ie_proc_mat_p = 'M') then

			dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_segurado', dados_conta_mat_p.nr_seq_segurado);
		end if;
	end if;

-- Quando for selecionado para verificar apenas itens executado pelo mesmo prestador então devem ser olhados os itens executados pelo prestador executor da conta dos itens
-- que estão sendo consistidos.
-- Prestador executor
elsif (dados_validacao_p.ie_tipo_pessoa_qtde = 'P') then

	if (ie_opcao_p = 'RESTRICAO') then

		if (dados_regra_p.ie_evento = 'IMP') then

			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.nr_seq_prestador_exec = :nr_seq_prestador_exec_imp ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.nr_seq_prestador_exec = :nr_seq_prestador_exec_imp ';
		else
			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.nr_seq_prestador_exec = :nr_seq_prestador_exec ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.nr_seq_prestador_exec = :nr_seq_prestador_exec ';
		end if;
	else

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec_imp', dados_conta_proc_p.nr_seq_prestador_exec_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec_imp', dados_conta_mat_p.nr_seq_prestador_exec_imp);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec', dados_conta_proc_p.nr_seq_prestador_exec);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_prestador_exec', dados_conta_mat_p.nr_seq_prestador_exec);
			end if;
		end if;
	end if;
end if;

------------------------------------------------------------------------  IE_REGRA_QTDE ------------------------------------------------------------------------
-- Aqui verifica a regra de verificação que será usada, informada no campo IE_REGRA_QTDE
-- Se for selecionado para filtrar apenas itens que foram executados pelo mesmo médico executor da conta então deve ser restringido para considerar apenas os itens de contas que foram
-- executadas pelo mesmo médico da conta que está sendo consistido no momentado.
-- Mesmo profissional executor
if (dados_validacao_p.ie_regra_qtde = 'M') then

	if (ie_opcao_p = 'RESTRICAO') then

		-- se for durante a informação verifica o médico que foi informado pelo prestador no XML, se não verifica o médico do campo "quente".
		if (dados_regra_p.ie_evento = 'IMP') then

			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.cd_medico_executor = :cd_medico_executor_imp ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.cd_medico_executor = :cd_medico_executor_imp ';
		else
			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.cd_medico_executor = :cd_medico_executor ';

			retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
						'and	outro_mat.cd_medico_executor = :cd_medico_executor ';
		end if;
	else

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_medico_executor_imp', dados_conta_proc_p.cd_medico_executor_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_medico_executor_imp', dados_conta_mat_p.cd_medico_executor_imp);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_medico_executor', dados_conta_proc_p.cd_medico_executor);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':cd_medico_executor', dados_conta_mat_p.cd_medico_executor);
			end if;
		end if;
	end if;
end if;

------------------------------------------------------------------------  IE_SOMAR_ESTRUTURA ------------------------------------------------------------------------
-- Aqui verifica se é para somar os itens da estrura informada ou apenas verificar o item que está sendo consistido.
-- para verificar os itens da estrutura então deve ter a estrutura informada. caso contrário verifica apenas o item consistido.
-- Para verificar se o item está na estrutura está sendo usada a Table Function pls_grupos_pck.obter_itens_estrut_ocor a qual traz os itens
-- que estão válidos para a estrutura, dessa forma é possível verificar apenas pelo cd_procedimento ou nr_seq_material para ver se o item faz parte da estrutura.
if (dados_validacao_p.ie_somar_estrutura = 'S') then

	if (ie_opcao_p = 'RESTRICAO') then

		-- gerencia a atualização da tabela TM
		CALL pls_gerencia_upd_obj_pck.atualizar_objetos('tasy', 'PLS_OC_CTA_OBTER_REST_VAL_UTIT', 'PLS_ESTRUTURA_OCOR_TM');

		retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
					'and	exists	(	select	1 ' || pls_tipos_ocor_pck.enter_w ||
					'			from	pls_estrutura_ocor_tm est '|| pls_tipos_ocor_pck.enter_w ||
					'			where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
					'			and	est.ie_origem_proced = outro_proc.ie_origem_proced'|| pls_tipos_ocor_pck.enter_w ||
					'			and	est.cd_procedimento = outro_proc.cd_procedimento'|| pls_tipos_ocor_pck.enter_w ||
					'		) ';

		retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	exists	(	select	1 ' || pls_tipos_ocor_pck.enter_w ||
					'			from	pls_estrutura_ocor_tm est '|| pls_tipos_ocor_pck.enter_w ||
					'			where	est.nr_seq_estrutura = :nr_seq_estrutura '|| pls_tipos_ocor_pck.enter_w ||
					'			and	est.nr_seq_material = outro_mat.nr_seq_material '|| pls_tipos_ocor_pck.enter_w ||
					'		) ';
	else
		dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_estrutura', dados_validacao_p.nr_seq_estrutura);
	end if;
else
	if (ie_opcao_p = 'RESTRICAO') then

		if (dados_regra_p.ie_evento = 'IMP') then

			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.ie_origem_proced = :ie_origem_proced ' || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.cd_procedimento = :cd_procedimento_imp ';
		else
			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.ie_origem_proced = :ie_origem_proced ' || pls_tipos_ocor_pck.enter_w ||
						'and	outro_proc.cd_procedimento = :cd_procedimento ';
		end if;

		retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
					'and	outro_mat.nr_seq_material = :nr_seq_material ';
	else

		if (dados_regra_p.ie_evento = 'IMP') then

			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':ie_origem_proced', dados_conta_proc_p.ie_origem_proced);
				dbms_sql.bind_variable(nr_cursor_p, ':cd_procedimento_imp', dados_conta_proc_p.cd_procedimento_imp);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_material', dados_conta_mat_p.nr_seq_material);
			end if;
		else
			-- Aqui atualiza os dados da sa binds para esta restricao, deve ser levado em consideração de onde o valor deve ser buscado, respeitando o valor do parâmetro IE_PROC_MAT_P.
			if (ie_proc_mat_p = 'P') then

				dbms_sql.bind_variable(nr_cursor_p, ':ie_origem_proced', dados_conta_proc_p.ie_origem_proced);
				dbms_sql.bind_variable(nr_cursor_p, ':cd_procedimento', dados_conta_proc_p.cd_procedimento);

			elsif (ie_proc_mat_p = 'M') then

				dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_material', dados_conta_mat_p.nr_seq_material);
			end if;
		end if;
	end if;
end if;

------------------------------------------------------------------------  NR_SEQ_GRAU_PARTIC ------------------------------------------------------------------------
if (dados_validacao_p.nr_seq_grau_partic IS NOT NULL AND dados_validacao_p.nr_seq_grau_partic::text <> '') then

	if (ie_proc_mat_p = 'P') then

		if (ie_opcao_p = 'RESTRICAO') then

			-- Quando for informado o grau de participação deve ser verificado se o procedimeno tem algum participante com aquele grau de participação, se tiver então é válido, caso contrário
			-- não será válido e não deve ser contabilizado.
			retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
							'and	exists	( 	select	1 ' || pls_tipos_ocor_pck.enter_w ||
							'			from	pls_proc_participante x ' || pls_tipos_ocor_pck.enter_w ||
							'			where	x.nr_seq_conta_proc = outro_proc.nr_sequencia ' || pls_tipos_ocor_pck.enter_w ||
							'			and	x.nr_seq_grau_partic = :nr_seq_grau_partic ' || pls_tipos_ocor_pck.enter_w ||
							'	) ';
		else

			dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_grau_partic', dados_validacao_p.nr_seq_grau_partic);
		end if;
	end if;
end if;

-- Esta restrição é obrigatória e a mesma deve ser sempre a última verificação, por favor só colocar restrições abaixo desta se for identificado que realmente é o melhor caminho a ser tomado.
if (ie_proc_mat_p = 'P') then

	if (ie_opcao_p = 'RESTRICAO') then

		retorno_w.ds_restricao_proc :=	retorno_w.ds_restricao_proc || pls_tipos_ocor_pck.enter_w ||
							'and	not exists (	select	1 ' || pls_tipos_ocor_pck.enter_w ||
							'			from	pls_oc_cta_val_utit_aux x, ' || pls_tipos_ocor_pck.enter_w ||
							'				pls_oc_cta_selecao_ocor_v y ' || pls_tipos_ocor_pck.enter_w ||
							'			where	y.nr_sequencia = x.nr_seq_selecao ' || pls_tipos_ocor_pck.enter_w ||
							'			and	y.nr_seq_conta = outro_proc.nr_seq_conta ' || pls_tipos_ocor_pck.enter_w ||
							'			and	y.nr_seq_conta_proc = outro_proc.nr_sequencia ' || pls_tipos_ocor_pck.enter_w ||
							'		) ';
	end if;

elsif (ie_proc_mat_p = 'M') then

	if (ie_opcao_p = 'RESTRICAO') then

		retorno_w.ds_restricao_mat :=	retorno_w.ds_restricao_mat || pls_tipos_ocor_pck.enter_w ||
							'and	not exists (	select	1 ' || pls_tipos_ocor_pck.enter_w ||
							'			from	pls_oc_cta_val_utit_aux x, ' || pls_tipos_ocor_pck.enter_w ||
							'				pls_oc_cta_selecao_ocor_v y ' || pls_tipos_ocor_pck.enter_w ||
							'			where	y.nr_sequencia = x.nr_seq_selecao ' || pls_tipos_ocor_pck.enter_w ||
							'			and	y.nr_seq_conta = outro_mat.nr_seq_conta ' || pls_tipos_ocor_pck.enter_w ||
							'			and	y.nr_seq_conta_mat = outro_mat.nr_sequencia ' || pls_tipos_ocor_pck.enter_w ||
							'		) ';
	end if;
end if;

return	retorno_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_oc_cta_obter_rest_val_utit (ie_opcao_p text, nr_cursor_p integer, nr_id_transacao_p pls_oc_cta_selecao_ocor_v.nr_id_transacao%type, dados_validacao_p pls_tipos_ocor_pck.dados_regra_val_util_item, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_conta_proc_p pls_tipos_ocor_pck.dados_conta_proc, dados_conta_mat_p pls_tipos_ocor_pck.dados_conta_mat, ie_proc_mat_p text) FROM PUBLIC;

