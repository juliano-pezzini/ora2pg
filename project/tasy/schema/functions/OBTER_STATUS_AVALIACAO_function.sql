-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION obter_status_avaliacao (nr_seq_registro_p bigint, valor_inicial_p double precision, dt_registro_p timestamp) RETURNS varchar AS $body$
DECLARE




ds_retorno_w	varchar(2);
valor_alteracao_w  double precision;
valor_nadir_w  	   double precision;
valor_soma_w       double precision;
Soma_Menor_w       double precision;
Quatid_atual_w     bigint;
Quatid_anterior_w  bigint;

C01 CURSOR FOR
	SELECT coalesce((dividir(((SUM(CASE WHEN QT_DIAMETRO_X > QT_DIAMETRO_Y THEN QT_DIAMETRO_X ELSE QT_DIAMETRO_Y END)) * 100) ,
	    ((SELECT MIN(SUM(CASE WHEN A.QT_DIAMETRO_X > A.QT_DIAMETRO_Y THEN A.QT_DIAMETRO_X ELSE A.QT_DIAMETRO_Y END))
				FROM RECIST_REG_LOCALIZACAO A,
				RECIST_LOCALIZACAO B
				WHERE  B.NR_SEQUENCIA = A.NR_SEQ_LOCALIZACAO
				AND B.NR_SEQ_REGISTRO = nr_seq_registro_p
				AND B.IE_MENSURAR = 'S'
				AND A.DT_REGISTRO < REC.DT_REGISTRO
				GROUP BY A.DT_REGISTRO)))) -100,0) Nadir,
				(dividir(((SUM(CASE WHEN QT_DIAMETRO_X > QT_DIAMETRO_Y THEN QT_DIAMETRO_X ELSE QT_DIAMETRO_Y END)) * 100) ,valor_inicial_p)) -100 Alteracao,
				(SUM(CASE WHEN QT_DIAMETRO_X > QT_DIAMETRO_Y THEN QT_DIAMETRO_X ELSE QT_DIAMETRO_Y END)) SOMA,
				(SELECT MIN(SUM(CASE WHEN A.QT_DIAMETRO_X > A.QT_DIAMETRO_Y THEN A.QT_DIAMETRO_X ELSE A.QT_DIAMETRO_Y END))
				FROM RECIST_REG_LOCALIZACAO A,
				RECIST_LOCALIZACAO B
				WHERE  B.NR_SEQUENCIA = A.NR_SEQ_LOCALIZACAO
				AND B.NR_SEQ_REGISTRO = nr_seq_registro_p
				AND B.IE_MENSURAR = 'S'
				AND A.DT_REGISTRO < REC.DT_REGISTRO
				GROUP BY A.DT_REGISTRO) Soma_Menor,
				coalesce((SELECT COUNT(*) QUANTIDADE_TUMOR
				FROM RECIST_REG_LOCALIZACAO A,
				RECIST_LOCALIZACAO B
				WHERE  B.NR_SEQUENCIA = A.NR_SEQ_LOCALIZACAO
				AND B.NR_SEQ_REGISTRO = nr_seq_registro_p
				AND DT_REGISTRO = REC.DT_REGISTRO
				GROUP BY A.DT_REGISTRO),0) Quantidade_atual,
				coalesce((SELECT COUNT(*)
				FROM RECIST_REG_LOCALIZACAO A,
				RECIST_LOCALIZACAO B
				WHERE  B.NR_SEQUENCIA = A.NR_SEQ_LOCALIZACAO
				AND B.NR_SEQ_REGISTRO = nr_seq_registro_p
				AND B.IE_MENSURAR = 'S'
				AND DT_REGISTRO = (SELECT MAX(A.DT_REGISTRO)
				FROM   RECIST_REG_LOCALIZACAO A
				WHERE  A.NR_SEQ_REGISTRO = B.NR_SEQ_REGISTRO
				AND  A.DT_REGISTRO < REC.DT_REGISTRO)
				GROUP BY A.DT_REGISTRO),0) Quantidade_Anterior
	FROM RECIST_REG_LOCALIZACAO REC,
		RECIST_LOCALIZACAO RL
		WHERE  RL.NR_SEQUENCIA = REC.NR_SEQ_LOCALIZACAO
		AND RL.NR_SEQ_REGISTRO = nr_seq_registro_p
		AND REC.DT_REGISTRO = dt_registro_p
		AND RL.IE_MENSURAR = 'S'
		GROUP BY DT_REGISTRO
		ORDER BY DT_REGISTRO;


BEGIN

ds_retorno_w := 'PD';
open C01;
loop
fetch C01 into
	valor_nadir_w,
	valor_alteracao_w,
	valor_soma_w,
	Soma_Menor_w,
	Quatid_atual_w,
	Quatid_anterior_w;
EXIT WHEN NOT FOUND; /* apply on C01 */
	begin
		if (valor_nadir_w >= -30) and (valor_nadir_w <= 19.99) then	 /* DE- Doença estável*/
			ds_retorno_w := 'DE';
		end if;
		if (valor_alteracao_w <= -30) then	  /* RP- Redução da soma das lesões tumorais em 30% baseado no 1 recist  */
			ds_retorno_w := 'RP';
		end if;
		if (valor_nadir_w >= 20) and ((valor_soma_w - Soma_Menor_w) > 5) or (Quatid_anterior_w < Quatid_atual_w) then	 /* PD- Aumento de 20 % em relação ao menor recist-  Aparecimento de nova lesão*/
			ds_retorno_w := 'PD';
		end if;
		if (valor_soma_w = 0) then	 /* RC- Lesão com diâmetro  0*/
			ds_retorno_w := 'RC';
		end if;

	end;
end loop;
close C01;

return	ds_retorno_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION obter_status_avaliacao (nr_seq_registro_p bigint, valor_inicial_p double precision, dt_registro_p timestamp) FROM PUBLIC;

