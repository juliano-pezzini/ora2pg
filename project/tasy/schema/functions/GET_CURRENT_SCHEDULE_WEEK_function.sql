-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION get_current_schedule_week ( nr_seq_schedule_p bigint, -- Schedule
 dt_current_day_p timestamp) RETURNS bigint AS $body$
 -- Day for which I want to know the week
DECLARE


qt_diff_weeks_w		bigint;
nr_seq_current_week_w	bigint;
nr_seq_first_week_w	bigint;
nr_seq_last_week_w	bigint;
ie_current_weekday_w	bigint;
dt_current_date_w	timestamp;
dt_first_day_w		timestamp;
nr_seq_active_cycle_w	schedule_cycle.nr_sequencia%type;
dt_validity_start_w	schedule_cycle.dt_validity_start%type;
nr_seq_cycle_week_w	schedule_cycle_week.nr_sequencia%type;
nr_week_w		bigint := 0;
qt_weeks_w		bigint := 0;

C01 CURSOR FOR
	SELECT 	nr_sequencia,
		row_number() OVER () AS nr_week
	FROM (
		SELECT	nr_sequencia,
			row_number() OVER () AS nr_week
		from	schedule_cycle_week
		where	nr_seq_schedule_cycle = nr_seq_active_cycle_w
		order by nr_presentation_order
	) alias0;

BEGIN

-- checking for active schedule cycles
begin
	select	a.nr_sequencia,
		a.dt_validity_start
	into STRICT	nr_seq_active_cycle_w,
		dt_validity_start_w
	from	schedule_cycle a
	where	dt_current_day_p between a.dt_validity_start and pkg_date_utils.end_of(coalesce(a.dt_validity_end, dt_current_day_p), 'DAY')
	and	nr_seq_agenda = nr_seq_schedule_p;
exception
	when	others then
		nr_seq_active_cycle_w := 0;
end;

select	count(*)
into STRICT	qt_weeks_w
from	schedule_cycle_week
where	nr_seq_schedule_cycle = nr_seq_active_cycle_w;		

if (dt_current_day_p IS NOT NULL AND dt_current_day_p::text <> '') and (nr_seq_active_cycle_w > 0) and (qt_weeks_w > 0) then
	
	qt_diff_weeks_w := trunc(trunc(dt_current_day_p - dt_validity_start_w) / 7);
	
	nr_seq_current_week_w := 1;
	
	/* Looping through all the days from the first to the one received by parameter */

	for i in 1..qt_diff_weeks_w loop
		/* Is it the last week of the cycle? */

		if (nr_seq_current_week_w = qt_weeks_w and qt_diff_weeks_w > 1) then
			/* If yes, go back to the first week */

			nr_seq_current_week_w := 1;
		else
			/* If not, go to the next week */

			nr_seq_current_week_w := nr_seq_current_week_w + 1;
		end if;
	end loop;
	
	open C01;
	loop
	fetch C01 into	
		nr_seq_cycle_week_w,
		nr_week_w;
	EXIT WHEN NOT FOUND; /* apply on C01 */
		if (nr_week_w = nr_seq_current_week_w) then
			exit;
		end if;
	end loop;
	close C01;
	
	return nr_seq_cycle_week_w;
else
	return null;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION get_current_schedule_week ( nr_seq_schedule_p bigint, dt_current_day_p timestamp) FROM PUBLIC;

