-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION man_obter_sobrepos_planej ( nr_seq_planej_prev_p bigint, nr_seq_equipamento_p bigint) RETURNS varchar AS $body$
DECLARE


dt_emissao_prev_w				timestamp;
dt_ordem_servico_w				timestamp;
dt_prevista_w					timestamp;
dt_ultima_ordem_w				timestamp;
ie_sobreposicao_w				varchar(1);
nr_seq_ordem_w				bigint;
nr_seq_superior_w				bigint;
qt_dia_freq_w					smallint;
qt_dia_ordem_w				smallint;
qt_dia_sobreposicao_w			integer;
ie_converter_mes_w				varchar(1);

BEGIN

ie_sobreposicao_w			:= 'N';

if (nr_seq_planej_prev_p IS NOT NULL AND nr_seq_planej_prev_p::text <> '') then
	/* Verifica se o planej possui um planejamento superior*/

	select	coalesce(max(nr_seq_superior),0),
		coalesce(max(qt_dia_sobreposicao),0)
	into STRICT	nr_seq_superior_w,
		qt_dia_sobreposicao_w
	from	man_planej_prev
	where	nr_sequencia = nr_seq_planej_prev_p;

	if (nr_seq_superior_w > 0) then
		begin
		/* Ultima ordem de serviço gerada do planej superior*/

		select	coalesce(max(nr_sequencia),0)
		into STRICT	nr_seq_ordem_w
		from	man_ordem_servico
		where	nr_seq_equipamento	= nr_seq_equipamento_p
		and	nr_seq_planej		= nr_seq_superior_w
		and	ie_tipo_ordem		= 2;

		/* se não existir ordem, não existe sobreposição*/

		if (nr_seq_ordem_w = 0) then
			ie_sobreposicao_w	:= 'N';
		else
			/* Se tiver OS, verificar se existirá sobreposição*/

			/* Data da ordem e encerramento da ultima OS gerada*/

			select	trunc(dt_ordem_servico),
				coalesce(dt_fim_real,clock_timestamp() + interval '1000 days')
			into STRICT	dt_ordem_servico_w,
				dt_ultima_ordem_w
			from	man_ordem_servico
			where	nr_sequencia = nr_seq_ordem_w;

			/* Se a data da ordem gerada estiver dentro do período - existe Sobreposição */

			if	(dt_ordem_servico_w > (clock_timestamp() - qt_dia_sobreposicao_w)) then
				ie_sobreposicao_w	:= 'S';
			else
				/* Verificar se pode existir uma sobreposição futura dentro do período da regra*/

				select	coalesce(max(a.qt_dia_gerar_ordem),0),
					coalesce(max(c.qt_dia),0),
					coalesce(max(c.ie_converter_mes), 'N')
				into STRICT	qt_dia_ordem_w,
					qt_dia_freq_w,
					ie_converter_mes_w
				from	man_localizacao d,
					man_freq_planej c,
					man_planej_prev a,
					man_equipamento b
				where	a.nr_seq_tipo_equip	= b.nr_seq_tipo_equip
				and	a.nr_seq_frequencia	= c.nr_sequencia
				and	b.nr_seq_local		= d.nr_sequencia
				and	a.nr_sequencia		= nr_seq_superior_w
				and	b.nr_sequencia		= nr_seq_equipamento_p
				and	coalesce(a.dt_inicial,clock_timestamp())	<= (clock_timestamp() + qt_dia_sobreposicao_w)
				and 	coalesce(a.cd_setor_atendimento, d.cd_setor)	= d.cd_setor
				and	b.cd_estab_contabil	= coalesce(a.cd_estabelecimento, b.cd_estab_contabil)
				and	coalesce(a.ie_situacao,'A')	= 'A'
				and	coalesce(b.ie_situacao,'A')	= 'A'
				and	coalesce(a.ie_contador,'N')	= 'N'
				and	((coalesce(a.ie_impacto,'T') = 'T') or (coalesce(b.cd_impacto, a.ie_impacto) = a.ie_impacto))
				and (b.nr_sequencia 	= coalesce(a.nr_seq_equip, b.nr_sequencia));
				/* Calculando data prevista da geração da ordem futura*/

				dt_prevista_w		:= obter_data_prev_futura(dt_ultima_ordem_w, qt_dia_freq_w, ie_converter_mes_w);
				dt_emissao_prev_w	:= dt_prevista_w - qt_dia_ordem_w;

				/* Se a data de emissao da ordem estiver dentro do periodo futuro entao existe sobreposição*/

				if (dt_emissao_prev_w >= clock_timestamp()) and
					(dt_emissao_prev_w <= (clock_timestamp() + qt_dia_sobreposicao_w)) then
					ie_sobreposicao_w	:= 'S';
				end if;
			end if;
		end if;
		end;
	end if;
end if;

return coalesce(ie_sobreposicao_w,'N');

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION man_obter_sobrepos_planej ( nr_seq_planej_prev_p bigint, nr_seq_equipamento_p bigint) FROM PUBLIC;

