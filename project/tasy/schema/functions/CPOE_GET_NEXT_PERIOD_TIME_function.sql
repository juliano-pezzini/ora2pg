-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION cpoe_get_next_period_time ( cd_intervalo_p intervalo_prescricao.cd_intervalo%type, nr_seq_period_p intervalo_prescr_period.nr_seq_period%type, dt_reference_p timestamp, cd_pessoa_fisica_p pessoa_fisica.cd_pessoa_fisica%type, nr_atendimento_p atendimento_paciente.nr_atendimento%type, cd_estabelcimento_p estabelecimento.cd_estabelecimento%type, cd_perfil_p perfil.cd_perfil%type, ie_via_aplicacao_p via_aplicacao.ie_via_aplicacao%type, nm_usuario_p usuario.nm_usuario%type) RETURNS timestamp AS $body$
DECLARE


dt_reference_w 					timestamp	:= clock_timestamp();

C01 CURSOR(    ds_horario_p 	 intervalo_prescricao.ds_horarios%type,
                ds_date_mask_shortdate_p  text,
                dt_date_reference_p  timestamp ) is
	with 	ds_horario_table as (WITH RECURSIVE cte AS (

	SELECT 	regexp_substr(ds_horario_p,'[^ ]+', 1, level) as horario
	(regexp_substr(ds_horario_p, '[^ ]+', 1, level) IS NOT NULL AND (regexp_substr(ds_horario_p, '[^ ]+', 1, level))::text <> '')  UNION ALL

	SELECT 	regexp_substr(ds_horario_p,'[^ ]+', 1, level) as horario 
	(regexp_substr(ds_horario_p, '[^ ]+', 1, level) IS NOT NULL AND (regexp_substr(ds_horario_p, '[^ ]+', 1, level))::text <> '') JOIN cte c ON ()

) SELECT * FROM cte;
)
	SELECT 	to_char(dt_reference_w, ds_date_mask_shortdate_p) || ' ' ||
                rpad(coalesce(substr(horario,0, 2), '00'), 2, 0) || ':' ||
		rpad(coalesce(substr(horario,4, 6), '00'), 2, 0) || ':' ||
		rpad(coalesce(substr(horario,8, 10), '00'), 2, 0) as formated_date_hour,
                to_char(dt_reference_w + interval '1' day, ds_date_mask_shortdate_p) || ' ' ||
                rpad(coalesce(substr(horario,0, 2), '00'), 2, 0) || ':' ||
		rpad(coalesce(substr(horario,4, 6), '00'), 2, 0) || ':' ||
		rpad(coalesce(substr(horario,8, 10), '00'), 2, 0) as formated_next_day                
	from 	ds_horario_table;
/*
ja_JP	short	        dd/mm/yyyy hh24:mi
ja_JP	shortDate	dd/mm/yyyy
ja_JP	shortTime	hh24:mi
ja_JP	timestamp	yyyy/mm/dd hh24:mi:ss
*/
ds_lang_tag_w                   user_locale.ds_locale%type;
ds_date_mask_shortdate_w        locale_formats.ds_localized_mask%type;
ds_date_mask_shorttime_w        locale_formats.ds_localized_mask%type;
ds_date_mask_withhours_w	locale_formats.ds_localized_mask%type;

ds_horarios_w		        intervalo_prescricao.ds_horarios%type;

dt_hr_start_time_w	        prescr_interval_period.hr_start_time%type;
dt_hr_end_time_w	        prescr_interval_period.hr_end_time%type;

dt_return_w                     timestamp	:= null;
qt_fisrt_hour_w                 bigint;
ds_hour_return_w                varchar(10);
BEGIN
        -- Get lang tag and all formats date from locale
        ds_lang_tag_w := pkg_date_formaters.getUserLanguageTag(cd_estabelcimento_p=> wheb_usuario_pck.get_cd_estabelecimento,
							     nm_usuario_p       => wheb_usuario_pck.get_nm_usuario);
	ds_date_mask_shortdate_w:= pkg_date_formaters.localize_mask(ds_mask => 'shortDate',
					 			    lang_tag=> ds_lang_tag_w);
	ds_date_mask_shorttime_w:= pkg_date_formaters.localize_mask(ds_mask => 'shortTime',
					 			    lang_tag=> ds_lang_tag_w);
        ds_date_mask_withhours_w:= pkg_date_formaters.localize_mask(ds_mask => 'short',
                                                                    lang_tag=> ds_lang_tag_w);
                                                                                                                                        
        -- Get ds_horarios config from table.																											
	begin
		select 	ds_horarios 
		into STRICT	ds_horarios_w
		from 	intervalo_prescricao
		where 	cd_intervalo = cd_intervalo_p;
	exception
		when others then
		begin
                ds_horarios_w := null;
		end;
	end;

        if (nr_seq_period_p IS NOT NULL AND nr_seq_period_p::text <> '') then
                -- Get interval from period
                begin
                        select 	to_date( to_char(dt_reference_w, ds_date_mask_shortdate_w) || ' ' ||to_char(hr_start_time, ds_date_mask_shorttime_w),
                                        ds_date_mask_shortdate_w || ' ' || ds_date_mask_shorttime_w),
                                case
                                when hr_start_time > hr_end_time then
                                        to_date( to_char(dt_reference_w + interval '1' day, ds_date_mask_shortdate_w) || ' ' || to_char(hr_end_time,  ds_date_mask_shorttime_w),
                                                ds_date_mask_shortdate_w || ' ' || ds_date_mask_shorttime_w )
                                else
                                        to_date( to_char(dt_reference_w, ds_date_mask_shortdate_w) || ' ' || to_char(hr_end_time,  ds_date_mask_shorttime_w),
                                                ds_date_mask_shortdate_w || ' ' || ds_date_mask_shorttime_w )
                                end                             
                        into STRICT	dt_hr_start_time_w,
                                dt_hr_end_time_w
                        from 	prescr_interval_period
                        where 	nr_sequencia = nr_seq_period_p;
                exception
                        when others then
                        begin
                        dt_hr_start_time_w 	:= null;
                        dt_hr_end_time_w 	:= null;
                        end;
                end;	

                if ((dt_hr_start_time_w IS NOT NULL AND dt_hr_start_time_w::text <> '') and
                        (dt_hr_end_time_w IS NOT NULL AND dt_hr_end_time_w::text <> '') 	and
                        (ds_horarios_w IS NOT NULL AND ds_horarios_w::text <> '') ) then   
                        
                        begin

                        <<get_first_hour>>
                        for C01row in C01( ds_horario_p => ds_horarios_w, ds_date_mask_shortdate_p => ds_date_mask_shortdate_w, dt_date_reference_p => dt_reference_w  )
                        loop
                                select  count(1) 
                                into STRICT    qt_fisrt_hour_w 
                                
                                where   to_date(C01row.formated_date_hour, ds_date_mask_shortdate_w || ' HH24:mi:ss') >= dt_reference_w
                                and     to_date(C01row.formated_date_hour, ds_date_mask_shortdate_w || ' HH24:mi:ss') between dt_hr_start_time_w and dt_hr_end_time_w;

                                if (qt_fisrt_hour_w > 0) then
                                        dt_return_w := to_date(C01row.formated_date_hour, ds_date_mask_shortdate_w || ' HH24:mi:ss');
                                end if;
                                exit get_first_hour when qt_fisrt_hour_w > 0;
                        end loop get_first_hour;	

                        if ( coalesce(dt_return_w::text, '') = '' ) then
                                <<get_next_day_first>>
                                for C01row in C01( ds_horario_p => ds_horarios_w, ds_date_mask_shortdate_p => ds_date_mask_shortdate_w, dt_date_reference_p => dt_reference_w  )
                                loop
                                        select  count(1)
                                        into STRICT    qt_fisrt_hour_w 
                                        
                                        where   to_date(C01row.formated_date_hour, ds_date_mask_shortdate_w || ' HH24:mi:ss') between dt_hr_start_time_w and dt_hr_end_time_w;

                                        if (qt_fisrt_hour_w > 0) then
                                                dt_return_w := to_date(C01row.formated_next_day, ds_date_mask_shortdate_w || ' HH24:mi:ss');
                                        end if;
                                        exit get_next_day_first when qt_fisrt_hour_w > 0;
                                end loop get_next_day_first;
                        end if;
                        exception
                                when others then
                                begin
                                        dt_return_w := null;
                                end;
                        end;

                end if;
        else
                ds_hour_return_w	:= CPOE_Obter_primeiro_horario(  nr_atendimento_p       => nr_atendimento_p,
                                                                         cd_intervalo_p         => cd_intervalo_p,
                                                                         cd_material_p          => null,
                                                                         cd_estabelecimento_p   => cd_estabelcimento_p,
                                                                         cd_perfil_p            => cd_perfil_p,
                                                                         nm_usuario_p           => nm_usuario_p,
                                                                         cd_pessoa_fisica_p     => cd_pessoa_fisica_p,
                                                                         ie_via_aplicacao_p     => ie_via_aplicacao_p,
                                                                         ie_hor_agora_p         => 'N',
                                                                         si_fulltime_p          => 'N' );

                if (ds_hour_return_w IS NOT NULL AND ds_hour_return_w::text <> '') then
                        dt_return_w := to_date( to_char(dt_reference_w, ds_date_mask_shortdate_w) || ' ' || ds_hour_return_w,
                                                                        ds_date_mask_shortdate_w  || ' ' || ds_date_mask_shorttime_w);
                        if (dt_return_w < dt_reference_w) then
                                dt_return_w	:= dt_return_w + 1;
                        end if;
        	/*else	dt_return_w	:= sysdate;*/

                end if;
        end if;

        return dt_return_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION cpoe_get_next_period_time ( cd_intervalo_p intervalo_prescricao.cd_intervalo%type, nr_seq_period_p intervalo_prescr_period.nr_seq_period%type, dt_reference_p timestamp, cd_pessoa_fisica_p pessoa_fisica.cd_pessoa_fisica%type, nr_atendimento_p atendimento_paciente.nr_atendimento%type, cd_estabelcimento_p estabelecimento.cd_estabelecimento%type, cd_perfil_p perfil.cd_perfil%type, ie_via_aplicacao_p via_aplicacao.ie_via_aplicacao%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;

