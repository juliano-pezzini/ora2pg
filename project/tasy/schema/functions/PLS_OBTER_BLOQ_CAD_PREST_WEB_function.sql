-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_obter_bloq_cad_prest_web ( nr_seq_usuario_web_p pls_usuario_web.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) RETURNS varchar AS $body$
DECLARE

/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Verificar se para o perfil do usuário web, existe alguma regra de atualização de cadastro
	do prestador, e se o usuário se enquadra em uma delas..

	Ao se enquadrar, será comparado se a data de referencia ultrapassa o prazo em dias, em comparação
	com a data atual. Se ultrapassar, será retornado 'S' - Sim, senão 'N' - Não
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[  ]  Objetos do dicionário [  ] Tasy (Delphi/Java) [ X] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Pontos de atenção:	Essa rotina deve ser utilzada no login do portal, portanto um cuidado especial
		com relação a performance deve ser tomado.

		Primeiro é verificado se existe alguma regra cadastrada para o estabelecimento,
		onde a busca utiliza um campo indexado, otimizando a busca. Caso não encontre nenhum,
		o restante da função não é executada. Isto otimiza para os clientes que não queriam
		utilizar essa regra.

		Se for encontrado alguma regra, é então verificado nelas se existe algum prazo válido.
		Se não possuir, a function não chega a fazer a busca na parte mais pesada da rotina, verificar
		as alterações no prestador.

		A busca no prestador é mais pesada, devido a foma de ligação da tasy_solic_alt_campo
		com o prestador, atualmente é necessário alguns "OR", e comparação de texto.... o que é pesado.
		Caso a situação não seja sustentável, será necessário realizar alguma alteração
		na forma de relacionar a alteração da documentação com o prestador, para ganhar performance.

		A alteração deste relacionamento não foi feito na criação desta função, pois fugia muito
		do escopo da OS, caso necessário, será aberto uma os de performance, pois a forma como
		está hoje, já é bem antiga,  e a tabela deve ser utilizada na aplicação principal.. por isso será
		necessario muito cuidado ao alterar ela.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/ds_retorno_w		varchar(1) := 'N';
qt_regras_w		integer;
nr_dias_prazo_w		pls_regra_atual_cad_prest.nr_prazo%type := null;
ie_data_referencia_w	pls_regra_atual_cad_prest.ie_data_referencia%type := null;
dt_ultima_atz_w		tasy_solic_alteracao.dt_analise%type;

-- Curso levando as regras elegiveis, já ordenado
c01 CURSOR(	nr_seq_usuario_web_pc	pls_usuario_web.nr_sequencia%type,
		cd_estabelecimento_pc	estabelecimento.cd_estabelecimento%type) FOR
	SELECT	a.nr_prazo,
		a.ie_data_referencia
	from	pls_regra_atual_cad_prest	a,
		pls_perfil_web			b,
		pls_usuario_web			c
	where	b.nr_sequencia			= a.nr_seq_perfil_web
	and	c.nr_seq_perfil_web		= b.nr_sequencia
	-- apenas regras para perfil
	and	coalesce(a.nr_seq_prestador::text, '') = ''
	and	c.nr_sequencia			= nr_seq_usuario_web_pc
	and	a.cd_estabelecimento		= cd_estabelecimento_pc
	-- Apenas se for para notificar no portal
	and	a.ie_solic_atual_cad		= 'S'
	-- vigencia
	and	trunc(clock_timestamp(), 'DD') between a.dt_inicio_vigencia and fim_dia(a.dt_fim_vigencia)
	
union all

	SELECT	a.nr_prazo,
		a.ie_data_referencia
	from	pls_regra_atual_cad_prest	a,
		pls_prestador_usuario_web	b
	where	b.nr_seq_prestador		= a.nr_seq_prestador
	and	b.nr_seq_usuario		= nr_seq_usuario_web_pc
	-- apenas regras para prestador
	and	coalesce(a.nr_seq_perfil_web::text, '') = ''
	and	a.cd_estabelecimento		= cd_estabelecimento_pc
	-- vigencia
	and	trunc(clock_timestamp(), 'DD') between a.dt_inicio_vigencia and fim_dia(a.dt_fim_vigencia)
	-- Apenas se for para notificar no portal
	and	a.ie_solic_atual_cad		= 'S'
	
union all

	select	a.nr_prazo,
		a.ie_data_referencia
	from	pls_regra_atual_cad_prest	a
	
	where	coalesce(a.nr_seq_perfil_web::text, '') = ''
	and	coalesce(a.nr_seq_prestador::text, '') = ''
	and	a.cd_estabelecimento		= cd_estabelecimento_pc
	-- vigencia
	and	trunc(clock_timestamp(), 'DD') between a.dt_inicio_vigencia and fim_dia(a.dt_fim_vigencia)
	-- Apenas se for para notificar no portal
	and	a.ie_solic_atual_cad		= 'S'
	order by nr_prazo desc;


BEGIN

-- Primeiro, verifica se existe qualquer regra, por questões de performance
select	count(1)
into STRICT	qt_regras_w
from	pls_regra_atual_cad_prest
where	cd_estabelecimento	= cd_estabelecimento_p;

-- se existir, prossegue com a regra
if (qt_regras_w > 0) then

	-- Abre as regras, e deixa apenas a com prazo mais restrito
	for r_c01_w in c01(nr_seq_usuario_web_p, cd_estabelecimento_p) loop

		nr_dias_prazo_w 	:= r_c01_w.nr_prazo;
		ie_data_referencia_w	:= r_c01_w.ie_data_referencia;

	end loop; -- fim cursor regras
	-- Se possuir um prazo e tipo de data definido, é buscado a ultima atualização de documentação
	-- O tipo de Data tem um tratamento especial na busca, quando for:
	--	SI	- Solicitação / Inclusão
	-- Será considerado primeiro a data de Solicitação(SI), se não existir será então avaliado a data de Inclusão (DI)
	--	DA	- Analise
	--	DS	- Solicitação
	-- Será considerado que deve existir uma solicitação de atualização de cadastro
	-- Quando for
	--	DI	- Inclusão
	-- Será considerado a data de inclusão dos prestadores, e não pode existir solicitações de atualização de cadastro.
	if (nr_dias_prazo_w IS NOT NULL AND nr_dias_prazo_w::text <> '') then

		dt_ultima_atz_w := null;
		-- Foi fracionado em IF, para respeitar a ordenação solicitada pelo cliente
		-- Primeiro verifica se é data de solicitação, analise ou solicitação / inclusão
		if (ie_data_referencia_w in ('DA', 'DS', 'SI')) then

			select	max(t.dt_referencia)
			into STRICT	dt_ultima_atz_w
			from (	SELECT	CASE WHEN ie_data_referencia_w='DA' THEN  d.dt_analise WHEN ie_data_referencia_w='DS' THEN  d.dt_atualizacao_nrec WHEN ie_data_referencia_w='SI' THEN  d.dt_atualizacao_nrec WHEN ie_data_referencia_w='DI' THEN  clock_timestamp() END  dt_referencia
				from	pls_prestador_usuario_web	a,
					pls_prestador			b,
					tasy_solic_alt_campo		c,
					tasy_solic_alteracao		d
				where	b.nr_sequencia		= a.nr_seq_prestador
				-- Forma de FK já existente na tabela, para ligar a solicitação de alteração no prestador, é necessário manter desta forma... qualquer duvida, consultar o comentário no cabeçalho da function
				and	((c.ds_chave_simples	= b.cd_pessoa_fisica)
					or (substr(c.ds_chave_composta,1,length(c.ds_chave_composta)-1)= 'CD_PESSOA_FISICA='||b.cd_pessoa_fisica||'#@#@IE_TIPO_COMPLEMENTO=')
					or (c.ds_chave_composta='CD_PESSOA_FISICA='||b.cd_pessoa_fisica))

				and	d.nr_sequencia			= c.nr_seq_solicitacao
				and     d.ie_tipo_solicitacao		= 'P'
				and	a.nr_seq_usuario		= nr_seq_usuario_web_p
				and	a.ie_situacao			= 'A'
				and	coalesce(b.dt_exclusao, clock_timestamp())	>= clock_timestamp()
				
union all

				SELECT	CASE WHEN ie_data_referencia_w='DA' THEN  d.dt_analise WHEN ie_data_referencia_w='DS' THEN  d.dt_atualizacao_nrec WHEN ie_data_referencia_w='SI' THEN  d.dt_atualizacao_nrec WHEN ie_data_referencia_w='DI' THEN  clock_timestamp() END  dt_referencia
				from	pls_prestador_usuario_web	a,
					pls_prestador			b,
					tasy_solic_alt_campo		c,
					tasy_solic_alteracao		d
				where	b.nr_sequencia		= a.nr_seq_prestador
				-- Forma de FK já existente na tabela, para ligar a solicitação de alteração no prestador, é necessário manter desta forma... qualquer duvida, consultar o comentário no cabeçalho da function
				and	((c.ds_chave_simples	= b.cd_cgc)
					or (substr(c.ds_chave_composta,1,length(c.ds_chave_composta)-1)= 'CD_CGC='||b.cd_cgc||'#@#@IE_TIPO_COMPLEMENTO=')
					or (c.ds_chave_composta='CD_CGC='||b.cd_cgc))

				and	d.nr_sequencia			= c.nr_seq_solicitacao
				and     d.ie_tipo_solicitacao		= 'P'
				and	a.nr_seq_usuario		= nr_seq_usuario_web_p
				and	a.ie_situacao			= 'A'
				and	coalesce(b.dt_exclusao, clock_timestamp())	>= clock_timestamp()) t;

		end if;

		-- Agora verifica se a regra é pela data de inclusão, ou é solicitação/ inclusão e não achou nenhuma data de solicitacao
		if	((ie_data_referencia_w = 'DI') or (ie_data_referencia_w = 'SI' and coalesce(dt_ultima_atz_w::text, '') = '')) then

			select	max(t.dt_referencia)
			into STRICT	dt_ultima_atz_w
			from (	-- Quando deve verificar a data de inclusão do prestador
				SELECT	CASE WHEN ie_data_referencia_w='DA' THEN  clock_timestamp() WHEN ie_data_referencia_w='DS' THEN  clock_timestamp() WHEN ie_data_referencia_w='SI' THEN  b.dt_cadastro WHEN ie_data_referencia_w='DI' THEN  b.dt_cadastro END  dt_referencia
				from	pls_prestador_usuario_web	a,
					pls_prestador			b
				where	b.nr_sequencia		= a.nr_seq_prestador
				-- Faz a restrição para o prestador elegivel não possuir nenhuma solicitação de atualização de dados
				and	not exists (	SELECT	1
							from	tasy_solic_alt_campo		c,
								tasy_solic_alteracao		d
							where	d.nr_sequencia		= c.nr_seq_solicitacao
							and     d.ie_tipo_solicitacao	= 'P'
							and	((c.ds_chave_simples	= b.cd_pessoa_fisica)
								or (substr(c.ds_chave_composta,1,length(c.ds_chave_composta)-1)= 'CD_PESSOA_FISICA='||b.cd_pessoa_fisica||'#@#@IE_TIPO_COMPLEMENTO=')
								or (c.ds_chave_composta='CD_PESSOA_FISICA='||b.cd_pessoa_fisica)))

				and	not exists (	select	1
							from	tasy_solic_alt_campo		c,
								tasy_solic_alteracao		d
							where	d.nr_sequencia		= c.nr_seq_solicitacao
							and     d.ie_tipo_solicitacao	= 'P'
							and	((c.ds_chave_simples	= b.cd_cgc)
								or (substr(c.ds_chave_composta,1,length(c.ds_chave_composta)-1)= 'CD_CGC='||b.cd_cgc||'#@#@IE_TIPO_COMPLEMENTO=')
								or (c.ds_chave_composta='CD_CGC='||b.cd_cgc)))
				and	a.nr_seq_usuario		= nr_seq_usuario_web_p
				and	a.ie_situacao			= 'A'
				and	coalesce(b.dt_exclusao, clock_timestamp())	>= clock_timestamp()) t;
		end if;

		-- se a data de referencia, somada com o prazo em dias, for inferior a data atual, então o retorno deve ser 'S'
		if	((trunc(dt_ultima_atz_w, 'DD') + coalesce(nr_dias_prazo_w,0)) < trunc(clock_timestamp(), 'DD')) then

			ds_retorno_w := 'S';
		else

			ds_retorno_w := 'N';
		end if;

	end if; -- Fim se encontrou algum prazo valido
end if; -- Fim existe alguma regra
return ds_retorno_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_obter_bloq_cad_prest_web ( nr_seq_usuario_web_p pls_usuario_web.nr_sequencia%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;

