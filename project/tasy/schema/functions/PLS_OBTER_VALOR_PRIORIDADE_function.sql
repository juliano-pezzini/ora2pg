-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_obter_valor_prioridade ( nr_sequencia_p bigint, ds_tabela_p text) RETURNS bigint AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: 	Obter o valor de prioridade do registro cadastro em regras.

	A lógica é verificar o valor de prioridade dos campos da regra para retirar o order by
	dos cursores de regra. Quando o campo possuir informação a soma do registro receberá
	um acrescimo de 100. Caso o campo não possuir informação a soma do registro recebrá 0.
	Logo, o registro que possuir mais campo informados terá maior prioridade. Esta function
	deve ser chamada no Delphi, no evento AfterPost do dbpanel da tabela que deseja ser
	verificada realizar alguma alteração no registro a function irá recalcular o valor da prioridade.
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[  X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Pontos de atenção:
Parâmetros :
	- nr_sequencia_p: A sequencia do registro que deseja verificar o valor
	- ds_tabela_p: O nome da tabela que deseja verificar o valor
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
ds_restricao_w		varchar(255);
ds_campo_temp_w		varchar(500);
ds_campo_w		varchar(32000);
ds_sql_w		varchar(32000);
ie_situacao_w		integer;
qt_pontos_w		integer;

c01 CURSOR(	ds_tabela_pc	text) FOR
	SELECT	nm_atributo,
		ie_componente
	from	tabela_atributo
	where 	nm_tabela = upper(ds_tabela_pc)
	and   	ie_tipo_atributo not in ('FUNCTION','VISUAL')
	and   	nm_atributo not in ('NR_SEQUENCIA', 'DT_ATUALIZACAO', 'NM_USUARIO',
				    'DT_ATUALIZACAO_NREC', 'NM_USUARIO_NREC', 'IE_SITUACAO',
				    'NR_ORDEM_EXECUCAO', 'IE_ORDENACAO_SUGERIDA');

BEGIN
if (ds_tabela_p IS NOT NULL AND ds_tabela_p::text <> '') then

	ds_restricao_w := '';
	-- Abre o cursor dos campos da tabela
	for r_C01_w in C01(ds_tabela_p) loop
		-- Caso for checkbox deve ser verificado se o mesmo está marcado ou não
		if (r_C01_w.ie_componente = 'cb') then
			ds_campo_temp_w := 'decode(nvl(' ||  r_c01_w.nm_atributo || ', ''N''), ''N'', 0, 100)';
		else
			ds_campo_temp_w := 'decode(' ||  r_c01_w.nm_atributo || ', null, 0, 100)';
		end if;
		-- Se a string de campos estiver vazia recebe somente o campo temporário,
		-- caso não, concatena com '+' pois deve realizar o sum para retornar a soma da prioridade
		if (coalesce(ds_campo_w::text, '') = '') then
			ds_campo_w := ds_campo_temp_w;
		else
			ds_campo_w := ds_campo_w || ' + ' || ds_campo_temp_w;
		end if;
	end loop;
	-- Verifica se a tabela possui 'ie_situacao'
	select	count(1)
	into STRICT	ie_situacao_w
	from	tabela_atributo
	where	nm_tabela = upper(ds_tabela_p)
	and	nm_atributo = 'IE_SITUACAO';
	-- Caso sim, restringe pelo 'ie_situacao'
	if (ie_situacao_w > 0) then
		ds_restricao_w := ds_restricao_w || ' and ie_situacao = ''A''';
	end if;
	-- Monta o sql dinâmico
	ds_sql_w := 'select	sum(' || ds_campo_w || ') qtde' || pls_util_pck.enter_w ||
		    'from	' || ds_tabela_p || pls_util_pck.enter_w ||
		    'where	nr_sequencia = :nr_sequencia_pc' || pls_util_pck.enter_w ||
				ds_restricao_w;
	-- Executa o sql, retornando a quantidade de pontos de prioridade
	EXECUTE ds_sql_w into STRICT qt_pontos_w using nr_sequencia_p;
end if;


return	qt_pontos_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_obter_valor_prioridade ( nr_sequencia_p bigint, ds_tabela_p text) FROM PUBLIC;

