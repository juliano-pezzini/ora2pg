-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION obter_se_cme_disp_agenda ( nr_seq_agenda_p bigint, lista_cme_p text, qt_tempo_p bigint, nr_seq_agenda_pos_p bigint) RETURNS varchar AS $body$
DECLARE


qt_agenda_per_w			bigint;
qt_tempo_esterilizacao_w	bigint	:= 0;
dt_inicial_w			timestamp;
dt_final_w			timestamp;
qt_conj_agenda_w		bigint;
qt_conj_agenda_exec_w		bigint;
ie_contador_w			bigint	:= 0;
lista_cme_w			varchar(400);
tam_lista_w			bigint;
ie_pos_virgula_w		smallint;
ie_disponivel_w			varchar(1)	:='S';
qt_tempo_w 			bigint	:= null;
nr_seq_conjunto_w		bigint;
qt_consiste_agenda_w		bigint;


BEGIN

if (coalesce(qt_tempo_p,0) > 0) then
	qt_tempo_w	:=  qt_tempo_p;
end if;

lista_cme_w	:= lista_cme_p;

while(ie_disponivel_w = 'S') and
	((lista_cme_w IS NOT NULL AND lista_cme_w::text <> '') or (ie_contador_w > 200)) loop
	begin
	tam_lista_w		:= length(lista_cme_w);
	ie_pos_virgula_w	:= position(',' in lista_cme_w);

	if (ie_pos_virgula_w <> 0) then
		begin
		nr_seq_conjunto_w	:= substr(lista_cme_w,1,(ie_pos_virgula_w - 1));
		lista_cme_w		:= substr(lista_cme_w,(ie_pos_virgula_w + 1),tam_lista_w);
		end;
	end if;

	select	coalesce(max(qt_consiste_agenda), 0)
	into STRICT	qt_consiste_agenda_w
	from	cm_conjunto
	where	nr_sequencia		= nr_seq_conjunto_w;

	select	coalesce(max(qt_tempo_esterelizacao),0)
	into STRICT	qt_tempo_esterilizacao_w
	from	cm_conjunto
	where	nr_sequencia = nr_seq_conjunto_w;

	select	hr_inicio,
		CASE WHEN ie_status_agenda='E' THEN  (hr_inicio + (qt_tempo_esterilizacao_w / 1440) - (1/86400))  ELSE (hr_inicio + ((coalesce(qt_tempo_w,nr_minuto_duracao) + coalesce(qt_tempo_esterilizacao_w,0)) / 1440) - (1/86400)) END
	into STRICT	dt_inicial_w,
		dt_final_w
	from	agenda_paciente
	where	nr_sequencia	= nr_seq_agenda_p;

	--Obter qtde de agendamentos que foram executadas no periodo - neste só é contado o tempo de esterilização e não considera mais o tempo de duração pois o mesmo já foi realizado
	select 	count(*)
	into STRICT	qt_conj_agenda_exec_w
	from	agenda_pac_cme a,
		agenda_paciente b
	where	b.nr_sequencia = a.nr_seq_agenda
	and	((hr_inicio between dt_inicial_w and dt_final_w) or
		(hr_inicio + (qt_tempo_esterilizacao_w / 1440) - (1/86400) between dt_inicial_w and dt_final_w) or
		((hr_inicio < dt_inicial_w) and (hr_inicio + (qt_tempo_esterilizacao_w / 1440) - (1/86400) > dt_final_w)))
	and	a.nr_seq_conjunto = nr_seq_conjunto_w
	and	b.ie_status_agenda = 'E'
	and	a.ie_origem_inf = 'I'
	and	b.nr_sequencia <> nr_seq_agenda_pos_p;

	--Obter qtde de agendamentos que não foram executados e/ou cancelados no periodo
	select 	count(*)
	into STRICT	qt_conj_agenda_w
	from	agenda_pac_cme a,
		agenda_paciente b
	where	b.nr_sequencia = a.nr_seq_agenda
	and	((hr_inicio between dt_inicial_w and dt_final_w) or
		(hr_inicio + ((nr_minuto_duracao + coalesce(qt_tempo_esterilizacao_w,0)) / 1440) - (1/86400) between dt_inicial_w and dt_final_w) or
		((hr_inicio < dt_inicial_w) and (hr_inicio + ((nr_minuto_duracao + coalesce(qt_tempo_esterilizacao_w,0)) / 1440) - (1/86400) > dt_final_w)))
	and	a.nr_seq_conjunto = nr_seq_conjunto_w
	and	b.ie_status_agenda not in ('C','E')
	and	a.ie_origem_inf = 'I'
	and	b.nr_sequencia <> nr_seq_agenda_pos_p;

	--Somado todos os agendamentos
	qt_conj_agenda_w	:= qt_conj_agenda_exec_w + qt_conj_agenda_w;

	if (qt_conj_agenda_w > 0) then
		-- Obter o último agendamento executado - Obter o último agendamento desconsiderando os executados e os cancelados
		select	max(qt_agenda_per)
		into STRICT	qt_agenda_per_w
		from	(SELECT	coalesce(max(b.nr_sequencia),0) nr_seq_agenda,
				count(*) qt_agenda_per
			from	agenda_pac_cme a,
				agenda_paciente b
			where	b.nr_sequencia = a.nr_seq_agenda
			and	((hr_inicio between dt_inicial_w and dt_final_w) or
				(hr_inicio + (qt_tempo_esterilizacao_w / 1440) - (1/86400) between dt_inicial_w and dt_final_w) or
				((hr_inicio < dt_inicial_w) and (hr_inicio + (qt_tempo_esterilizacao_w / 1440) - (1/86400) > dt_final_w)))
			and	a.nr_seq_conjunto = nr_seq_conjunto_w
			and	b.ie_status_agenda = 'E'
			and	a.ie_origem_inf = 'I'
			and	b.nr_sequencia <> nr_seq_agenda_pos_p
			
union

			SELECT	coalesce(max(b.nr_sequencia),0),
				count(*)
			from	agenda_pac_cme a,
				agenda_paciente b
			where	b.nr_sequencia = a.nr_seq_agenda
			and	((hr_inicio between dt_inicial_w and dt_final_w) or
				(hr_inicio + ((nr_minuto_duracao + coalesce(qt_tempo_esterilizacao_w,0)) / 1440) - (1/86400) between dt_inicial_w and dt_final_w) or
				((hr_inicio < dt_inicial_w) and (hr_inicio + ((nr_minuto_duracao + coalesce(qt_tempo_esterilizacao_w,0)) / 1440) - (1/86400) > dt_final_w)))
			and	a.nr_seq_conjunto = nr_seq_conjunto_w
			and	b.ie_status_agenda not in ('C','E')
			and	a.ie_origem_inf = 'I'
			and	b.nr_sequencia <> nr_seq_agenda_pos_p) alias33;

		if (qt_agenda_per_w >= qt_consiste_agenda_w) then
			ie_disponivel_w := 'N';
		end if;
		ie_contador_w	:= ie_contador_w + 1;
	end if;
	end;
end loop;

return	ie_disponivel_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION obter_se_cme_disp_agenda ( nr_seq_agenda_p bigint, lista_cme_p text, qt_tempo_p bigint, nr_seq_agenda_pos_p bigint) FROM PUBLIC;

