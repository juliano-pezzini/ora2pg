-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_oc_cta_val_23_consid_proc ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_seq_conta_proc_p pls_conta_proc_v.nr_sequencia%type, nr_seq_proc_ref_p pls_conta_proc_v.nr_seq_proc_ref%type, nr_seq_partic_hi_p pls_conta_proc_v.nr_seq_participante_hi%type, ie_tipo_conta_p pls_conta_v.ie_tipo_conta%type, nr_seq_outro_proc_p pls_conta_proc_v.nr_sequencia%type, nr_seq_outro_proc_ref_p pls_conta_proc_v.nr_seq_proc_ref%type, nr_seq_outro_partic_hi_p pls_conta_proc_v.nr_seq_participante_hi%type) RETURNS varchar AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Verificar se os procedimentos passados por parâmetros devem ser considerados iguais
	para a regra de utilização de itens.
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[X]  Objetos do dicionário [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatórios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------
Pontos de atenção:

Alterações:
------------------------------------------------------------------------------------------------------------------
jjung 17/09/2013 - Criação da function
------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
ie_considera_w		varchar(1);

qt_partic_proc_w	integer;
qt_partic_outro_proc_w	integer;

dados_partic_proc_w	pls_tipos_ocor_pck.dados_participante;

ds_sql_partic_w		varchar(4000);
ds_sql_outro_partic_w	varchar(4000);
ds_res_outro_partic_w	varchar(2000);

var_cur_w 		integer;
var_exec_w		integer;
var_retorno_w		integer;

var_cur_outro_w		integer;
var_exec_outro_w	integer;
var_retorno_outro_w	integer;

-- Retorna o acesso a tabela de participantes que deve ser feito, ou seja, diz de quem deve ser buscado os participantes.
function obter_acesso_proc_partic(	ie_opcao_p			text,
					nr_cursor_p			integer,
					nr_seq_conta_proc_p		pls_conta_proc_v.nr_sequencia%type,
					nr_seq_proc_ref_p		pls_conta_proc_v.nr_seq_proc_ref%type,
					nr_seq_partic_hi_p		pls_conta_proc_v.nr_seq_participante_hi%type)
					return text is
ds_retorno_w	varchar(255);


BEGIN

-- Participante de referência, quando este for informado apenas retorna o mesmo para que seja verificado os participantes do outro procedimento.
if (nr_seq_partic_hi_p IS NOT NULL AND nr_seq_partic_hi_p::text <> '') then

	-- Verificar se é para montar a restricao ou atualizar o valor das Binds
	if (ie_opcao_p = 'RESTRICAO') then

		ds_retorno_w := 'and	partic.nr_sequencia = :nr_seq_partic ';
	else
		dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_partic', nr_seq_partic_hi_p);
	end if;
-- Quando for informado apenas o procedimento de referência e não for informado o participante de referência, então deve
-- ser retornodo todos os partipantes do procedimento de referência.
elsif (nr_seq_proc_ref_p IS NOT NULL AND nr_seq_proc_ref_p::text <> '') then

	-- Verificar se é para montar a restricao ou atualizar o valor das Binds
	if (ie_opcao_p = 'RESTRICAO') then

		ds_retorno_w := 'and	partic.nr_seq_conta_proc = :nr_seq_proc_ref ';
	else
		dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_proc_ref', nr_seq_proc_ref_p);
	end if;
else
	-- Se não vai atrás dos participantes do procedimento mesmo.
	-- Verificar se é para montar a restricao ou atualizar o valor das Binds
	if (ie_opcao_p = 'RESTRICAO') then

		ds_retorno_w := 'and	partic.nr_seq_conta_proc = :nr_seq_conta_proc ';
	else
		dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_conta_proc', nr_seq_conta_proc_p);
	end if;
end if;

return ds_retorno_w;

end;

-- retorna qual a validação deve ser aplicada no participante para que ele seja considerado igual ao participante da tabela de seleção.
function obter_validacao_proc_partic(	ie_opcao_p	varchar2,
					nr_cursor_p	pls_integer,
					dados_regra_p	pls_tipos_ocor_pck.dados_regra,
					dados_partic_p	pls_tipos_ocor_pck.dados_participante,
					ie_tipo_conta_p	pls_conta_v.ie_tipo_conta%type)
					return varchar2 is
ds_retorno_w	varchar2(2000);

begin

-- Deve ser verificado o evento de geração das ocorrências para que se saiba de onde buscar a informação.
if (dados_regra_p.ie_evento = 'IMP') then

	-- Caso o participante tenha informação de grau de participação informada então busca os dados do grau de participação dos participantes
	-- do outro procedimento.
	if (dados_partic_p.cd_grau_partic_imp IS NOT NULL AND dados_partic_p.cd_grau_partic_imp::text <> '') then

		-- Quando for conta de intercâmbio deve se olhado o campo CD_PTU da PLS_GRAU_PARTICIPACAO e comparar com o código
		-- de participação informado para o participante do procedimento que está sendo consistido. Caso contrário usa o campo CD_TISS.
		if (ie_tipo_conta_p = 'I') then

			if (ie_opcao_p = 'RESTRICAO') then

				ds_retorno_w :=	'and	partic.nr_seq_grau_partic in (	select	grau_partic.nr_sequencia ' || pls_tipos_ocor_pck.enter_w ||
						'					from	pls_grau_participacao grau_partic ' || pls_tipos_ocor_pck.enter_w ||
						'					where	grau_partic.cd_ptu = :cd_ptu )';
			else
				dbms_sql.bind_variable(nr_cursor_p, ':cd_ptu', dados_partic_p.cd_grau_partic_imp);
			end if;

		else

			if (ie_opcao_p = 'RESTRICAO') then

				ds_retorno_w := 'and	partic.nr_seq_grau_partic in (	select	grau_partic.nr_sequencia '  || pls_tipos_ocor_pck.enter_w ||
						'					from	pls_grau_participacao grau_partic '|| pls_tipos_ocor_pck.enter_w ||
						'					where	grau_partic.cd_tiss = :cd_tiss ) ';
			else
				dbms_sql.bind_variable(nr_cursor_p, ':cd_tiss', dados_partic_p.cd_grau_partic_imp);
			end if;

		end if;
	end if;

else	-- Se o evento não for importação deve ser contado os participantes através do campo nr_seq_grau_partic da PLS_PROC_PARTICIPANTE. Caso exista
	-- algum participante com o mesmo campo informado para o procedimento que está sendo obtido para contagem então o mesmo é inserido e já aborta o cursor dos
	-- participantes.
	if (dados_partic_p.nr_seq_grau_partic IS NOT NULL AND dados_partic_p.nr_seq_grau_partic::text <> '') then

		if (ie_opcao_p = 'RESTRICAO') then

			ds_retorno_w :=	'and	partic.nr_seq_grau_partic = :nr_seq_grau_partic ';
		else
			dbms_sql.bind_variable(nr_cursor_p, ':nr_seq_grau_partic', dados_partic_p.nr_seq_grau_partic);
		end if;
	end if;
end if;

return ds_retorno_w;

end;

begin

-- Por padrão não é considerado o procedimento, para que isto mude é necessário que o procedimento se encaixe em determinado cenário.
ie_considera_w := 'N';

-- Deve ter informação sobre os procedimentos para que seja possível aplicar a validação.
if (nr_seq_conta_proc_p IS NOT NULL AND nr_seq_conta_proc_p::text <> '' AND nr_seq_outro_proc_p IS NOT NULL AND nr_seq_outro_proc_p::text <> '') then

	-- Se estiver falando do mesmo procedimento então insere e não é necessário verificar os participantes.
	if (nr_seq_conta_proc_p = nr_seq_outro_proc_p) then

		ie_considera_w := 'S';
	else
		-- Verificar de onde devem ser buscados os participantes do procedimento. Deve ser separado por que as contas de HI não tem os participantes
		-- e  sempre deve ser verificado o participante do procedimento de referência ou o participante ao qual o procedimento está verificado.
		-- Participante de referência, quando este for informado apenas verifica se existe este participante na base.
		if (nr_seq_partic_hi_p IS NOT NULL AND nr_seq_partic_hi_p::text <> '') then

			select	count(1)
			into STRICT	qt_partic_proc_w
			from	pls_proc_participante
			where	nr_sequencia = nr_seq_partic_hi_p;

		-- Quando for informado apenas o procedimento de referência e não for informado o participante de referência, então deve
		-- ser verificado se o procedimento de referência tem participantes informado.
		elsif (nr_seq_proc_ref_p IS NOT NULL AND nr_seq_proc_ref_p::text <> '') then

			select count(1)
			into STRICT	qt_partic_proc_w
			from	pls_proc_participante
			where	nr_seq_conta_proc = nr_seq_proc_ref_p;
		else
			-- Se não verifica se o próprio procedimento tem participantes informados.
			select	count(1)
			into STRICT	qt_partic_proc_w
			from	pls_proc_participante
			where	nr_seq_conta_proc = nr_seq_conta_proc_p;
		end if;

		-- Se o procedimento tiver participante
		if (qt_partic_proc_w > 0) then

			-- Montar o select para obter os participantes do item que está na tabela de seleção.
			ds_sql_partic_w	:=	'select	partic.nr_sequencia, ' || pls_tipos_ocor_pck.enter_w ||
						'	partic.nr_seq_grau_partic, ' || pls_tipos_ocor_pck.enter_w ||
						'	partic.cd_grau_partic_imp ' || pls_tipos_ocor_pck.enter_w ||
						'from	pls_proc_participante partic ' || pls_tipos_ocor_pck.enter_w ||
						'where	1 = 1 ' || pls_tipos_ocor_pck.enter_w ||
						-- Obter o acesso as participantes, seja do procedimento, do procedimento de referência ou um participante em específico.
						obter_acesso_proc_partic(	'RESTRICAO', var_cur_w,
										nr_seq_conta_proc_p,
										nr_seq_proc_ref_p,
										nr_seq_partic_hi_p);
			-- Preparação para varrer os participantes do procedimento da tabela de seleção.
			-- Abertura de um novo cursor
			var_cur_w := dbms_sql.open_cursor;
			-- Realizar o parse com o comando montado dinâmicamente
			dbms_sql.parse(var_cur_w,  ds_sql_partic_w, 1);

			-- Atualizar o valor das binds na consulta dos participantes do procedimento.
			ds_sql_partic_w	:=	obter_acesso_proc_partic(	'BINDS', var_cur_w,
										nr_seq_conta_proc_p,
										nr_seq_proc_ref_p,
										nr_seq_partic_hi_p);

			-- preparar o retorno do comando para que seja possível relizar o fetch dos valores.
			dbms_sql.define_column(var_cur_w, 1, dados_partic_proc_w.nr_sequencia);
			dbms_sql.define_column(var_cur_w, 2, dados_partic_proc_w.nr_seq_grau_partic);
			dbms_sql.define_column(var_cur_w, 3, dados_partic_proc_w.cd_grau_partic_imp, 2);

			-- Executar o comando.
			var_exec_w := dbms_sql.execute(var_cur_w);

			-- Aqui busca os participantes do item que está sendo consistido para verificar s algum destes está também no item que está sendo obtido para a contagem.
			loop
			var_retorno_w := dbms_sql.fetch_rows(var_cur_w);
			exit when var_retorno_w = 0;

				-- Obter os valores da linha do resultado do select.
				dbms_sql.column_value(var_cur_w, 1, dados_partic_proc_w.nr_sequencia);
				dbms_sql.column_value(var_cur_w, 2, dados_partic_proc_w.nr_seq_grau_partic);
				dbms_sql.column_value(var_cur_w, 3, dados_partic_proc_w.cd_grau_partic_imp);

				-- Para cada paticipante zera a varável de controle.
				qt_partic_outro_proc_w := 0;

				-- Montar o comando que será usado para verificar se o outro procedimento tem o mesmo participante que o procedimento informado.
				ds_sql_outro_partic_w :=	'select	count(1) ' || pls_tipos_ocor_pck.enter_w ||
								'from	pls_proc_participante partic ' || pls_tipos_ocor_pck.enter_w ||
								'where	1 = 1 ' || pls_tipos_ocor_pck.enter_w ||
								-- Obtém o acesso que será realizado para os participantes do outro procedimento.
								obter_acesso_proc_partic(	'RESTRICAO', var_cur_outro_w,
												nr_seq_outro_proc_p,
												nr_seq_outro_proc_ref_p,
												nr_seq_outro_partic_hi_p);

				-- Obter a restrição de validação do participante para verificar se o participante do outro procedimento
				-- é o mesmo do procedimento da tabela de seleção.
				ds_res_outro_partic_w := obter_validacao_proc_partic(	'RESTRICAO', var_cur_outro_w,
											dados_regra_p,
											dados_partic_proc_w,
											ie_tipo_conta_p);

				-- Caso não tenha sido retornado nenhuma restrição de validação do participante significa que o participante do procedimento
				-- da tabela de seleção não tem os dados necessário informado e não será feita nenhuma validação sobre o  outro procedimento,
				-- nenuhm procedimento será considerado para um participante que não tem dados informados.
				if ((ds_res_outro_partic_w IS NOT NULL AND ds_res_outro_partic_w::text <> '') or
					ds_res_outro_partic_w <> '') then


					ds_sql_outro_partic_w :=	ds_sql_outro_partic_w || pls_tipos_ocor_pck.enter_w ||
									ds_res_outro_partic_w;

					var_cur_outro_w := dbms_sql.open_cursor;
					dbms_sql.parse(var_cur_outro_w,  ds_sql_outro_partic_w, 1);

					-- Atualizar as binds da consulta dos participantes do outro procedimento.
					ds_sql_outro_partic_w := obter_acesso_proc_partic(	'BINDS', var_cur_outro_w,
												nr_seq_outro_proc_p,
												nr_seq_outro_proc_ref_p,
												nr_seq_outro_partic_hi_p);


					-- Obter a restrição de validação do participante para verificar se o participante do outro procedimento
					-- é o mesmo do procedimento da tabela de seleção.
					ds_res_outro_partic_w := obter_validacao_proc_partic(	'BINDS', var_cur_outro_w,
												dados_regra_p,
												dados_partic_proc_w,
												ie_tipo_conta_p);

					-- Preparar o retorno do comando de contagem dos participantes do outro procedimento.
					dbms_sql.define_column(var_cur_outro_w, 1, qt_partic_outro_proc_w);

					-- Executar a contagem dos participantes do outro procedimento.
					var_exec_outro_w := dbms_sql.execute(var_cur_outro_w);

					loop
					var_retorno_outro_w := dbms_sql.fetch_rows(var_cur_outro_w);
					exit when var_retorno_outro_w = 0;

						-- Atualizar o valor da contagem dos participantes do outro procedimento
						dbms_sql.column_value(var_cur_outro_w, 1, qt_partic_outro_proc_w);
					end loop;
					dbms_sql.close_cursor(var_cur_outro_w);-- Pariticpantes do outro procedimento
				end if;

				-- Se o procedimento que está sendo obtido para a contagem contém algum participante com mesmo grau de participação do proceidmento sendo consistido
				-- então o mesmo deve ser inserido portanto já aborta o cursor dos participantes e insere o procedimento na tabela de seleção.
				if (qt_partic_outro_proc_w > 0) then

					ie_considera_w := 'S';
					exit;
				end if;
			end loop;
			dbms_sql.close_cursor(var_cur_w); -- Pariticpantes do procedimento da tabela de seleção
		else
			-- Se o procedimento que está na tabela de seleção não tiver participantes então deve ser verificado se o outro procedimento tem algum participante,
			-- Caso ele tenha etão não será considerado, se não tiver será considerado.
			-- A octenção se deve do mesmo modo, primeiro verifica se tem participante de referência informado,
			-- depois se tem procedimento de referência informado, e se não tiver nenhum dos dois então verifica os participantes do procedimento.
			-- Participante de referência
			if (nr_seq_outro_partic_hi_p IS NOT NULL AND nr_seq_outro_partic_hi_p::text <> '') then

				select	count(1)
				into STRICT	qt_partic_outro_proc_w
				from	pls_proc_participante
				where	nr_sequencia = nr_seq_outro_partic_hi_p;

			-- Procedimento de referência
			elsif (nr_seq_outro_proc_ref_p IS NOT NULL AND nr_seq_outro_proc_ref_p::text <> '') then

				select	count(1)
				into STRICT	qt_partic_outro_proc_w
				from	pls_proc_participante
				where	nr_seq_conta_proc = nr_seq_outro_proc_ref_p;
			else
				-- se não tiver nenhum dos dois conta os participantes do procedimento.
				select	count(1)
				into STRICT	qt_partic_outro_proc_w
				from	pls_proc_participante
				where	nr_seq_conta_proc = nr_seq_outro_proc_p;
			end if;

			-- Se o outro procedimento tiver participantes e o procedimento da tabela de seleção não tiver então
			-- não deve ser considerado, caso contrário deve.
			if (qt_partic_outro_proc_w > 0) then

				ie_considera_w := 'N';
			else
				ie_considera_w := 'S';
			end if;
		end if;
	end if;
else
	ie_considera_w := 'N';
end if;

return	ie_considera_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_oc_cta_val_23_consid_proc ( dados_regra_p pls_tipos_ocor_pck.dados_regra, nr_seq_conta_proc_p pls_conta_proc_v.nr_sequencia%type, nr_seq_proc_ref_p pls_conta_proc_v.nr_seq_proc_ref%type, nr_seq_partic_hi_p pls_conta_proc_v.nr_seq_participante_hi%type, ie_tipo_conta_p pls_conta_v.ie_tipo_conta%type, nr_seq_outro_proc_p pls_conta_proc_v.nr_sequencia%type, nr_seq_outro_proc_ref_p pls_conta_proc_v.nr_seq_proc_ref%type, nr_seq_outro_partic_hi_p pls_conta_proc_v.nr_seq_participante_hi%type) FROM PUBLIC;

