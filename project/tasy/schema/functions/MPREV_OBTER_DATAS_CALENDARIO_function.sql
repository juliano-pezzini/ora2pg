-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION mprev_obter_datas_calendario (dt_agenda_p timestamp, nr_seq_equipe_p bigint, ie_loc_interno_p text, ie_loc_tipo_atend_p text, cd_agenda_p bigint, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) RETURNS varchar AS $body$
DECLARE

 
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
Finalidade: Retornar os status de cada dia do calendário da agenda. 
------------------------------------------------------------------------------------------------------------------- 
Locais de chamada direta: 
[x] Objetos do dicionário [ X] Tasy (Delphi/Java) [] Portal [] Relatórios [] Outros: 
 ------------------------------------------------------------------------------------------------------------------ 
Pontos de atenção: 
Se for de mais de uma agenda, deve usar a seguinte lógica: 
- Todos os horários de todas as agendas estão livres -> LIVRE 
- Todos os horários de todas as agendas estão ocupados -> CHEIO 
- Algum horário de qualquer uma das agendas utilizado -> ALGUNS 
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
 
 
cd_agenda_w		bigint;
ds_retorno_w		varchar(255);
nr_dia_semana_w		smallint;
dt_prim_dia_mes_w	timestamp;
dt_ult_dia_mes_w	timestamp;
dt_agenda_w		timestamp;
ie_agenda_w		varchar(2);
qt_atendimentos_w	bigint;
qt_horarios_w		bigint;
qt_indisponivel_w	bigint	:= 0;
qt_livre_w		bigint	:= 0;
qt_cheio_w		bigint	:= 0;
qt_agendas_w		bigint	:= 0;
nr_min_turno_w		bigint	:= 0;
nr_min_duracao_w	bigint	:= 0;

C02 CURSOR FOR 
	SELECT	distinct 
		b.cd_agenda 
	from	mprev_equipe_profissional a, 
		agenda b 
	where	b.cd_pessoa_fisica = a.cd_pessoa_fisica 
	and	b.cd_tipo_agenda = '6' 
	and	clock_timestamp() between a.dt_inclusao and coalesce(a.dt_exclusao,clock_timestamp()) 
	and	a.nr_seq_equipe = nr_seq_equipe_p;
	
C03 CURSOR FOR 
	SELECT	distinct 
		b.cd_agenda 
	from	mprev_local_atend a, 
		mprev_local_atend_agenda b 
	where	b.nr_seq_local_atend = a.nr_sequencia 
	and	a.ie_situacao = 'A' 
	and	b.ie_situacao = 'A' 
	and (a.ie_interno = ie_loc_interno_p or coalesce(ie_loc_interno_p::text, '') = '') 
	and (a.ie_tipo_atendimento = ie_loc_tipo_atend_p or coalesce(ie_loc_tipo_atend_p::text, '') = '');

BEGIN 
 
select	trunc(dt_agenda_p,'month') 
into STRICT	dt_prim_dia_mes_w
;
 
select	last_day( dt_agenda_p ) 
into STRICT	dt_ult_dia_mes_w
;
 
dt_agenda_w	:= dt_prim_dia_mes_w;
 
while(dt_agenda_w <= dt_ult_dia_mes_w) loop 
	begin 
	ie_agenda_w := 'L';
	/* Verificação das datas para uma agenda exclusiva */
 
	if (cd_agenda_p IS NOT NULL AND cd_agenda_p::text <> '') then 
	 
		cd_agenda_w := cd_agenda_p;
	 
		nr_min_turno_w := mprev_obter_min_dia_agenda(cd_agenda_w, dt_agenda_w, cd_estabelecimento_p);
	 
		if (nr_min_turno_w = 0) then 
			ie_agenda_w	:= 'I';
		else 
			select coalesce(sum(a.nr_minuto_duracao),0) 
			into STRICT	nr_min_duracao_w 
			from	mprev_agendamento a 
			where	cd_agenda = cd_agenda_w 
			and	dt_agenda between trunc(dt_agenda_w,'dd') and fim_dia(dt_agenda_w) 
			and	a.ie_status_agenda <> 'C';
			 
			if (nr_min_duracao_w = 0) then 
				ie_agenda_w := 'L';
			elsif (nr_min_duracao_w = nr_min_turno_w) then 
				ie_agenda_w := 'C';
			else 
				ie_agenda_w := 'A';
			end if;
		end if;
	/* Verificação das datas para todas as agendas da equipe */
	 
	elsif (nr_seq_equipe_p IS NOT NULL AND nr_seq_equipe_p::text <> '') then 
	 
		ie_agenda_w 		:= null;
		qt_cheio_w		:= 0;
		qt_livre_w		:= 0;
		qt_indisponivel_w	:= 0;
		qt_agendas_w		:= 0;
		for cr_02 in C02 loop 
			begin 
			cd_agenda_w 	:= cr_02.cd_agenda;
			qt_agendas_w	:= qt_agendas_w + 1;
			nr_min_turno_w 	:= mprev_obter_min_dia_agenda(cd_agenda_w, dt_agenda_w, cd_estabelecimento_p);
			 
			/* Se esta agenda não tem horários disponíveis e o status da legenda ainda não foi alterado 
			tem que mudar o status para Indisponível */
 
			if (nr_min_turno_w = 0) then 
				qt_indisponivel_w	:= qt_indisponivel_w + 1;
			else 
				select coalesce(sum(a.nr_minuto_duracao),0) 
				into STRICT	nr_min_duracao_w 
				from	mprev_agendamento a 
				where	cd_agenda = cd_agenda_w 
				and	dt_agenda between trunc(dt_agenda_w,'dd') and fim_dia(dt_agenda_w) 
				and	a.ie_status_agenda <> 'C';
				 
				if (nr_min_duracao_w > nr_min_turno_w) then 
					qt_cheio_w	:= qt_cheio_w + 1;
				elsif (nr_min_duracao_w = 0) then 
					qt_livre_w	:= qt_livre_w + 1;
				end if;
			end if;	
			end;
		end loop;
		 
		if (qt_indisponivel_w = qt_agendas_w) then 
			ie_agenda_w	:= 'I';
		elsif (qt_cheio_w = qt_agendas_w) then 
			ie_agenda_w	:= 'C';
		elsif (qt_livre_w + qt_indisponivel_w = qt_agendas_w) then 
			ie_agenda_w	:= 'L';
		else 
			ie_agenda_w	:= 'A';
		end if;
		 
	/* Verificação das datas para todas as agendas de local com o tipo selecionado */
	 
	elsif ((ie_loc_interno_p IS NOT NULL AND ie_loc_interno_p::text <> '') or (ie_loc_tipo_atend_p IS NOT NULL AND ie_loc_tipo_atend_p::text <> '')) then 
		ie_agenda_w 		:= null;
		qt_cheio_w		:= 0;
		qt_livre_w		:= 0;
		qt_indisponivel_w	:= 0;
		qt_agendas_w		:= 0;
		for cr_03 in C03 loop 
			begin 
			cd_agenda_w := cr_03.cd_agenda;
			nr_min_turno_w 	:= mprev_obter_min_dia_agenda(cd_agenda_w, dt_agenda_w, cd_estabelecimento_p);
			 
			qt_agendas_w	:= qt_agendas_w + 1;
			 
			/* Se esta agenda não tem horários disponíveis e o status da legenda ainda não foi alterado 
			tem que mudar o status para Indisponível */
 
			if (nr_min_turno_w = 0) then 
				qt_indisponivel_w	:= qt_indisponivel_w + 1;
			else 
				select coalesce(sum(a.nr_minuto_duracao),0) 
				into STRICT	nr_min_duracao_w 
				from	mprev_agendamento a 
				where	cd_agenda = cd_agenda_w 
				and	dt_agenda between trunc(dt_agenda_w,'dd') and fim_dia(dt_agenda_w) 
				and	a.ie_status_agenda <> 'C';
				 
				if (nr_min_duracao_w > nr_min_turno_w) then 
					qt_cheio_w	:= qt_cheio_w + 1;
				elsif (nr_min_duracao_w = 0) then 
					qt_livre_w	:= qt_livre_w + 1;
				end if;
			end if;	
			end;
		end loop;
		 
		if (qt_indisponivel_w = qt_agendas_w) then 
			ie_agenda_w	:= 'I';
		elsif (qt_cheio_w = qt_agendas_w) then 
			ie_agenda_w	:= 'C';
		elsif (qt_livre_w + qt_indisponivel_w = qt_agendas_w) then 
			ie_agenda_w	:= 'L';
		else 
			ie_agenda_w	:= 'A';
		end if;
		 
	end if;
	 
	dt_agenda_w := dt_agenda_w + 1;
	ds_retorno_w := ds_retorno_w || ie_agenda_w || ';';
		 
	end;
end loop;
 
 
return	ds_retorno_w;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION mprev_obter_datas_calendario (dt_agenda_p timestamp, nr_seq_equipe_p bigint, ie_loc_interno_p text, ie_loc_tipo_atend_p text, cd_agenda_p bigint, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;

