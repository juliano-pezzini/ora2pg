-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION obter_saldo_conpaci (nr_interno_conta_p bigint, cd_autorizacao_p text) RETURNS bigint AS $body$
DECLARE


vl_saldo_w		double precision;
vl_conta_w		double precision;
vl_retorno_w		double precision;
vl_grg_w		double precision;
vl_saldo_titulo_w	double precision;
vl_saldo_guia_w		double precision;
vl_glosa_w		double precision;
vl_pago_w		double precision;
vl_acatado_w		double precision;
nr_titulo_w		bigint;
nr_seq_guia_w		bigint;
vl_saldo_original_w	double precision;
ie_param_266_w		varchar(1) := 'N';
c01 CURSOR FOR
SELECT	coalesce(sum(a.vl_glosa),0) vl_glosa,
	coalesce(sum(a.vl_pago),0) vl_pago,
	coalesce(sum(a.vl_acatado),0) vl_acatado,
	coalesce(b.vl_saldo_guia,0) vl_saldo_guia,
	coalesce(b.vl_saldo_original,coalesce(b.vl_saldo_guia,0)),
	b.nr_sequencia
from	lote_audit_hist c,
	lote_audit_hist_item a,
	lote_audit_hist_guia b
where	b.nr_sequencia			= a.nr_seq_guia
and	coalesce(b.cd_autorizacao,'0')	= coalesce(coalesce(cd_autorizacao_p,b.cd_autorizacao),'0')
and	b.nr_interno_conta		= nr_interno_conta_p
and	b.nr_seq_lote_hist		= c.nr_sequencia
and ((b.dt_baixa_glosa IS NOT NULL AND b.dt_baixa_glosa::text <> '') or c.nr_sequencia <> (obter_ultima_analise(c.nr_seq_lote_audit))::numeric )
group by	b.nr_sequencia,
	b.vl_saldo_guia,
	b.vl_saldo_original;


BEGIN
ie_param_266_w := obter_param_usuario(27, 266, obter_perfil_ativo, wheb_usuario_pck.get_nm_usuario, wheb_usuario_pck.get_cd_estabelecimento, ie_param_266_w);

if (coalesce(cd_autorizacao_p::text, '') = '') then

	select	coalesce(max(a.vl_conta),0),
		max((obter_titulo_conta_guia(a.nr_interno_conta,null,null,null))::numeric )
	into STRICT	vl_conta_w,
		nr_titulo_w
	from	conta_paciente a
	where	a.nr_interno_conta	= nr_interno_conta_p;

else

	select	coalesce(max(a.vl_guia),0),
		max((obter_titulo_conta_guia(a.nr_interno_conta,cd_autorizacao_p,null,null))::numeric )
	into STRICT	vl_conta_w,
		nr_titulo_w
	from	conta_paciente_guia a
	where	a.nr_interno_conta	= nr_interno_conta_p
	and	a.cd_autorizacao	= cd_autorizacao_p;

end if;

select	max(a.vl_saldo_titulo)
into STRICT	vl_saldo_titulo_w
from	titulo_receber a
where	a.nr_titulo	= nr_titulo_w;

if (coalesce(vl_saldo_titulo_w,0) = 0) then
	vl_saldo_w	:= 0;
else

	select	coalesce(sum(a.vl_pago),0) + coalesce(sum(a.vl_desconto),0) + coalesce(sum(a.vl_perdas),0) + coalesce(sum(a.vl_nota_credito),0) + coalesce(sum(a.vl_glosado),0)
	into STRICT	vl_retorno_w
	from	convenio_retorno b,
		convenio_retorno_item a
	where	a.nr_interno_conta		= nr_interno_conta_p
	and	coalesce(a.cd_autorizacao,'0')	= coalesce(coalesce(cd_autorizacao_p,a.cd_autorizacao),'0')
	and	a.nr_seq_retorno		= b.nr_sequencia
	and	b.ie_status_retorno		= 'F';

	open	c01;
	loop
	fetch	c01 into
		vl_glosa_w,
		vl_pago_w,
		vl_acatado_w,
		vl_saldo_guia_w,
		vl_saldo_original_w,
		nr_seq_guia_w;
	EXIT WHEN NOT FOUND; /* apply on c01 */

		/* quando for glosa posterior, o sistema gera uma nota de crédito,
		   portanto o valor da glosa posterior não deve ser deduzido do saldo da guia */
		--if	(vl_glosa_w	> vl_saldo_guia_w) then
			--vl_grg_w	:= nvl(vl_grg_w,0) + vl_saldo_guia_w + vl_pago_w;
		--else
		if (coalesce(ie_param_266_w,'N') = 'N') then
			vl_grg_w	:= coalesce(vl_grg_w,0) + vl_glosa_w + vl_pago_w + vl_acatado_w;
		else
			vl_grg_w	:= coalesce(vl_grg_w,0) + vl_glosa_w + vl_acatado_w;
		end if;

		--end if;
		/* Retirei o if acima por dar vários problemas um desses casos é a OS 747196.

		O cliente possuia uma guia no valor de 12.432,22
		Baixou como valor pago no retorno convênio o valor de: 10.090,83
		Gerou a 1º GRG
		Foi baixado como glosa aceita o valor de 2.296,75
		Logo o saldo da guia ficou: 10.090,83 + 2.,296,75 = 12.387,58

		Logo: valor da guia: 12.432,22 - 12.387,58 = 44,64

		Foi criado novo retorno com valor amenor de 44,64 Fechado e gerada nova GRG.

		Esta com valor de glosa aceita de 12,28 e 32,36 de reapresentação.

		Porém quando foi baixar esta GRG, o sistema se perdeu
		neste if comentado.

		Pois o valor da glosa na primeira GRG é de 2.296,75 logo o saldo é de 44,66, então a variável vl_grg_w acumula o valor de 44,64 conforme if comentado.
		Na segunda GRG lida no cursor o valor de glosa é de 12,28 e o valor de saldo é 44,66,
		logo entra no else acumulando na variável vl_grg_w + 12,28. No total temos na variável vl_grg_w o valor de 56,80.

		Logo no final da rotina o saldo que retorna fica errado.

		vl_saldo_w	:= nvl(vl_conta_w,0) - nvl(vl_retorno_w,0) - nvl(vl_grg_w,0);

		vl_saldo_w := 12.432,22 - 10.090,83 - 56,80;

		vl_saldo_w := 2.284,59 Porém deveria ser 32,36 Se não tivesse entrado no if comentado.
		Pois o valor de glosa iria ser acumulado ao invés do valor de saldo. Logo seria assim:

		vl_grg_w := 2.296,75 + 12,28 = 2.309,03

		Logo teríamos:

		vl_saldo_w	:= nvl(vl_conta_w,0) - nvl(vl_retorno_w,0) - nvl(vl_grg_w,0);

		Vl_saldo_w := 12.432,22 - 10.090,83 - 2309,03;

		vl_saldo_W := 32,36

		Esta situação do saldo errado por ser vista no anexo desta OS
		\\whebs05\ordem_servico\OS747196_13_06_2014_08_42_02.zip

		*/
	end	loop;
	close	c01;

	vl_saldo_w	:= coalesce(vl_conta_w,0) - coalesce(vl_retorno_w,0) - coalesce(vl_grg_w,0);
end if;

RETURN vl_saldo_w;

END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION obter_saldo_conpaci (nr_interno_conta_p bigint, cd_autorizacao_p text) FROM PUBLIC;

