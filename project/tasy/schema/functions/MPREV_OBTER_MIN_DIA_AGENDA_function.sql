-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION mprev_obter_min_dia_agenda ( cd_agenda_p bigint, dt_agenda_p timestamp, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) RETURNS bigint AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Obter a quantidade total de minutos possivel de agendamento do turno da agenda 
para o dia em questao
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[  X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  x] Portal [  ]  Relatorios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------

Pontos de atencao:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
qt_minutos_w		bigint;
nr_dia_semana_w		smallint;
qt_minutos_inicial_w	bigint	:= 0;
qt_minutos_final_w	bigint	:= 0;
qt_total_minutos_w	bigint	:= 0;
cd_agenda_w		bigint;
ie_feriado_w		varchar(1);

-- Turnos da agenda para o dia 
C01 CURSOR FOR
	SELECT	hr_inicial,
		hr_final,
		nr_minuto_intervalo,
		hr_inicial_intervalo,
		hr_final_intervalo,
		coalesce(ie_feriado, 'S') ie_feriado
	from	agenda_turno
	where	cd_agenda = cd_agenda_w
	and (ie_dia_semana	= nr_dia_semana_w or (ie_dia_semana = '9' and pkg_date_utils.is_business_day(dt_agenda_p) = 1))
	and  	((Obter_Semana_Dia_Agecons(dt_agenda_p,ie_dia_semana) = coalesce(ie_semana,0)) or (coalesce(ie_semana,0) = 0))
	and	dt_agenda_p between dt_inicio_vigencia and coalesce(dt_final_vigencia,dt_agenda_p);
	
-- Bloqueios da agenda para o dia 
c02 CURSOR FOR
	SELECT	a.hr_inicio_bloqueio,
		a.hr_final_bloqueio
	from	agenda_bloqueio a
	where	a.cd_agenda	= cd_agenda_w
	and	a.dt_inicial	<= fim_dia(dt_agenda_p)
	and	a.dt_final 	>= pkg_date_utils.start_of(dt_agenda_p,'DD',0);

--Ausencias da agenda para o dia 
	
BEGIN

-- Verificar se e feriado ou dia de semana.
select	CASE WHEN obter_se_feriado(cd_estabelecimento_p,dt_agenda_p)=0 THEN 'N'  ELSE 'S' END
into STRICT	ie_feriado_w
;

if (cd_agenda_p IS NOT NULL AND cd_agenda_p::text <> '') then
	nr_dia_semana_w	:=  pkg_date_utils.get_weekday(dt_agenda_p);
	cd_agenda_w 	:= cd_agenda_p;

	-- Primeiro abrir os turnos possiveis para aquele dia 
	for cr01 in C01 loop
			
		-- Verificacao da geracao por feriado. 

		-- Se gera em feriado entao nao verifica mais nada

		-- Se nao gera em feriado entao so gera quando for dia util

		-- Se so gera em feriado entao gera quando nao e dia util.
		if	((cr01.ie_feriado = 'S') or (cr01.ie_feriado = 'N' and ie_feriado_w = 'N') or (cr01.ie_feriado = 'F' and ie_feriado_w = 'S'))then
			
			-- Contar quantos horarios do inicio do turno ate inicio de intervalo, se nao tiver intervalo, considera fim do turno 
			if (cr01.hr_inicial_intervalo IS NOT NULL AND cr01.hr_inicial_intervalo::text <> '') then
				qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_inicial, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_inicial, 0)));
				qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_inicial_intervalo, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_inicial_intervalo, 0)));
				qt_total_minutos_w	:= qt_minutos_final_w - qt_minutos_inicial_w;
			else
				qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_inicial, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_inicial, 0)));
				qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_final, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_final, 0)));
				qt_total_minutos_w	:= qt_minutos_final_w - qt_minutos_inicial_w;
			end if;
			
			-- Contar quantos horarios do fim do intervalo ate o fim do turno, se nao tiver intervalo nao considera 
			if (cr01.hr_final_intervalo IS NOT NULL AND cr01.hr_final_intervalo::text <> '') then
				qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_final_intervalo, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_final_intervalo, 0)));
				qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_final, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_final, 0)));
				qt_total_minutos_w	:= qt_total_minutos_w + (qt_minutos_final_w - qt_minutos_inicial_w);
			end if;
			
			-- Descontar os horarios ausencia / bloqueio 
			for cr02 in C02 loop
				qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr02.hr_inicio_bloqueio, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr02.hr_inicio_bloqueio, 0)));
				qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr02.hr_final_bloqueio, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr02.hr_final_bloqueio, 0)));
				qt_total_minutos_w	:= qt_total_minutos_w - (qt_minutos_final_w - qt_minutos_inicial_w);
			end loop;
		end if;
	end loop;
end if;

return	qt_total_minutos_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION mprev_obter_min_dia_agenda ( cd_agenda_p bigint, dt_agenda_p timestamp, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;

