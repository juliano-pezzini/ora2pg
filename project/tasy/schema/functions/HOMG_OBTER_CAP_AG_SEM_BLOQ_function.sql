-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION homg_obter_cap_ag_sem_bloq (cd_agenda_p bigint, nr_sequencia_p bigint, dt_inicial_p timestamp, dt_final_p timestamp) RETURNS bigint AS $body$
DECLARE

									 
/* function utilizada para agenda tipo (1,2) 
visando obter a capacidade total da agenda com base 
nas datas inicial e final, horarios inicial e final, 
dia da semana e duração do horário. 
*/
 
 
qt_dias_vigencia_w  		bigint;
qt_capacidade_w  			bigint;
dt_dia_semana_w  			smallint;
qt_dias_efetivos_w  		bigint;
qt_total_dias_efetivos_w 	bigint;
qt_hor_intervalo_selec_w	bigint;
qt_total_hor_intervalo_w	bigint;
dt_incrementa_w  			timestamp;
qt_agendamento_hr_espec		bigint;
dt_inicio_vigencia_w		timestamp;
dt_final_vigencia_w			timestamp;
qt_agendamento_hr_espec_w	bigint;
qt_total_agend_hr_espec_w	bigint;
hr_inicial_w				varchar(8);
hr_final_w					varchar(8);
hr_inicial_intervalo_w		varchar(8);
hr_final_intervalo_w		varchar(8);
qt_hor_bloq_per_w			bigint;
qt_total_hor_bloq_per_w		bigint;
nr_minuto_intervalo_w		bigint;
cd_estabelecimento_w		smallint;

 
C01 CURSOR FOR 
	SELECT	coalesce(((((coalesce(a.hr_final_bloqueio, to_date('31/12/1899 '||hr_final_w, 'dd/mm/yyyy hh24:mi:ss')) - coalesce(a.hr_inicio_bloqueio, to_date('31/12/1899 '||hr_inicial_w, 'dd/mm/yyyy hh24:mi:ss'))) * 1440) / nr_minuto_intervalo_w)), 0)						 
	from	agenda_bloqueio a, 
			agenda_horario b 
	where 	a.cd_agenda			= b.cd_agenda 
	and		a.cd_agenda 		= cd_agenda_p												 
	and		b.nr_sequencia		= nr_sequencia_p 
	and		((obter_cod_dia_semana(dt_incrementa_w) = a.ie_dia_semana) or (a.ie_dia_semana = 9) or (coalesce(a.ie_dia_semana::text, '') = '')) 
	and		obter_cod_dia_semana(dt_incrementa_w) not in (1,7) 
	and		((obter_cod_dia_semana(dt_incrementa_w)	= b.dt_dia_semana) or (b.dt_dia_semana = 9)) 
	and		dt_incrementa_w	between trunc(a.dt_inicial) and fim_dia(trunc(a.dt_final)) 
	and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
	
BEGIN 
	qt_total_dias_efetivos_w 	:= 0;
	dt_incrementa_w  			:= clock_timestamp();
	qt_dias_vigencia_w  		:= 0;
	qt_capacidade_w  			:= 0;
	dt_dia_semana_w  			:= 0;
	qt_dias_efetivos_w  		:= 0;	
	qt_agendamento_hr_espec		:= 0;
	dt_inicio_vigencia_w		:= clock_timestamp();
	dt_final_vigencia_w			:= clock_timestamp();
	qt_agendamento_hr_espec_w	:= 0;
	qt_total_agend_hr_espec_w	:= 0;
	qt_hor_intervalo_selec_w	:= 0;
	qt_total_hor_intervalo_w	:= 0;
	qt_hor_bloq_per_w			:= 0;
	qt_total_hor_bloq_per_w		:= 0;
	 
	--inicialização variaveis. 
 
	select 	a.dt_dia_semana, 
			dt_inicial_p, 
			dt_final_p - dt_inicial_p, 
			coalesce(a.dt_inicio_vigencia,null), 
			coalesce(a.dt_final_vigencia,null), 
			to_char(a.hr_inicial, 'hh24:mi:ss'), 
			to_char(a.hr_final, 'hh24:mi:ss'), 
			to_char(a.hr_inicial_intervalo, 'hh24:mi:ss'), 
			to_char(a.hr_final_intervalo, 'hh24:mi:ss'), 
			a.nr_minuto_intervalo, 
			b.cd_estabelecimento 
	into STRICT 	dt_dia_semana_w,		--selecionar qual o dia da semana para a agenda em questão 
			dt_incrementa_w, 		--usada no loop de verificação, compara todas as datas do periodo e filtra/soma dias conforme dia semana selecionado 
			qt_dias_vigencia_w,		--qtde dias possíveis para agendamento baseados na data inicial e final do relatorio 
			dt_inicio_vigencia_w, 
			dt_final_vigencia_w, 
			hr_inicial_w, 
			hr_final_w, 
			hr_inicial_intervalo_w, 
			hr_final_intervalo_w, 
			nr_minuto_intervalo_w, 
			cd_estabelecimento_w 
	from  agenda_horario a, 
			agenda b 
	where 	a.cd_agenda			= b.cd_agenda 
	and		a.cd_agenda   	= cd_agenda_p 
	and  	a.nr_sequencia  	= nr_sequencia_p;
	 
		if ((coalesce(dt_inicio_vigencia_w::text, '') = '') or (coalesce(dt_final_vigencia_w::text, '') = '')) then 
			begin			 
				if (dt_dia_semana_w <> 9) then 		--se não for dias de trabalho... 
					for i in 0..qt_dias_vigencia_w 	--até total dias possíveis p/ agendamento (*) 
					loop												 
						if (hr_inicial_intervalo_w IS NOT NULL AND hr_inicial_intervalo_w::text <> '') and (hr_final_intervalo_w IS NOT NULL AND hr_final_intervalo_w::text <> '') then													 
							 
							--buscar qtd. de horário dentro do período de intervalo 
							select	coalesce(max(((((a.hr_final_intervalo - a.hr_inicial_intervalo) * 1440) / a.nr_minuto_intervalo))),0) 
							into STRICT	qt_hor_intervalo_selec_w 
							from	agenda_horario a												 
							where 	a.cd_agenda   	= cd_agenda_p 
							and  	a.nr_sequencia  	= nr_sequencia_p 
							and		obter_cod_dia_semana(dt_incrementa_w) = dt_dia_semana_w 
							and		(a.hr_inicial_intervalo IS NOT NULL AND a.hr_inicial_intervalo::text <> '') 
							and		(a.hr_final_intervalo IS NOT NULL AND a.hr_final_intervalo::text <> '') 
							and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
							/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
							 
							 
						end if;
						 
						select 	count(*) 
						into STRICT 	qt_dias_efetivos_w 
						 
						where 	obter_cod_dia_semana(dt_incrementa_w) = dt_dia_semana_w 
						and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
						/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
												 
						--Validar(caso existir) a geração de horários bloqueados dentro do período 
						open C01;
						loop 
						fetch C01 into	 
							qt_hor_bloq_per_w;
						EXIT WHEN NOT FOUND; /* apply on C01 */
							begin 
							qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w;
							end;
						end loop;
						close C01;
						 
						/*select	nvl(((((nvl(a.hr_final_bloqueio, to_date('31/12/1899 '||hr_final_w, 'dd/mm/yyyy hh24:mi:ss')) - nvl(a.hr_inicio_bloqueio, to_date('31/12/1899 '||hr_inicial_w, 'dd/mm/yyyy hh24:mi:ss'))) * 1440) / nr_minuto_intervalo_w)), 0) 
						into	qt_hor_bloq_per_w 
						from	agenda_bloqueio a												 
						where 	a.cd_agenda   	= cd_agenda_p												 
						and		((obter_cod_dia_semana(dt_incrementa_w) = a.ie_dia_semana) or (a.ie_dia_semana = 9) or (a.ie_dia_semana is null)) 
						and		dt_incrementa_w	between trunc(a.dt_inicial) and fim_dia(trunc(a.dt_final)) 
						and		nvl(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;*/
 
												 
						qt_total_dias_efetivos_w 	:= qt_dias_efetivos_w 		+ qt_total_dias_efetivos_w;
						qt_total_hor_intervalo_w	:= qt_hor_intervalo_selec_w + qt_total_hor_intervalo_w;
						--qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w; 
						dt_incrementa_w  			:= dt_incrementa_w 		+ 1;	--(*) soma 1 dia a partir dt inicio até dt final						 
					end loop;
				else 					-- caso o dia da semana seja "dias de trabalho" (9), soma todos desconsiderando os sabados e domingos 
					for i in 0..qt_dias_vigencia_w 	--até total dias possíveis p/ agendamento(*) 
					loop 
						if (hr_inicial_intervalo_w IS NOT NULL AND hr_inicial_intervalo_w::text <> '') and (hr_final_intervalo_w IS NOT NULL AND hr_final_intervalo_w::text <> '') then						 
							--buscar qtd. de horário dentro do período de intervalo 
							select	coalesce(max(((((a.hr_final_intervalo - a.hr_inicial_intervalo) * 1440) / a.nr_minuto_intervalo))),0) 
							into STRICT	qt_hor_intervalo_selec_w 
							from	agenda_horario a												 
							where 	a.cd_agenda   	= cd_agenda_p 
							and  	a.nr_sequencia  	= nr_sequencia_p							 
							and		(a.hr_inicial_intervalo IS NOT NULL AND a.hr_inicial_intervalo::text <> '') 
							and		(a.hr_final_intervalo IS NOT NULL AND a.hr_final_intervalo::text <> '')					 
							and		obter_cod_dia_semana(dt_incrementa_w) not in (1,7) 
							and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
							/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
						 
						end if;
						 
						select count(*) 
						into STRICT 	qt_dias_efetivos_w 
						 
						where 	obter_cod_dia_semana(dt_incrementa_w) not in (1,7) 
						and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
						/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
												 
						--Validar(caso existir) a geração de horários bloqueados dentro do período 
						open C01;
						loop 
						fetch C01 into	 
							qt_hor_bloq_per_w;
						EXIT WHEN NOT FOUND; /* apply on C01 */
							begin 
							qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w;
							end;
						end loop;
						close C01;
						 
						/*select	nvl(((((nvl(a.hr_final_bloqueio, to_date('31/12/1899 '||hr_final_w, 'dd/mm/yyyy hh24:mi:ss')) - nvl(a.hr_inicio_bloqueio, to_date('31/12/1899 '||hr_inicial_w, 'dd/mm/yyyy hh24:mi:ss'))) * 1440) / nr_minuto_intervalo_w)), 0) 
						into	qt_hor_bloq_per_w 
						from	agenda_bloqueio a												 
						where 	a.cd_agenda   	= cd_agenda_p												 
						and		((obter_cod_dia_semana(dt_incrementa_w) = a.ie_dia_semana) or (a.ie_dia_semana = 9) or (a.ie_dia_semana is null)) 
						and		dt_incrementa_w	between trunc(a.dt_inicial) and fim_dia(trunc(a.dt_final)) 
						and		nvl(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;*/
 
						 
						qt_total_dias_efetivos_w 	:= qt_dias_efetivos_w 		+ qt_total_dias_efetivos_w;
						qt_total_hor_intervalo_w	:= qt_hor_intervalo_selec_w + qt_total_hor_intervalo_w;
						--qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w; 
						dt_incrementa_w  		 	:= dt_incrementa_w 			+ 1;	--(*) soma 1 dia a partir dt inicio até dt final 
					end loop;
				end if;
			end;		
		else 	--Se as datas de vigencia tiverem sido informadas... 
			begin 
				if (dt_dia_semana_w <> 9) then 			--se não for dias de trabalho... 
					for i in 0..qt_dias_vigencia_w 		--até total dias possíveis p/ agendamento (*) 
					loop						 
						if (hr_inicial_intervalo_w IS NOT NULL AND hr_inicial_intervalo_w::text <> '') and (hr_final_intervalo_w IS NOT NULL AND hr_final_intervalo_w::text <> '') then 
							--buscar qtd. de horário dentro do período de intervalo 
							select	coalesce(max(((((a.hr_final_intervalo - a.hr_inicial_intervalo) * 1440) / a.nr_minuto_intervalo))),0) 
							into STRICT	qt_hor_intervalo_selec_w 
							from	agenda_horario a												 
							where 	a.cd_agenda   	= cd_agenda_p 
							and  	a.nr_sequencia  	= nr_sequencia_p 
							and		obter_cod_dia_semana(dt_incrementa_w) = dt_dia_semana_w 
							and		(a.hr_inicial_intervalo IS NOT NULL AND a.hr_inicial_intervalo::text <> '') 
							and		(a.hr_final_intervalo IS NOT NULL AND a.hr_final_intervalo::text <> '') 
							and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
							/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
						end if;
						 
						select 	count(*) 
						into STRICT 	qt_dias_efetivos_w 
						 
						where 	obter_cod_dia_semana(dt_incrementa_w) = dt_dia_semana_w 
						and		dt_incrementa_w between trunc(dt_inicio_vigencia_w) and fim_dia(trunc(dt_final_vigencia_w)) 
						and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
						/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
												 
						--Validar(caso existir) a geração de horários bloqueados dentro do período 
						open C01;
						loop 
						fetch C01 into	 
							qt_hor_bloq_per_w;
						EXIT WHEN NOT FOUND; /* apply on C01 */
							begin 
							qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w;
							end;
						end loop;
						close C01;
						 
						/*select	nvl(((((nvl(a.hr_final_bloqueio, to_date('31/12/1899 '||hr_final_w, 'dd/mm/yyyy hh24:mi:ss')) - nvl(a.hr_inicio_bloqueio, to_date('31/12/1899 '||hr_inicial_w, 'dd/mm/yyyy hh24:mi:ss'))) * 1440) / nr_minuto_intervalo_w)), 0) 
						into	qt_hor_bloq_per_w 
						from	agenda_bloqueio a												 
						where 	a.cd_agenda   	= cd_agenda_p												 
						and		((obter_cod_dia_semana(dt_incrementa_w) = a.ie_dia_semana) or (a.ie_dia_semana = 9) or (a.ie_dia_semana is null)) 
						and		dt_incrementa_w	between trunc(a.dt_inicial) and fim_dia(trunc(a.dt_final)) 
						and		nvl(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;*/
 
												 
						qt_total_dias_efetivos_w 	:= qt_dias_efetivos_w 		+ qt_total_dias_efetivos_w;
						qt_total_hor_intervalo_w	:= qt_hor_intervalo_selec_w + qt_total_hor_intervalo_w;
						--qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w; 
						dt_incrementa_w  			:= dt_incrementa_w 		+ 1;	--(*) soma 1 dia a partir dt inicio até dt final 
					end loop;
				else 						-- caso o dia da semana seja "dias de trabalho" (9), soma todos desconsiderando os sabados e domingos 
					for i in 0..qt_dias_vigencia_w 		--até total dias possíveis p/ agendamento (*) 
					loop 
						if (hr_inicial_intervalo_w IS NOT NULL AND hr_inicial_intervalo_w::text <> '') and (hr_final_intervalo_w IS NOT NULL AND hr_final_intervalo_w::text <> '') then 
							--buscar qtd. de horário dentro do período de intervalo 
							select	coalesce(max(((((a.hr_final_intervalo - a.hr_inicial_intervalo) * 1440) / a.nr_minuto_intervalo))),0) 
							into STRICT	qt_hor_intervalo_selec_w 
							from	agenda_horario a												 
							where 	a.cd_agenda   	= cd_agenda_p 
							and  	a.nr_sequencia  	= nr_sequencia_p							 
							and		(a.hr_inicial_intervalo IS NOT NULL AND a.hr_inicial_intervalo::text <> '') 
							and		(a.hr_final_intervalo IS NOT NULL AND a.hr_final_intervalo::text <> '')					 
							and		obter_cod_dia_semana(dt_incrementa_w) not in (1,7) 
							and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
							/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
						end if;
						 
						select 	count(*) 
						into STRICT 	qt_dias_efetivos_w 
						 
						where 	obter_cod_dia_semana(dt_incrementa_w) not in (1,7) 
						and		dt_incrementa_w between trunc(dt_inicio_vigencia_w) and fim_dia(trunc(dt_final_vigencia_w)) 
						and		coalesce(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;
						/*and		not exists	(	select	x.nr_sequencia 
												from	agenda_bloqueio x 
												where	dt_incrementa_w	between trunc(x.dt_inicial) and fim_dia(trunc(x.dt_final)) 
												and		x.cd_agenda			= cd_agenda_p 
												and		((to_char(x.hr_inicio_bloqueio, 'hh24:mi:ss')		>= hr_inicial_w) or (x.hr_inicio_bloqueio is null)) 
												and		((to_char(x.hr_final_bloqueio, 'hh24:mi:ss')		<= hr_final_w) or (x.hr_final_bloqueio is null)));*/
 
												 
						--Validar(caso existir) a geração de horários bloqueados dentro do período 
						open C01;
						loop 
						fetch C01 into	 
							qt_hor_bloq_per_w;
						EXIT WHEN NOT FOUND; /* apply on C01 */
							begin 
							qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w;
							end;
						end loop;
						close C01;
						 
						/*select	nvl(((((nvl(a.hr_final_bloqueio, to_date('31/12/1899 '||hr_final_w, 'dd/mm/yyyy hh24:mi:ss')) - nvl(a.hr_inicio_bloqueio, to_date('31/12/1899 '||hr_inicial_w, 'dd/mm/yyyy hh24:mi:ss'))) * 1440) / nr_minuto_intervalo_w)), 0) 
						into	qt_hor_bloq_per_w 
						from	agenda_bloqueio a												 
						where 	a.cd_agenda   	= cd_agenda_p												 
						and		((obter_cod_dia_semana(dt_incrementa_w) = a.ie_dia_semana) or (a.ie_dia_semana = 9) or (a.ie_dia_semana is null)) 
						and		dt_incrementa_w	between trunc(a.dt_inicial) and fim_dia(trunc(a.dt_final)) 
						and		nvl(Obter_Se_Feriado(cd_estabelecimento_w, dt_incrementa_w),0) = 0;*/
 
						 
						qt_total_dias_efetivos_w 	:= qt_dias_efetivos_w 		+ qt_total_dias_efetivos_w;
						qt_total_hor_intervalo_w	:= qt_hor_intervalo_selec_w + qt_total_hor_intervalo_w;
						--qt_total_hor_bloq_per_w		:= qt_hor_bloq_per_w		+ qt_total_hor_bloq_per_w; 
						dt_incrementa_w  		 	:= dt_incrementa_w 			+ 1;	--(*) soma 1 dia a partir dt inicio até dt final 
					end loop;
				end if;
			end;
		end if;
		 
			dt_incrementa_w 	:= dt_inicial_p;
			qt_dias_vigencia_w 	:= dt_final_p - dt_inicial_p;
				for i in 0..qt_dias_vigencia_w			--até total dias possíveis p/ agendamento (*) 
				loop 
					select coalesce((sum(a.hr_final - a.hr_inicial) * 1440) / sum(a.nr_minuto_intervalo),0) 
					into STRICT 	qt_agendamento_hr_espec_w 
					from 	agenda_horario_esp a 
					where 	a.cd_agenda = cd_agenda_p 
					and		dt_incrementa_w between trunc(a.hr_inicial) and trunc(a.hr_final);
					 
					qt_total_agend_hr_espec_w 	:= qt_agendamento_hr_espec_w 	+ qt_total_agend_hr_espec_w;
					dt_incrementa_w  			:= dt_incrementa_w 				+ 1;	--(*) soma 1 dia a partir dt inicio até dt final 
				end loop;
				 
  select 	(((((((a.hr_final - a.hr_inicial) * 1440) / a.nr_minuto_intervalo)) * qt_total_dias_efetivos_w) + qt_total_agend_hr_espec_w) - qt_total_hor_intervalo_w) -- qt_total_hor_bloq_per_w 
  into STRICT 	qt_capacidade_w		--calculo para obter o total de agendamentos. 
  from  	agenda_horario a 
  where 	a.cd_agenda   	= cd_agenda_p 
  and   	a.nr_sequencia  	= nr_sequencia_p;	
	 
	/*if	(qt_capacidade_w < qt_total_hor_bloq_per_w)then 
		qt_capacidade_w	:= 0; 
	else 
		qt_capacidade_w	:= qt_capacidade_w - qt_total_hor_bloq_per_w; 
	end if;*/
 
 
  
return qt_capacidade_w;			--retorno total agendamentos, estes calculos não possuem consistências com feriados. 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION homg_obter_cap_ag_sem_bloq (cd_agenda_p bigint, nr_sequencia_p bigint, dt_inicial_p timestamp, dt_final_p timestamp) FROM PUBLIC;

