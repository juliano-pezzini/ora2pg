-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION cpoe_obter_proxima_data_proced ( dt_horario_p timestamp, nr_sequencia_p bigint, ds_horarios_p text) RETURNS timestamp AS $body$
DECLARE


ie_dia_semana_w		varchar(1);
ie_segunda_w		cpoe_procedimento.ie_segunda%type;
ie_terca_w		cpoe_procedimento.ie_terca%type;
ie_quarta_w		cpoe_procedimento.ie_quarta%type;
ie_quinta_w		cpoe_procedimento.ie_quinta%type;
ie_sexta_w		cpoe_procedimento.ie_sexta%type;
ie_sabado_w		cpoe_procedimento.ie_sabado%type;
ie_domingo_w		cpoe_procedimento.ie_domingo%type;
ie_dia_dif		bigint;
dt_inicio_cpoe_w		timestamp;
dt_horario_w		timestamp;
ds_horarios_w		varchar(255);
cont_w			smallint := 0;


BEGIN

-- Utilizado pra saber usa o by days
select	cpoe_obter_se_dia_diferenciado(nr_sequencia_p)
into STRICT	ie_dia_dif
;

-- Intervalo diferenciado por dias
if (ie_dia_dif IS NOT NULL AND ie_dia_dif::text <> '') then
	begin

	-- Buscar data inicio do Procedimento
	select	cpoe_obter_data_hora_form(max(dt_inicio), max(hr_prim_horario))
	into STRICT	dt_inicio_cpoe_w
	from	cpoe_procedimento
	where	nr_sequencia = nr_sequencia_p
	and		trunc(dt_inicio) >= trunc(clock_timestamp())
	and		(hr_prim_horario IS NOT NULL AND hr_prim_horario::text <> '');

	 -- Pegar o minimo pra data futura
	select	min(d.dt_procedimento)
	into STRICT	dt_horario_w
	from	cpoe_dias_procedimento d
	where	d.nr_seq_proc_cpoe = nr_sequencia_p
	and		trunc(d.dt_procedimento) >= trunc(clock_timestamp())
	order by dt_procedimento asc;

	if (dt_horario_w IS NOT NULL AND dt_horario_w::text <> '') then
		if (dt_inicio_cpoe_w IS NOT NULL AND dt_inicio_cpoe_w::text <> '') and (dt_inicio_cpoe_w < dt_horario_w) then
			return dt_inicio_cpoe_w;
		else
			return dt_horario_w;
		end if;
	end if;

	return dt_horario_p;
	end;

else
	begin
	dt_horario_w := dt_horario_p + 1;

	ds_horarios_w := obter_prim_dshorarios(ds_horarios_p);
	if	coalesce(ds_horarios_w::text, '') = '' then
		ds_horarios_w := to_char(dt_horario_p, 'hh24:mi');
	end if;

	select	max(ie_segunda),
		max(ie_terca),
		max(ie_quarta),
		max(ie_quinta),
		max(ie_sexta),
		max(ie_sabado),
		max(ie_domingo)
	into STRICT	ie_segunda_w,
		ie_terca_w,
		ie_quarta_w,
		ie_quinta_w,
		ie_sexta_w,
		ie_sabado_w,
		ie_domingo_w
	from	cpoe_procedimento
	where	nr_sequencia	= nr_sequencia_p;

	loop
		select	pkg_date_utils.get_WeekDay(dt_horario_w)
		into STRICT	ie_dia_semana_w
		;

		if (ie_dia_semana_w	= 1) and (ie_domingo_w		= 'S') then
			exit;
		elsif (ie_dia_semana_w	= 2) and (ie_segunda_w		= 'S') then
			exit;
		elsif (ie_dia_semana_w	= 3) and (ie_terca_w		= 'S') then
			exit;
		elsif (ie_dia_semana_w	= 4) and (ie_quarta_w		= 'S') then
			exit;
		elsif (ie_dia_semana_w	= 5) and (ie_quinta_w		= 'S') then
			exit;
		elsif (ie_dia_semana_w	= 6) and (ie_sexta_w		= 'S') then
			exit;
		elsif (ie_dia_semana_w	= 7) and (ie_sabado_w		= 'S') then
			exit;
		end if;

		dt_horario_w	:= dt_horario_w + 1;
		cont_w		:= cont_w + 1;

		-- condicao para nao entrar em looping caso nao houver dias pra gerar horario
		if (cont_w >= 7) then
			dt_horario_w := dt_horario_p + 1;
			exit;
		end if;
	end loop;

	return to_date(to_char(dt_horario_w, 'dd/mm/yyyy') || ' ' || ds_horarios_w || ':00', 'dd/mm/yyyy hh24:mi:ss');

	end;
end if;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION cpoe_obter_proxima_data_proced ( dt_horario_p timestamp, nr_sequencia_p bigint, ds_horarios_p text) FROM PUBLIC;

