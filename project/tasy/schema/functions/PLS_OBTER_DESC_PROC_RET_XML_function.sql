-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_obter_desc_proc_ret_xml ( nr_seq_conta_proc_p bigint, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type default null) RETURNS varchar AS $body$
DECLARE

 
ds_campo_w			varchar(255);
ds_procedimento_w		varchar(255);
ds_valor_w			varchar(255);
ds_valor_segundo_w		varchar(255);
ds_valor_campo_w		varchar(255);
ds_valor_campo_ww		varchar(255);
ds_valor_campo_pos_ww		varchar(255);
ds_valor_campo_pre_ww		varchar(255);
ds_material_w			varchar(255);
ds_anterior_w			varchar(100);
ds_posterior_w			varchar(100);
cd_prestador_exec_w		varchar(30);
nr_seq_prestador_exec_imp_w	varchar(20);
sg_cons_prest_solic_imp_w	varchar(20);
cd_cgc_executor_imp_w		varchar(14);
cd_cpf_executor_imp_w		varchar(11);
ie_campo_w			varchar(10);
cd_setor_atendimento_w		varchar(10);
cd_setor_atendimento_ww		varchar(10);
uf_crm_prest_solic_imp_w	varchar(2);
ie_via_acesso_w			varchar(1)	:= 'U';
nr_crm_prest_solic_imp_w	numeric(20);
nr_seq_prestador_exec_w		bigint;
nr_seq_regra_w			bigint;
nr_seq_apresentacao_w		bigint;
nr_seq_setor_atend_w		bigint;
nr_seq_fornecedor_mat_w		bigint;
qt_caracteres_w			bigint;
cd_estabelecimento_w		smallint;
ie_tipo_regra_retorno_w		smallint;
dt_procedimento_imp_w		timestamp;
nr_seq_prestador_regra_w	bigint;
cd_prestador_regra_w		varchar(30);
nr_seq_prestador_pgto_w		bigint;
nr_seq_conta_w			bigint;
qt_registros_w			integer;

/* 
Diego 27/05/2011 - OS 319313 
 
Esta rotina tem a finalidade de , durante a importação de arquivos xml de contas médicas, verificar se existe regras quanto a importação 
de campos especiais que não existem no schema TISS. 
 
Isto é realizado embutindo o valor do campo, não existente no TISS, em um campo existente demarcando o valor com caracteres especiais como # ou @. 
 
Na idéia original, por exemplo, iria ser embutido o setor do atendimento de um procedimento na descrição do mesmo sendo utilizado o caracter # para demarcação do inicio e fim. 
 
*/
 
 
C01 CURSOR FOR 
	SELECT	/* +USE_CONCAT */
 
		nr_sequencia, 
		ds_campo 
	from	pls_xml_regra_campo_esp 
	where	ie_situacao		= 'A' 
	and	ie_tipo_processo	= 'R' 
	and	((nr_seq_prestador_exec = coalesce(nr_seq_prestador_regra_w,nr_seq_prestador_exec)) or (coalesce(nr_seq_prestador_exec::text, '') = '')) 
	and	((cd_prestador_exec = coalesce(cd_prestador_regra_w,cd_prestador_exec)) or (coalesce(cd_prestador_exec::text, '') = '')) 
	and	clock_timestamp()	between coalesce(dt_inicio_vigencia,clock_timestamp() - interval '1 days') and coalesce(dt_fim_vigencia,clock_timestamp() + interval '1 days') 
and	((ds_campo = 'DS_PROCEDIMENTO' and (nr_seq_conta_proc_p IS NOT NULL AND nr_seq_conta_proc_p::text <> '')) or (ds_campo = 'DS_MATERIAL' and (nr_seq_conta_mat_p IS NOT NULL AND nr_seq_conta_mat_p::text <> ''))) 
	order by 
		coalesce(cd_prestador_exec,0), 
		coalesce(nr_seq_prestador_exec,0);

C02 CURSOR FOR 
	SELECT	ds_anterior, 
		ds_posterior, 
		ie_campo, 
		nr_seq_apresentacao, 
		qt_caracteres, 
		ie_tipo_regra_retorno 
	from	pls_xml_regra_esp_compl 
	where	nr_seq_regra = nr_seq_regra_w 
	order by 
		nr_seq_apresentacao;


BEGIN 
 
select	count(1) 
into STRICT	qt_registros_w 
from	pls_xml_regra_campo_esp 
where	ie_situacao		= 'A' 
and	ie_tipo_processo	= 'R';
 
if (qt_registros_w = 0) then 
	return '';
end if;
 
if (coalesce(nr_seq_conta_proc_p,0) > 0) then 
	select	coalesce(a.ds_procedimento_imp,pls_obter_desc_procedimento(a.cd_procedimento,a.ie_origem_proced)), 
		b.cd_cpf_executor_imp, 
		b.cd_cgc_executor_imp, 
		b.nr_seq_prestador_exec_imp, 
		b.nr_crm_prest_solic_imp, 
		b.sg_cons_prest_solic_imp, 
		b.uf_crm_prest_solic_imp, 
		c.cd_estabelecimento, 
		coalesce(a.dt_procedimento_imp,clock_timestamp()), 
		coalesce(a.ie_via_acesso,'U'), 
		b.nr_seq_prestador_exec, 
		c.nr_seq_prestador, 
		b.nr_sequencia 
	into STRICT	ds_procedimento_w, 
		cd_cpf_executor_imp_w, 
		cd_cgc_executor_imp_w, 
		nr_seq_prestador_exec_imp_w, 
		nr_crm_prest_solic_imp_w, 
		sg_cons_prest_solic_imp_w, 
		uf_crm_prest_solic_imp_w, 
		cd_estabelecimento_w, 
		dt_procedimento_imp_w, 
		ie_via_acesso_w, 
		nr_seq_prestador_exec_w, 
		nr_seq_prestador_regra_w, 
		nr_seq_conta_w 
	from	pls_conta_proc a, 
		pls_conta b, 
		pls_protocolo_conta c 
	where	a.nr_seq_conta 		= b.nr_sequencia 
	and	b.nr_seq_protocolo 	= c.nr_sequencia 
	and	a.nr_sequencia		= nr_seq_conta_proc_p;
	 
	select	max(nr_seq_prestador_pgto) 
	into STRICT	nr_seq_prestador_pgto_w 
	from	pls_conta_medica_resumo 
	where	nr_seq_conta_proc	= nr_seq_conta_proc_p 
	and	nr_seq_conta		= nr_seq_conta_w 
	and	ie_situacao		!= 'I';
	 
elsif (coalesce(nr_seq_conta_mat_p,0) > 0) then 
 
	begin 
	select	b.cd_cpf_executor_imp, 
		b.cd_cgc_executor_imp, 
		b.nr_seq_prestador_exec_imp, 
		b.nr_crm_prest_solic_imp, 
		b.sg_cons_prest_solic_imp, 
		b.uf_crm_prest_solic_imp, 
		c.cd_estabelecimento, 
		coalesce(ds_material_imp,pls_obter_desc_material(a.nr_seq_material)), 
		nr_seq_prestador_exec, 
		c.nr_seq_prestador, 
		coalesce(a.dt_atendimento_imp,clock_timestamp()), 
		b.nr_sequencia 
	into STRICT	cd_cpf_executor_imp_w, 
		cd_cgc_executor_imp_w, 
		nr_seq_prestador_exec_imp_w, 
		nr_crm_prest_solic_imp_w, 
		sg_cons_prest_solic_imp_w, 
		uf_crm_prest_solic_imp_w, 
		cd_estabelecimento_w, 
		ds_material_w, 
		nr_seq_prestador_exec_w, 
		nr_seq_prestador_regra_w, 
		dt_procedimento_imp_w, 
		nr_seq_conta_w 
	from	pls_protocolo_conta c, 
		pls_conta b, 
		pls_conta_mat a 
	where	a.nr_seq_conta 		= b.nr_sequencia 
	and	b.nr_seq_protocolo 	= c.nr_sequencia 
	and	a.nr_sequencia		= nr_seq_conta_mat_p;	
	exception 
	when others then 
		null;
	end;
	 
	select	max(nr_seq_prestador_pgto) 
	into STRICT	nr_seq_prestador_pgto_w 
	from	pls_conta_medica_resumo 
	where	nr_seq_conta_mat	= nr_seq_conta_mat_p 
	and	nr_seq_conta		= nr_seq_conta_w 
	and	ie_situacao		!= 'I';	
end if;
 
if (coalesce(nr_seq_prestador_regra_w::text, '') = '') then 
	nr_seq_prestador_regra_w:= pls_obter_prestador_imp(	cd_cgc_executor_imp_w, 
								cd_cpf_executor_imp_w, 
								nr_seq_prestador_exec_imp_w, 
								nr_crm_prest_solic_imp_w, 
								sg_cons_prest_solic_imp_w, 
								uf_crm_prest_solic_imp_w);
end if;
 
if (coalesce(nr_seq_prestador_exec_w::text, '') = '') then 
	nr_seq_prestador_exec_w	:= nr_seq_prestador_regra_w;
end if;
 
if (coalesce(nr_seq_prestador_pgto_w::text, '') = '') then 
	nr_seq_prestador_pgto_w	:= nr_seq_prestador_exec_w;
end if;
 
select	max(cd_prestador) 
into STRICT	cd_prestador_exec_w 
from	pls_prestador 
where	nr_sequencia	= nr_seq_prestador_pgto_w;
 
select	max(cd_prestador) 
into STRICT	cd_prestador_regra_w 
from	pls_prestador 
where	nr_sequencia	= nr_seq_prestador_regra_w;
 
/*Cursor que obtem a regra mais restritiva do cadastro de regres existente na função OPS - Cadastro de Regras > Contas Médicas > Regras especiais para importação do XML*/
 
open C01;
loop 
fetch C01 into 
	nr_seq_regra_w, 
	ds_campo_w; 	/*Campo existente no TISS que ira possuir tanto o valor correpondente ao campo quanto do campo não existente no TISS*/
EXIT WHEN NOT FOUND; /* apply on C01 */
end loop;
close C01;
 
if (ds_campo_w = 'DS_PROCEDIMENTO') then 
	ds_valor_campo_w := substr(ds_procedimento_w,1,120);	
elsif (ds_campo_w = 'DS_MATERIAL') then 
	ds_valor_campo_w := substr(ds_material_w,1,120);
end if;	
 
/*Cursor que verifica quais os caracteres de inicio e fim vai delimitar o valor do campo não existente no TISS e a qual campo este valor é referente*/
 
ds_valor_campo_ww	:= ds_valor_campo_w;
ds_valor_w		:= ds_valor_campo_w;
 
open C02;
loop 
fetch C02 into 
	ds_anterior_w, 
	ds_posterior_w, 
	ie_campo_w, 
	nr_seq_apresentacao_w, 
	qt_caracteres_w, 
	ie_tipo_regra_retorno_w;  /*Campo não existente no TISS ao qual o valor é referente*/
EXIT WHEN NOT FOUND; /* apply on C02 */
	begin 
	/*Valor enviado junto ao ds_procedimento_imp*/
 
	if (ds_campo_w in ('DS_PROCEDIMENTO','DS_MATERIAL')) then	 
		 
		if (coalesce(ds_valor_campo_w,'X') <> 'X') then				 
			/*Verificado caracter por caracter até achar o primeiro caracter que representa o inicio do valor 
			  Como esta ordenado por sequencia de apresentação, e é retirada cada novo valor encontrado referente a um campo, não sera necessário a consitência de que parte se esta verificando*/
			 
			 
			if (ie_campo_w = 'CP') then 
				ds_valor_w	:= ds_valor_w || '[' || cd_prestador_exec_w || ']';
			end if;
			 
			if (ie_campo_w = 'DR') then 
				ds_valor_w	:= ds_valor_w || '[' || to_char(dt_procedimento_imp_w,'YYYY-MM-DD') || ']';					
			end if;
			 
			if (ie_campo_w = 'VA') then 
				ds_valor_w	:= ds_valor_w || '[' || ie_via_acesso_w || ']';
			end if;
		end if;
		 
		if (ie_tipo_regra_retorno_w = 2) then 
			ds_valor_campo_ww	:= ds_valor_w;
		end if;
	end if;
	end;
end loop;
close C02;
 
return ds_valor_campo_ww;
 
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_obter_desc_proc_ret_xml ( nr_seq_conta_proc_p bigint, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type default null) FROM PUBLIC;

