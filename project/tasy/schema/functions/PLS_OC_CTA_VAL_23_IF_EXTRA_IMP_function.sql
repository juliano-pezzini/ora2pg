-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_oc_cta_val_23_if_extra_imp (dados_validacao_p pls_ocor_imp_pck.dados_regra_val_util_item, dados_conta_proc_p pls_ocor_imp_pck.dados_conta_proc, dados_conta_mat_p pls_ocor_imp_pck.dados_conta_mat, dados_outro_proc_p pls_ocor_imp_pck.dados_conta_proc, dados_outro_mat_p pls_ocor_imp_pck.dados_conta_mat, ie_proc_mat_p text) RETURNS varchar AS $body$
DECLARE

ie_valido_w	varchar(1) := 'S';
dt_val_inic_w	timestamp;
dt_val_fim_w	timestamp;

BEGIN

-- verificacoes que foram tiradas da clausula where do select por motivos de performance.

-- ocorre que ela sao buscadas da view pls_conta_proc_imp_v campos dt_procedimento, nr_seq_prestador_exec, cd_medico_executor e cd_procedimento

-- esses campos tem tratamentos especiais, pelo motivo que devem ser consideradas contas que inclusive ainda nao foram integradas

-- por isso que foi criada essa funcao.
if (dados_validacao_p.ie_somar_estrutura != 'S') then
	
	if (ie_proc_mat_p = 'P') then
	
		-- se o procedimento nao for igual desconsidera
		if not	((coalesce(dados_outro_proc_p.ie_origem_proced, 0) = coalesce(dados_conta_proc_p.ie_origem_proced, 0)) and (coalesce(dados_outro_proc_p.cd_procedimento, 0) = coalesce(dados_conta_proc_p.cd_procedimento, 0))) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;

	end if;
end if;

--Se regra estiver marcado como ie_guia_diferente, entao nao entra na contagem itens quando estiverem em contas co mesmo cd_guia_ok(cd_guia_referencia nas views)
if (dados_validacao_p.ie_guia_diferente = 'S') then

	if (ie_proc_mat_p = 'P') then
		if (dados_outro_proc_p.cd_guia_referencia = dados_conta_proc_p.cd_guia_referencia) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	else
		if (dados_outro_mat_p.cd_guia_referencia = dados_conta_mat_p.cd_guia_referencia) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	end if;

end if;


------------------------------------------------------------------------  IE_TIPO_PESSOA_QTDE  ------------------------------------------------------------------------  

-- IE_TIPO_PESSOA_QTDE: Aqui verifica o tipo de pessoa que deve ser verificado para buscar os itens antigos que contem apenas informacoes destas pessoas.


-- Ambos 

--Atende a glosa 9920(Retorno atendimento),,atributo ignorar o prestador da conta, 

--bastando marcar tipo de pessoa beneficiario, nao considerando prestador da conta nesse caso.
if (dados_validacao_p.ie_medico_prestador = 'S') then

	-- Quando for par verificar "Todos" os tipos de pessoa possiveis na regra entao so deve ser verificado os itens que tenham as mesmas informacoes de tais 

	-- pessoas que o item que esta sendo consistido. Por exemplo: Se for para verificar "Beneficiario"  e "Mesmo prestador executor" entao so podem ser contados 

	-- os itens que forem de contas do mesmo beneficiario e executadas pelo mesmo prestador.

	-- o prestador esta sendo verificado nessa funcao por motivos de performance e o segurado e verificado em pls_oc_cta_obter_rest_val_23

	
	-- se for procedimento
	if (ie_proc_mat_p = 'P') then

		-- se o prestador nao for igual desconsidera
		if not(coalesce(dados_outro_proc_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_proc_p.nr_seq_prestador_exec, 0)) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
			
	else

		-- se o prestador nao for igual desconsidera
		if not(coalesce(dados_outro_mat_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_mat_p.nr_seq_prestador_exec, 0)) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;

	end if;
elsif (dados_validacao_p.ie_medico_prestador = 'D') then
	if (ie_proc_mat_p = 'P') then

		-- se o prestador nao for igual desconsidera
		if	coalesce(dados_outro_proc_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_proc_p.nr_seq_prestador_exec, 0) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
			
	else

		-- se o prestador nao for igual desconsidera
		if	coalesce(dados_outro_mat_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_mat_p.nr_seq_prestador_exec, 0) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;

	end if;
end if;

------------------------------------------------------------------------  IE_REGRA_QTDE ------------------------------------------------------------------------  

-- IE_REGRA_QTDE: Aqui verifica a regra de verificacao que sera usada.

	
-- Mesmo profissional executor
if (dados_validacao_p.ie_mesmo_medico = 'S') and (dados_validacao_p.ie_medico_consistencia = 'C') then

	-- se for procedimento
	if (ie_proc_mat_p = 'P') then

		-- se o profissional executor nao for igual desconsidera
		if 	not(coalesce(dados_outro_proc_p.cd_medico_executor, 0) = coalesce(dados_conta_proc_p.cd_medico_executor,0)) then
			return 'N';
		end if;
	else
		-- se o profissional executor nao for igual desconsidera
		if not(coalesce(dados_outro_mat_p.cd_medico_executor,0) = coalesce(dados_conta_mat_p.cd_medico_executor,0)) then
			return 'N';
		end if;

	end if;
end if;

--Mesma categoria CID
if (dados_validacao_p.ie_mesma_categoria_cid = 'S') then

	if (ie_proc_mat_p = 'P') then
	
		-- se a categoria do cid nao for igual desconsidera
		if (coalesce(dados_outro_proc_p.cd_cat_cid,0) = coalesce(dados_conta_proc_p.cd_cat_cid,0)) or (dados_conta_proc_p.ie_tipo_guia <> '5') or (dados_outro_proc_p.ie_tipo_guia <> '5') then
			return 'N';
		end if;
	else
		if (coalesce(dados_outro_mat_p.cd_cat_cid,0) = coalesce(dados_conta_mat_p.cd_cat_cid,0)) or (dados_conta_mat_p.ie_tipo_guia <> '5') or (dados_outro_mat_p.ie_tipo_guia <> '5') then
			return 'N';
		end if;
	end if;

end if;

--Mesmo CID
if ( dados_validacao_p.ie_mesmo_cid = 'S') then
			
	if ( ie_proc_mat_p = 'P') then

		-- se o do cid nao for igual desconsidera
		if (coalesce(dados_outro_proc_p.cd_cid, 0) <> coalesce(dados_conta_proc_p.cd_cid, 0)) or (dados_conta_proc_p.ie_tipo_guia <> '5') or (dados_outro_proc_p.ie_tipo_guia <> '5') then	
			return 'N';
		end if;
	else
		if (coalesce(dados_outro_mat_p.cd_cid, 0) <> coalesce(dados_conta_mat_p.cd_cid, 0)) or (dados_conta_mat_p.ie_tipo_guia <> '5') or (dados_outro_mat_p.ie_tipo_guia <> '5') then	
			return 'N';
		end if;
	end if;
end if;

-- Mesma via acesso - Verificando se precisa tratar a mesma via de acesso
if (dados_validacao_p.ie_mesma_via_acesso = 'S') then
	if (ie_proc_mat_p = 'P') then
		-- se a mesma via de acesso nao for igual desconsidera
		if (coalesce(dados_outro_proc_p.ie_via_acesso, 0) <> coalesce(dados_conta_proc_p.ie_via_acesso, 0)) then		
    	    return 'N';
		end if;
	end if;
end if;

--Mesma especialidade(Nao precisa tratar para evento de importacao, ja popula essa informacao no campo quente ao importar)
if (dados_validacao_p.ie_mesma_especialidade = 'S') and (dados_validacao_p.ie_medico_consistencia = 'C') then

	if (ie_proc_mat_p = 'P') then
		-- se a especialidade do profissional  nao for igual desconsidera
		if not(coalesce(dados_outro_proc_p.nr_seq_cbo_saude,0) = coalesce(dados_conta_proc_p.nr_seq_cbo_saude,0)) then
			return 'N';
		end if;
	else
		-- se a especialidade do profissional  nao for igual desconsidera
		if not(coalesce(dados_outro_mat_p.nr_seq_cbo_saude,0) = coalesce(dados_conta_mat_p.nr_seq_cbo_saude,0)) then
			return 'N';
		end if;
	end if;
	
end if;

-- Anos
if (dados_validacao_p.ie_tipo_qtde = 'A') then
	-- Aqui verifica os itens lancados em um periodo de X Anos conforme definido pelo usuario no campo QT_TIPO_QUANTIDADE.

	-- Obs: deve se ter informacao neste campo para que o filtro seja aplicado.

	-- Se for para contar atendimentos posteriores ao que esta sendo consistido no momento, entao deve considerar atendimentos que foram lancados

	-- apos o procedimento dentro do periodo informado na regra do campo QT_TIPO_QUANTIDADE. Se nao considerar lancamentos posteriores 

	-- entao busca os procedimentos executados ate a data do procedimento.
	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- Quando for a consistencia no processo de importacao verifica a data apresentada pelo prestador

			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
			dt_val_fim_w := (add_months(dados_conta_proc_p.dt_procedimento, (dados_validacao_p.qt_tipo_quantidade * 12)));

			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
			dt_val_fim_w := (add_months(dados_conta_mat_p.dt_atendimento, (dados_validacao_p.qt_tipo_quantidade * 12)));

			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;

		end if;
		
	else		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
		
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
			dt_val_fim_w := dados_conta_proc_p.dt_procedimento;

			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
		
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
			dt_val_fim_w := dados_conta_mat_p.dt_atendimento;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	end if;	
	
-- Meses
elsif (dados_validacao_p.ie_tipo_qtde = 'M') then	
	-- Aqui verifica o periodo em meses na qual a ocorrencia busca os itens lancados.

	-- Se for para contar atendimentos posteriores ao que esta sendo consistido no momento, entao deve considerar atendimentos que foram lancados

	-- apos o procedimento dentro do periodo informado na regra do campo QT_TIPO_QUANTIDADE. Se nao considerar lancamentos posteriores 

	-- entao busca os procedimentos executados ate a data do procedimento. 
	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
	
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade)));
			dt_val_fim_w := (add_months(dados_conta_proc_p.dt_procedimento, (dados_validacao_p.qt_tipo_quantidade)));
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade)));
			dt_val_fim_w := (add_months(dados_conta_mat_p.dt_atendimento, (dados_validacao_p.qt_tipo_quantidade)));
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	else		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade)));
			dt_val_fim_w := dados_conta_proc_p.dt_procedimento;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade)));
			dt_val_fim_w := dados_conta_mat_p.dt_atendimento;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	end if;

-- Dias
elsif (dados_validacao_p.ie_tipo_qtde = 'D') then
	-- Aqui e verificado o periodo que sera buscado os itens por dia. Esta sendo verificado a data do item diminuindo ou adicionando a quantidade de dias informados no campo. 

			
	-- Se for para contar atendimentos posteriores ao que esta sendo consistido no momento, entao deve considerar atendimentos que foram lancados

	-- apos o procedimento dentro do periodo informado na regra do campo QT_TIPO_QUANTIDADE. Se nao considerar lancamentos posteriores 

	-- entao busca os procedimentos executados ate a data do procedimento.
	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
	
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := trunc(dados_conta_proc_p.dt_procedimento - (dados_validacao_p.qt_tipo_quantidade));
			dt_val_fim_w := fim_dia(dados_conta_proc_p.dt_procedimento + (dados_validacao_p.qt_tipo_quantidade));

			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := trunc(dados_conta_mat_p.dt_atendimento - (dados_validacao_p.qt_tipo_quantidade));
			dt_val_fim_w := fim_dia(dados_conta_mat_p.dt_atendimento + (dados_validacao_p.qt_tipo_quantidade));
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	else				
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := trunc(dados_conta_proc_p.dt_procedimento - (dados_validacao_p.qt_tipo_quantidade));
			dt_val_fim_w := fim_dia(dados_conta_proc_p.dt_procedimento);
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := trunc(dados_conta_mat_p.dt_atendimento - (dados_validacao_p.qt_tipo_quantidade));
			dt_val_fim_w := fim_dia(dados_conta_mat_p.dt_atendimento);
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		
		end if;
	end if;	
-- Horario
elsif (dados_validacao_p.ie_tipo_qtde = 'H') then
	-- Aqui e verificado o periodo que sera buscado os itens por dia e horas. Esta sendo verificado a data do item diminuindo ou adicionando a quantidade de dias informados no campo. 		

	-- se for procedimento
	if (ie_proc_mat_p = 'P') then
		
		-- calcula as datas do periodo que devem ser consideradas
		dt_val_inic_w := dados_conta_proc_p.dt_procedimento;

		-- se for  diferente do periodo e invalido
		if (dados_outro_proc_p.dt_procedimento != dt_val_inic_w) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	else
		-- calcula as datas do periodo que devem ser consideradas
		dt_val_inic_w := dados_conta_mat_p.dt_atendimento;
		
		-- se for  diferente do periodo e invalido
		if (dados_outro_mat_p.dt_atendimento != dt_val_inic_w) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	
	end if;
-- minutos
elsif (dados_validacao_p.ie_tipo_qtde = 'N') then

	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
	
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			dt_val_inic_w := dados_conta_proc_p.dt_procedimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
			dt_val_fim_w := dados_conta_proc_p.dt_procedimento + ((dados_validacao_p.qt_tipo_quantidade) / 1440);
					
			-- se nao estiver dentro do periodo e invalido			
			if ((not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w)) or coalesce(dados_outro_proc_p.dt_procedimento::text, '') = '') then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := dados_conta_mat_p.dt_atendimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
			dt_val_fim_w := dados_conta_mat_p.dt_atendimento + ((dados_validacao_p.qt_tipo_quantidade) /1440);

			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	else				
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			dt_val_inic_w := dados_conta_proc_p.dt_procedimento - ((dados_validacao_p.qt_tipo_quantidade)  /1440);
			dt_val_fim_w := dados_conta_proc_p.dt_procedimento;

			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
				dt_val_inic_w := dados_conta_mat_p.dt_atendimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento;

			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		
		end if;
	end if;	
end if;
	
return	ie_valido_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_oc_cta_val_23_if_extra_imp (dados_validacao_p pls_ocor_imp_pck.dados_regra_val_util_item, dados_conta_proc_p pls_ocor_imp_pck.dados_conta_proc, dados_conta_mat_p pls_ocor_imp_pck.dados_conta_mat, dados_outro_proc_p pls_ocor_imp_pck.dados_conta_proc, dados_outro_mat_p pls_ocor_imp_pck.dados_conta_mat, ie_proc_mat_p text) FROM PUBLIC;

