-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION mprev_obter_qt_atend (cd_agenda_p bigint, dt_agenda_p timestamp) RETURNS bigint AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Obter quantidade de agendamentos que o profissional/local de atendimento pode
ter em determinada data
-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[x] Objetos do dicionário [ X] Tasy (Delphi/Java)  []  Portal []  Relatórios [] Outros:
 ------------------------------------------------------------------------------------------------------------------
Pontos de atenção:

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
qt_minutos_inicial_w	bigint	:= 0;
qt_minutos_final_w	bigint	:= 0;
qt_total_minutos_w	bigint	:= 0;
qt_horarios_periodo_w	bigint	:= 0;
qt_horarios_w		bigint	:= 0;
cd_agenda_w		bigint	:= 0;
nr_dia_semana_w		smallint;
dt_ini_w		timestamp;
dt_fim_w		timestamp;

/* Turnos da agenda para o dia */

C01 CURSOR FOR
	SELECT	hr_inicial,
		hr_final,
		nr_minuto_intervalo,
		hr_inicial_intervalo,
		hr_final_intervalo
	from	agenda_turno
	where	cd_agenda = cd_agenda_w
	and (ie_dia_semana	= nr_dia_semana_w or (ie_dia_semana = '9' and pkg_date_utils.is_business_day(dt_agenda_p) = 1))
	and	dt_agenda_p between dt_inicio_vigencia and coalesce(dt_final_vigencia,dt_agenda_p);

/* Bloqueios da agenda para o dia */

c02 CURSOR FOR
	SELECT	a.hr_inicio_bloqueio,
		a.hr_final_bloqueio
	from	agenda_bloqueio a
	where	a.cd_agenda	= cd_agenda_w
	and	a.dt_inicial	<= fim_dia(dt_agenda_p)
	and	a.dt_final 	>= pkg_date_utils.start_of(dt_agenda_p,'DD',0);

/* Ausências da agenda para o dia */

BEGIN
nr_dia_semana_w	:=  pkg_date_utils.get_weekday(dt_agenda_p);
cd_agenda_w 	:= cd_agenda_p;

/* Primeiro abrir os turnos possíveis para aquele dia */

for cr01 in C01 loop
	begin
	/* Contar quantos horários do início do turno até início de intervalo, se não tiver intervalo, considera fim do turno */

	if (cr01.hr_inicial_intervalo IS NOT NULL AND cr01.hr_inicial_intervalo::text <> '') then
		qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_inicial, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_inicial, 0)));
		qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_inicial_intervalo, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_inicial_intervalo, 0)));
		qt_total_minutos_w	:= qt_minutos_final_w - qt_minutos_inicial_w;
		qt_horarios_periodo_w	:= trunc(qt_total_minutos_w / cr01.nr_minuto_intervalo);
		qt_horarios_w		:= qt_horarios_w + qt_horarios_periodo_w;
	else
		qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_inicial, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_inicial, 0)));
		qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_final, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_final, 0)));
		qt_total_minutos_w	:= qt_minutos_final_w - qt_minutos_inicial_w;
		qt_horarios_periodo_w	:= trunc(qt_total_minutos_w / cr01.nr_minuto_intervalo);
		qt_horarios_w		:= qt_horarios_w + qt_horarios_periodo_w;
	end if;
	/* Contar quantos horários do fim do intervalo até o fim do turno, se não tiver intervalo não considera */

	if (cr01.hr_final_intervalo IS NOT NULL AND cr01.hr_final_intervalo::text <> '') then
		qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_final_intervalo, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_final_intervalo, 0)));
		qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr01.hr_final, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr01.hr_final, 0)));
		qt_total_minutos_w	:= qt_minutos_final_w - qt_minutos_inicial_w;
		qt_horarios_periodo_w	:= trunc(qt_total_minutos_w / cr01.nr_minuto_intervalo);
		qt_horarios_w		:= qt_horarios_w + qt_horarios_periodo_w;
	end if;

	/* Descontar os horários ausência / bloqueio */

	for cr02 in C02 loop
		qt_minutos_inicial_w	:= ((pkg_date_utils.extract_field('HOUR', cr02.hr_inicio_bloqueio,0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr02.hr_inicio_bloqueio, 0)));
		qt_minutos_final_w	:= ((pkg_date_utils.extract_field('HOUR', cr02.hr_final_bloqueio, 0) * 60 ) + (pkg_date_utils.extract_field('MINUTE', cr02.hr_final_bloqueio, 0)));
		qt_total_minutos_w	:= qt_minutos_final_w - qt_minutos_inicial_w;
		qt_horarios_periodo_w	:= trunc(qt_total_minutos_w / cr01.nr_minuto_intervalo);
		qt_horarios_w		:= qt_horarios_w - qt_horarios_periodo_w;
	end loop;
	end;
end loop;


return	qt_horarios_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION mprev_obter_qt_atend (cd_agenda_p bigint, dt_agenda_p timestamp) FROM PUBLIC;

