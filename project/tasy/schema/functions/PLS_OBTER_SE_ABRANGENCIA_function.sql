-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_obter_se_abrangencia ( nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_segurado_p pls_segurado.nr_sequencia%type, nr_seq_plano_p pls_plano.nr_sequencia%type, nr_seq_prestador_p pls_prestador.nr_sequencia%type, nr_seq_cooperativa_p pls_congenere.nr_sequencia%type, dt_emissao_p timestamp, nm_usuario_p text) RETURNS varchar AS $body$
DECLARE

					
/*Esta rotina ira consistir a abrangencia geografica do atendimento da seguinte forma:

	O sistema ira buscar o tipo do segurado e pelo seu tipo ira consistir as informacoes  de abrangencia.
	tipos de segurado:
		A	Beneficiario de Servicos e coberturas adicionais 	= producao local
		B	Beneficiario de Plano de saude			= producao local
		P	Usuario de Pericia medica			= producao local
		I	Usuario eventual (Resp. Assumida)			= intercambio usuario eventual
		C	Intercambio entre OPS congeneres (Resp. Assumida)	= Repasse resp,Assumida
		T	Intercambio entre cooperativas (Resp. Assumida)		= Repasse resp,Assumida 
		R	Repasse para outra operadora  (Resp. Transferida)	= Intercambio de repasse de responsabilidade transferida (nao consiste abrangencia)

	Apos gerar a consistencia retorna para a rotina de geracao da glosa se a mesma sera gerada ou nao,  
	esta informacao e retornada pela variavel de retorno
	 IE_AREA_COBERTA_W	= 'S' - Nao ira gerar a glosa porque a area esta coberta
	 IE_AREA_COBERTA_W	= 'N' - Ira gerar a glosa porque a area nao esta coberta
*/
		
			
ie_area_coberta_w		varchar(1)	:= 'S';
ie_conta_autorizada_w           varchar(1);
qt_carater_internacao_w		integer;
qt_repasse_w			integer;
qt_resp_valido_w		integer;
qt_regra_repasse_w		integer;
ie_abrangencia_w		pls_plano.ie_abrangencia%type;
ie_tipo_conta_w			pls_conta.ie_tipo_conta%type;
ie_tipo_segurado_w		pls_segurado.ie_tipo_segurado%type;
nr_seq_outorgante_w		pls_outorgante.nr_sequencia%type;
ie_tipo_guia_w			pls_conta.ie_tipo_guia%type;
ie_carater_internacao_w		pls_conta.ie_carater_internacao%type;
cd_guia_referencia_w		pls_conta.cd_guia_referencia%type;
ie_origem_conta_w               pls_conta.ie_origem_conta%type;
ie_gerar_urgencia_emergencia_w	pls_regra_glosa_1215.ie_gera_urgencia_emergencia%type;

-- areas da cooperativa
c01 CURSOR(	nr_seq_cooperativa_pc	pls_congenere.nr_sequencia%type)FOR
	SELECT	a.cd_municipio_ibge,
		a.sg_estado,
		a.nr_seq_regiao
	from	pls_cooperativa_area	a
	where	a.nr_seq_cooperativa	= nr_seq_cooperativa_pc;

-- municipios do plano
c02 CURSOR(	nr_seq_plano_pc	pls_plano.nr_sequencia%type)FOR
	SELECT	a.cd_municipio_ibge,
		a.sg_estado,
		a.nr_seq_regiao
	from	pls_plano_area a
	where	a.nr_seq_plano	= nr_seq_plano_pc;

BEGIN
/*Se nao encaixar em nenhuma regra  gera a glosa*/

ie_area_coberta_w		:= 'N';

/*Obter valor maximo da tabela de regra da 1215*/

select 	max(ie_gera_urgencia_emergencia)
into STRICT	ie_gerar_urgencia_emergencia_w
from	pls_regra_glosa_1215;


/*Obtem as informacoes do beneficiario*/

select	max(a.ie_tipo_segurado)
into STRICT	ie_tipo_segurado_w
from	pls_segurado	a
where	a.nr_sequencia = nr_seq_segurado_p;

/*Obter as informacoes da conta*/

select	max(a.ie_tipo_conta),
	max(a.ie_tipo_guia),
	max(a.ie_carater_internacao),
	max(a.cd_guia_referencia),
        max(a.ie_origem_conta)
into STRICT	ie_tipo_conta_w,
	ie_tipo_guia_w,
	ie_carater_internacao_w,
	cd_guia_referencia_w,
        ie_origem_conta_w
from	pls_conta		a
where	a.nr_sequencia = nr_seq_conta_p;

/*Obter as informacoes nencessarias do plano*/

select	max(a.ie_abrangencia)	
into STRICT	ie_abrangencia_w
from	pls_plano	a
where	a.nr_sequencia 	= nr_seq_plano_p;
	
/*Obter a operadora que esta recebendo o arquivo, pegar a maior sequencia da tabela pois na mesma deve haver somente um registro*/

select	max(nr_sequencia)
into STRICT	nr_seq_outorgante_w
from	pls_outorgante;

/*Se o beneficiario e repasse*/

select	count(1)
into STRICT	qt_repasse_w
from	pls_segurado_repasse
where	nr_seq_segurado	= nr_seq_segurado_p
and	(( ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_emissao_p)	between  ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_repasse) and ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_fim_repasse))
or ( ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_emissao_p) >=  ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_repasse) and coalesce(dt_fim_repasse::text, '') = ''))
and ie_tipo_compartilhamento = 1
and	(dt_liberacao IS NOT NULL AND dt_liberacao::text <> '');

/*Se existe regra  de repasse cadastrada*/
	
select	count(1)
into STRICT	qt_regra_repasse_w
from	pls_regra_intercambio_aut;


/*Ira buscar se a conta esta autorizada*/

if (ie_origem_conta_w = 'E')      then
        ie_conta_autorizada_w := pls_obter_se_conta_autorizada(nr_seq_conta_p, 'IA');
else
        ie_conta_autorizada_w := pls_obter_se_conta_autorizada(nr_seq_conta_p, 'X');
end if;

/*Se for guia de honorario devera considerar o carater de internacao da guia de referencia
verifica se o parametro na funcao OPS - Glosas e Ocorrencias ira verificar o campo carater solicitacao*/
if (ie_gerar_urgencia_emergencia_w = 'S' or coalesce(ie_gerar_urgencia_emergencia_w::text, '') = '')  then
	if (ie_tipo_guia_w = '6')	then
		select	count(1)
		into STRICT 	qt_carater_internacao_w
		from	pls_conta	a
		where	a.cd_guia_referencia	= cd_guia_referencia_w
		and	a.ie_carater_internacao = 'U'  LIMIT 1;
		
		if (qt_carater_internacao_w > 0)	then
			ie_carater_internacao_w	:= 'U';
		else
			ie_carater_internacao_w	:= 'X';
		end if;	
	end if;
	
elsif (ie_gerar_urgencia_emergencia_w = 'N')	then
	ie_carater_internacao_w	:= 'X';
end if;

/*Se for urgencia emergencia ou a conta estiver autorizada nao gera glosa*/

if (ie_carater_internacao_w <> 'U' or coalesce(ie_carater_internacao_w::text, '') = '') and (ie_conta_autorizada_w = 'N')   then

        if (ie_tipo_segurado_w not in ('T','C'))	then
		/*Consistir repasse  -  Primeiro tem que verificar se o beneficiario e de repasse, se for repasse verifica se existe regra de repasse , se existir consiste como repasse.*/
				  
		if (qt_repasse_w	> 0)	and (qt_regra_repasse_w > 0) then
			ie_area_coberta_w	:= 	pls_obter_se_repas_abrang(nr_seq_segurado_p, nr_seq_cooperativa_p, nm_usuario_p,ie_tipo_conta_w,dt_emissao_p);
							
		/*Consistir a abrangencia de usuarios de  INTERCAMBIO*/

		elsif (ie_tipo_conta_w 	= 'I')	then /*Intercambio e Intercambio cobranca*/
		
			ie_area_coberta_w	:=	pls_obter_abran_int(	nr_seq_prestador_p,nr_seq_segurado_p,nr_seq_cooperativa_p,
										nr_seq_outorgante_w, nr_seq_plano_p,ie_abrangencia_w);
									
										
		/*Consistir a abrangencia de producao local*/

		elsif (ie_tipo_segurado_w in ('A','B','P'))	then
			
			ie_area_coberta_w	:=	pls_obter_abran_prest(	nr_seq_prestador_p,nr_seq_segurado_p,nr_seq_outorgante_w,
										nr_seq_plano_p,ie_tipo_segurado_w,dt_emissao_p,
										ie_abrangencia_w);
		/*Consistir a abrangencia de  USUARIO EVENTUAL*/

		elsif (ie_tipo_segurado_w in ('I','H'))	then
			
			ie_area_coberta_w	:= 	pls_obter_abran_event(	nr_seq_prestador_p, nr_seq_segurado_p, nr_seq_cooperativa_p,
										nr_seq_plano_p, ie_abrangencia_w);
		else
			ie_area_coberta_w	:= 'N';												
		end if;
		
		-- quando for conta de A500, considerar a abrangencia entre as unimeds, caso ja nao tenha area de cobertura
		if (ie_origem_conta_w = 'A') and (ie_area_coberta_w = 'N') then
			
			-- carrega as cooperativas
			for r_c01_w in c01(nr_seq_cooperativa_p) loop
				-- navega entre os municipios do plano
				for r_c02_w in c02(nr_seq_plano_p) loop
					-- Se o municipio da operadora executora esta no estado da cooperativa
					if (pls_obter_se_municipio_em_uf(r_c02_w.cd_municipio_ibge, r_c01_w.sg_estado)	= 'S') then
						ie_area_coberta_w	:= 'S';
						exit;
					-- Se o municipio da cooperativa esta no estado da operadora executora
					elsif (pls_obter_se_municipio_em_uf(r_c01_w.cd_municipio_ibge, r_c02_w.sg_estado)	= 'S') then
						ie_area_coberta_w	:= 'S';
						exit;
					end if;
				end loop;
				-- se ja achou uma area coberta, pode sair do loop
				if (ie_area_coberta_w = 'S') then
				
					exit;
				end if;
			end loop;
		end if;
		
		/*validacao para responsabilidades assumidas.*/

	elsif (ie_tipo_segurado_w in ('T','C'))then
		
		select	count(1)
		into STRICT	qt_resp_valido_w
		from	pls_segurado
		where	nr_sequencia = nr_seq_segurado_p
		and	(( ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_emissao_p) between  ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_contratacao) and  ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_rescisao))
		or ( ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_emissao_p) >  ESTABLISHMENT_TIMEZONE_UTILS.startOfDay(dt_contratacao) and coalesce(dt_rescisao::text, '') = ''));
		
		if (qt_resp_valido_w = 0)	and
			((ie_tipo_segurado_w = 'T') and (ie_tipo_conta_w <> 'I') or (ie_tipo_segurado_w = 'C'))then
			
			/*Quando for Resp assumida de  cooperativas, se nao estiver dentro de uma data valida, sera validado como usuario eventual*/

			if (ie_tipo_segurado_w = 'T')	then
				ie_area_coberta_w	:= 	pls_obter_abran_event(	nr_seq_prestador_p, nr_seq_segurado_p, nr_seq_cooperativa_p,
											nr_seq_plano_p, ie_abrangencia_w);
			else
				ie_area_coberta_w	:= 'N';
			end if;
		
		elsif (ie_tipo_conta_w 	= 'I')	then
			ie_area_coberta_w	:=	pls_obter_abran_int(	nr_seq_prestador_p,nr_seq_segurado_p,nr_seq_cooperativa_p,
										nr_seq_outorgante_w,nr_seq_plano_p,ie_abrangencia_w);
		else
			ie_area_coberta_w	:= 'S';
		end if;
	else
		ie_area_coberta_w	:= 'S';
	
	end if;
else
	ie_area_coberta_w	:= 'S';
end if;

return ie_area_coberta_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_obter_se_abrangencia ( nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_segurado_p pls_segurado.nr_sequencia%type, nr_seq_plano_p pls_plano.nr_sequencia%type, nr_seq_prestador_p pls_prestador.nr_sequencia%type, nr_seq_cooperativa_p pls_congenere.nr_sequencia%type, dt_emissao_p timestamp, nm_usuario_p text) FROM PUBLIC;

