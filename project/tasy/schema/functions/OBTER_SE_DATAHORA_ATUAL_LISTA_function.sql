-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



CREATE TYPE campos_dias_semana AS (
	ds_dia_semana	varchar(3)
);
CREATE TYPE campos_horarios AS (
	ds_hora_inicial	varchar(7),
	ds_hora_final	varchar(7)
);
CREATE TYPE campos AS (
	dias_semana	tabela_dias_semana,
	horarios	tabela_horarios
);


CREATE OR REPLACE FUNCTION obter_se_datahora_atual_lista (ds_lista_data_hora_p text, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type default null) RETURNS varchar AS $body$
DECLARE


/*
Valor do atributo para que a regra seja atendida.
Caso o atributo selecionado for "Dias da semana / horários", o valor deverá ser da seguinte forma:

caracteres:
HIFEN (-): separador de intervalos.
	Exemplos:
		. das 08:00 às 11:59 = 08:00-11:59;
		. de segunda à sexta = SEG-SEX.
VIRGULA (,): separador de informações.
	Exemplos:
		. segundas e quartas = SEG,QUA;
		. das 08:00 às 11:59 e das 13:30 às 17:59 = 08:00-11:59,13:30-17:59.
BARRA (/): separador de dias da semana e horários.
	Exemplo:
		. de segunda à sexta, das 08:00, às 17:00 = SEG-SEX/08:00-17:00.
PONTO-E-VIRGULA (;): separador de informações, para combinar dias com horários diferentes.
	Exemplo:
		. segundas, quartas e sextas, o dia inteiro, terças e quintas, das 13:00 às 17:00:
			SEG,QUA,SEX/00:00-23:59;TER,QUI/13:00-17:00.

REGRAS PARA FERIADOS: utilizar a abreviação FER.
	Exemplo:
		. sábados, domingos e feriados, das 13:00 às 17:00 = SÁB,DOM,FER/13:00-17:00.
	Obs.: não é possível utilizar feriados combinados com intervalos (ex.: SÁB-FER).

Existe a possibilidade de combinações para os dias da semana, por exemplo: SEG,QUA-SEX envolverá as segundas, quartas, quintas e sextas.

outros exemplos:
segundas, quartas, quintas e sextas, das 08:00 às 11:59, das 13:00 às 16:59 e das 19:00 às 23:59:
	SEG,QUA-SEX/08:00-11:59,13:00-16:59,19:00-23:59;
 de segunda à sexta feira, das 08:00 às 17:00:
	SEG-SEX/08:00-17:00;
segundas, quartas e sextas, das 00:00 às 23:59, e terças e quintas, das 13:00 às 17:00:
	SEG,QUA,SEX/00:00-23:59;TER,QUI/13:00-17:00
*/
cd_estabelecimento_w	estabelecimento.cd_estabelecimento%type;
ds_retorno_w		varchar(1) := 'S';
ds_sigla_feriado_w	varchar(10) := 'FER';
ds_dia_w		varchar(10);
ie_hoje_feriado_w	varchar(1) := 'N';
ie_regra_com_feriado_w	varchar(1) := 'N';

ds_lista_data_hora_w	varchar(255);
ds_data_hora_w		varchar(255);
ds_dias_semana_w	varchar(255);
ds_horas_w		varchar(255);

ds_dia_semana_w		varchar(255);
ds_hora_inicial_w	varchar(10);
ds_hora_final_w		varchar(10);

dia_ini_w		smallint;
dia_fim_w		smallint;

variavel_para_testar_w	varchar(255);

posicao_w		integer;
z			integer;
x			integer;
y			integer;
type tabela_dias_semana is table of campos_dias_semana index by integer;
type tabela_horarios is table of campos_horarios index by integer;
type tabela is table of campos index by integer;
dias_w			tabela;

ds_dia_semana_ok	varchar(1);


BEGIN

select	upper(obter_desc_expressao(733979))
into STRICT	ds_sigla_feriado_w
;

if (coalesce(cd_estabelecimento_p::text, '') = '') then
	cd_estabelecimento_w	:= wheb_usuario_pck.get_cd_estabelecimento;
else
	cd_estabelecimento_w	:= cd_estabelecimento_p;
end if;

if (Obter_Se_Feriado(cd_estabelecimento_w, clock_timestamp()) > 0) then
	ie_hoje_feriado_w := 'S';
end if;

/* montagem das tabelas com os dias e seus horários */

ds_lista_data_hora_w := UPPER(ds_lista_data_hora_p);
if (substr(ds_lista_data_hora_w, length(ds_lista_data_hora_w), 1) <> ';') then
	ds_lista_data_hora_w := ds_lista_data_hora_w || ';';
end if;

z := 0;
dias_w.delete;
while(ds_lista_data_hora_w IS NOT NULL AND ds_lista_data_hora_w::text <> '') loop
	z 				:= z + 1;
	posicao_w			:= position(';' in ds_lista_data_hora_w);
	ds_data_hora_w			:= substr(ds_lista_data_hora_w, 1, posicao_w-1);
	ds_lista_data_hora_w		:= substr(ds_lista_data_hora_w, posicao_w+1, length(ds_lista_data_hora_w));

	posicao_w			:= position('/' in ds_data_hora_w);
	ds_dias_semana_w		:= substr(ds_data_hora_w, 1, posicao_w-1);
	if (substr(ds_dias_semana_w, length(ds_dias_semana_w), 1) <> ',') then
		ds_dias_semana_w := ds_dias_semana_w || ',';
	end if;

	ds_data_hora_w			:= substr(ds_data_hora_w, posicao_w+1, length(ds_data_hora_w));
	if (substr(ds_data_hora_w, length(ds_data_hora_w), 1) <> ',') then
		ds_data_hora_w := ds_data_hora_w || ',';
	end if;

	x := 0;
	while(ds_dias_semana_w IS NOT NULL AND ds_dias_semana_w::text <> '') loop
		posicao_w			:= position(',' in ds_dias_semana_w);
		ds_dia_semana_w			:= substr(ds_dias_semana_w, 1, posicao_w-1);
		ds_dias_semana_w		:= substr(ds_dias_semana_w, posicao_w+1, length(ds_dias_semana_w));

		posicao_w			:= position('-' in ds_dia_semana_w);

		-- utilizado o next_day, pois passando o dia da semana abreviado retorna o número do dia correspondente. Também serve para validar as abreviações dos dias da semana.
		if (posicao_w > 0) then
			ds_dia_w := substr(ds_dia_semana_w, 1, posicao_w-1);
			if (ds_dia_w = ds_sigla_feriado_w) then -- identifica se algum dos dias que utilizam o hifen é feriado, e aborta com a mensagem, pois não tem como utulizar o feriado como intervalo
				CALL wheb_mensagem_pck.exibir_mensagem_abort(492265); --O feriado não pode ser utilizado como intervalo de dias!
			end if;
			dia_ini_w	:= pkg_date_utils.get_WeekDay(next_day(clock_timestamp(), ds_dia_w));

			ds_dia_w := substr(ds_dia_semana_w, posicao_w+1, length(ds_dia_semana_w));
			if (ds_dia_w = ds_sigla_feriado_w) then -- identifica se algum dos dias que utilizam o hifen é feriado, e aborta com a mensagem, pois não tem como utulizar o feriado como intervalo
				CALL wheb_mensagem_pck.exibir_mensagem_abort(492265); --O feriado não pode ser utilizado como intervalo de dias!
			end if;
			dia_fim_w	:= pkg_date_utils.get_WeekDay(next_day(clock_timestamp(), ds_dia_w));

			if (dia_fim_w < dia_ini_w) then
				dia_fim_w	:= dia_fim_w + 7;
			end if;

			y := dia_ini_w;
			while(y <= dia_fim_w) loop
				x := x + 1;
				dias_w[z].dias_semana(x).ds_dia_semana := to_char(trunc(clock_timestamp(), 'DAY')+mod(y,7)-1, 'DY');
				y := y + 1;
			end loop;
		else
			if (ds_dia_semana_w = ds_sigla_feriado_w) then
				ie_regra_com_feriado_w := 'S';
			else
				-- com a linha abaixo pode-se realizar o teste para identificar se os horários estão corretos (utilizado na trigger para não deixar salvar caso estiver com valores que possam gerar erro na utilização).
				dia_ini_w	:= pkg_date_utils.get_WeekDay(next_day(clock_timestamp(), ds_dia_semana_w));
			end if;
			x := x + 1;
			dias_w[z].dias_semana(x).ds_dia_semana := ds_dia_semana_w;
		end if;
	end loop;

	x := 0;
	while(ds_data_hora_w IS NOT NULL AND ds_data_hora_w::text <> '') loop
		x				:= x + 1;
		posicao_w			:= position(',' in ds_data_hora_w);
		ds_horas_w			:= substr(ds_data_hora_w, 1, posicao_w-1);
		ds_data_hora_w			:= substr(ds_data_hora_w, posicao_w+1, length(ds_data_hora_w));

		posicao_w				:= position('-' in ds_horas_w);
		if (posicao_w = 0) then
			CALL wheb_mensagem_pck.exibir_mensagem_abort(54643); --É necessário o preenchimento da hora inicial/Final !
		end if;
		if (position('AM' in ds_horas_w) > 0) or (position('PM' in ds_horas_w) > 0) then
			if (length(substr(ds_horas_w, 1, posicao_w-1)) <> 7) or (length(substr(ds_horas_w, posicao_w+1, length(ds_horas_w))) <> 7) then
				CALL wheb_mensagem_pck.exibir_mensagem_abort(262527); --Hora informada inválida, verifique!
			end if;
		else
			if (length(substr(ds_horas_w, 1, posicao_w-1)) <> 5) or (length(substr(ds_horas_w, posicao_w+1, length(ds_horas_w))) <> 5) then
				CALL wheb_mensagem_pck.exibir_mensagem_abort(262527); --Hora informada inválida, verifique!
			end if;
		end if;


		dias_w[z].horarios(x).ds_hora_inicial	:= substr(ds_horas_w, 1, posicao_w-1);
		dias_w[z].horarios(x).ds_hora_final	:= substr(ds_horas_w, posicao_w+1, length(ds_horas_w));


		-- com as linhas abaixo pode-se realizar o teste para identificar se os horários estão corretos (utilizado na trigger para não deixar salvar caso estiver com valores que possam gerar erro na utilização).
		if (position('AM' in ds_horas_w) > 0) or (position('PM' in ds_horas_w) > 0) then
			variavel_para_testar_w	:= to_char(to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || substr(ds_horas_w, 1, posicao_w-1), 'dd/mm/yyyy hh:miAM'));
			variavel_para_testar_w	:= to_char(to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || substr(ds_horas_w, posicao_w+1, length(ds_horas_w)), 'dd/mm/yyyy hh:miAM'));
		else
			variavel_para_testar_w	:= to_char(to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || substr(ds_horas_w, 1, posicao_w-1) || ':00', 'dd/mm/yyyy hh24:mi:ss'));
			variavel_para_testar_w	:= to_char(to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || substr(ds_horas_w, posicao_w+1, length(ds_horas_w)) || ':00', 'dd/mm/yyyy hh24:mi:ss'));
		end if;
	end loop;

end loop;

if (dias_w.count > 0) then
	ds_retorno_w := 'N';
end if;

-- abaixo é a parte em que é feita a leitura do array para validar o sysdate (verificar se o dia atual encaixa-se à alguma regra do array)
z := 1;
while(z <= dias_w.count) and (ds_retorno_w = 'N') loop
	x := 1;
	ds_dia_semana_ok := 'N';
	while(x <= dias_w[z].dias_semana.count) and (ds_dia_semana_ok = 'N') loop
		-- se a regra tem FER e o sysdate é um feriado, somente vai consistir a regra do FER, se o sysdate não for feriado, consiste o dia da semana
		if (ie_regra_com_feriado_w = 'S') then
			if	((ie_hoje_feriado_w = 'N') and (dias_w[z].dias_semana(x).ds_dia_semana = to_char(clock_timestamp(),'DY')) or
				((ie_hoje_feriado_w = 'S') and (dias_w[z].dias_semana(x).ds_dia_semana = ds_sigla_feriado_w))) then
				ds_dia_semana_ok := 'S';
			end if;
		else -- se  a regra não contém FER, apenas consiste o dia da semana
			if (dias_w[z].dias_semana(x).ds_dia_semana = to_char(clock_timestamp(),'DY')) then
				ds_dia_semana_ok := 'S';
			end if;
		end if;
		x := x + 1;
	end loop;

	if (ds_dia_semana_ok = 'S') then
		x := 1;
		while(x <= dias_w[z].horarios.count) and (ds_retorno_w = 'N') loop
			if (position('AM' in dias_w[z].horarios(x).ds_hora_inicial) > 0) or (position('PM' in dias_w[z].horarios(x).ds_hora_inicial) > 0) then
				if (clock_timestamp() >= to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || dias_w[z].horarios(x).ds_hora_inicial, 'dd/mm/yyyy hh:miAM')) and (clock_timestamp() <= to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || dias_w[z].horarios(x).ds_hora_final, 'dd/mm/yyyy hh:miAM')+59/24/60/60) then --adiciona 59 segundos à data
				ds_retorno_w := 'S';
				end if;
			else
				if (clock_timestamp() >= to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || dias_w[z].horarios(x).ds_hora_inicial || ':00', 'dd/mm/yyyy hh24:mi:ss')) and (clock_timestamp() <= to_date(to_char(clock_timestamp(),'dd/mm/yyyy') || ' ' || dias_w[z].horarios(x).ds_hora_final   || ':59', 'dd/mm/yyyy hh24:mi:ss')) then
				ds_retorno_w := 'S';
				end if;
			end if;
			x := x + 1;
		end loop;
	end if;
	z := z + 1;
end loop;

return	ds_retorno_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION obter_se_datahora_atual_lista (ds_lista_data_hora_p text, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type default null) FROM PUBLIC;

