-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pfcs_get_alarms_trends ( nr_seq_patient_p bigint, nr_seq_encounter_p bigint, ie_type_p text ) RETURNS varchar AS $body$
DECLARE


/*
    This function return Alarms count/ Alarms Trend values based on the rule type (ie_type_p)
    ie_type_p:
        -- RED: will return the red alarms count
        -- YELLOW: will return the yellow alarms count
        -- TREND: will return the Alarms Trend
*/
ds_start_time         varchar(20);
dt_started_time       pfcs_patient_flag.period_start%type;
dt_interleave_time    pfcs_patient_flag.period_start%type;
nr_red_alarms         bigint := 0;
nr_yellow_alarms      bigint := 0;
ds_out_pixel_var      varchar(100) := null;
qt_time_alarm         smallint := 0;
time_interval         smallint := 0;
qt_red_alarms         bigint := 0;
qt_yellow_alarms      bigint := 0;
nr_red_alarm_count    bigint := 0;
nr_yellow_alarm_count bigint := 0;
ds_return_w           varchar(100) := null;
ds_intermediateValue_w  varchar(100) := null;

BEGIN
  -- Get hours configurable from telemetry settings
  select coalesce(max(qt_time_alarm_trend_rule),12) into STRICT qt_time_alarm from pfcs_telemetry_config;

  select trunc(clock_timestamp()) + ( round ( (clock_timestamp() - trunc(clock_timestamp())) * 48) / 48 ) into STRICT dt_started_time;

  -- if hours = 8 then the last 8 hours alrams will be taken consideration by using 1 hour internal
  -- if hours = 12 then the last 12 hours alrams will be taken consideration by taking 1.5 hour internal
  -- if hours = 24 then the last 24 hours alrams will be taken consideration by taking 2 hour internal
  if (qt_time_alarm = 8) then
    time_interval := 1;
  elsif (qt_time_alarm = 12) then
    time_interval := 1.5;
  elsif (qt_time_alarm = 24) then
    time_interval := 2;
  else
     time_interval := 1;
  end if;

  select dt_started_time - (time_interval/24) into STRICT dt_interleave_time;
  for counter in 1..8 loop
    nr_yellow_alarms := 0;
    nr_red_alarms:= 0;
    ds_intermediateValue_w := null;

    select count(ds_flag) into STRICT nr_red_alarms
    from pfcs_patient_flag where nr_seq_patient = nr_seq_patient_p
    and cd_flag = pfcs_pck_constants.cd_red_alert
    and period_start  >= dt_interleave_time
    and period_start  <= dt_started_time;

    select count(ds_flag) into STRICT nr_yellow_alarms
    from pfcs_patient_flag where nr_seq_patient = nr_seq_patient_p
    and cd_flag = pfcs_pck_constants.cd_yellow_alert
    and period_start  >= dt_interleave_time
    and period_start  <= dt_started_time;

    dt_started_time := dt_interleave_time;

    select dt_started_time - (time_interval/24) into STRICT dt_interleave_time; -- here 1 must be configurable.
    nr_red_alarm_count  := nr_red_alarm_count  + nr_red_alarms;
    nr_yellow_alarm_count  := nr_yellow_alarm_count  + nr_yellow_alarms;

    if (nr_red_alarms = 0 and nr_yellow_alarms = 0) then
        ds_intermediateValue_w := 'n,0';
    elsif (nr_red_alarms > 0 and nr_red_alarms >= nr_yellow_alarms) then
		ds_intermediateValue_w := 'r,' || nr_red_alarms;
		qt_red_alarms := qt_red_alarms + nr_red_alarms;
    elsif (nr_yellow_alarms > 0 and nr_red_alarms < nr_yellow_alarms) then
		ds_intermediateValue_w := 'y,' || nr_yellow_alarms;
		qt_yellow_alarms := qt_yellow_alarms + nr_yellow_alarms;
    end if;

    if (coalesce(ds_out_pixel_var::text, '') = '') then
        ds_out_pixel_var := ds_intermediateValue_w;
    else
        ds_out_pixel_var := ds_out_pixel_var || ';' || ds_intermediateValue_w;
    end if;

  end loop;

  if (qt_red_alarms > 0) then
	ds_out_pixel_var := ds_out_pixel_var || ';ra,'|| qt_red_alarms;
  end if;

  if (qt_yellow_alarms > 0) then
	ds_out_pixel_var := ds_out_pixel_var || ';ya,'|| qt_yellow_alarms;
  end if;

  if (ie_type_p = 'RED') then
    ds_return_w := to_char(nr_red_alarm_count);
  elsif (ie_type_p = 'YELLOW') then
    ds_return_w := to_char(nr_yellow_alarm_count);
  elsif (ie_type_p = 'TREND') then
    ds_return_w := ds_out_pixel_var;
  end if;

 return ds_return_w;

 	exception
	-- If there will be no record
	when no_data_found then
	  return ds_out_pixel_var;
end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pfcs_get_alarms_trends ( nr_seq_patient_p bigint, nr_seq_encounter_p bigint, ie_type_p text ) FROM PUBLIC;

