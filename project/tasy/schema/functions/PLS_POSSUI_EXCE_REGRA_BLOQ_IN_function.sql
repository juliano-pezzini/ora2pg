-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_possui_exce_regra_bloq_in ( nr_seq_regra_p pls_regra_cta_bloq_integ.nr_sequencia%type, nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_prestador_p pls_regra_cta_bloq_integ.nr_seq_prestador%type, ie_conta_recurso_p pls_regra_cta_bloq_integ.ie_conta_recurso%type, ie_nova_imp_xml_p text) RETURNS bigint AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:  Verifica se a regra de bloqueio de integração possui uma excecão válida,

-------------------------------------------------------------------------------------------------------------------
Locais de chamada direta:
[ ]  Objetos do dicionário [ ] Tasy (Delphi/Java) [ X ] Portal [  ]  Relatórios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------
Pontos de atenção:

Alterações
-------------------------------------------------------------------------------------------------------------------
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
-- Carrega as exceções
c01 CURSOR(	nr_seq_regra_pc		pls_regra_cta_bloq_integ.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia,
		a.nr_seq_prestador,
		a.dt_atendimento_inicio,
		a.dt_atendimento_fim
	from	pls_excecao_cta_bloq_integ	a
	where	a.nr_seq_regra			= nr_seq_regra_pc;

ds_retorno_w		pls_excecao_cta_bloq_integ.nr_sequencia%type;
ie_entrou_regra_w	varchar(1);
dia_ref_ini_w		pls_excecao_cta_bloq_integ.dt_atendimento_inicio%type;
dia_ref_fim_w		pls_excecao_cta_bloq_integ.dt_atendimento_fim%type;

BEGIN

ds_retorno_w := null;

for r_c01_w in c01(nr_seq_regra_p) loop


	-- se ainda não encontrou uma exceção válida
	if (coalesce(ds_retorno_w::text, '') = '') then

		ie_entrou_regra_w := 'S';

		-- valida os Filtros, feito em if para performance
		-- Se tiver um prestador na regra e for igual ao passado por parametro, se não tiver inf na regra e tiver no parametro ou não tem na regra e parametro
		if (ie_entrou_regra_w = 'S') and
			((coalesce(r_c01_w.nr_seq_prestador, nr_seq_prestador_p) = nr_seq_prestador_p) or (coalesce(nr_seq_prestador_p::text, '') = '' and coalesce(r_c01_w.nr_seq_prestador::text, '') = '')) then

			ie_entrou_regra_w := 'S';
		else

			ie_entrou_regra_w := 'N';
		end if; -- Fim filtro prestador
		-- Se tiver a data inicio e fim e o protocolo informado, valida a dt atendimento ref das contas do pro
		if (ie_entrou_regra_w = 'S') and
			((r_c01_w.dt_atendimento_inicio IS NOT NULL AND r_c01_w.dt_atendimento_inicio::text <> '') and (r_c01_w.dt_atendimento_fim IS NOT NULL AND r_c01_w.dt_atendimento_fim::text <> '') and
			 ((nr_seq_protocolo_p IS NOT NULL AND nr_seq_protocolo_p::text <> '') or (nr_seq_lote_p IS NOT NULL AND nr_seq_lote_p::text <> ''))) then

			-- verifica se todas as contas estão compreendidas no periodo, se tiver alguma conta fora do periodo, a exceção não será valida
			-- compativel com a importação nova e antiga, e com a aplicação da regra
			-- se for conta médica
			if (ie_conta_recurso_p = 'C') then

				select	min(extract(DAY FROM t.dt_atendimento_referencia)),
					max(extract(DAY FROM t.dt_atendimento_referencia))
				into STRICT	dia_ref_ini_w,
					dia_ref_fim_w
				from (	-- importação antigao
					SELECT	a.dt_atendimento_referencia
					from	pls_conta	a
					where	a.nr_seq_protocolo	= nr_seq_protocolo_p
					and	(nr_seq_protocolo_p IS NOT NULL AND nr_seq_protocolo_p::text <> '')
					and	ie_nova_imp_xml_p 	= 'N'
					
union all

					SELECT	b.dt_atendimento_referencia
					from	pls_protocolo_conta	a,
						pls_conta		b
					where	b.nr_seq_protocolo	= a.nr_sequencia
					and	a.nr_seq_lote_conta	= nr_seq_lote_p
					and	(nr_seq_lote_p IS NOT NULL AND nr_seq_lote_p::text <> '')
					and	coalesce(nr_seq_protocolo_p::text, '') = ''
					and	ie_nova_imp_xml_p 	= 'N'
					
union all

					-- importacao nova
					select	a.dt_atendimento_conv dt_atendimento_referencia
					from	pls_conta_imp	a
					where	a.nr_seq_protocolo	= nr_seq_protocolo_p
					and	(nr_seq_protocolo_p IS NOT NULL AND nr_seq_protocolo_p::text <> '')
					and	ie_nova_imp_xml_p 	= 'S'
					
union all

					select	b.dt_atendimento_conv dt_atendimento_referencia
					from	pls_protocolo_conta_imp	a,
						pls_conta_imp		b
					where	b.nr_seq_protocolo	= a.nr_sequencia
					and	a.nr_seq_lote_protocolo	= nr_seq_lote_p
					and	(nr_seq_lote_p IS NOT NULL AND nr_seq_lote_p::text <> '')
					and	coalesce(nr_seq_protocolo_p::text, '') = ''
					and	ie_nova_imp_xml_p 	= 'S') t;
				-- se for recurso de glosa
			elsif (ie_conta_recurso_p = 'R') then

				select	min(extract(DAY FROM t.dt_apresentacao_lote)),
					max(extract(DAY FROM t.dt_apresentacao_lote))
				into STRICT	dia_ref_ini_w,
					dia_ref_fim_w
				from (	SELECT	a.dt_apresentacao_lote
					from	pls_rec_glosa_protocolo	a
					where	a.nr_sequencia		= nr_seq_protocolo_p
					and	(nr_seq_protocolo_p IS NOT NULL AND nr_seq_protocolo_p::text <> '')
					
union all

					SELECT	a.dt_apresentacao_lote
					from	pls_rec_glosa_protocolo	a
					where	a.nr_seq_lote		= nr_seq_lote_p
					and	(nr_seq_lote_p IS NOT NULL AND nr_seq_lote_p::text <> '')
					and	coalesce(nr_seq_protocolo_p::text, '') = '') t;

			end if; -- Fim tipo da aplicação da regra
			-- valida a data
			if (r_c01_w.dt_atendimento_inicio <= dia_ref_ini_w ) and (r_c01_w.dt_atendimento_fim >= dia_ref_fim_w ) then

				ie_entrou_regra_w := 'S';
			else

				ie_entrou_regra_w := 'N';
			end if;

		end if; -- Fim filtro dt inicio e fim
		-- no final verifica se ainda está na regra, e então devolve o sequencial. IMPORTANTE ficar no final
		if (ie_entrou_regra_w = 'S') then

			ds_retorno_w := r_c01_w.nr_sequencia;
		end if;

	end if; -- fim sem exceção valida
end loop; -- fim navegar pelas regras
return ds_retorno_w;


end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_possui_exce_regra_bloq_in ( nr_seq_regra_p pls_regra_cta_bloq_integ.nr_sequencia%type, nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_prestador_p pls_regra_cta_bloq_integ.nr_seq_prestador%type, ie_conta_recurso_p pls_regra_cta_bloq_integ.ie_conta_recurso%type, ie_nova_imp_xml_p text) FROM PUBLIC;

