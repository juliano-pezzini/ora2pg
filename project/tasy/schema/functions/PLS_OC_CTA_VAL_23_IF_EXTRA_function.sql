-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION pls_oc_cta_val_23_if_extra ( dados_validacao_p pls_tipos_ocor_pck.dados_regra_val_util_item, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_conta_proc_p pls_tipos_ocor_pck.dados_conta_proc, dados_conta_mat_p pls_tipos_ocor_pck.dados_conta_mat, dados_outro_proc_p pls_tipos_ocor_pck.dados_conta_proc, dados_outro_mat_p pls_tipos_ocor_pck.dados_conta_mat, ie_proc_mat_p text) RETURNS varchar AS $body$
DECLARE

ie_valido_w	varchar(1) := 'S';
dt_val_inic_w	timestamp;
dt_val_fim_w	timestamp;

BEGIN

-- verificacoes que foram tiradas da clausula where do select por motivos de performance.

-- ocorre que ela sao buscadas da view pls_conta_proc_imp_v campos dt_procedimento, nr_seq_prestador_exec, cd_medico_executor e cd_procedimento

-- esses campos tem tratamentos especiais, pelo motivo que devem ser consideradas contas que inclusive ainda nao foram integradas

-- por isso que foi criada essa funcao.
if (dados_validacao_p.ie_somar_estrutura != 'S') then
	
	if (ie_proc_mat_p = 'P') then
	
		if (dados_regra_p.ie_evento = 'IMP') then
			-- se o procedimento nao for igual desconsidera
			if not	((coalesce(dados_outro_proc_p.ie_origem_proced, 0) = coalesce(dados_conta_proc_p.ie_origem_proced, 0)) and (coalesce(dados_outro_proc_p.cd_procedimento, 0) = coalesce(dados_conta_proc_p.cd_procedimento_imp, 0))) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- se o procedimento nao for igual desconsidera
			if not	((coalesce(dados_outro_proc_p.ie_origem_proced, 0) = coalesce(dados_conta_proc_p.ie_origem_proced, 0)) and (coalesce(dados_outro_proc_p.cd_procedimento, 0) = coalesce(dados_conta_proc_p.cd_procedimento, 0))) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	end if;
end if;

--Se regra estiver marcado como ie_guia_diferente, entao nao entra na contagem itens quando estiverem em contas co mesmo cd_guia_ok(cd_guia_referencia nas views)
if (dados_validacao_p.ie_guia_diferente = 'S') then

	if (ie_proc_mat_p = 'P') then
		if (dados_outro_proc_p.cd_guia_referencia = dados_conta_proc_p.cd_guia_referencia) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	else
		if (dados_outro_mat_p.cd_guia_referencia = dados_conta_mat_p.cd_guia_referencia) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	end if;

end if;

------------------------------------------------------------------------  IE_TIPO_PESSOA_QTDE  ------------------------------------------------------------------------  

-- IE_TIPO_PESSOA_QTDE: Aqui verifica o tipo de pessoa que deve ser verificado para buscar os itens antigos que contem apenas informacoes destas pessoas.


-- Ambos 

--Atende a glosa 9920(Retorno atendimento),atributo ignorar o prestador da conta, 

--bastando marcar tipo de pessoa beneficiario, nao considerando prestador da conta nesse caso.
if (dados_validacao_p.ie_medico_consistencia = 'C') then
	if (dados_validacao_p.ie_medico_prestador = 'S') then

		-- Quando for par verificar "Todos" os tipos de pessoa possiveis na regra entao so deve ser verificado os itens que tenham as mesmas informacoes de tais 

		-- pessoas que o item que esta sendo consistido. Por exemplo: Se for para verificar "Beneficiario"  e "Mesmo prestador executor" entao so podem ser contados 

		-- os itens que forem de contas do mesmo beneficiario e executadas pelo mesmo prestador.

		-- o prestador esta sendo verificado nessa funcao por motivos de performance e o segurado e verificado em pls_oc_cta_obter_rest_val_23

		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			if (dados_regra_p.ie_evento = 'IMP') then
				-- se o prestador nao for igual desconsidera
				if not(coalesce(dados_outro_proc_p.nr_seq_prestador_exec_imp, 0) = coalesce(dados_conta_proc_p.nr_seq_prestador_exec_imp, 0)) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			else
				-- se o prestador nao for igual desconsidera
				if not(coalesce(dados_outro_proc_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_proc_p.nr_seq_prestador_exec, 0)) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			end if;
		else
			if (dados_regra_p.ie_evento = 'IMP') then
				-- se o prestador nao for igual desconsidera
				if not(coalesce(dados_outro_mat_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_mat_p.nr_seq_prestador_exec_imp, 0)) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			else
				-- se o prestador nao for igual desconsidera
				if not(coalesce(dados_outro_mat_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_mat_p.nr_seq_prestador_exec, 0)) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			end if;
		end if;
	elsif (dados_validacao_p.ie_medico_prestador = 'D') then
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			if (dados_regra_p.ie_evento = 'IMP') then
				-- se o prestador nao for igual desconsidera
				if	coalesce(dados_outro_proc_p.nr_seq_prestador_exec_imp, 0) = coalesce(dados_conta_proc_p.nr_seq_prestador_exec_imp, 0) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			else
				-- se o prestador nao for igual desconsidera
				if	coalesce(dados_outro_proc_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_proc_p.nr_seq_prestador_exec, 0) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			end if;
		else
			if (dados_regra_p.ie_evento = 'IMP') then
				-- se o prestador nao for igual desconsidera
				if	coalesce(dados_outro_mat_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_mat_p.nr_seq_prestador_exec_imp, 0) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			else
				-- se o prestador nao for igual desconsidera
				if	coalesce(dados_outro_mat_p.nr_seq_prestador_exec, 0) = coalesce(dados_conta_mat_p.nr_seq_prestador_exec, 0) then
					ie_valido_w := 'N';
					return ie_valido_w;
				end if;
			end if;
		end if;
	end if;

	------------------------------------------------------------------------  IE_REGRA_QTDE ------------------------------------------------------------------------  

	-- IE_REGRA_QTDE: Aqui verifica a regra de verificacao que sera usada.

		
	-- Mesmo profissional executor
	if (dados_validacao_p.ie_mesmo_medico = 'S') then

		-- se for procedimento
		if (ie_proc_mat_p = 'P') then

			-- se o profissional executor nao for igual desconsidera
			if 	not(coalesce(dados_outro_proc_p.cd_medico_executor, 0) = coalesce(dados_conta_proc_p.cd_medico_executor,0)) then
				return 'N';
			end if;
		else
			-- se o profissional executor nao for igual desconsidera
			if not(coalesce(dados_outro_mat_p.cd_medico_executor,0) = coalesce(dados_conta_mat_p.cd_medico_executor,0)) then
				return 'N';
			end if;

		end if;
	end if;
end if;

--Mesma categoria CID
if (dados_validacao_p.ie_mesma_categoria_cid = 'S') then

	if (ie_proc_mat_p = 'P') then
		-- se a categoria do cid nao for igual desconsidera
		if (coalesce(dados_outro_proc_p.cd_cat_cid,0) <> coalesce(dados_conta_proc_p.cd_cat_cid,0)) or (dados_conta_proc_p.ie_tipo_guia <> '5') or (dados_outro_proc_p.ie_tipo_guia <> '5') then
			return 'N';
		end if;
	else
		-- se a categoria do cid nao for igual desconsidera
		if (coalesce(dados_outro_mat_p.cd_cat_cid,0) <> coalesce(dados_conta_mat_p.cd_cat_cid,0)) or (dados_conta_mat_p.ie_tipo_guia <> '5') or (dados_outro_mat_p.ie_tipo_guia <> '5') then
			return 'N';
		end if;
	end if;

end if;

--Mesmo CID
if ( dados_validacao_p.ie_mesmo_cid = 'S') then
			
	if ( ie_proc_mat_p = 'P') then
		-- se o do cid nao for igual desconsidera
		if (coalesce(dados_outro_proc_p.cd_cid, 0) <> coalesce(dados_conta_proc_p.cd_cid, 0)) or (dados_conta_proc_p.ie_tipo_guia <> '5') or (dados_outro_proc_p.ie_tipo_guia <> '5') then	
			return 'N';
		end if;
	else
		-- se o do cid nao for igual desconsidera
		if (coalesce(dados_outro_mat_p.cd_cid, 0) <> coalesce(dados_conta_mat_p.cd_cid, 0)) or (dados_conta_mat_p.ie_tipo_guia <> '5') or (dados_outro_mat_p.ie_tipo_guia <> '5') then	
			return 'N';
		end if;
	end if;
end if;

-- Mesma via acesso
if (dados_validacao_p.ie_mesma_via_acesso = 'S') then
	if (ie_proc_mat_p = 'P') then
		-- se a mesma via de acesso nao for igual desconsidera
		if (coalesce(dados_outro_proc_p.ie_via_acesso, 0) <> coalesce(dados_conta_proc_p.ie_via_acesso, 0)) then
			return 'N';
		end if;
	end if;
end if;

--Mesma especialidade(Nao precisa tratar para evento de importacao, ja popula essa informacao no campo quente ao importar)
if (dados_validacao_p.ie_mesma_especialidade = 'S') and (dados_validacao_p.ie_medico_consistencia = 'C') then

	if (ie_proc_mat_p = 'P') then
		-- se a especialidade do profissional  nao for igual desconsidera
		if not(coalesce(dados_outro_proc_p.nr_seq_cbo_saude,0) = coalesce(dados_conta_proc_p.nr_seq_cbo_saude,0)) then
			return 'N';
		end if;
	else
		-- se a especialidade do profissional  nao for igual desconsidera
		if not(coalesce(dados_outro_mat_p.nr_seq_cbo_saude,0) = coalesce(dados_conta_mat_p.nr_seq_cbo_saude,0)) then
			return 'N';
		end if;
	end if;
	
end if;

--Verifica se medico na nota servico do procedimento selecionado e igual as informacoes do outro procedimento( Isso quando a origem da conta for A500 "A")
if (dados_validacao_p.ie_busca_medico_nota_servico = 'S') then

	if (ie_proc_mat_p = 'P') then
	
		if (dados_outro_proc_p.ie_origem_conta = 'A' and dados_conta_proc_p.ie_origem_conta = 'A') then
			if   not((coalesce(dados_outro_proc_p.sg_cons_prof_prest_nota_serv,0) = coalesce(dados_conta_proc_p.sg_cons_prof_prest_nota_serv,0)) and (coalesce(dados_outro_proc_p.nr_cons_prof_prest_nota_serv,0) = coalesce(dados_conta_proc_p.nr_cons_prof_prest_nota_serv,0)) and (coalesce(dados_outro_proc_p.sg_uf_cons_prest_nota_serv,0)   = coalesce(dados_conta_proc_p.sg_uf_cons_prest_nota_serv,0)))then
				
				return 'N';
			end if;
		else	--aaschlote 31/03/2015 - Quando a conta nao for A500, entao tambem nao entra na regra
			return 'N';
		end if;
		
	end if;
	
end if;

--Mesma especialidade(Nao precisa tratar para evento de importacao, ja popula essa informacao no campo quente ao importar)
if (dados_validacao_p.ie_grau_participacao = 'S') and (dados_validacao_p.ie_medico_consistencia = 'C') then

	if (ie_proc_mat_p = 'P') then
	
		if (dados_regra_p.ie_evento = 'IMP') then
			-- se a especialidade do profissional  nao for igual desconsidera
			if (coalesce(dados_outro_proc_p.nr_seq_grau_partic_imp,0) <> coalesce(dados_conta_proc_p.nr_seq_grau_partic_imp,0)) then
				return 'N';
			end if;
		else
			-- se a especialidade do profissional  nao for igual desconsidera
			if (coalesce(dados_outro_proc_p.nr_seq_grau_partic_conta,0) <> coalesce(dados_conta_proc_p.nr_seq_grau_partic_conta,0)) then
				return 'N';
			end if;
		end if;
	end if;
	
end if;

-- Anos
if (dados_validacao_p.ie_tipo_qtde = 'A') then
	-- Aqui verifica os itens lancados em um periodo de X Anos conforme definido pelo usuario no campo QT_TIPO_QUANTIDADE.

	-- Obs: deve se ter informacao neste campo para que o filtro seja aplicado.

	-- Se for para contar atendimentos posteriores ao que esta sendo consistido no momento, entao deve considerar atendimentos que foram lancados

	-- apos o procedimento dentro do periodo informado na regra do campo QT_TIPO_QUANTIDADE. Se nao considerar lancamentos posteriores 

	-- entao busca os procedimentos executados ate a data do procedimento.
	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- Quando for a consistencia no processo de importacao verifica a data apresentada pelo prestador

			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento_imp, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := (add_months(dados_conta_proc_p.dt_procedimento_imp, (dados_validacao_p.qt_tipo_quantidade * 12)));
			else
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := (add_months(dados_conta_proc_p.dt_procedimento, (dados_validacao_p.qt_tipo_quantidade * 12)));
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento_imp, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := (add_months(dados_conta_mat_p.dt_atendimento_imp, (dados_validacao_p.qt_tipo_quantidade * 12)));
			else
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := (add_months(dados_conta_mat_p.dt_atendimento, (dados_validacao_p.qt_tipo_quantidade * 12)));
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;

		end if;
		
	else		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
		
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento_imp, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento_imp;
			else
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento;
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
		
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento_imp, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento_imp;
			else
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade * 12)));
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento;
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	end if;	
	
-- Meses
elsif (dados_validacao_p.ie_tipo_qtde = 'M') then	
	-- Aqui verifica o periodo em meses na qual a ocorrencia busca os itens lancados.

	-- Se for para contar atendimentos posteriores ao que esta sendo consistido no momento, entao deve considerar atendimentos que foram lancados

	-- apos o procedimento dentro do periodo informado na regra do campo QT_TIPO_QUANTIDADE. Se nao considerar lancamentos posteriores 

	-- entao busca os procedimentos executados ate a data do procedimento. 
	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
	
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento_imp, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := (add_months(dados_conta_proc_p.dt_procedimento_imp, (dados_validacao_p.qt_tipo_quantidade)));
			else
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := (add_months(dados_conta_proc_p.dt_procedimento, (dados_validacao_p.qt_tipo_quantidade)));
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento_imp, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := (add_months(dados_conta_mat_p.dt_atendimento_imp, (dados_validacao_p.qt_tipo_quantidade)));
			else
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := (add_months(dados_conta_mat_p.dt_atendimento, (dados_validacao_p.qt_tipo_quantidade)));
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	else		
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento_imp, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento_imp;
			else
				dt_val_inic_w := (add_months(dados_conta_proc_p.dt_procedimento, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento;
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento_imp, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento_imp;
			else
				dt_val_inic_w := (add_months(dados_conta_mat_p.dt_atendimento, - (dados_validacao_p.qt_tipo_quantidade)));
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento;
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	end if;

-- Dias
elsif (dados_validacao_p.ie_tipo_qtde = 'D') then
	-- Aqui e verificado o periodo que sera buscado os itens por dia. Esta sendo verificado a data do item diminuindo ou adicionando a quantidade de dias informados no campo. 

			
	-- Se for para contar atendimentos posteriores ao que esta sendo consistido no momento, entao deve considerar atendimentos que foram lancados

	-- apos o procedimento dentro do periodo informado na regra do campo QT_TIPO_QUANTIDADE. Se nao considerar lancamentos posteriores 

	-- entao busca os procedimentos executados ate a data do procedimento.
	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
	
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := trunc(dados_conta_proc_p.dt_procedimento_imp - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_proc_p.dt_procedimento_imp + (dados_validacao_p.qt_tipo_quantidade));
			else
				dt_val_inic_w := trunc(dados_conta_proc_p.dt_procedimento - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_proc_p.dt_procedimento + (dados_validacao_p.qt_tipo_quantidade));
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := trunc(dados_conta_mat_p.dt_atendimento_imp - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_mat_p.dt_atendimento_imp + (dados_validacao_p.qt_tipo_quantidade));
			else
				dt_val_inic_w := trunc(dados_conta_mat_p.dt_atendimento - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_mat_p.dt_atendimento + (dados_validacao_p.qt_tipo_quantidade));
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	else				
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := trunc(dados_conta_proc_p.dt_procedimento_imp - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_proc_p.dt_procedimento_imp);
			else
				dt_val_inic_w := trunc(dados_conta_proc_p.dt_procedimento - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_proc_p.dt_procedimento);
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := trunc(dados_conta_mat_p.dt_atendimento_imp - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_mat_p.dt_atendimento_imp);
			else
				dt_val_inic_w := trunc(dados_conta_mat_p.dt_atendimento - (dados_validacao_p.qt_tipo_quantidade));
				dt_val_fim_w := fim_dia(dados_conta_mat_p.dt_atendimento);
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		
		end if;
	end if;	
-- Horario
elsif (dados_validacao_p.ie_tipo_qtde = 'H') then
	-- Aqui e verificado o periodo que sera buscado os itens por dia e horas. Esta sendo verificado a data do item diminuindo ou adicionando a quantidade de dias informados no campo. 

			
			
	-- se for procedimento
	if (ie_proc_mat_p = 'P') then
		
		-- calcula as datas do pereodo que devem ser consideradas
		if (dados_regra_p.ie_evento = 'IMP') then
			
			dt_val_inic_w := dados_conta_proc_p.dt_procedimento_imp;
		else

			dt_val_inic_w := dados_conta_proc_p.dt_procedimento;
		end if;
		
		-- se for  diferente do periodo e invalido
		if (dados_outro_proc_p.dt_procedimento != dt_val_inic_w) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	else
		-- calcula as datas do periodo que devem ser consideradas
		if (dados_regra_p.ie_evento = 'IMP') then
			
			dt_val_inic_w := dados_conta_mat_p.dt_atendimento_imp;
		else

			dt_val_inic_w := dados_conta_mat_p.dt_atendimento;
		end if;
		
		-- se for  diferente do periodo e invalido
		if (dados_outro_mat_p.dt_atendimento != dt_val_inic_w) then
			ie_valido_w := 'N';
			return ie_valido_w;
		end if;
	
	end if;
-- minutos
elsif (dados_validacao_p.ie_tipo_qtde = 'N') then

	if (dados_validacao_p.ie_qt_lib_posterior = 'S') then
	
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := dados_conta_proc_p.dt_procedimento_imp - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento_imp + ((dados_validacao_p.qt_tipo_quantidade) / 1440);
			else
				dt_val_inic_w := dados_conta_proc_p.dt_procedimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento + ((dados_validacao_p.qt_tipo_quantidade) / 1440);
			end if;
						
			-- se nao estiver dentro do periodo e invalido			
			if ((not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w)) or coalesce(dados_outro_proc_p.dt_procedimento::text, '') = '') then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := dados_conta_mat_p.dt_atendimento_imp - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento_imp + ((dados_validacao_p.qt_tipo_quantidade) /1440);
			else
				dt_val_inic_w := dados_conta_mat_p.dt_atendimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento + ((dados_validacao_p.qt_tipo_quantidade) /1440);
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		end if;
	else				
		-- se for procedimento
		if (ie_proc_mat_p = 'P') then
			
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := dados_conta_proc_p.dt_procedimento_imp - ((dados_validacao_p.qt_tipo_quantidade)  /1440);
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento_imp;
			else
				dt_val_inic_w := dados_conta_proc_p.dt_procedimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_proc_p.dt_procedimento;
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			
			if not(dados_outro_proc_p.dt_procedimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		else
			-- calcula as datas do periodo que devem ser consideradas
			if (dados_regra_p.ie_evento = 'IMP') then
				dt_val_inic_w := dados_conta_mat_p.dt_atendimento_imp - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento_imp;
			else
				dt_val_inic_w := dados_conta_mat_p.dt_atendimento - ((dados_validacao_p.qt_tipo_quantidade) /1440);
				dt_val_fim_w := dados_conta_mat_p.dt_atendimento;
			end if;
			
			-- se nao estiver dentro do periodo e invalido
			if not(dados_outro_mat_p.dt_atendimento between dt_val_inic_w and dt_val_fim_w) then
				ie_valido_w := 'N';
				return ie_valido_w;
			end if;
		
		end if;
	end if;
end if;
	
return	ie_valido_w;

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION pls_oc_cta_val_23_if_extra ( dados_validacao_p pls_tipos_ocor_pck.dados_regra_val_util_item, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_conta_proc_p pls_tipos_ocor_pck.dados_conta_proc, dados_conta_mat_p pls_tipos_ocor_pck.dados_conta_mat, dados_outro_proc_p pls_tipos_ocor_pck.dados_conta_proc, dados_outro_mat_p pls_tipos_ocor_pck.dados_conta_mat, ie_proc_mat_p text) FROM PUBLIC;

