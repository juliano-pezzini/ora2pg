-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';





CREATE OR REPLACE FUNCTION obter_san_proc_tran_parcial (nr_seq_reserva_p bigint, nr_seq_transfusao_p bigint, nr_seq_exame_p bigint, ie_busca_sentido_p text) RETURNS bigint AS $body$
 -- 'A' Ambas direções; 'O' na Origem; 'D' no Destino
DECLARE


nr_seq_retorno_w	bigint;
nr_seq_reserva_w	bigint;
nr_seq_res_origem_w	bigint;
nr_seq_res_gerada_w	bigint;
nr_seq_transf_origem_w	bigint;
nr_seq_transf_destino_w	bigint;

BEGIN

IF (nr_seq_exame_p IS NOT NULL AND nr_seq_exame_p::text <> '') AND (ie_busca_sentido_p IS NOT NULL AND ie_busca_sentido_p::text <> '') THEN

	--1a Parte: verifica se a transfusão é remanescente de reserva anterior já transfundido (quebra de reserva com transfusão parcial)
	IF (ie_busca_sentido_p = 'A') OR (ie_busca_sentido_p = 'O') then
		IF (nr_seq_transfusao_p IS NOT NULL AND nr_seq_transfusao_p::text <> '') THEN
			SELECT MAX(nr_seq_reserva)
			INTO STRICT	nr_seq_reserva_w
			FROM	san_transfusao
			WHERE	nr_sequencia = nr_seq_transfusao_p;
		END IF;

		SELECT MAX(nr_seq_reserva_origem)
		INTO STRICT	nr_seq_res_origem_w
		FROM	san_reserva
		WHERE	nr_sequencia = coalesce(nr_seq_reserva_w, nr_seq_reserva_p);

		IF (nr_seq_res_origem_w IS NOT NULL AND nr_seq_res_origem_w::text <> '') THEN
			SELECT MAX(nr_sequencia)
			INTO STRICT	nr_seq_transf_origem_w
			FROM	san_transfusao
			WHERE	nr_seq_reserva = nr_seq_res_origem_w;
		END IF;

		IF (nr_seq_transf_origem_w IS NOT NULL AND nr_seq_transf_origem_w::text <> '') THEN
			SELECT 	MAX(a.nr_sequencia)
			INTO STRICT	nr_seq_retorno_w
			FROM 	procedimento_paciente a,
				san_exame_realizado b,
				san_exame_lote c
			WHERE 	b.nr_seq_exame_lote = c.nr_sequencia
			and	c.nr_seq_transfusao = nr_seq_transf_origem_w
			and	a.nr_seq_transfusao = nr_seq_transf_origem_w
			and	b.nr_seq_propaci = a.nr_sequencia
			AND 	b.nr_seq_exame = nr_seq_exame_p;
		END IF;

		IF (coalesce(nr_seq_retorno_w,0) <= 0) and (nr_seq_res_origem_w IS NOT NULL AND nr_seq_res_origem_w::text <> '') THEN
			SELECT 	MAX(a.nr_sequencia)
			INTO STRICT	nr_seq_retorno_w
			FROM 	procedimento_paciente a,
				san_exame_realizado b,
				san_exame_lote c
			WHERE 	b.nr_seq_exame_lote = c.nr_sequencia
			and	c.nr_seq_reserva = nr_seq_res_origem_w
			and	a.nr_seq_reserva = nr_seq_res_origem_w
			and	b.nr_seq_propaci = a.nr_sequencia
			AND 	b.nr_seq_exame = nr_seq_exame_p;
		END IF;

		--1.1a Parte: recursividade, verificando se sequência de doação ou de transfusão de origem, é desdobramento de outro registro.
		IF (coalesce(nr_seq_retorno_w,0) <= 0) THEN

			IF (nr_seq_res_origem_w IS NOT NULL AND nr_seq_res_origem_w::text <> '') OR (nr_seq_transf_origem_w IS NOT NULL AND nr_seq_transf_origem_w::text <> '') THEN
				nr_seq_retorno_w := Obter_san_proc_tran_parcial(nr_seq_res_origem_w, nr_seq_transf_origem_w, nr_seq_exame_p, 'O');
			END IF;

		END IF;
	END IF;

	--2a Parte: verifica se reserva originou quebras (novas reservas) por transfusão parcial.
	IF (ie_busca_sentido_p = 'A') OR (ie_busca_sentido_p = 'D') then
		IF (coalesce(nr_seq_retorno_w,0) <= 0) THEN
			SELECT MAX(nr_sequencia)
			INTO STRICT	nr_seq_res_gerada_w
			FROM	san_reserva
			WHERE	nr_seq_reserva_origem = nr_seq_reserva_p;

			IF (nr_seq_res_gerada_w IS NOT NULL AND nr_seq_res_gerada_w::text <> '') THEN
				SELECT MAX(nr_sequencia)
				INTO STRICT	nr_seq_transf_destino_w
				FROM	san_transfusao
				WHERE	nr_seq_reserva = nr_seq_res_gerada_w;
			END IF;

			IF (nr_seq_transf_destino_w IS NOT NULL AND nr_seq_transf_destino_w::text <> '') THEN
				SELECT 	MAX(a.nr_sequencia)
				INTO STRICT	nr_seq_retorno_w
				FROM 	procedimento_paciente a,
					san_exame_realizado b,
					san_exame_lote c
				WHERE 	b.nr_seq_exame_lote = c.nr_sequencia
				and	c.nr_seq_transfusao = nr_seq_transf_destino_w
				and	a.nr_seq_transfusao = nr_seq_transf_destino_w
				and	b.nr_seq_propaci = a.nr_sequencia
				AND 	b.nr_seq_exame = nr_seq_exame_p;
			END IF;

			IF (coalesce(nr_seq_retorno_w,0) <= 0) and (nr_seq_res_gerada_w IS NOT NULL AND nr_seq_res_gerada_w::text <> '') THEN
				SELECT 	MAX(a.nr_sequencia)
				INTO STRICT	nr_seq_retorno_w
				FROM 	procedimento_paciente a,
					san_exame_realizado b,
					san_exame_lote c
				WHERE 	b.nr_seq_exame_lote = c.nr_sequencia
				and	c.nr_seq_reserva = nr_seq_res_gerada_w
				and	a.nr_seq_reserva = nr_seq_res_gerada_w
				and	b.nr_seq_propaci = a.nr_sequencia
				AND 	b.nr_seq_exame = nr_seq_exame_p;
			END IF;

			--2.1a Parte: recursividade, verificando se sequência de doação ou de transfusão, é desdobrada para outro registro.
			IF (coalesce(nr_seq_retorno_w,0) <= 0) THEN

				IF (nr_seq_res_gerada_w IS NOT NULL AND nr_seq_res_gerada_w::text <> '') OR (nr_seq_transf_destino_w IS NOT NULL AND nr_seq_transf_destino_w::text <> '') THEN
					nr_seq_retorno_w := Obter_san_proc_tran_parcial(nr_seq_res_gerada_w, nr_seq_transf_destino_w, nr_seq_exame_p, 'D');
				END IF;

			END IF;

		END IF;
	END IF;


END IF;

return	coalesce(nr_seq_retorno_w,0);

end;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION obter_san_proc_tran_parcial (nr_seq_reserva_p bigint, nr_seq_transfusao_p bigint, nr_seq_exame_p bigint, ie_busca_sentido_p text) FROM PUBLIC;

