-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS data_model_before_upd ON data_model CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_data_model_before_upd() RETURNS trigger AS $BODY$
declare

-- If on 19c, dbms_job implicitly schedule the job using dbms_scheduler
-- Dbms_scheduler has an implicit commit, which cannot be executed under a trigger
-- So on 19c, an autonomous transaction is required
$if dbms_db_version.version >= 19 $then
	pragma autonomous_transaction;
$end

jobno bigint;

BEGIN

if (wheb_usuario_pck.get_ie_executar_trigger = 'S') then

	if	((TG_OP = 'UPDATE') and
		 ((NEW.object_name <> OLD.object_name) or (NEW.hr_time_intervalo <> OLD.hr_time_intervalo))) then
		BEGIN		
		
		$if 	dbms_db_version.version >= 19 $then
			-- If 19c or higher, schedule the job using the dbms_scheduler (which will commit).
			-- So the autonomous transaction is commited but the main transaction still have to be commited
			-- To give some time to the main trasaction, the job schedule to run a few minutes in the future
			dbms_scheduler.create_job(
				job_name  => 'DROP_VIEW_DATAMODEL' || round(dbms_random.value(1000000, 9999999)), 
				job_type => 'PLSQL_BLOCK', 
				job_action => 'begin DROP_VIEW_DATAMODEL('|| chr(39)|| to_char(OLD.object_name) ||chr(39)|| '); end;',
				start_date  => CURRENT_TIMESTAMP + interval '1' second, 
				enabled   => TRUE, 
				auto_drop => TRUE);
				
			dbms_scheduler.create_job(
				job_name  => 'DATA_MODEL_VIEW_GENERATE' || round(dbms_random.value(1000000, 9999999)),
				job_type => 'PLSQL_BLOCK', 
				job_action => 'begin DATA_MODEL_VIEW_GENERATE('|| to_char(coalesce(NEW.nr_sequencia, OLD.nr_sequencia)) || '); end;',
				start_date  => CURRENT_TIMESTAMP + interval '1' second, 
				enabled   => TRUE, 
				auto_drop => TRUE);
		$else
			-- If not 19c, schedule the job using dbms_job and the job will only run once the main transaction commits
			dbms_job.submit(jobno, 'DROP_VIEW_DATAMODEL('|| chr(39)|| to_char(OLD.object_name) ||chr(39)|| ');');		
		
			dbms_job.submit(jobno, 'DATA_MODEL_VIEW_GENERATE('|| to_char(coalesce(NEW.nr_sequencia, OLD.nr_sequencia)) || ');');
		$end
		
		end;
	end if;
end if;

RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_data_model_before_upd() FROM PUBLIC;

CREATE TRIGGER data_model_before_upd
	BEFORE UPDATE ON data_model FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_data_model_before_upd();

