-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS pls_conta_proc_atual ON pls_conta_proc CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pls_conta_proc_atual() RETURNS trigger AS $BODY$
declare

C01 CURSOR(	ds_lista_p		text,
		ds_separador_p	text) FOR
	SELECT	ds_valor_vchr2
	from	table(pls_util_pck.converter_lista_valores(ds_lista_p, ds_separador_p));

C02 CURSOR(	ds_lista_p		text,
		ds_separador_p	text) FOR
	SELECT	ds_valor_vchr2,
		dt_valor_date,
		nr_valor_number
	from	table(pls_util_pck.converter_lista_valores(ds_lista_p, ds_separador_p));

sql_err_w			varchar(4000);
cd_guia_w		varchar(30);
ie_origem_conta_w		varchar(5);
ie_tipo_intercambio_w	varchar(5);
ie_regra_preco_w		varchar(3)	:= 'N';
ie_internado_w		varchar(3);
sg_estado_w		pessoa_juridica.sg_estado%type;
sg_estado_int_w		pessoa_juridica.sg_estado%type;
ie_tipo_despesa_w		varchar(1);
vl_pacote_out_w		double precision	:= 0;
vl_medico_out_w		double precision	:= 0;
vl_anestesista_out_w	double precision	:= 0;
vl_auxiliares_out_w		double precision	:= 0;
vl_custo_operacional_out_w	double precision	:= 0;
vl_materiais_out_w		double precision	:= 0;
cd_proc_pacote_out_w	bigint	:= null;
ie_origem_pacote_out_w	bigint	:= null;
cd_procedimento_w	bigint;
ie_origem_proced_w	bigint;
nr_seq_prestador_w	bigint;
nr_seq_pacote_w		bigint;
nr_seq_regra_pacote_out_w	bigint;
nr_seq_intercambio_w	bigint;
nr_seq_classificacao_prest_w	bigint;
nr_seq_protocolo_w		bigint;
nr_seq_segurado_w		bigint;
nr_seq_prestador_prot_w		bigint;
nr_seq_tipo_acomod_w		bigint;
nr_seq_plano_w			bigint;
nr_contrato_w			bigint;
nr_seq_congenere_w		bigint;
nr_seq_conta_w			bigint;
nr_seq_prestador_conta_w	bigint;
cd_estabelecimento_w		smallint;
dt_procedimento_w		timestamp;
dt_procedimento_imp_w		timestamp;
dt_conta_guia_w			timestamp;
dt_pacote_w			timestamp;
ie_desc_item_glosa_atend_w	pls_parametros.ie_desc_item_glosa_atend%type;


dt_atendimento_referencia_w	pls_conta.dt_atendimento_referencia%type;
nr_seq_prestador_exec_w		pls_conta.nr_seq_prestador_exec%type;
dt_protocolo_w			pls_protocolo_conta.dt_protocolo%type;
dt_mes_competencia_w		pls_protocolo_conta.dt_mes_competencia%type;
nr_contador_w			integer;
ds_campo_w			varchar(100);
ds_log_call_w			varchar(1500);
ds_log_glosa_w			varchar(100);
ds_log_w			plsprco_cta.ds_log%type;
BEGIN
  BEGIN
if (coalesce(wheb_usuario_pck.get_ie_executar_trigger,'S') = 'S') and (coalesce(wheb_usuario_pck.get_ie_lote_contabil,'N') = 'N') and (coalesce(wheb_usuario_pck.get_ie_atualizacao_contabil,'N') = 'N')  then
	-- essa parte da trigger não irá rodar se for necessário fazer algum trabalho de redundância para evitar trigger mutante

	if (pls_util_pck.get_ie_executar_redundancia_w	= 'N')  then
	
		if (((NEW.vl_liberado + NEW.vl_glosa) <> NEW.vl_procedimento_imp) and (NEW.vl_glosa <> 0) and (NEW.vl_procedimento_imp <> 0)) then
		
			ds_log_call_w := substr(	' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
							' CallStack: '|| chr(13) || chr(10)|| dbms_utility.format_call_stack,1,1500);
		
			ds_log_w := 	'Verificar valores de glosa e liberado em relação ao valor apresentado.' || pls_util_pck.enter_w ||
					'Valor liberado: '||NEW.vl_liberado || pls_util_pck.enter_w ||
					'Vl apresentado: ' || NEW.vl_procedimento_imp || pls_util_pck.enter_w ||
					'Vl calculado: ' || NEW.vl_procedimento|| pls_util_pck.enter_w ||
					'Vl glosa: ' || NEW.vl_glosa;
		
			insert	into	plsprco_cta( 	nr_sequencia, dt_atualizacao, nm_usuario,
					dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
					ds_log, ds_log_call, ds_funcao_ativa, 
					ie_aplicacao_tasy, nm_maquina, ie_opcao,
					pls_conta_proc)
			values ( 	nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
					LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_CONTA', 
					ds_log_w, ds_log_call_w, obter_funcao_ativa, 
					pls_se_aplicacao_tasy, wheb_usuario_pck.get_machine, '1',
					NEW.nr_sequencia);
		
		end if;
	
		
		if	((coalesce(NEW.vl_liberado_hi,0) <> coalesce(OLD.vl_liberado_hi,0)) or (coalesce(NEW.vl_liberado_co,0) <> coalesce(OLD.vl_liberado_co,0)) or (coalesce(NEW.vl_liberado_material,0) <> coalesce(OLD.vl_liberado_material,0)) or (coalesce(NEW.vl_lib_taxa_servico,0) <> coalesce(OLD.vl_lib_taxa_servico,0)) or (coalesce(NEW.vl_lib_taxa_co,0) <> coalesce(OLD.vl_lib_taxa_co,0)) or (coalesce(NEW.vl_lib_taxa_material,0) <> coalesce(OLD.vl_lib_taxa_material,0))) and (coalesce(NEW.tx_intercambio,0) > 0) and (coalesce(NEW.vl_liberado,0) > 0) and
			((coalesce(NEW.vl_liberado_hi,0) + coalesce(NEW.vl_lib_taxa_servico,0) +
			coalesce(NEW.vl_liberado_co,0) + coalesce(NEW.vl_lib_taxa_co,0) +
			coalesce(NEW.vl_liberado_material,0) + coalesce(NEW.vl_lib_taxa_material,0)) <> NEW.vl_liberado) then
			
			ds_log_w := 	'Diferença nos valores individuais com o valor total.' || pls_util_pck.enter_w ||
					'Valores Novos: ' || pls_util_pck.enter_w ||
					'Vl hi: ' || NEW.vl_liberado_hi || pls_util_pck.enter_w ||
					'Vl co: ' || NEW.vl_liberado_co || pls_util_pck.enter_w ||
					'Vl mat: ' || NEW.vl_liberado_material || pls_util_pck.enter_w ||
					'Vl taxa hi: ' || NEW.vl_lib_taxa_servico || pls_util_pck.enter_w ||
					'Vl taxa co: ' || NEW.vl_lib_taxa_co || pls_util_pck.enter_w ||
					'Vl taxa mat: ' || NEW.vl_lib_taxa_material || pls_util_pck.enter_w ||
					'Vl liberado: ' || NEW.vl_liberado || pls_util_pck.enter_w ||
					'Tx intercambio: ' || NEW.tx_intercambio || pls_util_pck.enter_w ||
					'Valores antigos: ' || pls_util_pck.enter_w ||
					'Vl hi: ' || OLD.vl_liberado_hi || pls_util_pck.enter_w ||
					'Vl co: ' || OLD.vl_liberado_co || pls_util_pck.enter_w ||
					'Vl mat: ' || OLD.vl_liberado_material || pls_util_pck.enter_w ||
					'Vl taxa hi: ' || OLD.vl_lib_taxa_servico || pls_util_pck.enter_w ||
					'Vl taxa co: ' || OLD.vl_lib_taxa_co || pls_util_pck.enter_w ||
					'Vl taxa mat: ' || OLD.vl_lib_taxa_material || pls_util_pck.enter_w ||
					'Vl liberado: ' || OLD.vl_liberado || pls_util_pck.enter_w ||
					'Tx intercambio: ' || OLD.tx_intercambio;
			
			ds_log_call_w := substr(	' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
							' CallStack: '|| chr(13) || chr(10)|| dbms_utility.format_call_stack,1,1500);
			
			insert	into	plsprco_cta( 	nr_sequencia, dt_atualizacao, nm_usuario,
					dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
					ds_log, ds_log_call, ds_funcao_ativa, 
					ie_aplicacao_tasy, nm_maquina, ie_opcao,
					pls_conta_proc)
			values ( 	nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
					LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_CONTA', 
					ds_log_w, ds_log_call_w, obter_funcao_ativa, 
					pls_se_aplicacao_tasy, wheb_usuario_pck.get_machine, '1',
					NEW.nr_sequencia);
			
		end if;
		
		if (coalesce(NEW.ds_justificativa, 'A')  != coalesce(OLD.ds_justificativa, 'A')) then
		
			ds_log_call_w := substr(	' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
							' CallStack: '|| chr(13) || chr(10)|| dbms_utility.format_call_stack,1,1500);

							
			ds_log_w := 'Alterado a justificativa do procedimento'|| pls_util_pck.enter_w ||' - de: '|| OLD.ds_justificativa || pls_util_pck.enter_w || pls_util_pck.enter_w ||' - para: '||NEW.ds_justificativa;
			insert	into	plsprco_cta( 	nr_sequencia, dt_atualizacao, nm_usuario,
					dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
					ds_log, ds_log_call, ds_funcao_ativa, 
					ie_aplicacao_tasy, nm_maquina, ie_opcao,
					pls_conta_proc)
			values ( 	nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
					LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_CONTA', 
					ds_log_w, ds_log_call_w, obter_funcao_ativa, 
					pls_se_aplicacao_tasy, wheb_usuario_pck.get_machine, '1',
					NEW.nr_sequencia);
					
		end if;
		
		if (coalesce(NEW.ds_especif_material, 'A')  != coalesce(OLD.ds_especif_material, 'A')) then
		
			ds_log_call_w := substr(	' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
							' CallStack: '|| chr(13) || chr(10)|| dbms_utility.format_call_stack,1,1500);

							
			ds_log_w := 'Alterado a especificação do procedimento'|| pls_util_pck.enter_w ||' - de: '|| OLD.ds_especif_material || pls_util_pck.enter_w || pls_util_pck.enter_w ||' - para: '||NEW.ds_especif_material;
			insert	into	plsprco_cta( 	nr_sequencia, dt_atualizacao, nm_usuario,
					dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
					ds_log, ds_log_call, ds_funcao_ativa, 
					ie_aplicacao_tasy, nm_maquina, ie_opcao,
					pls_conta_proc)
			values ( 	nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
					LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_CONTA', 
					ds_log_w, ds_log_call_w, obter_funcao_ativa, 
					pls_se_aplicacao_tasy, wheb_usuario_pck.get_machine, '1',
					NEW.nr_sequencia);
					
		end if;
		
		BEGIN
		dt_procedimento_w	:= to_date(to_char(NEW.dt_procedimento,'dd/mm/yyyy') || ' ' || to_char(NEW.dt_inicio_proc,'hh24:mi:ss'),'dd/mm/yyyy hh24:mi:ss');
		NEW.dt_procedimento	:= dt_procedimento_w;
		exception
		when others then
			sql_err_w	:= substr(sqlerrm, 1, 1800);
		end;
		
		BEGIN
		dt_procedimento_imp_w		:= to_date(to_char(NEW.dt_procedimento_imp,'dd/mm/yyyy') || ' ' || to_char(NEW.dt_inicio_proc_imp,'hh24:mi:ss'),'dd/mm/yyyy hh24:mi:ss');
		NEW.dt_procedimento_imp	:= dt_procedimento_imp_w;
		exception
		when others then
			sql_err_w	:= substr(sqlerrm, 1, 1800);
		end;

		/* Verificar se o procedimento é um pacote */


		select	coalesce(max(nr_sequencia),0)
		into STRICT	nr_seq_pacote_w
		from	pls_pacote
		where	cd_procedimento		= NEW.cd_procedimento
		and	ie_origem_proced	= NEW.ie_origem_proced
		and	ie_situacao		= 'A';

		/* Francisco - 16/05/2012 - OS 447352 */


		if (nr_seq_pacote_w > 0) then
			select	coalesce(ie_regra_preco,'N')
			into STRICT	ie_regra_preco_w
			from	pls_pacote a
			where	a.nr_sequencia	= nr_seq_pacote_w;
			
			if (ie_regra_preco_w = 'S') then
				nr_seq_conta_w		:= NEW.nr_seq_conta;
				cd_procedimento_w	:= NEW.cd_procedimento;
				ie_origem_proced_w	:= NEW.ie_origem_proced;
				
				select	coalesce(nr_seq_prestador_exec,0),
					nr_seq_protocolo,
					cd_estabelecimento,
					nr_seq_tipo_acomodacao,
					coalesce(dt_atendimento_referencia, coalesce(dt_autorizacao, coalesce(dt_entrada, LOCALTIMESTAMP))),
					nr_seq_plano,
					--substr(pls_obter_se_internado(nr_sequencia,'X'),1,1),

					nr_seq_segurado,
					coalesce(cd_guia,'X'),
					ie_origem_conta
				into STRICT	nr_seq_prestador_conta_w,
					nr_seq_protocolo_w,
					cd_estabelecimento_w,
					nr_seq_tipo_acomod_w,
					dt_conta_guia_w,
					nr_seq_plano_w,
					--ie_internado_w,

					nr_seq_segurado_w,
					cd_guia_w,
					ie_origem_conta_w
				from	pls_conta
				where	nr_sequencia	= nr_seq_conta_w;
				
				ie_internado_w	:= substr(pls_obter_se_internado(nr_seq_conta_w,'X'),1,1);
				
				dt_pacote_w	:= coalesce(dt_procedimento_w, dt_conta_guia_w);
				
				/* Obter o prestador do protocolo */


				select	nr_seq_prestador
				into STRICT	nr_seq_prestador_prot_w
				from	pls_protocolo_conta
				where	nr_sequencia	= nr_seq_protocolo_w;

				if (nr_seq_prestador_conta_w > 0) then
					nr_seq_prestador_w	:= nr_seq_prestador_conta_w;
				else
					nr_seq_prestador_w	:= nr_seq_prestador_prot_w;
				end if;
				
				if (nr_seq_plano_w is null) then		
					BEGIN
					select	pls_obter_produto_benef(a.nr_sequencia,dt_conta_guia_w)
					into STRICT	nr_seq_plano_w
					from	pls_segurado a	
					where	a.nr_sequencia	= nr_seq_segurado_w;	
					exception
					when others then
						nr_seq_plano_w	:= null;
					end;
				end if;
				
				BEGIN
				select	coalesce(a.nr_contrato,0),
					b.nr_seq_congenere
				into STRICT	nr_contrato_w,
					nr_seq_congenere_w
				from	pls_contrato	a,
					pls_segurado	b
				where	a.nr_sequencia	= b.nr_seq_contrato
				and	b.nr_sequencia	= nr_seq_segurado_w;
				exception
				when others then
					nr_contrato_w	:= 0;
				end;
				
				if (nr_seq_congenere_w is null) then
					select	max(b.nr_seq_congenere)
					into STRICT	nr_seq_congenere_w
					from	pls_segurado	b
					where	b.nr_sequencia	= nr_seq_segurado_w;
				end if;
				
				select	max(nr_seq_intercambio)
				into STRICT	nr_seq_intercambio_w
				from	pls_segurado
				where	nr_sequencia	= nr_seq_segurado_w;
				
				select	max(nr_seq_classificacao)
				into STRICT	nr_seq_classificacao_prest_w
				from	pls_prestador
				where	nr_sequencia = nr_seq_prestador_w;
				
				select	coalesce(max(sg_estado),'X')
				into STRICT	sg_estado_w
				from	pessoa_juridica
				where	cd_cgc	= (	SELECT	max(cd_cgc_outorgante)
							from	pls_outorgante
							where	cd_estabelecimento	= cd_estabelecimento_w);
				
				BEGIN
				select	coalesce(max(a.sg_estado),'X')
				into STRICT	sg_estado_int_w
				from	pessoa_juridica	a,
					pls_congenere	b
				where	a.cd_cgc	= b.cd_cgc
				and	b.nr_sequencia	= nr_seq_congenere_w;
				exception
				when others then
					sg_estado_int_w	:= 0;
				end;

				if (sg_estado_w <> 'X') and (sg_estado_int_w <> 'X') then
					if (sg_estado_w	= sg_estado_int_w) then
						ie_tipo_intercambio_w	:= 'E';
					else	
						ie_tipo_intercambio_w	:= 'N';
					end if;
				else
					ie_tipo_intercambio_w	:= 'A';
				end if;

				SELECT * FROM pls_define_preco_pacote(cd_estabelecimento_w, nr_seq_prestador_w, nr_seq_tipo_acomod_w, dt_pacote_w, cd_procedimento_w, ie_origem_proced_w, ie_internado_w, nr_seq_plano_w, nr_contrato_w, nr_seq_congenere_w, NEW.nm_usuario, ie_origem_conta_w, ie_tipo_intercambio_w, nr_seq_pacote_w, nr_seq_regra_pacote_out_w, cd_proc_pacote_out_w, ie_origem_pacote_out_w, vl_pacote_out_w, vl_medico_out_w, vl_anestesista_out_w, vl_auxiliares_out_w, vl_custo_operacional_out_w, vl_materiais_out_w, nr_seq_intercambio_w, nr_seq_classificacao_prest_w, null, nr_seq_segurado_w, 'N', 'S', null, 1) INTO STRICT nr_seq_pacote_w, nr_seq_regra_pacote_out_w, cd_proc_pacote_out_w, ie_origem_pacote_out_w, vl_pacote_out_w, vl_medico_out_w, vl_anestesista_out_w, vl_auxiliares_out_w, vl_custo_operacional_out_w, vl_materiais_out_w;
			
				if (coalesce(nr_seq_regra_pacote_out_w,0) = 0) then
					nr_seq_pacote_w := 0;
				
				end if;
			end if; /* Se validar por regra de preço */

		end if;

		if (nr_seq_pacote_w > 0) then
			NEW.ie_tipo_despesa	:= '4';
			NEW.nr_seq_pacote	:= nr_seq_pacote_w;
		else
			/* Buscar a classificação do procedimento e atualizar na tabela */


			select 	substr(coalesce(max(ie_classificacao),coalesce(NEW.ie_tipo_despesa,'1')),1,1)
			into STRICT	ie_tipo_despesa_w
			from	procedimento
			where	cd_procedimento		= NEW.cd_procedimento
			and	ie_origem_proced	= NEW.ie_origem_proced;
			
			NEW.nr_seq_pacote	:= null;
			NEW.ie_tipo_despesa	:= substr(ie_tipo_despesa_w,1,1);
		end if;

		if (TG_OP = 'UPDATE') and
			((OLD.nr_id_analise is not null) and ((NEW.nr_id_analise is null) or (OLD.nr_id_analise != NEW.nr_id_analise)))then

			CALL wheb_mensagem_pck.exibir_mensagem_abort(247472);
		end if;

		if (NEW.vl_liberado < 0) then
			CALL wheb_mensagem_pck.exibir_mensagem_abort(271939);
		end if;
		
		-- busca os dados para tratar as redundâncias logo abaixo

		select	max(a.dt_atendimento_referencia),
			max(a.nr_seq_prestador_exec),
			max(b.dt_protocolo),
			max(b.dt_mes_competencia),
			max(a.cd_estabelecimento)
		into STRICT	dt_atendimento_referencia_w,
			nr_seq_prestador_exec_w,
			dt_protocolo_w,
			dt_mes_competencia_w,
			cd_estabelecimento_w
		from	pls_conta a,
			pls_protocolo_conta b
		where	a.nr_sequencia = NEW.nr_seq_conta
		and	b.nr_sequencia = a.nr_seq_protocolo;
		
		if (dt_atendimento_referencia_w is null) then
			ds_log_call_w := substr(	' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
							' CallStack: '|| chr(13) || chr(10)|| dbms_utility.format_call_stack,1,1500);
			
			insert into plsprco_cta( 	nr_sequencia, dt_atualizacao, nm_usuario,
								dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
								ds_log, ds_log_call, ds_funcao_ativa, 
								ie_aplicacao_tasy, nm_maquina, pls_conta_proc, ie_opcao )
					values ( 	nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
								LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_CONTA_PROC', 
								'Item sem data de atendimento referência', ds_log_call_w, obter_funcao_ativa, 
								'N', wheb_usuario_pck.get_machine, OLD.nr_sequencia, '0');
		end if;
	end if;
	
	-- se foi alimentado o campo com os valores da redundância, extrai os valores dele e alimenta as variáveis

	if (NEW.ds_redundancia is not null) then
		
		-- percorre para trazer campo=valor em cada registro

		for r_C01_w in C01(NEW.ds_redundancia, ';') loop
			
			-- percorre para trazer campo em um registro e valor em outro

			nr_contador_w := 0;
			ds_campo_w := null;
			for r_C02_w in C02(r_C01_w.ds_valor_vchr2, '=') loop
				
				-- significa que tenho o campo

				if (nr_contador_w = 0) then
					ds_campo_w := r_C02_w.ds_valor_vchr2;
				else
					-- atribui os valores para as variáveis

					case(ds_campo_w)
						when 'dt_atendimento_referencia' then
							dt_atendimento_referencia_w := r_C02_w.dt_valor_date;
						
						when 'nr_seq_prestador_exec' then
							nr_seq_prestador_exec_w := r_C02_w.nr_valor_number;
						
						when 'dt_protocolo' then
							dt_protocolo_w := r_C02_w.dt_valor_date;
							
						when 'dt_mes_competencia' then
							dt_mes_competencia_w := r_C02_w.dt_valor_date;
							
						else
							null;
					end case;
				end if;
				
				nr_contador_w := nr_contador_w + 1;
			end loop;
		end loop;
		NEW.ds_redundancia := null;
	end if;

	-- início redundâncias e formatações

	NEW.dt_procedimento_referencia := pls_obter_data_conta_proc(	nr_seq_prestador_exec_w, NEW.ie_tipo_despesa,
									NEW.dt_procedimento, dt_atendimento_referencia_w,
									dt_protocolo_w, dt_mes_competencia_w);
									
	-- se houve mudança na data de referência alimenta a mesma sem a hora no campo dt_procedimento_referencia_sh

	-- criado para questões de performance quando existe a necessidade de filtrar tudo o que é do dia ignorando a hora

	if (coalesce(NEW.dt_procedimento_referencia, to_date('01/01/2000', 'dd/mm/yyyy')) !=
		 coalesce(OLD.dt_procedimento_referencia, to_date('01/01/2000', 'dd/mm/yyyy'))) then
		NEW.dt_procedimento_referencia_sh := trunc(NEW.dt_procedimento_referencia, 'dd');
	end if;
									
	if (NEW.cd_procedimento 	is not null) 	and (NEW.ie_origem_proced	is null)	and (OLD.ie_origem_proced	is not null)	then
		CALL wheb_mensagem_pck.exibir_mensagem_abort(288127);
	elsif (TG_OP = 'INSERT') and (NEW.cd_procedimento 	is not null) and (NEW.ie_origem_proced	is null) then
		ds_log_glosa_w := 'Procedimento informado no entanto origem do mesmo nula ';
		
		insert into	pls_conta_log(	nr_sequencia,dt_atualizacao, nm_usuario,
							dt_atualizacao_nrec, nm_usuario_nrec, nr_seq_conta,
							nr_seq_conta_proc, nr_seq_conta_mat, nm_usuario_alteracao,
							dt_alteracao, ds_alteracao)
				values (	nextval('pls_conta_log_seq'), LOCALTIMESTAMP, NEW.nm_usuario,
							LOCALTIMESTAMP, NEW.nm_usuario, NEW.nr_seq_conta,
							NEW.nr_sequencia, null, NEW.nm_usuario,
							LOCALTIMESTAMP, ds_log_glosa_w ||dbms_utility.format_call_stack);
	end if;
	
	
	if	((OLD.vl_glosa > 0 and NEW.vl_glosa = 0 AND NEW.ie_glosa = 'S') or
		 ((NEW.vl_glosa = 0) and (NEW.ie_glosa = 'S') and (OLD.ie_glosa = 'N'))) then
		
		ds_log_glosa_w := 'new.vl_glosa = '||NEW.vl_glosa||' Old.vl_glosa = '||OLD.vl_glosa||' new.ie_glosa ='||NEW.ie_glosa||' old.ie_glosa = '||OLD.ie_glosa;
		
		insert into	pls_conta_log(	nr_sequencia,dt_atualizacao, nm_usuario,
							dt_atualizacao_nrec, nm_usuario_nrec, nr_seq_conta,
							nr_seq_conta_proc, nr_seq_conta_mat, nm_usuario_alteracao,
							dt_alteracao, ds_alteracao)
				values (	nextval('pls_conta_log_seq'), LOCALTIMESTAMP, NEW.nm_usuario,
							LOCALTIMESTAMP, NEW.nm_usuario, NEW.nr_seq_conta,
							NEW.nr_sequencia, null, NEW.nm_usuario,
							LOCALTIMESTAMP, ds_log_glosa_w ||dbms_utility.format_call_stack);
	end if;
	
	-- OS 1900828, log para registar quando um proc fica com ie_glosa = 'S', vl_glosa = 0 e com o vl_liberado > 0

	-- podera ser removido se desejado, apos a solucao da os 1900828

	if	((NEW.ie_glosa =  'S') and (NEW.vl_glosa = 0) and (NEW.vl_Liberado > 0)) then
	
		ds_log_glosa_w := substr(':new.ie_glosa: '||NEW.ie_glosa||' - old.ie_glosa: '||OLD.ie_glosa||' - :new.vl_glosa: '||NEW.vl_glosa||' - :old.vl_glosa: '||OLD.vl_glosa||' - :new.vl_liberado: '||NEW.vl_liberado||' - :old.vl_liberado: '||OLD.vl_liberado, 1, 100);
		insert into	pls_conta_log(	nr_sequencia,dt_atualizacao, nm_usuario,
							dt_atualizacao_nrec, nm_usuario_nrec, nr_seq_conta,
							nr_seq_conta_proc, nr_seq_conta_mat, nm_usuario_alteracao,
							dt_alteracao, ds_alteracao)
				values (	nextval('pls_conta_log_seq'), LOCALTIMESTAMP, NEW.nm_usuario,
							LOCALTIMESTAMP, NEW.nm_usuario, NEW.nr_seq_conta,
							NEW.nr_sequencia, null, NEW.nm_usuario,
							LOCALTIMESTAMP, ds_log_glosa_w ||dbms_utility.format_call_stack);
	end if;
	
	-- controle OS 737623

	
	if (OLD.dt_inicio_proc is not null and NEW.dt_inicio_proc is null) and (NEW.ie_situacao	= 'D') then
		insert into	pls_conta_log(	nr_sequencia,dt_atualizacao, nm_usuario,
							dt_atualizacao_nrec, nm_usuario_nrec, nr_seq_conta,
							nr_seq_conta_proc, nr_seq_conta_mat, nm_usuario_alteracao,
							dt_alteracao, ds_alteracao)
				values (	nextval('pls_conta_log_seq'), LOCALTIMESTAMP, NEW.nm_usuario,
							LOCALTIMESTAMP, NEW.nm_usuario, NEW.nr_seq_conta,
							NEW.nr_sequencia, null, NEW.nm_usuario,
							LOCALTIMESTAMP, 'Hora nula '||dbms_utility.format_call_stack);
	end if;
	
	if (NEW.ie_ato_cooperado is null) and (NEW.ie_status	= 'M') and (TG_OP = 'UPDATE') then
		insert into	pls_conta_log(	nr_sequencia,dt_atualizacao, nm_usuario,
							dt_atualizacao_nrec, nm_usuario_nrec, nr_seq_conta,
							nr_seq_conta_proc, nr_seq_conta_mat, nm_usuario_alteracao,
							dt_alteracao, ds_alteracao)
				values (	nextval('pls_conta_log_seq'), LOCALTIMESTAMP, NEW.nm_usuario,
							LOCALTIMESTAMP, NEW.nm_usuario, NEW.nr_seq_conta,
							NEW.nr_sequencia, null, NEW.nm_usuario,
							LOCALTIMESTAMP, 'Ato cooperado não identificado '||dbms_utility.format_call_stack);
	end if;
	
	-- Adiciona a data do procedimento no dt_inicio_proc

	-- Necessário pois na gestão de contas médicas a data de inicio pode vir como 30/12/1899, e a data de fim como a data atual.

	-- Na valorização essa situação é problematica quando existe regra para verificar a diferença entre minutos, gerando um travamento devido 

	-- a grande diferença entre as datas.

	
	if	(NEW.dt_inicio_proc is not null AND NEW.dt_procedimento is not null) then
	
		NEW.dt_inicio_proc	:= to_date(to_char(NEW.dt_procedimento, 'dd/mm/yyyy')|| ' ' || coalesce(to_char(NEW.dt_inicio_proc, 'hh24:mi:ss'), '00:00:00'), 'dd/mm/yyyy hh24:mi:ss');	
	end if;
	
	-- Adiciona a data do procedimento no dt_fim_proc

	-- Necessário pois na gestão de contas médicas a data de inicio pode vir como 30/12/1899, e a data de fim como a data atual.

	-- Na valorização essa situação é problematica quando existe regra para verificar a diferença entre minutos, gerando um travamento devido 

	-- a grande diferença entre as datas.

	if	(NEW.dt_fim_proc is not null AND NEW.dt_procedimento is not null) then
	
		NEW.dt_fim_proc	:= to_date(to_char(NEW.dt_procedimento, 'dd/mm/yyyy')|| ' ' || coalesce(to_char(NEW.dt_fim_proc, 'hh24:mi:ss'), '00:00:00'), 'dd/mm/yyyy hh24:mi:ss');
	end if;
	
	if (OLD.vl_pag_medico_conta <= OLD.vl_liberado) and
		(NEW.vl_pag_medico_conta > NEW.vl_liberado AND NEW.vl_liberado > 0 ) then
		insert into	pls_conta_log(	nr_sequencia,dt_atualizacao, nm_usuario,
							dt_atualizacao_nrec, nm_usuario_nrec, nr_seq_conta,
							nr_seq_conta_proc, nr_seq_conta_mat, nm_usuario_alteracao,
							dt_alteracao, ds_alteracao)
				values (	nextval('pls_conta_log_seq'), LOCALTIMESTAMP, NEW.nm_usuario,
							LOCALTIMESTAMP, NEW.nm_usuario, NEW.nr_seq_conta,
							NEW.nr_sequencia, null, NEW.nm_usuario,
							LOCALTIMESTAMP, 'Pag médico superior vl liberado '||NEW.vl_pag_medico_conta||' vl medico '||NEW.vl_liberado||' '||dbms_utility.format_call_stack);
	end if;
		
	/* Francisco - OS 812883 - Se mudar a data de um procedimento precisa recalcular a data do atendimento */


	if (NEW.dt_procedimento <> OLD.dt_procedimento) or (OLD.dt_procedimento is null and NEW.dt_procedimento is not null) then
		
		CALL wheb_usuario_pck.set_ie_executar_trigger('N');
		
		update	pls_conta
		set		dt_atendimento_referencia	 = NULL
		where	nr_sequencia	= NEW.nr_seq_conta;
		
		CALL wheb_usuario_pck.set_ie_executar_trigger('S');
		
	end if;
	
	select	coalesce(max(ie_desc_item_glosa_atend),'N')
	into STRICT	ie_desc_item_glosa_atend_w
	from	pls_parametros
	where	cd_estabelecimento = cd_estabelecimento_w;

	-- OS 1100687 - Se o item for glosado 100% e se a data dele for a data da conta	

	if 	((((coalesce(OLD.ie_glosa,'N') = 'N') and (NEW.ie_glosa = 'S')) or
		((coalesce(OLD.ie_glosa,'N') = 'S') and (coalesce(NEW.ie_glosa,'N') = 'N'))) and (ie_desc_item_glosa_atend_w = 'S') and (NEW.dt_procedimento_referencia = dt_atendimento_referencia_w)) then
	
		CALL wheb_usuario_pck.set_ie_executar_trigger('N');
		
		update	pls_conta
		set	dt_atendimento_referencia  = NULL
		where	nr_sequencia = NEW.nr_seq_conta;

		CALL wheb_usuario_pck.set_ie_executar_trigger('S');

	end if;
		
	--Durante o processo de importação o campo dt_atendimento_imp_referencia não estava sendo atualizado à medida que os procedimentos eram inseridos.

	if (NEW.dt_procedimento_imp <> OLD.dt_procedimento_imp) or (OLD.dt_procedimento_imp is null and NEW.dt_procedimento_imp is not null) then
		
		CALL wheb_usuario_pck.set_ie_executar_trigger('N');
		
		update	pls_conta
		set	dt_atendimento_imp_referencia	 = NULL
		where	nr_sequencia	= NEW.nr_seq_conta;
		
		CALL wheb_usuario_pck.set_ie_executar_trigger('S');
	end if;
	
	if (TG_OP = 'INSERT') and (NEW.ie_via_acesso is not null and NEW.ie_via_acesso_imp is null) then
		NEW.ie_via_acesso_imp := NEW.ie_via_acesso;
	end if;
end if;
--é necessário que estes controles fiquem aqui fora pois independente do processo precisa ser mantida a consistência

if (OLD.ie_status = 'D') and
	((NEW.ie_status <> 'D') or (NEW.ie_status is null)) and (NEW.nr_seq_regra_canc_item_orig is not null) then
	NEW.ie_status := 'D';
end if;
/*O item com status faturamento manual, não pode ser alterado de modo a não interferir no pagamento*/


if (OLD.ie_status	= 'M') and (OLD.ie_status	!= NEW.ie_status) then
	NEW.ie_status	:= 'M';
end if;
		
  END;
RETURN NEW;
end;
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_pls_conta_proc_atual() FROM PUBLIC;

CREATE TRIGGER pls_conta_proc_atual
	BEFORE INSERT OR UPDATE ON pls_conta_proc FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_pls_conta_proc_atual();

