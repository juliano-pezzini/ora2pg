-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS checkup_before ON checkup CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_checkup_before() RETURNS trigger AS $BODY$
declare
qt_reg_w			bigint;
ie_dia_semana_w			bigint;
ie_bloqueio_w			varchar(10);
ie_bloqueio_dia_w		varchar(10);
cd_empresa_w			bigint;
cd_estabelecimento_w		smallint;
ie_bloqueio_exce_w		varchar(10) := 'N';
cd_estabelecimento_base_w	smallint;
BEGIN
  BEGIN


if (wheb_usuario_pck.get_ie_executar_trigger	= 'N')  then
	goto Final;
end if;
if (NEW.dt_previsto <> OLD.dt_previsto) then
	update	checkup_etapa
	set	dt_prevista	= (dt_prevista + (NEW.dt_previsto - OLD.dt_previsto))
	where	nr_seq_checkup	= NEW.nr_sequencia;
end if;

if (OLD.nr_atendimento is null) and (NEW.nr_atendimento is not null) then
	update	med_avaliacao_paciente
	set	nr_atendimento = NEW.nr_atendimento
	where	nr_seq_checkup = NEW.nr_sequencia;
end if;

if (NEW.cd_pessoa_fisica	is not null) and (OLD.cd_pessoa_fisica is null) then
	if (NEW.nm_usuario_original is null) then
		NEW.nm_usuario_original	:= NEW.nm_usuario;
	end if;
	if (NEW.dt_agendamento is null) then
		NEW.dt_agendamento		:= NEW.dt_atualizacao;
	end if;
end if;

select  COUNT(*)
INTO STRICT	QT_REG_W
from   	CHECKUP_EMPRESA_ESTAB a
where 	a.cd_empresa    = NEW.cd_empresa_ref;

if (QT_REG_W > 0) then
	select  COUNT(*)
	INTO STRICT	QT_REG_W
	from   	CHECKUP_EMPRESA_ESTAB a
	where 	a.cd_empresa    = NEW.cd_empresa_ref
	and   	a.cd_estabelecimento  = NEW.cd_estabelecimento
	and	coalesce(ie_permite,'N') = 'N';

	if (QT_REG_W > 0) then
		CALL exibir_erro_abortar('Empresa não liberada para este estabelecimento. #@#@',null);
	end if;
end if;

select  count(*)
into STRICT	qt_reg_w
from   	checkup_empresa_estab a
where 	a.cd_convenio    = NEW.cd_convenio;

if (qt_reg_w > 0) then
	select  COUNT(*)
	INTO STRICT	qt_reg_w
	from   	CHECKUP_EMPRESA_ESTAB a
	where 	a.cd_convenio    = NEW.cd_convenio
	and   	a.cd_estabelecimento  = NEW.cd_estabelecimento
	and	coalesce(ie_permite,'N') = 'N';

	if (qt_reg_w > 0) then
		CALL exibir_erro_abortar('Convênio não liberado para este estabelecimento. #@#@',null);
	end if;
end if;

BEGIN
ie_dia_semana_w		:= pkg_date_utils.get_WeekDay(NEW.dt_previsto);
select 'S'
into STRICT	ie_bloqueio_w
from	CHECKUP_bloqueio
where	trunc(NEW.dt_previsto) between dt_inicial and dt_final
and	((cd_Estabelecimento = NEW.cd_estabelecimento) or (cd_estabelecimento is null))
and	ie_dia_semana is null;
exception
	when others then
		ie_bloqueio_w := 'N';
	end;

BEGIN
/* bloqueio por dia */

select 'S'
into STRICT	ie_bloqueio_dia_w
from	CHECKUP_bloqueio
where	trunc(NEW.dt_previsto) between dt_inicial and dt_final
and	((ie_dia_semana = ie_dia_semana_w) or (ie_dia_semana = 9))
and	((cd_Estabelecimento = NEW.cd_estabelecimento) or (cd_estabelecimento is null))
and	ie_dia_semana is not null;
exception
	when others then
		ie_bloqueio_dia_w := 'N';
end;

BEGIN
select 'S'
into STRICT	ie_bloqueio_exce_w
from	CHECKUP_REGRA_DIA a
where	trunc(NEW.dt_previsto) = trunc(a.dt_referencia)
and	((cd_Estabelecimento = NEW.cd_estabelecimento) or (cd_estabelecimento is null));
exception
	when others then
		ie_bloqueio_exce_w := 'N';
end;

if	((ie_bloqueio_w	= 'S') or (ie_bloqueio_dia_w	= 'S')) and (ie_bloqueio_exce_w = 'N') then
	CALL exibir_erro_abortar('Período bloqueado para o agendamento. #@#@',null);
end if;

if (NEW.NR_SEQ_MOTIVO_CANCEL is null) and (OLD.NR_SEQ_MOTIVO_CANCEL is not null) and (NEW.DT_CANCELAMENTO is not null) then
	CALL exibir_erro_abortar('Não é possível remover o motivo de cancelamento. #@#@',null);
end if;

if (NEW.cd_setor_atendimento is not null) then
	select	max(cd_estabelecimento_base)
	into STRICT	cd_estabelecimento_base_w
	from	setor_atendimento
	where	cd_setor_atendimento	= NEW.cd_setor_atendimento;

	if (cd_estabelecimento_base_w <> NEW.cd_estabelecimento) then
		CALL Wheb_mensagem_pck.exibir_mensagem_abort(270147);
	end if;
end if;

<<Final>>
qt_reg_w	:= 0;

  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_checkup_before() FROM PUBLIC;

CREATE TRIGGER checkup_before
	BEFORE INSERT OR UPDATE ON checkup FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_checkup_before();

