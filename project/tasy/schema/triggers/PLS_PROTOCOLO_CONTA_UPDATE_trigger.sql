-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS pls_protocolo_conta_update ON pls_protocolo_conta CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pls_protocolo_conta_update() RETURNS trigger AS $BODY$
declare

qt_titulo_w			bigint;
vl_saldo_titulos_w		double precision;
ds_log_call_w			varchar(1500);
ds_observacao_w			varchar(4000);
ds_string_redundancia_w		pls_conta_proc.ds_redundancia%type;
qt_sem_tit_w			integer;

C01 CURSOR(	nr_seq_protocolo_pc	pls_protocolo_conta.nr_sequencia%type) FOR
	SELECT	a.dt_atendimento_imp_referencia,
		a.dt_atendimento_referencia,
		a.nr_seq_prestador_exec,
		a.nr_sequencia nr_seq_conta
	from	pls_conta a
	where	a.nr_seq_protocolo = nr_seq_protocolo_pc;

BEGIN

if (coalesce(wheb_usuario_pck.get_ie_lote_contabil,'N') = 'N') and (coalesce(wheb_usuario_pck.get_ie_atualizacao_contabil,'N') = 'N') then

	if (coalesce(wheb_usuario_pck.get_ie_executar_trigger,'S') = 'S')  then

		if (NEW.ie_tipo_protocolo = 'R') and (NEW.nr_seq_segurado <> OLD.nr_seq_segurado) then

			--aaschlote 22/12/2014 OS 824746 - Tratamento para não dar erro quando chamar a trigger PLS_CONTA_ATUAL
			CALL wheb_usuario_pck.set_ie_executar_trigger('N');
			update	pls_conta
			set	nr_seq_segurado = NEW.nr_seq_segurado
			where	nr_seq_protocolo = NEW.nr_sequencia;
			CALL wheb_usuario_pck.set_ie_executar_trigger('S');
		end if;

		if (NEW.dt_integracao is not null) and (OLD.dt_integracao is null) and (NEW.ie_situacao = 'RE') then

			CALL wheb_mensagem_pck.exibir_mensagem_abort(273258);
		end if;

		/*Consistência para verificar se existe títulos já quitados para o protocolo, este caso não pode ser alterado o status dos itens*/

		if (OLD.ie_status = '6') and (OLD.ie_status <> NEW.ie_status) then

			select	sum(qt)
			into STRICT	qt_titulo_w
			from (
				SELECT	count(1) qt
				from	pls_pag_prest_vencimento a,
					pls_pagamento_prestador b,
					pls_conta_medica_resumo c
				where	a.nr_seq_pag_prestador = b.nr_sequencia
				and	c.nr_seq_prestador_pgto = b.nr_seq_prestador
				and	b.nr_seq_lote = c.nr_seq_lote_pgto
				and	c.nr_seq_protocolo = NEW.nr_sequencia
				and	a.nr_titulo is not null
				and	c.ie_situacao = 'A'
				
union all

				SELECT	count(1) qt
				from	pls_conta_medica_resumo a,
					pls_pp_prestador b
				where	a.nr_seq_protocolo = NEW.nr_sequencia
				and	a.ie_situacao = 'A'
				and	b.nr_seq_lote = a.nr_seq_pp_lote
				and	b.nr_seq_prestador = a.nr_seq_prestador_pgto
				and	b.nr_titulo_pagar is not null  LIMIT 1) alias5;

			if (qt_titulo_w > 0) then

				select	sum(vl_saldo)
				into STRICT	vl_saldo_titulos_w
				from (
					SELECT	coalesce(sum(CASE WHEN d.ie_situacao='C' THEN  1  ELSE d.vl_saldo_titulo END ),0) vl_saldo	-- Edgar 03/05/2014, OS 743393, coloquei o decode "1", para considerar que os títulos cancelados tem saldo, para não entrar na consistência abaixo
					from	pls_pag_prest_vencimento a,
						pls_pagamento_prestador b,
						pls_conta_medica_resumo c,
						titulo_pagar d
					where	a.nr_seq_pag_prestador	= b.nr_sequencia
					and	c.nr_seq_prestador_pgto	= b.nr_seq_prestador
					and	a.nr_titulo = d.nr_titulo
					and	b.nr_seq_lote = c.nr_seq_lote_pgto
					and	c.nr_seq_protocolo = NEW.nr_sequencia
					and	c.ie_situacao = 'A'
					
union all

					SELECT	sum(CASE WHEN c.ie_situacao='C' THEN  1  ELSE coalesce(c.vl_saldo_titulo,0) END ) vl_saldo
					from	pls_conta_medica_resumo a,
						pls_pp_prestador b,
						titulo_pagar c
					where	a.nr_seq_protocolo = NEW.nr_sequencia
					and	a.ie_situacao = 'A'
					and	b.nr_seq_lote = a.nr_seq_pp_lote
					and	b.nr_seq_prestador = a.nr_seq_prestador_pgto
					and	c.nr_titulo = b.nr_titulo_pagar) alias6;

				-- tratamento criado para quando não houver titulo ainda gerado para os itens
				-- alterei este tratamento para verificar se os lotes já estão todos com data de geração dos títulos
				-- pois não necessáriamente um prestador irá ter um titulo a pagar, pode ser que ele tenha ficado com valores
				-- negativos e estes valores foram apropriados ou gerado um título a receber
				select	sum(qt)
				into STRICT	qt_sem_tit_w
				from (
					SELECT	count(1) qt
					from	pls_conta_medica_resumo a,
						pls_lote_pagamento b
					where	a.nr_seq_protocolo = NEW.nr_sequencia
					and	a.ie_situacao = 'A'
					and	b.nr_sequencia = a.nr_seq_lote_pgto
					and	b.dt_geracao_titulos is null
					
union all

					SELECT	count(1) qt
					from	pls_conta_medica_resumo a,
						pls_pp_lote b
					where	a.nr_seq_protocolo = NEW.nr_sequencia
					and	a.ie_situacao = 'A'
					and	b.nr_sequencia = a.nr_seq_pp_lote
					and	b.dt_geracao_titulo is null  LIMIT 1) alias3;

				if (vl_saldo_titulos_w = 0) and (qt_sem_tit_w = 0) then

					--'Os títulos do protocolo estão liquidados não é possível alterar o status do mesmo !  #@#@');
					CALL wheb_mensagem_pck.exibir_mensagem_abort(226722);
				end if;
			end if;
		end if;

		if (pls_se_aplicacao_tasy = 'N') then

			ds_log_call_w := substr(pls_obter_detalhe_exec(false),1,1500);/*substr(	' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
					' CallStack: '|| chr(13) || chr(10)|| dbms_utility.format_call_stack,1,1500);*/
					--' Função ativa : '|| obter_funcao_ativa || chr(13) ||chr(10)||
			ds_observacao_w := 'Protocolo: '||OLD.nr_sequencia;

			if (coalesce(OLD.nr_seq_prestador,0) <> coalesce(NEW.nr_seq_prestador,0)) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Prestador: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||OLD.nr_seq_prestador||' - Modificada: '||NEW.nr_seq_prestador||chr(13)||chr(10);
			end if;

			if (coalesce(OLD.ie_tipo_protocolo,'X') <> coalesce(NEW.ie_tipo_protocolo,'X')) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Tipo protocolo: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||OLD.ie_tipo_protocolo||' - Modificada: '||NEW.ie_tipo_protocolo||chr(13)||chr(10);
			end if;

			if (coalesce(OLD.nr_seq_lote,0) <> coalesce(NEW.nr_seq_lote,0)) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Lote: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||OLD.nr_seq_lote||' - Modificada: '||NEW.nr_seq_lote||chr(13)||chr(10);
			end if;

			if (coalesce(OLD.nr_seq_lote_conta,0) <> coalesce(NEW.nr_seq_lote_conta,0)) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Lote de contas: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||OLD.nr_seq_lote_conta||' - Modificada: '||NEW.nr_seq_lote_conta||chr(13)||chr(10);
			end if;

			if (coalesce(OLD.ie_status,'X') <> coalesce(NEW.ie_status,'X')) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Status: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||OLD.ie_status||' - Modificada: '||NEW.ie_status||chr(13)||chr(10);
			end if;

			if (coalesce(to_char(OLD.dt_protocolo),'X') <> coalesce(to_char(NEW.dt_protocolo),'X')) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Dt. protocolo: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||to_char(OLD.dt_protocolo, 'dd/mm/yyyy')||' - Modificada: '||to_char(NEW.dt_protocolo, 'dd/mm/yyyy')||chr(13)||chr(10);
			end if;

			if (coalesce(to_char(OLD.dt_recebimento),'X') <> coalesce(to_char(NEW.dt_recebimento),'X')) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Dt. recebimento: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||to_char(OLD.dt_recebimento, 'dd/mm/yyyy')||' - Modificada: '||to_char(NEW.dt_recebimento, 'dd/mm/yyyy')||chr(13)||chr(10);
			end if;

			if (coalesce(to_char(OLD.dt_mes_competencia),'X') <> coalesce(to_char(NEW.dt_mes_competencia),'X')) then
				ds_observacao_w :=	ds_observacao_w||chr(13)||chr(10)||
							'Dt. mês competência: '||chr(13)||chr(10)||
							chr(9)||'Anterior: '||to_char(OLD.dt_mes_competencia, 'dd/mm/yyyy')||' - Modificada: '||to_char(NEW.dt_mes_competencia, 'dd/mm/yyyy')||chr(13)||chr(10);
			end if;

			if (NEW.ie_apresentacao is null and OLD.ie_apresentacao is not null) then
				ds_observacao_w := ds_observacao_w||chr(13)||chr(10)||
								chr(9)||'  sem informação de tipo de apresentação'||chr(13)||chr(10)||
								chr(9)||'Anterior: '||OLD.ie_apresentacao||' - Modificada: '||NEW.ie_apresentacao||chr(13)||chr(10);
			end if;

			insert into plsprco_cta(
				nr_sequencia, dt_atualizacao, nm_usuario,
				dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
				ds_log, ds_log_call, ds_funcao_ativa,
				ie_aplicacao_tasy, nm_maquina, ie_opcao,
				nr_seq_protocolo
			) values (
				nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
				LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_PROTOCOLO_CONTA',
				ds_observacao_w, ds_log_call_w, obter_funcao_ativa,
				'N', wheb_usuario_pck.get_machine, '0',
				NEW.nr_sequencia
			);
		else
			if (NEW.ie_apresentacao is null and OLD.ie_apresentacao is not null) then

				ds_log_call_w := substr(pls_obter_detalhe_exec(false),1,1500);
				ds_observacao_w := ds_observacao_w||chr(13)||chr(10)||
								chr(9)||'  sem informação de tipo de apresentação'||chr(13)||chr(10)||
								chr(9)||'Anterior: '||OLD.ie_apresentacao||' - Modificada: '||NEW.ie_apresentacao||chr(13)||chr(10);

				insert into plsprco_cta(
					nr_sequencia, dt_atualizacao, nm_usuario,
					dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
					ds_log, ds_log_call, ds_funcao_ativa,
					ie_aplicacao_tasy, nm_maquina, ie_opcao,
					nr_seq_protocolo
				) values (
					nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
					LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_PROTOCOLO_CONTA',
					ds_observacao_w, ds_log_call_w, obter_funcao_ativa,
					'N', wheb_usuario_pck.get_machine, '0',
					NEW.nr_sequencia
				);

			end if;
		end if;

		if (NEW.dt_integracao is not null) and (NEW.ie_situacao = 'RE') then

			ds_log_call_w := substr(pls_obter_detalhe_exec(false),1,1500);

			insert into plsprco_cta(
				nr_sequencia, dt_atualizacao, nm_usuario,
				dt_atualizacao_nrec, nm_usuario_nrec, nm_tabela,
				ds_log, ds_log_call, ds_funcao_ativa,
				ie_aplicacao_tasy, nm_maquina, ie_opcao,
				nr_seq_protocolo
			) values (
				nextval('plsprco_cta_seq'), LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14),
				LOCALTIMESTAMP, substr(coalesce(wheb_usuario_pck.get_nm_usuario,'Usuário não identificado '),1,14), 'PLS_PROTOCOLO_CONTA',
				'Rejeitou um protocolo integrado', ds_log_call_w, obter_funcao_ativa,
				pls_se_aplicacao_tasy, wheb_usuario_pck.get_machine, '0',
				NEW.nr_sequencia
			);
		end if;
	end if;

	-- controle de redundâncias para tratamento de procedimentos e materiais
	-- se for atualização somente, pois no insert ainda não existem procedimentos ou materiais
	if (TG_OP = 'UPDATE') then

		-- se mudou alguma destas datas na conta significa que é necessário atualizar as redundâncias que existem nos itens
		-- isso é feito por motivos de performance e principalmente para atender as regras de negócio de forma mais simples
		-- possibilita que exista no item a data correta do atendimento sem precisar efetuar cálculos
		-- centraliza a regra de negócio da atualização dos itens na trigger dos itens
		if	((coalesce(NEW.dt_protocolo, to_date('31/12/1899', 'DD/MM/YYYY')) != coalesce(OLD.dt_protocolo, to_date('31/12/1899','DD/MM/YYYY'))) or (coalesce(NEW.dt_mes_competencia, to_date('31/12/1899', 'DD/MM/YYYY')) != coalesce(OLD.dt_mes_competencia, to_date('31/12/1899', 'DD/MM/YYYY')))) then

			-- seta para controlar para que partes das triggers dos itens não rode
			pls_util_pck.get_ie_executar_redundancia_w := 'S';

			for r_C01_w in C01(NEW.nr_sequencia) loop

				ds_string_redundancia_w := 'dt_atendimento_imp_referencia=' || to_char(r_C01_w.dt_atendimento_imp_referencia) ||
							   ';dt_atendimento_referencia=' || to_char(r_C01_w.dt_atendimento_referencia) ||
							   ';nr_seq_prestador_exec=' || to_char(r_C01_w.nr_seq_prestador_exec) ||
							   ';dt_protocolo=' || to_char(NEW.dt_protocolo) ||
							   ';dt_mes_competencia=' || to_char(NEW.dt_mes_competencia);

				-- atualiza os procedimentos
				update	pls_conta_proc set
					ds_redundancia = ds_string_redundancia_w
				where	nr_seq_conta = r_C01_w.nr_seq_conta;

				-- atualiza os materiais
				update	pls_conta_mat set
					ds_redundancia = ds_string_redundancia_w
				where	nr_seq_conta = r_C01_w.nr_seq_conta;
			end loop;

			-- volta para o valor padrão
			pls_util_pck.get_ie_executar_redundancia_w := 'N';
		end if;
	end if;
end if;
RETURN NEW;
end
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_pls_protocolo_conta_update() FROM PUBLIC;

CREATE TRIGGER pls_protocolo_conta_update
	BEFORE UPDATE ON pls_protocolo_conta FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_pls_protocolo_conta_update();

