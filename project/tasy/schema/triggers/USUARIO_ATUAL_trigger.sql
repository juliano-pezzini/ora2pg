-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS usuario_atual ON usuario CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_usuario_atual() RETURNS trigger AS $BODY$
DECLARE
  linha RECORD;

qt_senha_w	bigint;
qt_reg_w	bigint;
qt_usuario_w integer;

BEGIN
if (wheb_usuario_pck.get_ie_executar_trigger	= 'N')  then
	goto Final;
end if;

if (NEW.qt_dia_senha is null) then
	NEW.qt_dia_senha	:= 180;
end if;

if	((NEW.qt_dia_senha > 180) or (NEW.qt_dia_senha < 1)) and (NEW.qt_dia_senha <> coalesce(OLD.qt_dia_senha,99999)) then
	--197506
	CALL wheb_mensagem_pck.exibir_mensagem_abort(197506);
	--rise_application_error(-20011,'O Número de dias deve estar entre 1 e 180. (CFM/SBIS)');
end if;

if	(( OLD.nm_usuario is null) or (upper(OLD.nm_usuario) <> upper(NEW.nm_usuario) )) and (existe_login_usuario(NEW.nm_usuario) = 'S') then
	--197545
	CALL wheb_mensagem_pck.exibir_mensagem_abort(197545);
	--rise_application_error(-20011,'Nome de usuário já sendo utilizado. Registro não gravado!');
end if;
if	((OLD.ds_login is null) or (upper(OLD.ds_login) <> upper(NEW.ds_login))) and ( existe_login_usuario(NEW.ds_login) = 'S') then
	--197546
	CALL wheb_mensagem_pck.exibir_mensagem_abort(197546);
	--rise_application_error(-20011,'Login alternativo já está sendo utilizado. Registro não gravado!#@#@');
end if;

if (NEW.ds_login is not null) and (upper(NEW.nm_usuario) <> upper(OLD.ds_login)) and (upper(NEW.nm_usuario)  = upper(NEW.ds_login)) then
	 --197547
	 CALL wheb_mensagem_pck.exibir_mensagem_abort(197547);
	--rise_application_error(-20011,'O nome do usuário e login alternativo não podem ser iguais. Registro não gravado!#@#@');
end if;

if ( NEW.ds_senha_email <> OLD.ds_senha_email ) or ( OLD.ds_senha_email is null and NEW.ds_senha_email is not null) then
	NEW.ds_senha_email := WHEB_SEGURANCA.ENCRYPT(NEW.ds_senha_email);
end if;

if (NEW.ds_senha <> OLD.ds_senha) then
	insert	into usuario_hist_senha(
		NR_SEQUENCIA,
		DS_SENHA,
		DT_ATUALIZACAO,
		NM_USUARIO,
		DT_ATUALIZACAO_NREC,
		NM_USUARIO_NREC,
		ds_tec
	)values (
		nextval('usuario_hist_senha_seq'),
		NEW.ds_senha,
		LOCALTIMESTAMP,
		NEW.nm_usuario,
		LOCALTIMESTAMP,
		NEW.nm_usuario,
		NEW.ds_tec
	);
	NEW.qt_acesso_invalido := 0;

	if (NEW.dt_alteracao_senha is null) then
		delete from usuario_pergunta_senha where Upper(nm_usuario_pergunta) = Upper(OLD.nm_usuario);
	end	if;

	select	(obter_valor_param_usuario(6001,30,null,null, wheb_usuario_pck.get_cd_Estabelecimento))::numeric
	into STRICT	qt_senha_w
	;

	qt_reg_w := 0;
	for linha in (	SELECT	nr_sequencia
			FROM	USUARIO_HIST_SENHA
			WHERE	UPPER(nm_usuario) = UPPER(NEW.nm_usuario)
			ORDER BY dt_atualizacao DESC) loop

		qt_reg_w	:= qt_reg_w + 1;

		if (qt_reg_w > qt_senha_w) then
			delete from usuario_hist_senha where nr_sequencia = linha.nr_sequencia;
		end	if;

	end loop;
end if;


if (OLD.cd_certificado is null) and (NEW.cd_certificado is not null) then
	update	pep_item_pendente
	set	IE_PENDENTE_ASSINAT_USUARIO = 'N'
	where	IE_PENDENTE_ASSINAT_USUARIO = 'S'
	and	nm_usuario	= NEW.nm_usuario;
end if;

if (gerar_int_dankia_pck.get_ie_int_dankia = 'S') and (TG_OP = 'UPDATE') and (gerar_int_dankia_pck.get_ie_find_user_dankia(NEW.nm_usuario) = 'S') then
	if ((coalesce(NEW.ie_profissional,'X') <> coalesce(OLD.ie_profissional,'X')) or (coalesce(NEW.nm_usuario,'X') <> coalesce(OLD.nm_usuario, 'X')) or (coalesce(NEW.ds_usuario,'X') <> coalesce(OLD.ds_usuario, 'X')) or (coalesce(NEW.cd_barras, 'X') <> coalesce(OLD.cd_barras, 'X')) or (coalesce(NEW.ie_situacao, 'X') <> coalesce(OLD.ie_situacao, 'X')) or (coalesce(NEW.cd_estabelecimento,9999) <> coalesce(OLD.cd_estabelecimento,9999))) then
		CALL gerar_int_dankia_pck.dankia_atualizar_funcionario('A', NEW.ie_profissional, NEW.nm_usuario, NEW.ds_usuario, NEW.cd_barras, NEW.ie_situacao, NEW.cd_estabelecimento);
	end if;
end if;

NEW.nm_usuario_pesquisa	:= upper(NEW.nm_usuario);
NEW.ds_utc_atualizacao := obter_data_utc(LOCALTIMESTAMP,'HV');
NEW.ds_utc := OBTER_DATA_UTC(NEW.dt_atualizacao,'HV');
NEW.ie_horario_verao := obter_se_horario_verao(NEW.dt_atualizacao);

<<Final>>
qt_reg_w	:= 0;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_usuario_atual() FROM PUBLIC;

CREATE TRIGGER usuario_atual
	BEFORE INSERT OR UPDATE ON usuario FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_usuario_atual();

