-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE calculated_dose_pck.set_record (material_p bigint, pres_dose_p bigint, finalarray_p INOUT DOSAGE_ARRAY) AS $body$
DECLARE

    dos_object_w          DOSAGE_OBJECT;
    countqty_w            bigint;
    dosage_w              DOSAGE_ARRAY;
    reverese_dosage_w     DOSAGE_ARRAY;
    reverse_array1        DOSAGE_ARRAY;
    pres_dose_w           bigint;
    remainder_w           bigint;
    quoient_w             bigint;
    count_w               bigint;
    current_assumed_qty_w bigint;
    current_ppu_w         bigint;
    dose_w                bigint;
    current_w             bigint;
    total_cost_loop1_w    bigint;
    sum_assumed_qty       bigint;
    cost_w                bigint;
    c_record CURSOR FOR
      SELECT a.cd_material                                material,
             a.ds_material                                ds_material,
             qt_spec_group_dose                           QTY,
             b.vl_delivery_price                          packetprice,
             ( b.vl_delivery_price / qt_spec_group_dose ) PPU
      FROM   material a,
             mat_vendor_price_rules b
      WHERE  a.cd_material = b.cd_material
             AND b.dt_invoice_start <= Trunc(clock_timestamp())
             AND a.ie_situacao = 'A'
             AND a.cd_material_spec_grp = material_p
             AND NOT EXISTS (SELECT 1
                            FROM   mat_vendor_price_rules c
                            WHERE  c.cd_material = b.cd_material
                                   AND c.dt_invoice_start > b.dt_invoice_start
                                   AND c.dt_invoice_start <= Trunc(clock_timestamp()))
      ORDER  BY ppu ASC,
                qty DESC;

BEGIN
      SELECT Count(1)
      INTO STRICT   countqty_w
      FROM   material a,
             mat_vendor_price_rules b
      WHERE  a.cd_material = b.cd_material
             AND b.dt_invoice_start <= Trunc(clock_timestamp())
             AND a.ie_situacao = 'A'
             AND a.cd_material_spec_grp = material_p
             AND NOT EXISTS (SELECT 1
                            FROM   mat_vendor_price_rules c
                            WHERE  c.cd_material = b.cd_material
                                   AND c.dt_invoice_start > b.dt_invoice_start
                                   AND c.dt_invoice_start <= Trunc(clock_timestamp()));

      pres_dose_w := pres_dose_p;
      count_w := 1;
      FOR r_record IN c_record LOOP
          current_assumed_qty_w := 0;
          current_ppu_w := 0;
          dose_w := 0;
          remainder_w := MOD(pres_dose_w, r_record.qty);
          quoient_w := Floor(pres_dose_w / r_record.qty);
          IF ( countqty_w = count_w
              AND remainder_w > 0 ) THEN
            current_assumed_qty_w := ( r_record.qty * quoient_w ) + remainder_w;
          ELSE
            current_assumed_qty_w := r_record.qty * quoient_w;
          END IF;
          dose_w := Ceil(current_assumed_qty_w / r_record.qty);
          current_ppu_w := r_record.packetprice / r_record.qty;
          --dos_object_w :=Dosage_object('priceAlgo', r_record.qty, dose_w, 		   current_assumed_qty_w, r_record.packetprice, current_ppu_w, r_record.material, r_record.ds_material);
            dos_object_w.ppu  := 'priceAlgo';
            dos_object_w.qty := r_record.qty;
            dos_object_w.dose :=  dose_w;
            dos_object_w.assumedQty := current_assumed_qty_w;
            dos_object_w.packetprice := r_record.packetprice;
            dos_object_w.ppuValue := current_ppu_w;
            dos_object_w.material := r_record.material;
            dos_object_w.ds_material := r_record.ds_material;
           Dosage_w(count_w) := dos_object_w;
          pres_dose_w := remainder_w;
          count_w := count_w + 1;
END LOOP;

IF dosage_w.count > 0 THEN
  current_w := dosage_w.last;
  count_w := 1;
  total_cost_loop1_w := 0;

  WHILE current_w > 0 LOOP
      Reverese_dosage_w(count_w) := Dosage_w(current_w);
      total_cost_loop1_w := total_cost_loop1_w + (
      Dosage_w[current_w].packetprice * Dosage_w[current_w].dose );
      current_w := current_w - 1;
      count_w := count_w + 1;
  END LOOP;
END IF;
reverse_array1 := reverese_dosage_w;
FOR j IN 2.. reverse_array1.last LOOP
    sum_assumed_qty := 0;
    FOR k IN 1.. j-1 LOOP
        sum_assumed_qty := sum_assumed_qty  + Reverse_array1[k].assumedqty;
        Reverse_array1[k].assumedqty := 0;
        Reverse_array1[k].dose := 0;
    END LOOP;

    Reverse_array1[j].assumedqty := Reverse_array1[j].assumedqty + sum_assumed_qty;

    Reverse_array1[j].dose := Ceil(Reverse_array1[j].assumedqty /Reverse_array1[j].qty);

    cost_w := 0;

    FOR m IN reverse_array1.first .. reverse_array1.last LOOP
        cost_w := cost_w + Reverse_array1[m].dose * Reverse_array1[m].packetprice;
    END LOOP;

    IF ( cost_w <= total_cost_loop1_w ) THEN
      reverese_dosage_w := reverse_array1;

      total_cost_loop1_w := cost_w;
    END IF;

    reverse_array1 := reverese_dosage_w;
END LOOP;

finalarray_p := reverese_dosage_w;
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE calculated_dose_pck.set_record (material_p bigint, pres_dose_p bigint, finalarray_p INOUT DOSAGE_ARRAY) FROM PUBLIC;
