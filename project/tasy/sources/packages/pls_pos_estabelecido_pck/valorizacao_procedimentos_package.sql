-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


--Etapa de valorizacao dos procedimentos selecionados. Ser_o chamadas funcionalidades para leitura e aplicacao de regras



CREATE OR REPLACE PROCEDURE pls_pos_estabelecido_pck.valorizacao_procedimentos ( nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) AS $body$
DECLARE


_ora2pg_r RECORD;
dados_regra_preco_proc_w	dados_regra_preco_proc;
tb_dados_proc_w			table_dados_regra_preco_proc;
tx_intercambio_w		pls_conta_proc.tx_intercambio%type;
nr_seq_pos_estab_interc_w	pls_regra_preco_proc.nr_sequencia%type;
vl_beneficiario_w		pls_conta_pos_estabelecido.vl_beneficiario%type;
vl_custo_operacional_w		w_pls_conta_pos_proc.vl_custo_operacional_calc%type;
vl_materiais_w			w_pls_conta_pos_proc.vl_materiais_calc%type;
vl_medico_w			w_pls_conta_pos_proc.vl_medico_calc%type;
vl_dif_w			w_pls_conta_pos_proc.vl_prestador_apresentado%type;
tb_vl_medico_w			pls_util_cta_pck.t_number_table;
tb_vl_materiais_w		pls_util_cta_pck.t_number_table;
tb_vl_custo_operacional_w	pls_util_cta_pck.t_number_table;
tb_seq_item_w			pls_util_cta_pck.t_number_table;
ie_nao_gera_tx_inter_w		w_pls_conta_pos_proc.ie_nao_gera_tx_inter%type;
i				integer := 0;
tb_seq_part_w			pls_util_cta_pck.t_number_table;

--Apenas retorna os procedimentos que est_o eleg_veis para geracao de p_s-esatbelecido para ser realizado zeramento

--de valor de p_s-estabelecido, de modo a evitar alguns erros de c_lculo provenientes dessa "sujeira"

C00 CURSOR FOR
	SELECT  proc.nr_seq_conta_proc
	from	w_pls_conta_pos_proc proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB');

--Cursor com os itens identificados anteriormente como eleg_veis para geracao de p_s.

C01 CURSOR FOR
	SELECT	proc.nr_sequencia,
		proc.ie_tipo_despesa,
		proc.nr_seq_cabecalho,
		proc.tx_administracao,
		proc.nr_seq_conta_proc
	from	w_pls_conta_pos_proc proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and 	proc.ie_tipo_regra_pos not in (2, 3, 7, 8)
	
union all

	SELECT	proc.nr_sequencia,
		proc.ie_tipo_despesa,
		proc.nr_seq_cabecalho,
		proc.tx_administracao,
		proc.nr_seq_conta_proc
	from	w_pls_conta_pos_proc proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and 	coalesce(proc.ie_tipo_regra_pos::text, '') = '';

/*
Cursor utilizado para pegar casos onde pode n_o ter calculado os valores individuais. Entram os tipos 4 e 5 novamente pois pode n_o ter
pego regra de pre_o e nesse caso necessita calcular os valores individuais. 
valores:
	Primeira parte do union, onde pega o valor apresentado como "vl_beneficiario"
	2 -  Valor apresentado pelo prestador
	4-  Valor apresentado, caso Regra de pre_o seja 0
	7 -  Aceitar valor apresentado e desconta a taxa de interc_mbio
	
	Segunda parte do union, onde pega o valor liberado como "vl_beneficiario"
	3-  Valor a ser pago ao prestador 
	5 - Valor a ser pago ao prestador, caso Regra de pre_o seja 0
	7 -  Aceitar valor apresentado e desconta a taxa de interc_mbio
	
	Terceira parte do union, onde tinha uma regra por_m o valor obtido na mesma _ inferior ao valor pago ao prestador
	9 -  Valor a ser pago ao prestador, desde que menor que a regra de pre_o. Nesse caso, os valores vl_medico, vl_materiais
	      vl_custo_operacional estar_o populados na tabela tempor_ria, pois obteve regra de valorizacao na etapa anterior(cursor 1).

	Os tipos 4 e 5 entram no cursor 1, que faz a leitura de regras, por_m pode ser que n_o obtenha regra e devido a isso _ necess_rio 
	obter os valores individuais.
	
	Obs: Os valores individuais s_o calculados proporcionalmente conforme o valor calculado, por_m nos casos onde n_o obteve valor calculado
	ent_o n_o h_ divis_o do valor total entre os individuais, ficando tudo no vl_medico(um dos 3 valores individuais).

*/

C02 CURSOR FOR
	SELECT	proc.nr_sequencia,
		proc.vl_prestador_apresentado 				vl_pagto,
		(vl_custo_operacional_calc + vl_materiais_calc +
		 vl_medico_calc)					vl_calculado,
		proc.vl_custo_operacional_calc				vl_custo_operacional_calc,
		proc.vl_materiais_calc                                  vl_materiais_calc,
		proc.vl_medico_calc                                     vl_medico_calc,
		proc.nr_seq_conta_proc
	from	w_pls_conta_pos_proc proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and 	proc.ie_tipo_regra_pos  in (2, 4, 7)
	and 	coalesce(proc.nr_seq_regra_preco::text, '') = ''
	
union all

	SELECT	proc.nr_sequencia,
		proc.vl_prestador_pag					vl_pagto,
		(vl_custo_operacional_calc + vl_materiais_calc +
		 vl_medico_calc)					vl_calculado,
		proc.vl_custo_operacional_calc				vl_custo_operacional_calc,
		proc.vl_materiais_calc					vl_materiais_calc,
		proc.vl_medico_calc					vl_medico_calc,
		proc.nr_seq_conta_proc
	from	w_pls_conta_pos_proc proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and 	proc.ie_tipo_regra_pos  in (3, 5, 8, 9)
	and	coalesce(proc.nr_seq_regra_preco::text, '') = ''
	
union all
 
	select	proc.nr_sequencia,
		proc.vl_prestador_pag					vl_pagto,
		(vl_custo_operacional_calc + vl_materiais_calc +
		 vl_medico_calc)					vl_calculado,
		proc.vl_custo_operacional_calc				vl_custo_operacional_calc,
		proc.vl_materiais_calc					vl_materiais_calc,
		proc.vl_medico_calc					vl_medico_calc,
		proc.nr_seq_conta_proc
	from	w_pls_conta_pos_proc proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and 	proc.ie_tipo_regra_pos  = 9
	and	(proc.nr_seq_regra_preco IS NOT NULL AND proc.nr_seq_regra_preco::text <> '')
	and	proc.vl_prestador_apresentado > ( proc.vl_medico + proc.vl_custo_operacional + 
						  proc.vl_materiais);

BEGIN

	-- Primeiro reseta o valor de p_s(vl_pos_estab em todos os particiantes entre os procedimentos marcados como eleg_veis de gerar p_s). Como n_o tem operacaes

	--sobre a massa retornada, utilizo fetch com bulk collect j_ atualizando a informacao com o forall, reduzindo troca de contexto ao m_ximo.

	open C00;
	loop
		fetch 	C00 bulk collect
		into	tb_seq_part_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when tb_seq_part_w.count = 0;
		
		forall i in tb_seq_part_w.first..tb_seq_part_w.last
			update	pls_proc_participante
			set	vl_pos_estab = 0
			where 	nr_seq_conta_proc = tb_seq_part_w(i);
	end loop;
	close C00;
	
	tb_dados_proc_w := pls_pos_estabelecido_pck.atualiza_val_regra_proc_int(tb_dados_proc_w);
	for r_c01_w in C01 loop
	
		tx_intercambio_w := r_c01_w.tx_administracao;
		--Processa regras de valorizacao

		SELECT * FROM pls_pos_estabelecido_pck.pls_atualiza_valor_proc_pos(	r_c01_w.nr_sequencia, r_c01_w.nr_seq_cabecalho, r_c01_w.ie_tipo_despesa, 'N', nm_usuario_p, tx_intercambio_w, current_setting('pls_pos_estabelecido_pck.ie_pos_estab_faturamento_w')::pls_parametros.ie_pos_estab_faturamento%type, current_setting('pls_pos_estabelecido_pck.ie_geracao_pos_estabelecido_w')::pls_parametros.ie_geracao_pos_estabelecido%type, current_setting('pls_pos_estabelecido_pck.ie_preco_interc_congenere_w')::pls_parametros.ie_preco_interc_congenere%type, nr_seq_pos_estab_interc_w, vl_beneficiario_w, dados_regra_preco_proc_w ) INTO STRICT _ora2pg_r;
 tx_intercambio_w := _ora2pg_r.tx_intercambio_p; nr_seq_pos_estab_interc_w := _ora2pg_r.nr_seq_regra_p; vl_beneficiario_w := _ora2pg_r.vl_beneficiario_p; dados_regra_preco_proc_w  := _ora2pg_r.dados_regra_preco_proc_p;
		
		--tb_dados_proc_w(i) := dados_regra_preco_proc_w;

		tb_dados_proc_w.nr_seq_regra_preco(i) 		:= dados_regra_preco_proc_w.nr_seq_regra_preco;
		tb_dados_proc_w.vl_taxa_co(i)			:= coalesce(dados_regra_preco_proc_w.vl_taxa_co,0);
		tb_dados_proc_w.vl_taxa_material(i)		:= coalesce(dados_regra_preco_proc_w.vl_taxa_material,0);
		tb_dados_proc_w.vl_taxa_servico(i)		:= coalesce(dados_regra_preco_proc_w.vl_taxa_servico,0);
		tb_dados_proc_w.vl_materiais(i)			:= coalesce(dados_regra_preco_proc_w.vl_materiais,0);
		tb_dados_proc_w.vl_medico(i)			:= coalesce(dados_regra_preco_proc_w.vl_medico,0);
		tb_dados_proc_w.vl_custo_operacional(i)		:= coalesce(dados_regra_preco_proc_w.vl_custo_operacional,0);
		tb_dados_proc_w.qt_filme_tab(i)			:= dados_regra_preco_proc_w.qt_filme_tab;
		tb_dados_proc_w.vl_custo_operacional_tab(i)	:= coalesce(dados_regra_preco_proc_w.vl_custo_operacional_tab,0);
		tb_dados_proc_w.nr_seq_criterio_horario(i)	:= dados_regra_preco_proc_w.nr_seq_criterio_horario;
		tb_dados_proc_w.vl_proc_tabela(i)		:= coalesce(dados_regra_preco_proc_w.vl_proc_tabela,0);
		tb_dados_proc_w.vl_ch_honorarios(i)		:= coalesce(dados_regra_preco_proc_w.vl_ch_honorarios,0);
		tb_dados_proc_w.cd_moeda_autogerado(i)		:= dados_regra_preco_proc_w.cd_moeda_autogerado;
		tb_dados_proc_w.vl_base_filme(i)		:= coalesce(dados_regra_preco_proc_w.vl_base_filme,0);
		tb_dados_proc_w.cd_porte_anestesico(i)		:= dados_regra_preco_proc_w.cd_porte_anestesico;
		tb_dados_proc_w.tx_intercambio(i)		:= dados_regra_preco_proc_w.tx_intercambio;
		tb_dados_proc_w.ie_nao_gera_tx_inter(i)		:= dados_regra_preco_proc_w.ie_nao_gera_tx_inter;
		tb_dados_proc_w.nr_seq_proc(i)			:= dados_regra_preco_proc_w.nr_seq_proc;
				
		--Se atingiu quantidade m_xima de registros, atualiza no banco

		if ( i > pls_util_cta_pck.qt_registro_transacao_w) then
			
			--Realiza update dos valores retornados no processamento de regras anterior

			tb_dados_proc_w := pls_pos_estabelecido_pck.atualiza_val_regra_proc_int(tb_dados_proc_w);
			i := 0;
		else
			i := i + 1;
		end if;
		
	end loop;
	
	--Se sobraram registros nas estruturas, manda para o banco para atualizar a tabela tempor_ria de procedimentos.

	tb_dados_proc_w := pls_pos_estabelecido_pck.atualiza_val_regra_proc_int(tb_dados_proc_w);
	i := 0;
	
	--Chama a rotina aqui apenas para zerar as estruturas, antes de popular as mesmas na sequ_ncia da rotina.

	SELECT * FROM pls_pos_estabelecido_pck.atualiza_val_individuais_proc(tb_seq_item_w, tb_vl_medico_w, tb_vl_materiais_w, tb_vl_custo_operacional_w) INTO STRICT _ora2pg_r;
 tb_seq_item_w := _ora2pg_r.tb_seq_item_p; tb_vl_medico_w := _ora2pg_r.tb_vl_medico_p; tb_vl_materiais_w := _ora2pg_r.tb_vl_materiais_p; tb_vl_custo_operacional_w := _ora2pg_r.tb_vl_custo_operacional_p;
	for	r_c02_w in C02 loop
		
		--Se calculou valor para custo operacional no procedimento, proporcionaliza o mesmo e atribui _ vari_vel que posteriormente ser_ o vl_co no p_s-estab.

		if ( r_c02_w.vl_custo_operacional_calc > 0) then
			vl_custo_operacional_w	:= dividir_sem_round(( r_c02_w.vl_pagto * r_c02_w.vl_custo_operacional_calc), r_c02_w.vl_calculado );
		end if;

		--Se calculou valor para cmateriais no procedimento, proporcionaliza o mesmo e atribui _ vari_vel que posteriormente ser_ o vl_materiais no p_s-estab.

		if (r_c02_w.vl_materiais_calc > 0) then
			vl_materiais_w 	:= dividir_sem_round(( r_c02_w.vl_pagto * r_c02_w.vl_materiais_calc), r_c02_w.vl_calculado );
		end if;

		--Se calculou valor para cm_dico no procedimento, proporcionaliza o mesmo e atribui _ vari_vel que posteriormente ser_ o vl_medico no p_s-estab

		if (r_c02_w.vl_medico_calc > 0) then
			vl_medico_w	:= dividir_sem_round(( r_c02_w.vl_pagto * r_c02_w.vl_medico_calc), r_c02_w.vl_calculado );
		end if;

		--Se valor calculado for zero, ent_o os calculados individuais tamb_m ser_o e nesse caso, 

		--pega o valor considerado (apresentado ou liberado no procedimento de acordo com a regra) e joga tudocomo vl_medico.

		if (r_c02_w.vl_calculado = 0) then
			vl_medico_w := r_c02_w.vl_pagto;
		end if;
		
		--Caso existir diferen_a entre a soma dos valores individuais e o valor total a ser faturado, ent_o a diferen_a ser_ dividida proporcionalmente entre

		--os 3 valores individuais.

		vl_dif_w := r_c02_w.vl_pagto - (vl_medico_w + vl_materiais_w + vl_custo_operacional_w);
		
		/*N_o _ preciso verificar se o valor diferen_a _ maior ou menor que zero, basta apenas somar o valor, pois se o dif for negativo, significa 
		    que a soma dos valores individuais _ maior que o  total, ent_o tem que subtrair dos individuais essa diferen_a e o valor estar_ negativo
		
		somente aplica o ajuste se o valor individual prosseguir maior que zero(Mantendo comportamento j_ existente na geracao de p_s-estabelecido)
		*/

		if (vl_dif_w <> 0) then
			if ( vl_medico_w + vl_dif_w > 0 and vl_medico_w > 0) then
				vl_medico_w := vl_medico_w + vl_dif_w;
				
			elsif ( vl_materiais_w + vl_dif_w > 0 and vl_materiais_w > 0) then	
				vl_materiais_w := vl_materiais_w + vl_dif_w;
				
			elsif ( vl_custo_operacional_w + vl_dif_w > 0 and vl_custo_operacional_w > 0) then
				vl_custo_operacional_w := vl_custo_operacional_w + vl_dif_w;
				
			end if;
		end if;
		
		tb_seq_item_w(i) 		:= r_c02_w.nr_sequencia;
		tb_vl_medico_w(i)		:= coalesce(vl_medico_w,0);
		tb_vl_materiais_w(i)		:= coalesce(vl_materiais_w,0);
		tb_vl_custo_operacional_w(i)	:= coalesce(vl_custo_operacional_w,0);
		
		--Se atingiu a quantidade de registros determinada, persiste as informacaes no banco.

		if ( i > pls_util_cta_pck.qt_registro_transacao_w) then
			
			SELECT * FROM pls_pos_estabelecido_pck.atualiza_val_individuais_proc(tb_seq_item_w, tb_vl_medico_w, tb_vl_materiais_w, tb_vl_custo_operacional_w) INTO STRICT _ora2pg_r;
 tb_seq_item_w := _ora2pg_r.tb_seq_item_p; tb_vl_medico_w := _ora2pg_r.tb_vl_medico_p; tb_vl_materiais_w := _ora2pg_r.tb_vl_materiais_p; tb_vl_custo_operacional_w := _ora2pg_r.tb_vl_custo_operacional_p;
			i := 0;
		else
			i := i + 1;
		end if;
		
	end loop;
	
	--O que sobrar nas estruturas, _ enviado para atualizacao no banco.

	SELECT * FROM pls_pos_estabelecido_pck.atualiza_val_individuais_proc(tb_seq_item_w, tb_vl_medico_w, tb_vl_materiais_w, tb_vl_custo_operacional_w) INTO STRICT _ora2pg_r;
 tb_seq_item_w := _ora2pg_r.tb_seq_item_p; tb_vl_medico_w := _ora2pg_r.tb_vl_medico_p; tb_vl_materiais_w := _ora2pg_r.tb_vl_materiais_p; tb_vl_custo_operacional_w := _ora2pg_r.tb_vl_custo_operacional_p;
	
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_pos_estabelecido_pck.valorizacao_procedimentos ( nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;
