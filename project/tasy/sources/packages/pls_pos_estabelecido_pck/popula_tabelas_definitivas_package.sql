-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


--Respons_vel por levar as informacaes das tabelas tempor_rias para as tabelas definitivas do sistema(que ser_o utilizadas posteriormente no faturamento)



CREATE OR REPLACE PROCEDURE pls_pos_estabelecido_pck.popula_tabelas_definitivas ( nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) AS $body$
DECLARE


_ora2pg_r RECORD;
result_cursor_w 	table_dados_proc_persistir;
result_cursor_mat_w	table_dados_mat_persistir;
tb_seq_proc_partic_w	pls_util_cta_pck.t_number_table;
tb_seq_conta_proc_w	pls_util_cta_pck.t_number_table;
tb_vl_pos_estab_w	pls_util_cta_pck.t_number_table;
tb_vl_administracao_w	pls_util_cta_pck.t_number_table;
tb_maior_valor_w	pls_util_cta_pck.t_number_table;
tb_vl_dif_pos_w		pls_util_cta_pck.t_number_table;
tb_vl_dif_taxa_w	pls_util_cta_pck.t_number_table;
tb_pos_proc_part_w		pls_util_cta_pck.t_number_table;
tb_seq_proc_partic_upd_w 	pls_util_cta_pck.t_number_table;
tb_seq_conta_proc_upd_w    	pls_util_cta_pck.t_number_table;
tb_vl_pos_estab_upd_w       	pls_util_cta_pck.t_number_table;
tb_vl_administracao_upd_w   	pls_util_cta_pck.t_number_table;
tb_pos_proc_part_upd_w      	pls_util_cta_pck.t_number_table;
i			integer := 0;

--Esse cursor levanta os registros que devem ser inseridos na pls_conta_pos_proc. Caso j_ existir registro na mesma, ent_o n_o

--entra nesse cursor e sim no seguinte, onde ocorre a atualizacao da informacao pr_-existente.

--Quanto ao valor de provis_o, ao inserir o registro n_o ter_ valor antigo, portanto o vl_provisao_old da estrutura ser_ nulo, enquanto

--o vl_provisao sera calculado aqui.

C01 CURSOR FOR
	SELECT	cd_procedimento,
		dt_item,
		ie_origem_proced,
		nr_seq_cabecalho,
		nr_seq_conta,
		nr_seq_conta_proc,
		nr_seq_regra_horario,
		qt_filme_tab,
		qt_item,
		tx_administracao,
		tx_item,
		vl_cotacao_moeda,
		vl_custo_operacional,
		vl_custo_operacional_calc,
		vl_custo_operacional_tab,
		vl_liberado_co_fat,
		vl_liberado_hi_fat,
		vl_liberado_material_fat,
		vl_lib_taxa_co,
		vl_lib_taxa_material,
		vl_lib_taxa_servico,
		vl_materiais,
		vl_materiais_calc,
		vl_material_tab,
		vl_medico,
		vl_medico_calc,
		CASE WHEN(vl_lib_taxa_material + vl_lib_taxa_servico + vl_lib_taxa_co +			vl_custo_operacional + vl_materiais + vl_medico)=0 THEN  proc.vl_provisao  ELSE (vl_lib_taxa_material + vl_lib_taxa_servico + vl_lib_taxa_co + 			vl_custo_operacional + vl_materiais + vl_medico) END 	vl_provisao,
		null vl_provisao_old, 
		vl_tabela_preco,
		vl_taxa_co,
		vl_taxa_material,
		vl_taxa_servico,
		nr_seq_regra_preco,
		cd_procedimento_conv,
		nr_seq_regra_co_filme,
		ie_origem_proced_conv,
		cd_procedimento_conv_xml,
		nr_seq_regra_conv_xml,
		ie_origem_conv_xml,
		nr_seq_regra_conv,
		dt_inicio_proc,
		dt_fim_proc,
		nextval('pls_conta_pos_proc_seq')  nr_sequencia,
		ie_origem_conta,
		pls_obter_pagador_benef(nr_seq_segurado, dt_mes_competencia, '6') nr_seq_pagador,
		nr_seq_segurado,
		null ie_atualiza_prov
	from	w_pls_conta_pos_proc proc                                               
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and ( SELECT count(1)
		from   pls_conta_pos_proc pos_proc
		where  pos_proc.nr_seq_conta_proc = proc.nr_seq_conta_proc) = 0;

--Esse cursor levanta os registros que devem ser atualizados na pls_conta_pos_proc. Caso n_o existir registro na mesma, ent_o n_o

--entra nesse cursor e sim no anterior, onde ocorre a insercao dos registros encontrados.

--Quanto ao valor de provis_o, ao atualizar o registro, busca o valor antigo com base no valor j_ presente na tabela definitiva e recalcula

--o valor com base nos subvalores atuais e decidir_ se atualizar_ com base no ie_atualiza_prov.

C01_upd CURSOR FOR
	SELECT	proc.cd_procedimento,
		proc.dt_item,
		proc.ie_origem_proced,
		proc.nr_seq_cabecalho,
		proc.nr_seq_conta,
		proc.nr_seq_conta_proc,
		proc.nr_seq_regra_horario,
		proc.qt_filme_tab,
		proc.qt_item,
		proc.tx_administracao,
		proc.tx_item,
		proc.vl_cotacao_moeda,
		proc.vl_custo_operacional,
		proc.vl_custo_operacional_calc,
		proc.vl_custo_operacional_tab,
		proc.vl_liberado_co_fat,
		proc.vl_liberado_hi_fat,
		proc.vl_liberado_material_fat,
		proc.vl_lib_taxa_co,
		proc.vl_lib_taxa_material,
		proc.vl_lib_taxa_servico,
		proc.vl_materiais,
		proc.vl_materiais_calc,
		proc.vl_material_tab,
		proc.vl_medico,
		proc.vl_medico_calc,
		CASE WHEN(proc.vl_taxa_material + proc.vl_taxa_servico + proc.vl_taxa_co + 			proc.vl_custo_operacional_calc + proc.vl_materiais_calc + proc.vl_medico_calc)=0 THEN  proc.vl_provisao  ELSE (			proc.vl_taxa_material + proc.vl_taxa_servico + proc.vl_taxa_co + 			proc.vl_custo_operacional_calc + proc.vl_materiais_calc + proc.vl_medico_calc			) END  vl_provisao,
		pos_proc.vl_provisao vl_provisao_old,
		proc.vl_tabela_preco,
		proc.vl_taxa_co,
		proc.vl_taxa_material,
		proc.vl_taxa_servico,
		proc.nr_seq_regra_preco,
		proc.cd_procedimento_conv,
		proc.nr_seq_regra_co_filme,
		proc.ie_origem_proced_conv,
		proc.cd_procedimento_conv_xml,
		proc.nr_seq_regra_conv_xml,
		proc.ie_origem_conv_xml,
		proc.nr_seq_regra_conv,
		proc.dt_inicio_proc,
		proc.dt_fim_proc,
		0 nr_sequencia, --retorno zero pois nao vou inserir registro algo, entao esse campo nao ser_ utilizado,
		proc.ie_origem_conta,
		pls_obter_pagador_benef(proc.nr_seq_segurado, proc.dt_mes_competencia, '6') nr_seq_pagador,
		proc.nr_seq_segurado,
		(
			SELECT 	CASE WHEN count(1)=0 THEN  'S'  ELSE 'N' END 
			from	pls_conta_pos_proc_contab a,
				pls_pos_estab_dados_contab b
			where 	a.nr_seq_conta_pos_proc	= pos_proc.nr_sequencia
			and	b.nr_seq_pos_proc_contab = a.nr_sequencia
			and ((b.nr_lote_contabil_prov IS NOT NULL AND b.nr_lote_contabil_prov::text <> '')	or
				 (b.nr_lote_contabil IS NOT NULL AND b.nr_lote_contabil::text <> '')	)) ie_atualiza_prov		
	from	w_pls_conta_pos_proc 	proc,
		pls_conta_pos_proc	pos_proc
	where	proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and	pos_proc.nr_seq_conta_proc = proc.nr_seq_conta_proc;
	
--Esse cursor levanta os registros que devem ser inseridos na pls_conta_pos_mat. Caso j_ existir registro na mesma, ent_o n_o

--entra nesse cursor e sim no seguinte, onde ocorre a atualizacao da informacao pr_-existente.

--Quanto ao valor de provis_o, ao inserir o registro n_o ter_ valor antigo, portanto o vl_provisao_old da estrutura ser_ nulo, enquanto

--o vl_provisao sera calculado aqui.

C02 CURSOR FOR
	SELECT	cd_ref_fabricante,
		cd_ref_material_fab_opme,
		det_reg_anvisa_opme,
		dt_item,
		nr_registro_anvisa,
		nr_seq_cabecalho,
		nr_seq_conta,
		nr_seq_conta_mat,
		nr_seq_material,
		CASE WHEN ie_tipo_tabela_valorizacao='IC' THEN  nr_seq_regra_preco  ELSE null END  nr_seq_pos_estab_interc,
		CASE WHEN ie_tipo_tabela_valorizacao='O' THEN  nr_seq_regra_preco  ELSE null END  nr_seq_regra_pos_estab,
		qt_item,
		qt_original,
		tx_administracao,
		vl_administracao,
		vl_liberado_material_fat,
		vl_lib_taxa_material,
		vl_materiais,
		vl_materiais_calc,
		vl_material_tab,
		vl_taxa_material,
		nr_seq_regra_conv,
		ds_item_convertido,
		cd_item_convertido,
		nextval('pls_conta_pos_mat_seq') nr_sequencia,
		ie_origem_conta,
		pls_obter_pagador_benef(nr_seq_segurado, dt_mes_competencia, '6') nr_seq_pagador,
		nr_seq_segurado,
		null ie_atualiza_prov,
		CASE WHEN(vl_lib_taxa_material + vl_materiais)=0 THEN  mat.vl_provisao  ELSE (vl_lib_taxa_material + vl_materiais) END  vl_provisao,
		null vl_provisao_old
	from	w_pls_conta_pos_mat mat
	where	mat.ie_gera_valor_pos_estab in ('S', 'SB')
	and (  SELECT count(1)
		from  pls_conta_pos_mat pos_mat
		where   pos_mat.nr_seq_conta_mat = mat.nr_seq_conta_mat) = 0;

--Esse cursor levanta os registros que devem ser atualizados na pls_conta_pos_mat. Caso n_o existir registro na mesma, ent_o n_o

--entra nesse cursor e sim no anterior, onde ocorre a insercao dos registros encontrados.

--Quanto ao valor de provis_o, ao atualizar o registro, busca o valor antigo com base no valor j_ presente na tabela definitiva e recalcula

--o valor com base nos subvalores atuais e decidir_ se atualizar_ com base no ie_atualiza_prov

C02_upd CURSOR FOR
	SELECT	mat.cd_ref_fabricante,
		mat.cd_ref_material_fab_opme,
		mat.det_reg_anvisa_opme,
		mat.dt_item,
		mat.nr_registro_anvisa,
		mat.nr_seq_cabecalho,
		mat.nr_seq_conta,
		mat.nr_seq_conta_mat,
		mat.nr_seq_material,
		CASE WHEN mat.ie_tipo_tabela_valorizacao='IC' THEN  mat.nr_seq_regra_preco  ELSE null END  nr_seq_pos_estab_interc,
		CASE WHEN mat.ie_tipo_tabela_valorizacao='O' THEN  mat.nr_seq_regra_preco  ELSE null END  nr_seq_regra_pos_estab,
		mat.qt_item,
		mat.qt_original,
		mat.tx_administracao,
		mat.vl_administracao,
		mat.vl_liberado_material_fat,
		mat.vl_lib_taxa_material,
		mat.vl_materiais,
		mat.vl_materiais_calc,
		mat.vl_material_tab,
		mat.vl_taxa_material,
		mat.nr_seq_regra_conv,
		mat.ds_item_convertido,
		mat.cd_item_convertido,
		0 nr_sequencia,
		mat.ie_origem_conta,
		pls_obter_pagador_benef(mat.nr_seq_segurado, mat.dt_mes_competencia, '6') nr_seq_pagador,
		mat.nr_seq_segurado,
		(
			SELECT 	CASE WHEN count(1)=0 THEN  'S'  ELSE 'N' END
			from	pls_conta_pos_mat_contab a,
				pls_pos_estab_dados_contab b
			where 	a.nr_seq_conta_mat_pos	= pos_mat.nr_sequencia
			and	b.nr_seq_pos_mat_contab = a.nr_sequencia
			and ((b.nr_lote_contabil_prov IS NOT NULL AND b.nr_lote_contabil_prov::text <> '')	or
				 (b.nr_lote_contabil IS NOT NULL AND b.nr_lote_contabil::text <> '')	)) ie_atualiza_prov,
		CASE WHEN(mat.vl_taxa_material + mat.vl_materiais_calc)=0 THEN  mat.vl_provisao  ELSE (mat.vl_taxa_material + mat.vl_materiais_calc) END  vl_provisao,
		pos_mat.vl_provisao vl_provisao_old
	from	w_pls_conta_pos_mat	mat,
		pls_conta_pos_mat	pos_mat
	where	mat.ie_gera_valor_pos_estab in ('S', 'SB')
	and 	pos_mat.nr_seq_conta_mat = mat.nr_seq_conta_mat;
	
/*Cursos retorna todos os procedimentos el_giveis para geracao de p_s que tenha participante e que 
ao menos um  dos participantes tenha valor no vl_pos_estab, pois caso um dos participantes tiver, esse ser_ o 
valor de p_s para o mesmo e caso tenha outros participantes nesse mesmo procedimentos sem esse valor
de p_s, ent_o ficar_o zerados


--A utilizacao da tabela w_pls_conta_pos_proc nos cursores abaixo se deve a necessidade de utilizar apenas o que est_ sendo processado nessa

sess_o, sendo assim um delimitar de procedimentos que precisam ser processados
*/

C03 CURSOR FOR
	SELECT  part.nr_sequencia,
		proc.nr_sequencia,
		coalesce(part.vl_pos_estab,0) vl_pos_estab,
		0 			vl_administracao,
		nextval('pls_conta_pos_proc_part_seq')
	from	pls_proc_participante 	part,
		pls_conta_pos_proc	proc,
		w_pls_conta_pos_proc 	w_proc
	where	part.nr_seq_conta_proc = proc.nr_seq_conta_proc
	and	proc.nr_seq_conta_proc = w_proc.nr_seq_conta_proc
	and	w_proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and	exists ( SELECT 1
			 from	pls_proc_participante partic
			 where 	partic.nr_seq_conta_proc = proc.nr_seq_conta_proc
			 and	partic.vl_pos_estab > 0
			 and	partic.ie_status in ('L', 'P', 'U'))
	and	part.ie_status in ('L', 'P', 'U')
	and (select 	count(1)
		from	pls_conta_pos_proc_part
		where	nr_seq_proc_partic = part.nr_sequencia) = 0;

C03_upd CURSOR FOR
	SELECT  part.nr_sequencia,
		proc.nr_sequencia,
		coalesce(part.vl_pos_estab,0) vl_pos_estab,
		0 			vl_administracao,
		nextval('pls_conta_pos_proc_part_seq')
	from	pls_proc_participante 	part,
		pls_conta_pos_proc	proc,
		w_pls_conta_pos_proc 	w_proc
	where	part.nr_seq_conta_proc = proc.nr_seq_conta_proc
	and	proc.nr_seq_conta_proc = w_proc.nr_seq_conta_proc
	and	w_proc.ie_gera_valor_pos_estab in ('S', 'SB')
	and	exists ( SELECT 1
			 from	pls_proc_participante partic
			 where 	partic.nr_seq_conta_proc = proc.nr_seq_conta_proc
			 and	partic.vl_pos_estab > 0
			 and	partic.ie_status in ('L', 'P', 'U'))
	and	part.ie_status in ('L', 'P', 'U')
	and    exists (	select 	1
			from	pls_conta_pos_proc_part
			where	nr_seq_proc_partic = part.nr_sequencia);
	
C04 CURSOR FOR
	SELECT	nr_seq_conta_proc_partic,
		nr_seq_conta_proc_pos,
		vl_calculado,
		vl_tot_calc_partic,
		vl_medico,
		vl_taxa_servico,
		dividir(vl_calculado, vl_tot_calc_partic) perc_proporcao
	from
	       (SELECT  part.nr_sequencia	 nr_seq_conta_proc_partic,
			proc.nr_sequencia	 nr_seq_conta_proc_pos,
			proc.vl_medico,
			proc.vl_taxa_servico,
			coalesce(part.vl_calculado,0) vl_calculado,
			(	select 	sum(vl_calculado)
				from	pls_proc_participante
				where	nr_seq_conta_proc = proc.nr_seq_conta_proc
				and	ie_status in ('L', 'P', 'U')) 	vl_tot_calc_partic
		from	pls_proc_participante 	part,
			pls_conta_pos_proc	proc,
			w_pls_conta_pos_proc 	w_proc
		where	part.nr_seq_conta_proc = proc.nr_seq_conta_proc
		and	proc.nr_seq_conta_proc = w_proc.nr_seq_conta_proc
		and	w_proc.ie_gera_valor_pos_estab in ('S', 'SB')
		and ( select count(1)
				 from	pls_proc_participante partic
				 where 	partic.nr_seq_conta_proc = proc.nr_seq_conta_proc
				 and	partic.vl_pos_estab > 0
				 and	partic.ie_status in ('L', 'P', 'U')) = 0
		and	part.ie_status in ('L', 'P', 'U')
		and (select 	count(1)
			from	pls_conta_pos_proc_part
			where	nr_seq_proc_partic = part.nr_sequencia) = 0) alias12;
		
C04_upd CURSOR FOR
	SELECT	nr_seq_conta_proc_partic,
		nr_seq_conta_proc_pos,
		vl_calculado,
		vl_tot_calc_partic,
		vl_medico,
		vl_taxa_servico,
		dividir(vl_calculado, vl_tot_calc_partic) perc_proporcao
	from
	       (SELECT  part.nr_sequencia	 nr_seq_conta_proc_partic,
			proc.nr_sequencia	 nr_seq_conta_proc_pos,
			proc.vl_medico,
			proc.vl_taxa_servico,
			coalesce(part.vl_calculado,0) vl_calculado,
			(	select 	sum(vl_calculado)
				from	pls_proc_participante
				where	nr_seq_conta_proc = proc.nr_seq_conta_proc
				and	ie_status in ('L', 'P', 'U')) 	vl_tot_calc_partic
		from	pls_proc_participante 	part,
			pls_conta_pos_proc	proc,
			w_pls_conta_pos_proc 	w_proc
		where	part.nr_seq_conta_proc = proc.nr_seq_conta_proc
		and	proc.nr_seq_conta_proc = w_proc.nr_seq_conta_proc
		and	w_proc.ie_gera_valor_pos_estab in ('S', 'SB')
		and ( select count(1)
				 from	pls_proc_participante partic
				 where 	partic.nr_seq_conta_proc = proc.nr_seq_conta_proc
				 and	partic.vl_pos_estab > 0
				 and	partic.ie_status in ('L', 'P', 'U')) = 0
		and	part.ie_status in ('L', 'P', 'U')
		and    exists (	select 	count(1)
			from	pls_conta_pos_proc_part
			where	nr_seq_proc_partic = part.nr_sequencia)) alias12;

--Retorna os registros de participantes criados anteriormente, apenas para fazer ajustes quanto a distribuicao

-- proporcional do valor do procedimento entre seus participantes.    Apenas _ necess_rio retornar os casos onde 

--o procedimento tenha mais do que um participante.

C05 CURSOR FOR
	SELECT  part.nr_seq_conta_pos_proc	nr_seq_proc_pos,
		max(proc.vl_medico) 		vl_medico,
		max(proc.vl_taxa_servico) 	vl_taxa_servico,
		sum(part.vl_participante_pos)	vl_tot_pos_partic,
		sum(part.vl_administracao)	vl_tot_adm_partic,
		max(part.vl_participante_pos)	vl_maior_valor
	from	pls_conta_pos_proc_part part,
		pls_conta_pos_proc	proc,
		w_pls_conta_pos_proc 	w_proc
	where	part.nr_seq_conta_pos_proc = proc.nr_sequencia
	and	proc.nr_seq_conta_proc = w_proc.nr_seq_conta_proc
	and	w_proc.ie_gera_valor_pos_estab in ('S', 'SB')	
	and ( SELECT count(1)
			 from	pls_proc_participante partic
			 where 	partic.nr_seq_conta_proc = proc.nr_seq_conta_proc
			 and	partic.ie_status in ('L', 'P', 'U')) > 1
	and ( select count(1) 
			 from	pls_proc_participante partic
			 where 	partic.nr_seq_conta_proc = proc.nr_seq_conta_proc
			 and	partic.vl_pos_estab > 0
			 and	partic.ie_status in ('L', 'P', 'U')) = 0
	group by part.nr_seq_conta_pos_proc;

BEGIN
        --Primeiro executa-se o cursor de atualizacao e somente depois o de insercao, pois se executar primeiro o cursor de insercao na pls_conta_pos_proc, poder_ 

	--entrar no cursor de atualizacao sem necessidade para o registro rec_m-criado.

	open C01_upd;
	loop
		fetch 	C01_upd bulk collect
		into	result_cursor_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when result_cursor_w.cd_procedimento.count = 0;
		
		 result_cursor_w := pls_pos_estabelecido_pck.update_proc_tab_definitiva( result_cursor_w, nm_usuario_p, cd_estabelecimento_p);
		
	end loop;
	close C01_upd;
	
	--Insere novos registros na pls_conta_pos_proc.

	open C01;
	loop
		fetch 	C01 bulk collect
		into	result_cursor_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when result_cursor_w.cd_procedimento.count = 0;
		
		 result_cursor_w := pls_pos_estabelecido_pck.insere_proc_tab_definitiva( result_cursor_w, nm_usuario_p, cd_estabelecimento_p);
		
	end loop;
	close C01;
	
	--Primeiro executa-se o cursor de atualizacao e somente depois o de insercao, pois se executar primeiro o cursor de insercao na pls_conta_pos_mat, poder_ 

	--entrar no cursor de atualizacao sem necessidade para o registro rec_m-criado.

	open C02_upd;
	loop
		fetch 	C02_upd bulk collect
		into	result_cursor_mat_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when result_cursor_mat_w.cd_ref_fabricante.count = 0;
		
		 result_cursor_mat_w := pls_pos_estabelecido_pck.update_mat_tab_definitiva( result_cursor_mat_w, nm_usuario_p, cd_estabelecimento_p);
		
	end loop;
	close C02_upd;
	
	--Insere novos registros na pls_conta_pos_mat

	open C02;
	loop
		fetch 	C02 bulk collect
		into	result_cursor_mat_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when result_cursor_mat_w.cd_ref_fabricante.count = 0;
		
		 result_cursor_mat_w := pls_pos_estabelecido_pck.insere_mat_tab_definitiva( result_cursor_mat_w, nm_usuario_p, cd_estabelecimento_p);
		
	end loop;
	close C02;
		
	--Aqui atualiza os  participantes considerando apenas os casos onde valorizou ao menos um participante(vl_pos_estab) do procedimento. O valor de p_s ser_ considerado apenas o calculado mesmo

	open C03_upd;
	loop
		fetch 	C03_upd bulk collect
		into	tb_seq_proc_partic_upd_w, tb_seq_conta_proc_upd_w,
			tb_vl_pos_estab_upd_w, tb_vl_administracao_upd_w,
			tb_pos_proc_part_upd_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when result_cursor_w.nr_sequencia.count = 0;

		SELECT * FROM pls_pos_estabelecido_pck.atualiza_partic_pos( tb_seq_proc_partic_upd_w, tb_seq_conta_proc_upd_w, tb_vl_pos_estab_upd_w, tb_vl_administracao_upd_w, tb_pos_proc_part_upd_w, nm_usuario_p) INTO STRICT _ora2pg_r;
  tb_seq_proc_partic_upd_w := _ora2pg_r.tb_seq_proc_partic; tb_seq_conta_proc_upd_w := _ora2pg_r.tb_seq_conta_proc; tb_vl_pos_estab_upd_w := _ora2pg_r.tb_vl_pos_estab; tb_vl_administracao_upd_w := _ora2pg_r.tb_vl_administracao; tb_pos_proc_part_upd_w := _ora2pg_r.tb_seq_pos_proc_part;
		
	end loop;
	close C03_upd;

	--Aqui insere participantes considerando apenas os casos onde valorizou ao menos um participante(vl_pos_estab) do procedimento. O valor de p_s ser_ considerado apenas o calculado mesmo

	open C03;
	loop		
		fetch 	C03 bulk collect
		into	tb_seq_proc_partic_w, tb_seq_conta_proc_w,
			tb_vl_pos_estab_w, tb_vl_administracao_w,
			tb_pos_proc_part_w
		limit pls_util_cta_pck.qt_registro_transacao_w;
		exit when result_cursor_w.nr_sequencia.count = 0;
		
		SELECT * FROM pls_pos_estabelecido_pck.insere_partic_pos( tb_seq_proc_partic_w, tb_seq_conta_proc_w, tb_vl_pos_estab_w, tb_vl_administracao_w, tb_pos_proc_part_w, nm_usuario_p) INTO STRICT _ora2pg_r;
  tb_seq_proc_partic_w := _ora2pg_r.tb_seq_proc_partic; tb_seq_conta_proc_w := _ora2pg_r.tb_seq_conta_proc; tb_vl_pos_estab_w := _ora2pg_r.tb_vl_pos_estab; tb_vl_administracao_w := _ora2pg_r.tb_vl_administracao; tb_pos_proc_part_w := _ora2pg_r.tb_seq_pos_proc_part;
		
	end loop;
	close C03;
				
	--Quando todos os participantes do procedimento n_o tem valor de p_s-estab, ent_o distribui proporcionalmente o valor m_dico e o vl_taxa entre o vl_participante_pos e vl_administracao, respectivamente.

	for r_c04_upd_w in C04_upd loop
	
		tb_seq_proc_partic_upd_w(i)	:= r_c04_upd_w.nr_seq_conta_proc_partic;
		tb_seq_conta_proc_upd_w(i) 	:= r_c04_upd_w.nr_seq_conta_proc_pos;
		tb_vl_pos_estab_upd_w(i)	:= r_c04_upd_w.vl_medico * r_c04_upd_w.perc_proporcao;
		tb_vl_administracao_upd_w(i)	:= r_c04_upd_w.vl_taxa_servico * r_c04_upd_w.perc_proporcao;
		
		select 	nextval('pls_conta_pos_proc_part_seq')
		into STRICT	tb_pos_proc_part_w(i)
		;
		
		--Se atingiu a quantidade de registros pr_-definida, envia para o banco.

		if ( i > pls_util_cta_pck.qt_registro_transacao_w ) then
			--Calcula os valores com base na proporcao de cada participante perante o procedimento executado e faz a insercao.

			SELECT * FROM pls_pos_estabelecido_pck.atualiza_partic_pos( tb_seq_proc_partic_upd_w, tb_seq_conta_proc_upd_w, tb_vl_pos_estab_upd_w, tb_vl_administracao_upd_w, tb_pos_proc_part_upd_w, nm_usuario_p) INTO STRICT _ora2pg_r;
  tb_seq_proc_partic_upd_w := _ora2pg_r.tb_seq_proc_partic; tb_seq_conta_proc_upd_w := _ora2pg_r.tb_seq_conta_proc; tb_vl_pos_estab_upd_w := _ora2pg_r.tb_vl_pos_estab; tb_vl_administracao_upd_w := _ora2pg_r.tb_vl_administracao; tb_pos_proc_part_upd_w := _ora2pg_r.tb_seq_pos_proc_part;
			i := 0;
		else
			i := i + 1;
		end if;
	
	end loop;
		
	--Quando todos os participantes do procedimento n_o tem valor de p_s-estab, ent_o distribui proporcionalmente o valor m_dico e o vl_taxa entre o vl_participante_pos e vl_administracao, respectivamente.

	for r_c04_w in C04 loop
	
		tb_seq_proc_partic_w(i)	:= r_c04_w.nr_seq_conta_proc_partic;
		tb_seq_conta_proc_w(i) 	:= r_c04_w.nr_seq_conta_proc_pos;
		tb_vl_pos_estab_w(i)	:= r_c04_w.vl_medico * r_c04_w.perc_proporcao;
		tb_vl_administracao_w(i):= r_c04_w.vl_taxa_servico * r_c04_w.perc_proporcao;
		
		select 	nextval('pls_conta_pos_proc_part_seq')
		into STRICT	tb_pos_proc_part_w(i)
		;
		
		--Se atingiu a quantidade de registros pr_-definida, envia para o banco.

		if ( i > pls_util_cta_pck.qt_registro_transacao_w ) then
			--Calcula os valores com base na proporcao de cada participante perante o procedimento executado e faz a insercao.

			SELECT * FROM pls_pos_estabelecido_pck.insere_partic_pos( tb_seq_proc_partic_w, tb_seq_conta_proc_w, tb_vl_pos_estab_w, tb_vl_administracao_w, tb_pos_proc_part_w, nm_usuario_p) INTO STRICT _ora2pg_r;
  tb_seq_proc_partic_w := _ora2pg_r.tb_seq_proc_partic; tb_seq_conta_proc_w := _ora2pg_r.tb_seq_conta_proc; tb_vl_pos_estab_w := _ora2pg_r.tb_vl_pos_estab; tb_vl_administracao_w := _ora2pg_r.tb_vl_administracao; tb_pos_proc_part_w := _ora2pg_r.tb_seq_pos_proc_part;
			i := 0;
		else
			i := i + 1;
		end if;
	
	end loop;
	
	SELECT * FROM pls_pos_estabelecido_pck.atualiza_partic_pos( tb_seq_proc_partic_upd_w, tb_seq_conta_proc_upd_w, tb_vl_pos_estab_upd_w, tb_vl_administracao_upd_w, tb_pos_proc_part_upd_w, nm_usuario_p) INTO STRICT _ora2pg_r;
  tb_seq_proc_partic_upd_w := _ora2pg_r.tb_seq_proc_partic; tb_seq_conta_proc_upd_w := _ora2pg_r.tb_seq_conta_proc; tb_vl_pos_estab_upd_w := _ora2pg_r.tb_vl_pos_estab; tb_vl_administracao_upd_w := _ora2pg_r.tb_vl_administracao; tb_pos_proc_part_upd_w := _ora2pg_r.tb_seq_pos_proc_part;
	SELECT * FROM pls_pos_estabelecido_pck.insere_partic_pos( tb_seq_proc_partic_w, tb_seq_conta_proc_w, tb_vl_pos_estab_w, tb_vl_administracao_w, tb_pos_proc_part_w, nm_usuario_p) INTO STRICT _ora2pg_r;
  tb_seq_proc_partic_w := _ora2pg_r.tb_seq_proc_partic; tb_seq_conta_proc_w := _ora2pg_r.tb_seq_conta_proc; tb_vl_pos_estab_w := _ora2pg_r.tb_vl_pos_estab; tb_vl_administracao_w := _ora2pg_r.tb_vl_administracao; tb_pos_proc_part_w := _ora2pg_r.tb_seq_pos_proc_part;
	i := 0;
	
	--Faz ajuste de valor em caso ocorrer pequenas diferen_as devido a proporcionalizacao de valores no passo anterior.

	for r_c05_w in c05 loop
	
		--Se existir diferen_a entre ao valor_medico no procedimetno e a soma dos valores de p_s no registro de participante ou

		--se existir diferen_a entre o valor de taxa no procedimento ou a soma das taxas em seus participantes, nesse caso tem que atualizar algum participante

		-- para eliminar as diferen_as

		if	(( r_c05_w.vl_taxa_servico - r_c05_w.vl_tot_adm_partic <> 0) or ( r_c05_w.vl_medico - r_c05_w.vl_tot_pos_partic <> 0))then
	
			tb_vl_dif_taxa_w(i) 	:= r_c05_w.vl_taxa_servico - r_c05_w.vl_tot_adm_partic;
			tb_vl_dif_pos_w(i) 	:= r_c05_w.vl_medico - r_c05_w.vl_tot_pos_partic;
			tb_seq_conta_proc_w(i) 	:= r_c05_w.nr_seq_proc_pos;
			tb_maior_valor_w(i)	:= r_c05_w.vl_maior_valor;
			
			if (i > pls_util_cta_pck.qt_registro_transacao_w) then
				
				SELECT * FROM pls_pos_estabelecido_pck.atualiza_dif_participantes(tb_seq_conta_proc_w, tb_vl_dif_pos_w, tb_vl_dif_taxa_w, tb_maior_valor_w) INTO STRICT _ora2pg_r;
 tb_seq_conta_proc_w := _ora2pg_r.tb_seq_conta_proc_w; tb_vl_dif_pos_w := _ora2pg_r.tb_vl_dif_pos_w; tb_vl_dif_taxa_w := _ora2pg_r.tb_vl_dif_taxa_w; tb_maior_valor_w := _ora2pg_r.tb_maior_valor_w;
				i := 0;
			else
				i := i + 1;
			end if;
		end if;
		
	end loop;
	
	SELECT * FROM pls_pos_estabelecido_pck.atualiza_dif_participantes(tb_seq_conta_proc_w, tb_vl_dif_pos_w, tb_vl_dif_taxa_w, tb_maior_valor_w) INTO STRICT _ora2pg_r;
 tb_seq_conta_proc_w := _ora2pg_r.tb_seq_conta_proc_w; tb_vl_dif_pos_w := _ora2pg_r.tb_vl_dif_pos_w; tb_vl_dif_taxa_w := _ora2pg_r.tb_vl_dif_taxa_w; tb_maior_valor_w := _ora2pg_r.tb_maior_valor_w;
	i := 0;
	
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_pos_estabelecido_pck.popula_tabelas_definitivas ( nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;
