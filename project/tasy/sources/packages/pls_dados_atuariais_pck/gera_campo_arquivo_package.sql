-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION pls_dados_atuariais_pck.gera_campo_arquivo ( nr_seq_regra_p pls_atuarial_arq_regra.nr_sequencia%type, ds_alias_p text) RETURNS CAMPO_ARQUIVO AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Gera as colunas usando como base uma regra pre definida.

	Essa rotina vai percorrer os campos das regras, ordenado pelo campo nr_ordem de forma
	ascendente, e vai implementar para cada campo as suas regras. 
	
	o campo vai ter suas infromacoes carregadas, e a sua sintax de SQL sera atribuida no campo ds_sql
	
	sera concatenado entao na variavel de retorno, a ds_colunas_w.
	
	
	A ordem de montagem das regras de cada coluna sera  a seguinte:
		1 - Campo, se nao encontrado a function propria
		2 - Padrao caso o item 1 vier null  (se hover)
		3 - Mascara (se hover)
		4 - tamanho (se hover)
		5 - Preenchimento, respeitando o alinhamento e se foi informado o Tamanho anteriormente(se hover)
		6 - Titulo (se hover)
		
		
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------

Pontos de atencao:

	A montagem da mascara sera feita utilizando as rotinas ja disponibilizadas pela Oracle
	
	quando uma mascara for determinada, sera buscado o tipo do campo conforme metadata,
	se for uma coluna de tabela, ou sera considerado "varchar2" se o campo for uma function
	
	Conform e o tipo do campo, sera aplicada a  mascara, por exemplo se o campo for uma 
	coluna data ou numero, entao aplicado o TO_CHAR.
	
	um exemplo para converter um numero em 2 casas decimais, com separador de milhar conforme
	territorio configurado no banco, e separador de decimais como ",":
	'999G999G999D99MI', 'NLS_NUMERIC_CHARACTERS = '',.'' NLS_CURRENCY = ''territory'' '
	
	DEVE-SE MANTER OS APOSTROFOS, pois essa mascara sera concatenada de forma pura.
	
	Um exemplo para fazer uma data ficar no formado ano mes dia: 'yyyyMMdd'.
	
	
	Os campos que forem VARCHAR2 ou FUNCTION, terao o tratamento baseado em expressoes regulares.
	
	um exemplo para formatar um CNPJ: 
	'([0-9]{3})([0-9]{3})([0-9]{3})([0-9]{4})([0-9]{2})','\1.\2.\3/\4-\5'
	
	um exemplo para formatar um CPF:
	'([0-9]{3})([0-9]{3})([0-9]{3})([0-9]{2})','\1.\2.\3-\4'
	
	DEVE-SE MANTER OS APOSTROFOS, pois essa mascara sera concatenada de forma pura.
	
	Apos aplicar a mascara, os campos receberao um TRIM, para evitar "poluicao" por conta da mascara em si,
	se os espacos em branco forem necessarios, utilizar a configuracao para preenchimento e tamanho
	
	
Alteracoes:
-------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */


i		integer;
ds_colunas_w	campo_arquivo;

-- Carrega os campos

c01 CURSOR(	nr_seq_regra_pc	pls_atuarial_arq_regra.nr_sequencia%type,
		ds_alias_pc	text) FOR
	SELECT	a.nr_sequencia,
		replace(trim(both a.ds_function), '''', '''') ds_function,
		a.ds_mascara,
		a.ds_preenchimento,
		a.ds_titulo,
		a.ie_alinhamento,
		a.ie_campo,
		ds_alias_pc||'.'||a.ie_campo ie_campo_alias,
		a.ie_padrao,
		a.ie_tamanho,
		c.ie_tipo_arquivo,
		b.ie_separador
	from	pls_atuarial_arq_campo	a,
		pls_atuarial_arq_reg	b,
		pls_atuarial_arq_regra	c
	where	a.nr_seq_registro	= b.nr_sequencia
	and	c.nr_sequencia		= b.nr_seq_regra
	and	c.nr_sequencia		= nr_seq_regra_pc
	order by a.nr_ordem;

BEGIN
-- Limpa as variaveis

ds_colunas_w := pls_dados_atuariais_pck.apaga_campo_arquivo(ds_colunas_w);
i := 0;

-- Navega pelos campos, montando a coluna

for r_c01_w in c01(nr_seq_regra_p, ds_alias_p) loop

	-- So monta a coluna se houver pelo menos um campo ou function informado

	if ((coalesce(r_c01_w.ie_campo, r_c01_w.ds_function) IS NOT NULL AND (coalesce(r_c01_w.ie_campo, r_c01_w.ds_function))::text <> '')) then
	
		-- Atribui o valor a cada propriedade, nesta caso e melhor nao usar bulk collect (sao poucos dados)

		ds_colunas_w.nr_seq_regra_campo(i)	:= r_c01_w.nr_sequencia;
		ds_colunas_w.ds_function(i)		:= r_c01_w.ds_function;
		ds_colunas_w.ds_mascara(i)		:= r_c01_w.ds_mascara;
		ds_colunas_w.ds_preenchimento(i)	:= r_c01_w.ds_preenchimento;
		ds_colunas_w.ds_titulo(i)		:= r_c01_w.ds_titulo;
		ds_colunas_w.ie_alinhamento(i)		:= r_c01_w.ie_alinhamento;
		ds_colunas_w.ie_campo(i)		:= r_c01_w.ie_campo;
		ds_colunas_w.ie_campo_alias(i)		:= r_c01_w.ie_campo_alias;
		ds_colunas_w.ie_padrao(i)		:= r_c01_w.ie_padrao;
		ds_colunas_w.ie_tamanho(i)		:= r_c01_w.ie_tamanho;
		ds_colunas_w.ie_tipo_arquivo(i)		:= r_c01_w.ie_tipo_arquivo;
		ds_colunas_w.ie_separador(i)		:= r_c01_w.ie_separador;
		ds_colunas_w.ds_sql(i)			:= '';
		
	
		-- a primeira atribuicao e a do campo ou function base

		
		ds_colunas_w.ds_sql(i) := ds_colunas_w.ds_sql(i) || coalesce(ds_colunas_w.ds_function(i), ds_colunas_w.ie_campo_alias(i));
		
		-- Valor padrao

		if ((ds_colunas_w.ie_padrao(i) IS NOT NULL AND (ds_colunas_w.ie_padrao(i))::text <> '')) then
		
			ds_colunas_w.ds_sql(i) := 'nvl('||ds_colunas_w.ds_sql(i)||','||replace(ds_colunas_w.ie_padrao(i), '''', '''')||')';
		end if;
		
		-- Mascara

		if ((ds_colunas_w.ds_mascara(i) IS NOT NULL AND (ds_colunas_w.ds_mascara(i))::text <> '')) then
		
			-- Essa rotina ja monta o campo corretamente, por isso nao precisa concatentar com a atribuicao direta do campo

			ds_colunas_w.ds_sql(i) := pls_dados_atuariais_pck.monta_mascara_sql_campo_arq(	ds_colunas_w.ie_campo(i),
										ds_colunas_w.ds_sql(i),
										ds_colunas_w.ds_mascara(i),
										ds_colunas_w.ie_tipo_arquivo(i));
										
		end if;
		
		-- tamanho

		if ((ds_colunas_w.ie_tamanho(i) IS NOT NULL AND (ds_colunas_w.ie_tamanho(i))::text <> '')) and (ds_colunas_w.ie_tamanho(i) != 0) then
		
			ds_colunas_w.ds_sql(i) := 'substr('||ds_colunas_w.ds_sql(i)||',1,'||ds_colunas_w.ie_tamanho(i)||')';
		end if;
		
		-- preenchimento (requer tamanho, alinhamento)

		if ((ds_colunas_w.ie_tamanho(i) IS NOT NULL AND (ds_colunas_w.ie_tamanho(i))::text <> '')) and (ds_colunas_w.ie_tamanho(i) != 0) and ((ds_colunas_w.ds_preenchimento(i) IS NOT NULL AND (ds_colunas_w.ds_preenchimento(i))::text <> '')) and ((ds_colunas_w.ie_alinhamento(i) IS NOT NULL AND (ds_colunas_w.ie_alinhamento(i))::text <> '')) then
			
			if (ds_colunas_w.ie_alinhamento(i) = 'E') then
			
				ds_colunas_w.ds_sql(i) := 'lpad('||ds_colunas_w.ds_sql(i)||','||to_char(ds_colunas_w.ie_tamanho(i))||','''||ds_colunas_w.ds_preenchimento(i)||''')';
			end if;
			
			if (ds_colunas_w.ie_alinhamento(i) = 'D') then
			
				ds_colunas_w.ds_sql(i) := 'rpad('||ds_colunas_w.ds_sql(i)||','||to_char(ds_colunas_w.ie_tamanho(i))||','''||ds_colunas_w.ds_preenchimento(i)||''')';
			end if;
		end if;	
		
		i := i +1;
		
	end if; -- fim monta coluna
	

end loop;


return ds_colunas_w;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pls_dados_atuariais_pck.gera_campo_arquivo ( nr_seq_regra_p pls_atuarial_arq_regra.nr_sequencia%type, ds_alias_p text) FROM PUBLIC;
