-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


-- Validate Windows Directory
CREATE OR REPLACE PROCEDURE jpn_utl_file_pck.validate_directory (ds_local_windows_p text, nr_seq_erro_p INOUT dic_objeto.nr_sequencia%type ) AS $body$
BEGIN

-- Validate for Windows directory to be mandatory
if (coalesce(ds_local_windows_p::text, '') = '') then
	nr_seq_erro_p := 460844; -- Favor verificar o cadastro UTL_FILE, necessario informar o campo Local na rede (Windows)
end if;

-- Validate whether the directory is common to Windows
if (ds_local_windows_p IS NOT NULL AND ds_local_windows_p::text <> '') and
	(position('\') = 0) then --'
	nr_seq_erro_p := 460848; -- Please check the UTL_FILE register, it is necessary to enter a valid directory for Windows in the Local on the network field (Windows)
end if;

end jpn_utl_file_pck.validate_directory();

-- Get the error caused in UTL_FILE
function jpn_utl_file_pck.get_error_code( sqlcode_p	number )
			return number is

begin

if	(sqlcode = -29289) then
	return 281845; -- O acesso ao arquivo foi negado pelo sistema operacional (access_denied).
elsif	(sqlcode = -29298) then
	return 281846; -- O arquivo foi aberto usando FOPEN_NCHAR,  mas efetuaram-se operacoes de I/O usando funcoes nonchar comos PUTF ou GET_LINE (charsetmismatch).
elsif	(sqlcode = -29291) then
	return 281847; -- Nao foi possivel apagar o arquivo (delete_failed).
elsif	(sqlcode = -29286) then
	return 281848; -- Erro interno desconhecido no package UTL_FILE (internal_error).
elsif	(sqlcode = -29282) then
	return 281849; -- O handle do arquivo nao existe (invalid_filehandle).
elsif	(sqlcode = -29288) then
	return 281850; -- O arquivo com o nome especificado nao foi encontrado neste local (invalid_filename).
elsif	(sqlcode = -29287) then
	return 281851; -- O valor de MAX_LINESIZE para FOPEN() e invalido; deveria estar na faixa de 1 a 32767 (invalid_maxlinesize).
elsif	(sqlcode = -29281) then
	return 281852; -- O parametro open_mode na chamda FOPEN e invalido (invalid_mode).
elsif	(sqlcode = -29290) then
	return 281853; -- O parametro ABSOLUTE_OFFSET para a chamada FSEEK() e invalido; deveria ser maior do que 0 e menor do que o numero total de bytes do arquivo (invalid_offset).
elsif	(sqlcode = -29283) then
	return 1080852; -- O arquivo nao pode ser aberto ou nao foi encontrado no diretorio especificado.
elsif	(sqlcode = -29280) then
	return 281855; -- O caminho especificado nao existe ou nao esta visivel ao Oracle (invalid_path).
elsif	(sqlcode = -29284) then
	return 281856; -- Nao e possivel efetuar a leitura do arquivo (read_error).
elsif	(sqlcode = -29292) then
	return 281857; -- Nao e possivel renomear o arquivo.
elsif	(sqlcode = -29285) then
	return 281858; -- Nao foi possivel gravar no arquivo (write_error).
else
	return 281859; -- Erro desconhecido no package UTL_FILE.
end if;

end;

-- Get UTL / Windows directories
procedure jpn_utl_file_pck.get_directory_information_utl(	cd_evento_p			evento_tasy_utl_file.cd_evento%type,
				ds_local_utl_p		out	varchar,
				ds_local_windows_p	out	varchar,
				ie_valida_dir_ws_p		varchar) is
begin

begin
-- Get location recognized by ORACLE for UTL_FILE file generation
obter_evento_utl_file( cd_evento_p, null, ds_local_utl_p, ds_erro_w);
exception
when others then
	ds_local_utl_p 		:= null;
end;

-- Get location recognized by WINDOWS for UTL_FILE file generation
if	(ie_valida_dir_ws_p = 'S') and
	(ds_erro_w is null)  then
	begin
	pls_obter_dir_rede_utl_file( cd_evento_p, null, ds_local_windows_p, ds_erro_w);
	exception
	when others then
		ds_local_windows_p	:= null;
	end;

	-- Validate Windows Directory
	if	(ds_erro_w is null) then
		jpn_utl_file_pck.validate_directory( ds_local_windows_p, nr_seq_erro_w);
	end if;
end if;

-- If there is an error in the file directory by UTL_FILE, stop the process
jpn_utl_file_pck.error_handling( ds_erro_w, nr_seq_erro_w);

end jpn_utl_file_pck.get_directory_information_utl();

-- open file for reading
procedure jpn_utl_file_pck.open_file(	cd_evento_p		evento_tasy_utl_file.cd_evento%type,
				nm_arquivo_p		varchar2,
				ie_acao_p		in varchar2 default 'RB') is

-- Variaveis
ds_local_w		varchar2(4000) := null;
ds_local_windows_w	varchar2(4000) := null;

begin
-- Get location recognized by ORACLE for UTL_FILE file generation
jpn_utl_file_pck.get_directory_information_utl( cd_evento_p, ds_local_w, ds_local_windows_w, 'N');

-- Open for reading the text file by UTL_FILE inside the directory recognized by ORACLE
jpn_utl_file_pck.file_options_by_mode( ds_local_w, nm_arquivo_p, nvl(ie_acao_p,'R'), 4000);

end jpn_utl_file_pck.open_file();

-- Return line from file
procedure jpn_utl_file_pck.read_file(	ds_conteudo_p	out varchar2,
			ie_leitura_p	out boolean ) is

begin
-- Check if the file is open for reading
if	(utl_file.is_open(ds_arquivo_w)) then
	ie_leitura_p := true;

	-- get the line
	begin
	utl_file.get_raw( ds_arquivo_w, ds_conteudo_p);
	exception
	when others then
		ie_leitura_p := false;
	end;
    select utl_i18n.raw_to_char(ds_conteudo_p, 'JA16SJIS')
    into ds_conteudo_p
    from dual;
end if;

end jpn_utl_file_pck.read_file();

-- Copy the file
procedure jpn_utl_file_pck.copy_file(	cd_evento_origem_p	evento_tasy_utl_file.cd_evento%type,
				nm_arquivo_origem_p	varchar2,
				cd_evento_dest_p	evento_tasy_utl_file.cd_evento%type,
				nm_arquivo_dest_p	varchar2,
				nr_seq_linha_ini_p	number,
				nr_seq_linha_fim_p	number ) is

ds_local_origem_w	varchar2(4000) := null;
ds_local_dest_w		varchar2(4000) := null;
ds_local_windows_w	varchar2(4000) := null;

begin
-- Get location recognized by ORACLE for UTL_FILE file generation
jpn_utl_file_pck.get_directory_information_utl( cd_evento_origem_p, ds_local_origem_w, ds_local_windows_w, 'N');

if	(nr_seq_erro_w is null) then
	-- Get location recognized by ORACLE for UTL_FILE file generation
	jpn_utl_file_pck.get_directory_information_utl( nvl(cd_evento_dest_p,cd_evento_origem_p), ds_local_dest_w, ds_local_windows_w, 'N');
end if;

-- Copy information from source file to destination file (destination file cannot exist)
begin
utl_file.fcopy( ds_local_origem_w, nm_arquivo_origem_p, ds_local_dest_w, nm_arquivo_dest_p, nr_seq_linha_ini_p, nr_seq_linha_fim_p);
exception
when others then
	nr_seq_erro_w := 462978; -- Nao foi possivel copiar o arquivo por UTL_FILE
end;

-- If you have an error copying the UTL_FILE directory
jpn_utl_file_pck.error_handling( null, nr_seq_erro_w);

end jpn_utl_file_pck.copy_file();

-- Delete the file
procedure jpn_utl_file_pck.delete_file(	cd_evento_exc_p		evento_tasy_utl_file.cd_evento%type,
				nm_arquivo_exc_p	varchar2) is

ds_local_exc_w		varchar2(4000) := null;
ds_local_windows_w	varchar2(4000) := null;

begin
-- Get location recognized by ORACLE for UTL_FILE file generation
jpn_utl_file_pck.get_directory_information_utl( cd_evento_exc_p, ds_local_exc_w, ds_local_windows_w, 'N');

-- Command to delete file
begin
utl_file.fremove( ds_local_exc_w, nm_arquivo_exc_p);
exception
when others then
	nr_seq_erro_w := 466335; -- Nao foi possivel excluir o arquivo por UTL_FILE
end;

-- Handling an error to delete the UTL_FILE directory
jpn_utl_file_pck.error_handling( null, nr_seq_erro_w);

end jpn_utl_file_pck.delete_file();

-- Get file information
function jpn_utl_file_pck.get_file_information(	cd_evento_p		evento_tasy_utl_file.cd_evento%type,
					nm_arquivo_p		varchar2, -- name of the file with extension
					ie_opcao_p		varchar2)
					return varchar2 is

ds_local_w		varchar2(4000) := null;
ds_local_windows_w	varchar2(4000) := null;
ds_retorno_w		varchar2(4000) := null;
ie_existe_arq_w		boolean;
nr_tamanho_arq_w	number(20,4);
nr_tam_bloco_arq_w	number(20,4);

begin
-- Get location recognized by ORACLE for UTL_FILE file generation
jpn_utl_file_pck.get_directory_information_utl( cd_evento_p, ds_local_w, ds_local_windows_w, 'N');

begin
-- Command to check file information
utl_file.fgetattr(ds_local_w,nm_arquivo_p, ie_existe_arq_w, nr_tamanho_arq_w, nr_tam_bloco_arq_w);
exception
when others then
	ie_existe_arq_w		:= false;
	nr_tamanho_arq_w	:= 0;
	nr_tam_bloco_arq_w	:= 0;
end;

--	check whether File exists in UTL directory
if	(ie_opcao_p = 'E') then
	ds_retorno_w := 'N';
	if	(ie_existe_arq_w) then
		ds_retorno_w := 'S';
	end if;

--	File size in bytes
elsif	(ie_opcao_p = 'T') then
	ds_retorno_w := nr_tamanho_arq_w;

--	File system block size in bytes.
elsif	(ie_opcao_p = 'B') then
	ds_retorno_w := nr_tam_bloco_arq_w;
end if;

return ds_retorno_w;

end jpn_utl_file_pck.get_file_information();

-- Get windows location from UTL
function jpn_utl_file_pck.get_directory_info_by_event(	cd_evento_p		evento_tasy_utl_file.cd_evento%type) 
					return varchar2 is

ds_retorno_w		varchar2(4000) := null;

begin
pls_obter_dir_rede_utl_file( cd_evento_p, null, ds_retorno_w, ds_erro_w);

if	(ds_erro_w is not null) then
	jpn_utl_file_pck.error_handling( ds_erro_w, null);
end if;

return ds_retorno_w;

end jpn_utl_file_pck.get_directory_info_by_event();

function jpn_utl_file_pck.get_directory_information(	cd_evento_p			evento_tasy_utl_file.cd_evento%type,
			ie_opcao_p			varchar2) return varchar2 is

ds_local_windows_w	varchar2(4000) := null;
ds_local_w		varchar2(4000) := null;
ds_retorno_w		varchar2(4000) := null;

begin

if	(ie_opcao_p = 'W') then
	ds_retorno_w	:= jpn_utl_file_pck.get_directory_info_by_event(cd_evento_p);

elsif	(ie_opcao_p = 'L') then
	jpn_utl_file_pck.get_directory_information_utl( cd_evento_p, ds_local_w, ds_local_windows_w, 'N' in ds_local_windows_p);

	ds_retorno_w	:= ds_local_w;
end if;

return;

end;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE jpn_utl_file_pck.validate_directory (ds_local_windows_p text, nr_seq_erro_p INOUT dic_objeto.nr_sequencia%type ) FROM PUBLIC;
