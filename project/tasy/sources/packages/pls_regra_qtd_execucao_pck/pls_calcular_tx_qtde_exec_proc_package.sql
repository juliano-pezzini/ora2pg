-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

CREATE OR REPLACE PROCEDURE pls_regra_qtd_execucao_pck.pls_calcular_tx_qtde_exec_proc ( nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Esta procedure é responsável por calcular as novas taxas para os procedimentos de acordo com as regras de taxa de quantidade de execução.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
nr_seq_taxa_item_w    pls_regra_preco_tx_proc.nr_seq_taxa_item%type;
tx_procedimento_w                pls_regra_preco_tx_proc.tx_procedimento%type;
tx_medico_w                     pls_regra_preco_tx_proc.tx_medico%type;
tx_custo_operacional_w          pls_regra_preco_tx_proc.tx_custo_operacional%type;
tx_material_w                   pls_regra_preco_tx_proc.tx_material%type;
tx_anestesista_w                pls_regra_preco_tx_proc.tx_anestesista%type;
tx_auxiliares_w                  pls_regra_preco_tx_proc.tx_auxiliares%type;
ie_abrir_execucao_w    pls_regra_preco_qtde_proc.ie_abrir_execucao%type;
ie_alterar_se_maior_w    pls_regra_preco_qtde_proc.ie_alterar_se_maior%type;

tx_procedimento_tot_w           pls_regra_preco_tx_proc.tx_procedimento%type    := 0;
tx_medico_tot_w                 pls_regra_preco_tx_proc.tx_medico%type      := 0;
tx_custo_operacional_tot_w      pls_regra_preco_tx_proc.tx_custo_operacional%type  := 0;
tx_material_tot_w               pls_regra_preco_tx_proc.tx_material%type    := 0;
tx_anestesista_tot_w            pls_regra_preco_tx_proc.tx_anestesista%type    := 0;
tx_auxiliares_tot_w             pls_regra_preco_qtde_proc.ie_abrir_execucao%type  := 0;
ie_via_acesso_w      pls_conta_proc.ie_via_acesso%type;

nr_seq_conta_proc_table_w  dbms_sql.number_table;
tx_procedimento_table_w   dbms_sql.number_table;
tx_medico_table_w               dbms_sql.number_table;
tx_custo_operacional_table_w    dbms_sql.number_table;
tx_material_table_w             dbms_sql.number_table;
tx_anestesista_table_w          dbms_sql.number_table;
tx_auxiliares_table_w           dbms_sql.number_table;
ie_via_acesso_table_w    dbms_sql.varchar2_table;

i        integer;
qt_registro_transacao_w    integer;

-- Filtrar os procedimentos que tenham tanto a regra de quantidade de execução como a regra de taxa vinculadas
C01 CURSOR(  nr_seq_lote_pc    pls_lote_protocolo_conta.nr_sequencia%type,
    nr_seq_protocolo_pc  pls_protocolo_conta.nr_sequencia%type,
    nr_seq_lote_processo_pc  pls_cta_lote_processo.nr_sequencia%type,
    nr_seq_conta_pc    pls_conta.nr_sequencia%type,
    nr_seq_conta_proc_pc  pls_conta_proc.nr_sequencia%type ) FOR
  SELECT  a.nr_sequencia nr_seq_conta_proc,
    a.nr_seq_regra_tx_proc,
    a.qt_procedimento_imp,
    a.tx_item
  from  pls_conta_proc_v     a
  where  a.nr_seq_lote_conta = nr_seq_lote_pc
  and  (a.nr_seq_regra_qtde_exec IS NOT NULL AND a.nr_seq_regra_qtde_exec::text <> '')
  and  a.nr_seq_regra_qtde_exec > 0
  and  (a.nr_seq_regra_tx_proc IS NOT NULL AND a.nr_seq_regra_tx_proc::text <> '')

union all

  SELECT  a.nr_sequencia nr_seq_conta_proc,
    a.nr_seq_regra_tx_proc,
    a.qt_procedimento_imp,
    a.tx_item
  from  pls_conta_proc_v     a
  where  a.nr_seq_protocolo = nr_seq_protocolo_pc
  and  (a.nr_seq_regra_qtde_exec IS NOT NULL AND a.nr_seq_regra_qtde_exec::text <> '')
  and  a.nr_seq_regra_qtde_exec > 0
  and  (a.nr_seq_regra_tx_proc IS NOT NULL AND a.nr_seq_regra_tx_proc::text <> '')
  
union all

  select  a.nr_sequencia nr_seq_conta_proc,
    a.nr_seq_regra_tx_proc,
    a.qt_procedimento_imp,
    a.tx_item
  from  pls_cta_lote_proc_conta   b,
    pls_conta_proc_v     a
        where    a.nr_seq_conta = b.nr_seq_conta
  and  b.nr_seq_lote_processo = nr_seq_lote_processo_pc
  and  (a.nr_seq_regra_qtde_exec IS NOT NULL AND a.nr_seq_regra_qtde_exec::text <> '')
  and  a.nr_seq_regra_qtde_exec > 0
  and  (a.nr_seq_regra_tx_proc IS NOT NULL AND a.nr_seq_regra_tx_proc::text <> '')
  
union all

  select  a.nr_sequencia nr_seq_conta_proc,
    a.nr_seq_regra_tx_proc,
    a.qt_procedimento_imp,
    a.tx_item
  from  pls_conta_proc_v     a
  where  a.nr_seq_conta = nr_seq_conta_pc
  and  coalesce(nr_seq_conta_proc_pc::text, '') = ''
  and  (a.nr_seq_regra_qtde_exec IS NOT NULL AND a.nr_seq_regra_qtde_exec::text <> '')
  and  a.nr_seq_regra_qtde_exec > 0
  and  (a.nr_seq_regra_tx_proc IS NOT NULL AND a.nr_seq_regra_tx_proc::text <> '')
  
union all

  select  a.nr_sequencia nr_seq_conta_proc,
    a.nr_seq_regra_tx_proc,
    a.qt_procedimento_imp,
    a.tx_item
  from  pls_conta_proc_v     a
        where    a.nr_sequencia = nr_seq_conta_proc_pc
  and  (a.nr_seq_regra_qtde_exec IS NOT NULL AND a.nr_seq_regra_qtde_exec::text <> '')
  and  a.nr_seq_regra_qtde_exec > 0
  and  (a.nr_seq_regra_tx_proc IS NOT NULL AND a.nr_seq_regra_tx_proc::text <> '');
BEGIN

i := 0;

-- Obter o controle padrão para quantidade de registros que será enviada a cada vez para o banco de dados
qt_registro_transacao_w := pls_util_cta_pck.qt_registro_transacao_w;

-- Cursor para obter os procedimentos
for r_C01_w in C01(nr_seq_lote_p, nr_seq_protocolo_p, nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p) loop

  -- Se as taxas tiverem valor zero, então é tratado para que sejam consideradas como 100%
  select  a.nr_seq_taxa_item,
    CASE WHEN coalesce(a.tx_procedimento, 0)=0 THEN  100  ELSE a.tx_procedimento END  tx_procedimento,
    CASE WHEN coalesce(a.tx_medico, 0)=0 THEN  100  ELSE a.tx_medico END  tx_medico,
    CASE WHEN coalesce(a.tx_custo_operacional, 0)=0 THEN  100  ELSE a.tx_custo_operacional END  tx_custo_operacional,
    CASE WHEN coalesce(a.tx_material, 0)=0 THEN  100  ELSE a.tx_material END  tx_material,
    CASE WHEN coalesce(a.tx_anestesista, 0)=0 THEN  100  ELSE a.tx_anestesista END  tx_anestesista,
    CASE WHEN coalesce(a.tx_auxiliares, 0)=0 THEN  100  ELSE a.tx_auxiliares END  tx_auxiliares,
    coalesce(b.ie_abrir_execucao,'N') ie_abrir_execucao,
    coalesce(b.ie_alterar_se_maior,'N') ie_alterar_se_maior,
    a.ie_via_acesso
  into STRICT  nr_seq_taxa_item_w,
    tx_procedimento_w,
    tx_medico_w,
    tx_custo_operacional_w,
    tx_material_w,
    tx_anestesista_w,
    tx_auxiliares_w,
    ie_abrir_execucao_w,
    ie_alterar_se_maior_w,
    ie_via_acesso_w
        from    pls_regra_preco_tx_proc   a,
    pls_regra_preco_qtde_proc  b
        where   b.nr_sequencia = a.nr_seq_regra
  and  a.nr_sequencia  = r_C01_w.nr_seq_regra_tx_proc;

  -- NR_SEQ_TAXA_ITEM_W - Se algum valor for informado neste campo, então o sistema irá utilizar apenas esse valor para atribuir a taxa aos procedimentos, e não irá utilizar as taxas informadas nos outros campos da regra.
  if (coalesce(nr_seq_taxa_item_w,0) > 0) then
    tx_procedimento_w       := pls_obter_taxa_item(nr_seq_taxa_item_w);
    tx_medico_w             := tx_procedimento_w;
    tx_custo_operacional_w  := tx_procedimento_w;
    tx_material_w           := tx_procedimento_w;
    tx_anestesista_w        := tx_procedimento_w;
    tx_auxiliares_w         := tx_procedimento_w;
  end if;

  if (ie_abrir_execucao_w = 'S') then
    tx_procedimento_table_w(i)       := tx_procedimento_w;
    tx_medico_table_w(i)             := tx_medico_w;
    tx_custo_operacional_table_w(i)  := tx_custo_operacional_w;
    tx_material_table_w(i)           := tx_material_w;
    tx_anestesista_table_w(i)        := tx_anestesista_w;
    tx_auxiliares_table_w(i)         := tx_auxiliares_w;
    ie_via_acesso_table_w(i)   := ie_via_acesso_w;
  else
    for x in 1..(r_C01_w.qt_procedimento_imp) loop
      tx_procedimento_tot_w           := tx_procedimento_tot_w + tx_procedimento_w;
      tx_medico_tot_w                 := tx_medico_tot_w + tx_medico_w;
      tx_custo_operacional_tot_w      := tx_custo_operacional_tot_w + tx_custo_operacional_w;
      tx_material_tot_w               := tx_material_tot_w + tx_material_w;
      tx_anestesista_tot_w            := tx_anestesista_tot_w + tx_anestesista_w;
      tx_auxiliares_tot_w             := tx_auxiliares_tot_w + tx_auxiliares_w;
    end loop;

    tx_procedimento_table_w(i)       := dividir(tx_procedimento_tot_w, r_C01_w.qt_procedimento_imp);
    tx_medico_table_w(i)             := dividir(tx_medico_tot_w, r_C01_w.qt_procedimento_imp);
    tx_custo_operacional_table_w(i)  := dividir(tx_custo_operacional_tot_w, r_C01_w.qt_procedimento_imp);
    tx_material_table_w(i)           := dividir(tx_material_tot_w, r_C01_w.qt_procedimento_imp);
    tx_anestesista_table_w(i)        := dividir(tx_anestesista_tot_w, r_C01_w.qt_procedimento_imp);
    tx_auxiliares_table_w(i)         := dividir(tx_auxiliares_tot_w, r_C01_w.qt_procedimento_imp);
    ie_via_acesso_table_w(i)   := null;
  end if;

  -- IE_ALTERAR_SE_MAIOR_W - Informar se o sistema irá alterar a taxa do item conforme a regra somente se a taxa obtida pela regra for menor do que a taxa já existente no item
  if (ie_alterar_se_maior_w = 'S') and (tx_procedimento_table_w(i) < r_C01_w.tx_item)then
    tx_procedimento_table_w(i) := r_C01_w.tx_item;
  end if;

  nr_seq_conta_proc_table_w(i)   := r_C01_w.nr_seq_conta_proc;

  if (i >= qt_registro_transacao_w) then
    CALL pls_regra_qtd_execucao_pck.pls_gravar_tx_qtd_exec_proc(  nr_seq_conta_proc_table_w, tx_procedimento_table_w, tx_medico_table_w, tx_custo_operacional_table_w,
            tx_material_table_w, tx_anestesista_table_w, tx_auxiliares_table_w, ie_via_acesso_table_w);

    -- Limpa as variáveis table
    nr_seq_conta_proc_table_w.delete;
    tx_procedimento_table_w.delete;
    tx_medico_table_w.delete;
    tx_custo_operacional_table_w.delete;
    tx_material_table_w.delete;
    tx_anestesista_table_w.delete;
    tx_auxiliares_table_w.delete;
    ie_via_acesso_table_w.delete;

    i := 0;
  else
    i := i + 1;
  end if;
end loop;

-- Caso sobre algum registro dentro das tables, as novas taxas precisam ser gravadas nestes também
if (nr_seq_conta_proc_table_w.count > 0) then
  CALL pls_regra_qtd_execucao_pck.pls_gravar_tx_qtd_exec_proc(  nr_seq_conta_proc_table_w, tx_procedimento_table_w, tx_medico_table_w, tx_custo_operacional_table_w,
          tx_material_table_w, tx_anestesista_table_w, tx_auxiliares_table_w, ie_via_acesso_table_w);
end if;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_regra_qtd_execucao_pck.pls_calcular_tx_qtde_exec_proc ( nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;
