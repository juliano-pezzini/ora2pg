-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

CREATE OR REPLACE PROCEDURE pls_regra_qtd_execucao_pck.pls_vincular_regras_qtd_exec ( nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_analise_p pls_analise_conta.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type ) AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Esta procedure tem por objetivo vincular as regras de quantidade de execução aos procedimentos.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
ds_sql_w    varchar(4000);
cursor_w    sql_pck.t_cursor;
valor_bind_w    sql_pck.t_dado_bind;

ds_inicio_sql_w    varchar(4000);
ds_restricao_w    varchar(4000);
ds_tabela_extra_w  varchar(500);
ds_restricao_extra_w  varchar(1000);

nr_seq_conta_proc_w    pls_conta_proc.nr_sequencia%type;
ie_glosa_w      pls_conta_proc.ie_glosa%type;
ie_tipo_conta_w      pls_conta.ie_tipo_conta%type;
nr_seq_regra_qtde_exec_w  pls_conta_proc.nr_seq_regra_qtde_exec%type;
ie_status_w      pls_conta_proc.ie_status%type;
ie_tipo_intercambio_w	pls_regra_preco_qtde_proc.ie_tipo_intercambio%type;

qt_registro_w    integer;
tb_seq_conta_proc_w  pls_util_cta_pck.t_number_table;
tb_seq_regra_w    pls_util_cta_pck.t_number_table;

dados_regra_w    pls_regra_qtd_execucao_pck.dados_regra;
qt_conta_lote_w    integer;
ie_considerar_glosados_w	pls_parametros.ie_considerar_glosados%type;

C01 CURSOR( cd_estabelecimento_pc  estabelecimento.cd_estabelecimento%type) FOR
  SELECT  a.nr_sequencia nr_seq_regra,
    a.cd_area_procedimento,
    a.cd_especialidade,
    a.cd_grupo_proc,
    a.cd_procedimento,
    a.ie_origem_proced,
    a.nr_seq_grupo_servico,
    a.nr_seq_grupo_prestador,
    a.nr_seq_prestador,
    a.ie_tipo_guia,
    a.ie_tipo_conta,
    a.cd_edicao_amb,
    a.nr_seq_tipo_prestador,
    a.dt_inicio_vigencia,
    a.dt_fim_vigencia,
    a.ie_preco,
    a.ie_via_acesso,
    a.ie_tipo_segurado,
    a.ie_apresentacao,
    a.ie_origem_protocolo,
    coalesce(a.ie_tipo_intercambio, 'X') ie_tipo_intercambio
  from  pls_regra_preco_qtde_proc  a
  where  a.cd_estabelecimento  = cd_estabelecimento_pc
  and  a.ie_situacao = 'A'
  order by coalesce(a.cd_procedimento,0) desc,
     coalesce(a.cd_grupo_proc,0) desc,
     coalesce(a.cd_especialidade,0) desc,
     coalesce(a.cd_area_procedimento,0) desc,
     a.ie_tipo_conta;
BEGIN

select 	max(ie_considerar_glosados)
into STRICT ie_considerar_glosados_w
from	pls_parametros
where 	cd_estabelecimento = cd_estabelecimento_p;

ds_tabela_extra_w := null;
ds_restricao_extra_w := null;
-- se for por lote de processo busca tudo da pls_cta_lote_proc_cta_temp que é alimentada na pls_cta_lote_proc_cta_temp
-- isso é um tratamento de performance
if (nr_seq_lote_processo_p IS NOT NULL AND nr_seq_lote_processo_p::text <> '') then
  ds_tabela_extra_w := ', pls_cta_lote_proc_cta_temp b' || pls_util_pck.enter_w;
  ds_restricao_extra_w := ' and b.nr_seq_conta = a.nr_seq_conta' || pls_util_pck.enter_w;
end if;

-- Select dinâmico
ds_inicio_sql_w :=  'select  a.nr_sequencia,        ' || pls_util_pck.enter_w ||
      '  a.ie_glosa,        ' || pls_util_pck.enter_w ||
      '  a.ie_tipo_conta,      ' || pls_util_pck.enter_w ||
      '  a.nr_seq_regra_qtde_exec,    ' || pls_util_pck.enter_w ||
      '  nvl(a.ie_status, ''D'')  ie_status,  ' || pls_util_pck.enter_w ||
      '  pls_obter_dados_conta(a.nr_seq_conta, ''TI1'')  ie_tipo_intercambio  ' || pls_util_pck.enter_w ||
      'from  pls_conta_proc_v  a    ' || pls_util_pck.enter_w ||
      ds_tabela_extra_w ||
      'where  1 = 1  '         || pls_util_pck.enter_w ||
      ds_restricao_extra_w;

-- Atribuição dos valores para os campos do type DADOS_REGRA
dados_regra_w.nr_seq_lote    := nr_seq_lote_p;
dados_regra_w.nr_seq_protocolo    := nr_seq_protocolo_p;
dados_regra_w.nr_seq_lote_processo  := nr_seq_lote_processo_p;
dados_regra_w.nr_seq_conta    := nr_seq_conta_p;
dados_regra_w.nr_seq_conta_proc    := nr_seq_conta_proc_p;
dados_regra_w.nr_seq_analise    := nr_seq_analise_p;

-- Cursor da tabela PLS_REGRA_PRECO_QTDE_PROC
for r_C01_w in C01(cd_estabelecimento_p) loop

  -- Atribuição dos valores para os campos do type DADOS_REGRA
  dados_regra_w.cd_procedimento    := r_C01_w.cd_procedimento;
  dados_regra_w.ie_origem_proced    := r_C01_w.ie_origem_proced;
  dados_regra_w.cd_grupo_proc    := r_C01_w.cd_grupo_proc;
  dados_regra_w.cd_especialidade    := r_C01_w.cd_especialidade;
  dados_regra_w.cd_area_procedimento  := r_C01_w.cd_area_procedimento;
  dados_regra_w.nr_seq_grupo_servico  := r_C01_w.nr_seq_grupo_servico;
  dados_regra_w.nr_seq_grupo_prestador  := r_C01_w.nr_seq_grupo_prestador;
  dados_regra_w.nr_seq_prestador    := r_C01_w.nr_seq_prestador;
  dados_regra_w.ie_tipo_guia    := r_C01_w.ie_tipo_guia;
  dados_regra_w.ie_tipo_conta    := r_C01_w.ie_tipo_conta;
  dados_regra_w.cd_edicao_amb    := r_C01_w.cd_edicao_amb;
  dados_regra_w.nr_seq_tipo_prestador  := r_C01_w.nr_seq_tipo_prestador;
  dados_regra_w.dt_inicio_vigencia  := r_C01_w.dt_inicio_vigencia;
  dados_regra_w.dt_fim_vigencia    := r_C01_w.dt_fim_vigencia;
  dados_regra_w.ie_preco      := r_C01_w.ie_preco;
  dados_regra_w.ie_via_acesso    := r_C01_w.ie_via_acesso;
  dados_regra_w.ie_tipo_segurado    := r_C01_w.ie_tipo_segurado;
  dados_regra_w.ie_apresentacao    := r_C01_w.ie_apresentacao;
  dados_regra_w.ie_origem_protocolo  := r_C01_w.ie_origem_protocolo;

  -- Obter restrições
  valor_bind_w := pls_regra_qtd_execucao_pck.pls_obter_restr_qtd_execucao(dados_regra_w, valor_bind_w);

  -- Concatena todas as partes do select para resultar em um só
  ds_sql_w := ds_inicio_sql_w || ds_restricao_w || pls_util_pck.enter_w;

  qt_registro_w := 0;

  -- executa o comando e devolve o cursor
  valor_bind_w := sql_pck.executa_sql_cursor(  ds_sql_w, valor_bind_w);
  loop
    fetch cursor_w
    into   nr_seq_conta_proc_w, ie_glosa_w, ie_tipo_conta_w, nr_seq_regra_qtde_exec_w, ie_status_w, ie_tipo_intercambio_w;
    EXIT WHEN NOT FOUND; /* apply on cursor_w */

    -- para intercâmbio não existe o ie_glosa, ou seja o ie_glosa deve ser N e se for intercâmbio ele não precisa ser considerado
    -- isso não é filtrado diretamente no select por motivo de performance pois o ie_glosa é uma função dentro da view
    -- os outros campos também foram retirados do select por esse motivo
    if  ((ie_glosa_w = 'N' or ie_tipo_conta_w = 'I' or ie_considerar_glosados_w = 'S') and (coalesce(nr_seq_regra_qtde_exec_w::text, '') = '') and (ie_status_w != 'D')) and
       -- valida o intercambio
       ((r_C01_w.ie_tipo_intercambio = 'X') or (ie_tipo_intercambio_w = r_C01_w.ie_tipo_intercambio) or
	(((r_C01_w.ie_tipo_intercambio = 'A') and (ie_tipo_intercambio_w in ('E', 'N'))))) then
      tb_seq_conta_proc_w(qt_registro_w) := nr_seq_conta_proc_w;
      tb_seq_regra_w(qt_registro_w) := r_C01_w.nr_seq_regra;
      qt_registro_w := qt_registro_w + 1;
    end if;

    -- se atingiu a quantidade de registros, manda para o banco de dados
    if (qt_registro_w >= pls_util_cta_pck.qt_registro_transacao_w) then
      CALL pls_regra_qtd_execucao_pck.atualiza_regra_qtde_exec(tb_seq_conta_proc_w, tb_seq_regra_w, nm_usuario_p);
      -- zera as variáveis
      qt_registro_w := 0;
      tb_seq_conta_proc_w.delete;
      tb_seq_regra_w.delete;
    end if;
  end loop;
  close cursor_w;

  -- se sobrou registros, manda pro banco
  CALL pls_regra_qtd_execucao_pck.atualiza_regra_qtde_exec(tb_seq_conta_proc_w, tb_seq_regra_w, nm_usuario_p);

  -- zera as variáveis
  qt_registro_w := 0;
  tb_seq_conta_proc_w.delete;
  tb_seq_regra_w.delete;
end loop;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_regra_qtd_execucao_pck.pls_vincular_regras_qtd_exec ( nr_seq_lote_p pls_lote_protocolo_conta.nr_sequencia%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_analise_p pls_analise_conta.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type ) FROM PUBLIC;
