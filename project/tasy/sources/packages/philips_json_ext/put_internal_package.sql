-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE philips_json_ext.put_internal (obj INOUT philips_json, v_path text, elem philips_json_value, base bigint) AS $body$
DECLARE

    val philips_json_value := elem;
    path philips_json_list;
    backreference philips_json_list := philips_json_list();

    keyval philips_json_value;keynum bigint;keystring varchar(4000);
    temp philips_json_value := obj.to_json_value;
    obj_temp  philips_json;
    list_temp philips_json_list;
    inserter philips_json_value;

BEGIN
    path := philips_json_ext.parsePath(v_path, base);
    if (path.count = 0) then CALL wheb_mensagem_pck.exibir_mensagem_abort( 'philips_json_ext put error: cannot put with empty string.'); end if;

    FOR i in 1 .. path.count loop

      keyval := path.get(i);
      if (keyval.is_number()) then
        --nummer index
        keynum := keyval.get_number();
        if((not temp.is_object()) and (not temp.is_array())) then
          if (coalesce(val::text, '') = '') then return; end if;
          backreference.remove_last;
          temp := philips_json_list().to_json_value();
          backreference.append(temp);
        end if;

        if (temp.is_object()) then
          obj_temp := philips_json(temp);
          if (obj_temp.count < keynum) then
            if (coalesce(val::text, '') = '') then return; end if;
            CALL wheb_mensagem_pck.exibir_mensagem_abort( 'philips_json_ext put error: access object with to few members.');
          end if;
          temp := obj_temp.get(keynum);
        else
          list_temp := philips_json_list(temp);
          if (list_temp.count < keynum) then
            if (coalesce(val::text, '') = '') then return; end if;

            for i in list_temp.count+1 .. keynum loop
              list_temp.append(philips_json_value.makenull);
            end loop;
            backreference.remove_last;
            backreference.append(list_temp);
          end if;

          temp := list_temp.get(keynum);
        end if;
      else

        keystring := keyval.get_string();
        if (not temp.is_object()) then

          if (coalesce(val::text, '') = '') then return; end if;
          backreference.remove_last;
          temp := philips_json().to_json_value();
          backreference.append(temp);

        end if;
        obj_temp := philips_json(temp);
        temp := obj_temp.get(keystring);
      end if;

      if (coalesce(temp::text, '') = '') then
        if (coalesce(val::text, '') = '') then return; end if;

        keyval := path.get(i+1);
        if ((keyval IS NOT NULL AND keyval::text <> '') and keyval.is_number()) then
          temp := philips_json_list().to_json_value;
        else
          temp := philips_json().to_json_value;
        end if;
      end if;
      backreference.append(temp);
    end loop;

    inserter := val;
    for i IN REVERSE backreference.count..1 loop

      if ( i = 1 ) then
        keyval := path.get(1);
        if (keyval.is_string()) then
          keystring := keyval.get_string();
        else
          keynum := keyval.get_number();
          declare
            t1 philips_json_value := obj.get(keynum);
          begin
            keystring := t1.mapname;
          end;
        end if;
        if (coalesce(inserter::text, '') = '') then obj.remove(keystring); else obj.put(keystring, inserter); end if;
      else
        temp := backreference.get(i-1);
        if (temp.is_object()) then
          keyval := path.get(i);
          obj_temp := philips_json(temp);
          if (keyval.is_string()) then
            keystring := keyval.get_string();
          else
            keynum := keyval.get_number();
            declare
              t1 philips_json_value := obj_temp.get(keynum);
            begin
              keystring := t1.mapname;
            end;
          end if;
          if (coalesce(inserter::text, '') = '') then
            obj_temp.remove(keystring);
            if (obj_temp.count > 0) then inserter := obj_temp.to_json_value; end if;
          else
            obj_temp.put(keystring, inserter);
            inserter := obj_temp.to_json_value;
          end if;
        else

          keynum := path.get[i].get_number();
          list_temp := philips_json_list(temp);
          list_temp.remove(keynum);
          if (not coalesce(inserter::text, '') = '') then
            list_temp.append(inserter, keynum);
            inserter := list_temp.to_json_value;
          else
            if (list_temp.count > 0) then inserter := list_temp.to_json_value; end if;
          end if;
        end if;
      end if;

    end loop;

  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE philips_json_ext.put_internal (obj INOUT philips_json, v_path text, elem philips_json_value, base bigint) FROM PUBLIC;
