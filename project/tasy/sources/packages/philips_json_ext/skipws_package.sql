-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE philips_json_ext.skipws () AS $body$
BEGIN while(buf in (chr(9),chr(10),chr(13),' ')) loop CALL philips_json_ext.next_char(); end loop; end;

  begin
    CALL philips_json_ext.next_char();
    while(buf IS NOT NULL AND buf::text <> '') loop
      if (buf = '.') then
        CALL philips_json_ext.next_char();
        if (coalesce(buf::text, '') = '') then CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: . is not a valid json_path end'); end if;
        if (not regexp_like(buf, '^[[:alnum:]\_ ]+', 'c') ) then
          CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: alpha-numeric character or space expected at position '||current_setting('philips_json_ext.indx')::bigint);
        end if;

        if (build_path != '[') then build_path := build_path || ','; end if;
        build_path := build_path || '"';
        while(regexp_like(buf, '^[[:alnum:]\_ ]+', 'c') ) loop
          build_path := build_path || buf;
          CALL philips_json_ext.next_char();
        end loop;
        build_path := build_path || '"';
      elsif (buf = '[') then
        CALL philips_json_ext.next_char();
        CALL philips_json_ext.skipws();
        if (coalesce(buf::text, '') = '') then CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: [ is not a valid json_path end'); end if;
        if (buf in ('1','2','3','4','5','6','7','8','9') or (buf = '0' and base = 0)) then
          if (build_path != '[') then build_path := build_path || ','; end if;
          while(buf in ('0','1','2','3','4','5','6','7','8','9')) loop
            build_path := build_path || buf;
            CALL philips_json_ext.next_char();
          end loop;
        elsif (regexp_like(buf, '^(\"|\'')', 'c')) then
          endstring := buf;
          if (build_path != '[') then build_path := build_path || ','; end if;
          build_path := build_path || '"';
          CALL philips_json_ext.next_char();
          if (coalesce(buf::text, '') = '') then CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: premature json_path end'); end if;
          while(buf != endstring) loop
            build_path := build_path || buf;
            CALL philips_json_ext.next_char();
            if (coalesce(buf::text, '') = '') then CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: premature json_path end'); end if;
            if (buf = '\') then
              CALL philips_json_ext.next_char();
              build_path := build_path || '\' || buf;
              CALL philips_json_ext.next_char();
            end if;
          end loop;
          build_path := build_path || '"';
          CALL philips_json_ext.next_char();
        else
          CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: expected a string or an positive integer at '||current_setting('philips_json_ext.indx')::bigint);
        end if;
        CALL philips_json_ext.skipws();
        if (coalesce(buf::text, '') = '') then CALL wheb_mensagem_pck.exibir_mensagem_abort( 'philips_json Path parse error: premature json_path end'); end if;
        if (buf != ']') then CALL wheb_mensagem_pck.exibir_mensagem_abort( 'philips_json Path parse error: no array ending found. found: '|| buf); end if;
        CALL philips_json_ext.next_char();
        CALL philips_json_ext.skipws();
      elsif (build_path = '[') then
        if (not regexp_like(buf, '^[[:alnum:]\_ ]+', 'c') ) then
          CALL wheb_mensagem_pck.exibir_mensagem_abort('philips_json Path parse error: alpha-numeric character or space expected at position '||current_setting('philips_json_ext.indx')::bigint);
        end if;
        build_path := build_path || '"';
        while(regexp_like(buf, '^[[:alnum:]\_ ]+', 'c') ) loop
          build_path := build_path || buf;
          CALL philips_json_ext.next_char();
        end loop;
        build_path := build_path || '"';
      else
        CALL wheb_mensagem_pck.exibir_mensagem_abort( 'philips_json Path parse error: expected . or [ found '|| buf || ' at position '|| current_setting('philips_json_ext.indx')::bigint);
      end if;

    end loop;

    build_path := build_path || ']';
    build_path := replace(replace(replace(replace(replace(build_path, chr(9), '\t'), chr(10), '\n'), chr(13), '\f'), chr(8), '\b'), chr(14), '\r');

    PERFORM set_config('philips_json_ext.ret', philips_json_list(build_path), false);
    if (base != 1) then

      declare
        elem philips_json_value;
      begin
        for i in 1 .. current_setting('philips_json_ext.ret')::philips_json_list.count loop
          elem := current_setting('philips_json_ext.ret')::philips_json_list.get(i);
          if (elem.is_number) then
            current_setting('philips_json_ext.ret')::philips_json_list.replace(i, elem.get_number()+1, '');
          end if;
        end loop;
      end;
    end if;

    return;
  END;



$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE philips_json_ext.skipws () FROM PUBLIC;
