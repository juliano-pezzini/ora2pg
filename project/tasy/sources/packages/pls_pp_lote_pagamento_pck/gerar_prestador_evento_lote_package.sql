-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_pp_lote_pagamento_pck.gerar_prestador_evento_lote ( nr_seq_lote_p pls_pp_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

					
_ora2pg_r RECORD;
-- Tables

tb_nr_seq_prestador_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_evento_w	pls_util_cta_pck.t_number_table;
tb_ie_acao_pgto_neg_w	pls_util_cta_pck.t_varchar2_table_5;

tb_nr_seq_item_lote_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_valor_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_item_valor_w	pls_util_cta_pck.t_number_table;
tb_vl_glosa_w		pls_util_cta_pck.t_number_table;
tb_vl_item_w		pls_util_cta_pck.t_number_table;
tb_vl_negativo_w	pls_util_cta_pck.t_number_table;
tb_vl_tributo_w		pls_util_cta_pck.t_number_table;
tb_vl_liquido_w		pls_util_cta_pck.t_number_table;

-- Indice das Tables

nr_idx_insert_w		integer;
nr_idx_update_w		integer;

-- Controla a soma de valores

vl_glosa_w		pls_pp_item_lote.vl_glosa%type;
vl_item_w		pls_pp_item_lote.vl_item%type;
vl_negativo_w		pls_pp_item_lote.vl_acao_negativo%type;
vl_tributo_w		pls_pp_item_lote.vl_desconto_tributo%type;
vl_liquido_w		pls_pp_item_lote.vl_liquido%type;

C01 CURSOR(	nr_seq_lote_pc		pls_pp_lote.nr_sequencia%type) FOR
	SELECT	distinct o.nr_seq_evento,
		o.nr_seq_prestador,
		(SELECT	max(i.ie_acao_pgto_negativo)
		from	pls_pp_item_lote i
		where	i.nr_seq_evento		= o.nr_seq_evento
		and	i.nr_seq_lote		= o.nr_seq_lote
		and	i.nr_seq_prestador	= o.nr_seq_prestador) ie_acao_pgto_negativo  -- Pegar a acao para nao duplicar registro
	from	pls_pp_item_lote o
	where	o.nr_seq_lote = nr_seq_lote_pc
	and	coalesce(o.nr_seq_lanc_prog::text, '') = ''
	
union

		select	distinct o.nr_seq_evento,
		o.nr_seq_prestador,
		(select	max(i.ie_acao_pgto_negativo)
		from	pls_pp_item_lote i
		where	i.nr_seq_evento		= o.nr_seq_evento
		and	i.nr_seq_lote		= o.nr_seq_lote
		and	i.nr_seq_prestador	= o.nr_seq_prestador) ie_acao_pgto_negativo  -- Pegar a acao para nao duplicar registro
	from	pls_pp_item_lote o
	where	o.nr_seq_lote = nr_seq_lote_pc
	and	(o.nr_seq_lanc_prog IS NOT NULL AND o.nr_seq_lanc_prog::text <> '')
	and	o.vl_item <> 0;
	
C02 CURSOR(	nr_seq_lote_pc		pls_pp_lote.nr_sequencia%type) FOR
	SELECT	nr_sequencia,
		nr_seq_prestador,
		nr_seq_evento
	from	pls_pp_prest_evento_valor
	where	nr_seq_lote = nr_seq_lote_pc;
	
C03 CURSOR(	nr_seq_lote_pc		pls_pp_lote.nr_sequencia%type,
		nr_seq_prestador_pc	pls_pp_prest_evento_valor.nr_seq_prestador%type,
		nr_seq_evento_pc	pls_pp_prest_evento_valor.nr_seq_evento%type) FOR
	SELECT	nr_sequencia,
		coalesce(vl_glosa, 0) vl_glosa,
		coalesce(vl_item, 0) vl_item,
		coalesce(vl_acao_negativo, 0) vl_acao_negativo,
		coalesce(vl_liquido, 0) vl_liquido,
		coalesce(vl_desconto_tributo, 0) vl_tributo
	from	pls_pp_item_lote
	where	nr_seq_lote = nr_seq_lote_pc
	and	nr_seq_prestador = nr_seq_prestador_pc
	and	nr_seq_evento = nr_seq_evento_pc
	and	coalesce(nr_seq_lanc_prog::text, '') = ''
	
union all

	SELECT	nr_sequencia,
		coalesce(vl_glosa, 0) vl_glosa,
		coalesce(vl_item, 0) vl_item,
		coalesce(vl_acao_negativo, 0) vl_acao_negativo,
		coalesce(vl_liquido, 0) vl_liquido,
		coalesce(vl_desconto_tributo, 0) vl_tributo
	from	pls_pp_item_lote
	where	nr_seq_lote = nr_seq_lote_pc
	and	nr_seq_prestador = nr_seq_prestador_pc
	and	nr_seq_evento = nr_seq_evento_pc
	and	(nr_seq_lanc_prog IS NOT NULL AND nr_seq_lanc_prog::text <> '')
	and	vl_item <> 0;
	
BEGIN

tb_nr_seq_evento_w.delete;
tb_nr_seq_prestador_w.delete;

-- Varre todos os itens e insere na tabela 'pls_pp_prest_evento_valor' ja agrupando por evento e prestador porem com os valores zerados, estes serao atualizados posteriormente

open C01( nr_seq_lote_p );
	loop
		fetch C01 bulk collect into tb_nr_seq_evento_w, tb_nr_seq_prestador_w, tb_ie_acao_pgto_neg_w
		limit pls_util_pck.qt_registro_transacao_w;
		exit when tb_nr_seq_evento_w.count = 0;
					
		forall i in tb_nr_seq_evento_w.first..tb_nr_seq_evento_w.last
			insert into pls_pp_prest_evento_valor(	nr_sequencia, dt_atualizacao, dt_atualizacao_nrec,
								nm_usuario, nm_usuario_nrec, nr_seq_evento, 
								nr_seq_lote, nr_seq_prestador, vl_glosa, 
								vl_item, vl_liquido, ie_acao_pgto_negativo,
								vl_acao_negativo, ie_cancelado, vl_tributo)
							values (	nextval('pls_pp_prest_evento_valor_seq'), clock_timestamp(), clock_timestamp(), 
								nm_usuario_p, nm_usuario_p, tb_nr_seq_evento_w(i), 
								nr_seq_lote_p, tb_nr_seq_prestador_w(i), 0, 
								0, 0, tb_ie_acao_pgto_neg_w(i),
								0, 'N', 0);
		commit;
	end loop;
close C01;

-- Limpa as tables

SELECT * FROM pls_pp_lote_pagamento_pck.grava_lista_prest_evento(	tb_nr_seq_item_lote_w, tb_nr_seq_valor_w, tb_nr_seq_item_valor_w, tb_vl_glosa_w, tb_vl_item_w, tb_vl_negativo_w, tb_vl_tributo_w, tb_vl_liquido_w, nr_idx_update_w, nr_idx_insert_w) INTO STRICT _ora2pg_r;
 	tb_nr_seq_item_lote_w := _ora2pg_r.tb_nr_seq_item_lote_p; tb_nr_seq_valor_w := _ora2pg_r.tb_nr_seq_valor_p; tb_nr_seq_item_valor_w := _ora2pg_r.tb_nr_seq_item_valor_p; tb_vl_glosa_w := _ora2pg_r.tb_vl_glosa_p; tb_vl_item_w := _ora2pg_r.tb_vl_item_p; tb_vl_negativo_w := _ora2pg_r.tb_vl_negativo_p; tb_vl_tributo_w := _ora2pg_r.tb_vl_tributo_p; tb_vl_liquido_w := _ora2pg_r.tb_vl_liquido_p; nr_idx_update_w := _ora2pg_r.nr_idx_update_p; nr_idx_insert_w := _ora2pg_r.nr_idx_insert_p;

-- Retorna todos os registros da tabela 'pls_pp_prest_evento_valor' ja agrupados por lote, evento e prestador

for r_C02_w in C02( nr_seq_lote_p ) loop

	-- Zera os somadores de valores

	vl_glosa_w := 0;
	vl_item_w := 0;
	vl_negativo_w := 0;
	vl_tributo_w := 0;
	vl_liquido_w := 0;

	-- Retorna todos os itens, neste bloco deve ser somado os itens por lote, evento e prestador

	for r_C03_w in C03( nr_seq_lote_p, r_C02_w.nr_seq_prestador, r_C02_w.nr_seq_evento ) loop
	
		-- Grava os dados nas tables para um futuro insert na tabela 'pls_pp_it_prest_event_val'

		tb_nr_seq_item_lote_w( nr_idx_insert_w ) := r_C03_w.nr_sequencia;
		tb_nr_seq_valor_w( nr_idx_insert_w ) := r_C02_w.nr_sequencia;
		
		-- Soma os valores agrupados por evento e prestador

		vl_glosa_w := vl_glosa_w + r_C03_w.vl_glosa;
		vl_item_w := vl_item_w + r_C03_w.vl_item;
		vl_negativo_w := vl_negativo_w + r_C03_w.vl_acao_negativo;
		vl_tributo_w := vl_tributo_w + r_C03_w.vl_tributo;
		vl_liquido_w := vl_liquido_w + r_C03_w.vl_liquido;
		
		-- se atingiu a quantidade manda para o banco

		if (nr_idx_insert_w >= pls_util_cta_pck.qt_registro_transacao_w) then

			SELECT * FROM pls_pp_lote_pagamento_pck.grava_lista_prest_evento(	tb_nr_seq_item_lote_w, tb_nr_seq_valor_w, tb_nr_seq_item_valor_w, tb_vl_glosa_w, tb_vl_item_w, tb_vl_negativo_w, tb_vl_tributo_w, tb_vl_liquido_w, nr_idx_update_w, nr_idx_insert_w) INTO STRICT _ora2pg_r;
 	tb_nr_seq_item_lote_w := _ora2pg_r.tb_nr_seq_item_lote_p; tb_nr_seq_valor_w := _ora2pg_r.tb_nr_seq_valor_p; tb_nr_seq_item_valor_w := _ora2pg_r.tb_nr_seq_item_valor_p; tb_vl_glosa_w := _ora2pg_r.tb_vl_glosa_p; tb_vl_item_w := _ora2pg_r.tb_vl_item_p; tb_vl_negativo_w := _ora2pg_r.tb_vl_negativo_p; tb_vl_tributo_w := _ora2pg_r.tb_vl_tributo_p; tb_vl_liquido_w := _ora2pg_r.tb_vl_liquido_p; nr_idx_update_w := _ora2pg_r.nr_idx_update_p; nr_idx_insert_w := _ora2pg_r.nr_idx_insert_p;
		else
			-- Incrementa o index do update

			nr_idx_insert_w := nr_idx_insert_w + 1;
			-- Zera os somadores de valores

		end if;
	end loop;
	
	-- Grava os dados nas tables para um futuro update na tabela 'pls_pp_prest_evento_valor'

	tb_nr_seq_item_valor_w( nr_idx_update_w ) := r_C02_w.nr_sequencia;
	tb_vl_glosa_w( nr_idx_update_w ) := vl_glosa_w;
	tb_vl_item_w( nr_idx_update_w ) := vl_item_w;
	tb_vl_negativo_w( nr_idx_update_w ) := vl_negativo_w;
	tb_vl_tributo_w( nr_idx_update_w ) := vl_tributo_w;
	tb_vl_liquido_w( nr_idx_update_w ) := vl_liquido_w;
	
	-- se atingiu a quantidade manda para o banco

	if (nr_idx_update_w >= pls_util_cta_pck.qt_registro_transacao_w) then

		SELECT * FROM pls_pp_lote_pagamento_pck.grava_lista_prest_evento(	tb_nr_seq_item_lote_w, tb_nr_seq_valor_w, tb_nr_seq_item_valor_w, tb_vl_glosa_w, tb_vl_item_w, tb_vl_negativo_w, tb_vl_tributo_w, tb_vl_liquido_w, nr_idx_update_w, nr_idx_insert_w) INTO STRICT _ora2pg_r;
 	tb_nr_seq_item_lote_w := _ora2pg_r.tb_nr_seq_item_lote_p; tb_nr_seq_valor_w := _ora2pg_r.tb_nr_seq_valor_p; tb_nr_seq_item_valor_w := _ora2pg_r.tb_nr_seq_item_valor_p; tb_vl_glosa_w := _ora2pg_r.tb_vl_glosa_p; tb_vl_item_w := _ora2pg_r.tb_vl_item_p; tb_vl_negativo_w := _ora2pg_r.tb_vl_negativo_p; tb_vl_tributo_w := _ora2pg_r.tb_vl_tributo_p; tb_vl_liquido_w := _ora2pg_r.tb_vl_liquido_p; nr_idx_update_w := _ora2pg_r.nr_idx_update_p; nr_idx_insert_w := _ora2pg_r.nr_idx_insert_p;
	else
		-- Incrementa o index do update

		nr_idx_update_w := nr_idx_update_w + 1;
	end if;
end loop;

SELECT * FROM pls_pp_lote_pagamento_pck.grava_lista_prest_evento(	tb_nr_seq_item_lote_w, tb_nr_seq_valor_w, tb_nr_seq_item_valor_w, tb_vl_glosa_w, tb_vl_item_w, tb_vl_negativo_w, tb_vl_tributo_w, tb_vl_liquido_w, nr_idx_update_w, nr_idx_insert_w) INTO STRICT _ora2pg_r;
 	tb_nr_seq_item_lote_w := _ora2pg_r.tb_nr_seq_item_lote_p; tb_nr_seq_valor_w := _ora2pg_r.tb_nr_seq_valor_p; tb_nr_seq_item_valor_w := _ora2pg_r.tb_nr_seq_item_valor_p; tb_vl_glosa_w := _ora2pg_r.tb_vl_glosa_p; tb_vl_item_w := _ora2pg_r.tb_vl_item_p; tb_vl_negativo_w := _ora2pg_r.tb_vl_negativo_p; tb_vl_tributo_w := _ora2pg_r.tb_vl_tributo_p; tb_vl_liquido_w := _ora2pg_r.tb_vl_liquido_p; nr_idx_update_w := _ora2pg_r.nr_idx_update_p; nr_idx_insert_w := _ora2pg_r.nr_idx_insert_p;
				
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_pp_lote_pagamento_pck.gerar_prestador_evento_lote ( nr_seq_lote_p pls_pp_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
