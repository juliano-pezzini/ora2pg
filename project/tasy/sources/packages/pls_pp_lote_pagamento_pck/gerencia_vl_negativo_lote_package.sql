-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_pp_lote_pagamento_pck.gerencia_vl_negativo_lote ( nr_seq_lote_p pls_pp_item_lote.nr_seq_lote%type) AS $body$
DECLARE


_ora2pg_r RECORD;
/* 
	Esta rotina gerencia a regra de prioridade de desconto, ela ira pegar os prestador que irao ficar com valor liquido negativo e ira ver quais
	os itens que irao ser 'abatidos' da divida. Para isso invertemos a logica para ficar mais facil a rotina, ou seja, vamos verificar quais itens
	precisam ser 'eliminados' do lote para que o valor liquido do prestador fique zerado.
	Entao comecamos com os eventos que nao tem prioridade de desconto, ou seja, que nao necessariamente precisam ser pagos neste pagamento, para
	eliminar a maior quantidade de registros neste pagamento a segunda ordenacao e pelo valor, pegando os registros que sao as maiores dividas do prestador
	isso deve nos retornar o minimo possivel ate chegarmos no ponto zero.
	Dentro do cursor c02 entao e feito esse controle jogando os registros que deverao ser desconsiderados deste pagamento para uma variavel ate que chege o
	valor do pagamento a zero.
*/

vl_negativo_prest_w	double precision;

tb_nr_sequencia_w	pls_util_cta_pck.t_number_table;
tb_vl_negativo_item_w	pls_util_cta_pck.t_number_table;
nr_cont_w		integer;

c01 CURSOR(	nr_seq_lote_pc	pls_pp_item_lote.nr_seq_lote%type) FOR
	SELECT	a.nr_seq_prestador,
		abs(sum(a.vl_liquido)) vl_liquido_prest
	from	pls_pp_item_lote a
	where	a.nr_seq_lote = nr_seq_lote_pc
	GROUP BY a.nr_seq_prestador;

c02 CURSOR(	nr_seq_lote_pc	pls_pp_item_lote.nr_seq_lote%type,
		nr_seq_prest_pc	pls_prestador.nr_sequencia%type HAVING	sum(a.vl_liquido) < 0
	) FOR
	SELECT	a.nr_sequencia,
		abs(a.vl_liquido) vl_liquido_item
	from	pls_pp_item_lote a,
		pls_evento b
	where	a.nr_seq_lote = nr_seq_lote_pc
	and	a.nr_seq_prestador = nr_seq_prest_pc
	and	b.nr_sequencia = a.nr_seq_evento
	and	a.vl_liquido < 0
	order by
		coalesce(b.nr_prior_desc, -1),
		a.vl_liquido;

BEGIN
-- inicia as variaveis

SELECT * FROM pls_pp_lote_pagamento_pck.atualiza_valor_negativo(nr_seq_lote_p, tb_nr_sequencia_w, tb_vl_negativo_item_w, nr_cont_w) INTO STRICT _ora2pg_r;
 tb_nr_sequencia_w := _ora2pg_r.tb_nr_sequencia_p; tb_vl_negativo_item_w := _ora2pg_r.tb_vl_item_p; nr_cont_w := _ora2pg_r.nr_cont_p;

-- retorna todos os prestadores do lote que ficaram com valor negativo e o valor que ficou negativo

for r_c01_w in c01(nr_seq_lote_p) loop

	vl_negativo_prest_w := r_c01_w.vl_liquido_prest;

	for r_c02_w in c02(nr_seq_lote_p, r_c01_w.nr_seq_prestador) loop
	
		tb_nr_sequencia_w(nr_cont_w) := r_c02_w.nr_sequencia;
		
		-- se o valor do item for maior ou igual ao valor que esta faltando para fechar entao so alimenta o 

		-- campo de valor negativo com o valor que falta e seta o valor que esta faltando para zero

		if (r_c02_w.vl_liquido_item >= vl_negativo_prest_w) then

			tb_vl_negativo_item_w(nr_cont_w) := pls_util_pck.obter_valor_negativo(vl_negativo_prest_w);
			vl_negativo_prest_w := 0;

		-- senao o valor negativo e o valor do item e deduz o valor do item do valor total

		else

			tb_vl_negativo_item_w(nr_cont_w) := pls_util_pck.obter_valor_negativo(r_c02_w.vl_liquido_item);
			vl_negativo_prest_w := vl_negativo_prest_w - r_c02_w.vl_liquido_item;
		end if;

		-- se atingiu a quantidade manda pro banco

		if (nr_cont_w >= pls_util_pck.qt_registro_transacao_w) then

			SELECT * FROM pls_pp_lote_pagamento_pck.atualiza_valor_negativo(nr_seq_lote_p, tb_nr_sequencia_w, tb_vl_negativo_item_w, nr_cont_w) INTO STRICT _ora2pg_r;
 tb_nr_sequencia_w := _ora2pg_r.tb_nr_sequencia_p; tb_vl_negativo_item_w := _ora2pg_r.tb_vl_item_p; nr_cont_w := _ora2pg_r.nr_cont_p;
		else
			nr_cont_w := nr_cont_w + 1;
		end if;
		
		-- se o total chegou a zero e pq nao precisa mais verificar os outros itens

		-- por isso saimos do cursor c02

		if (vl_negativo_prest_w = 0) then

			exit;
		end if;
	end loop;
end loop;

-- se sobrou algo manda pro banco

SELECT * FROM pls_pp_lote_pagamento_pck.atualiza_valor_negativo(nr_seq_lote_p, tb_nr_sequencia_w, tb_vl_negativo_item_w, nr_cont_w) INTO STRICT _ora2pg_r;
 tb_nr_sequencia_w := _ora2pg_r.tb_nr_sequencia_p; tb_vl_negativo_item_w := _ora2pg_r.tb_vl_item_p; nr_cont_w := _ora2pg_r.nr_cont_p;
			
-- percorre todos os registros do lote e seta os valores nulos para N

CALL pls_pp_lote_pagamento_pck.alimentar_registros_nulos(	nr_seq_lote_p);

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_pp_lote_pagamento_pck.gerencia_vl_negativo_lote ( nr_seq_lote_p pls_pp_item_lote.nr_seq_lote%type) FROM PUBLIC;
