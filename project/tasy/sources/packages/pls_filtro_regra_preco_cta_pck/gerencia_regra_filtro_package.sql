-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_filtro_regra_preco_cta_pck.gerencia_regra_filtro ( ie_destino_regra_p text, nr_seq_lote_conta_p pls_protocolo_conta.nr_seq_lote%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type, nr_seq_analise_p pls_analise_conta.nr_sequencia%type, cd_acao_analise_p pls_acao_analise.cd_acao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


_ora2pg_r RECORD;
nr_id_transacao_w	pls_cp_cta_selecao.nr_id_transacao%type;

nr_contador_w	integer;
tb_regra_w	pls_util_cta_pck.t_number_table;
tb_dt_inicio_w	pls_util_cta_pck.t_date_table;
tb_dt_fim_w	pls_util_cta_pck.t_date_table;
tb_id_trans_w	pls_util_cta_pck.t_number_table;

/*
 ie_destino_regra_p 	P -> Prestador
			R -> Reembolso
			F -> Fatura (Pos-estabelecido)
			C -> coparticipacao
			I -> intercambio
*/

c_regra CURSOR(	ie_destino_regra_pc	text,
		ie_calculo_coparticipacao_pc	pls_parametros.ie_calculo_coparticipacao%type) FOR
	SELECT 	a.nr_sequencia nr_seq_regra_filtro,
		a.dt_inicio_vigencia_ref,
		a.dt_fim_vigencia_ref,
		a.ie_tipo_regra,
		a.nr_ordem_execucao
	from	pls_cp_cta_combinada a
	where  	a.ie_situacao = 'A'
	and    	a.ie_dest_prestador = 'S'
	and	ie_destino_regra_pc = 'P'
	
union all

	SELECT 	a.nr_sequencia nr_seq_regra_filtro,
		a.dt_inicio_vigencia_ref,
		a.dt_fim_vigencia_ref,
		a.ie_tipo_regra,
		a.nr_ordem_execucao
	from	pls_cp_cta_combinada a
	where  	a.ie_situacao = 'A'
	and    	a.ie_dest_reembolso = 'S'
	and	ie_destino_regra_pc = 'R'
	
union all

	select 	a.nr_sequencia nr_seq_regra_filtro,
		a.dt_inicio_vigencia_ref,
		a.dt_fim_vigencia_ref,
		a.ie_tipo_regra,
		a.nr_ordem_execucao
	from	pls_cp_cta_combinada a
	where  	a.ie_situacao = 'A'
	and    	a.ie_dest_coparticipacao = 'S'
	and	ie_destino_regra_pc = 'C'
	and	ie_calculo_coparticipacao_pc in ('O', 'R')
	
union all

	select 	a.nr_sequencia nr_seq_regra_filtro,
		a.dt_inicio_vigencia_ref,
		a.dt_fim_vigencia_ref,
		a.ie_tipo_regra,
		a.nr_ordem_execucao
	from	pls_cp_cta_combinada a
	where  	a.ie_situacao = 'A'
	and    	a.ie_dest_intercambio = 'S'
	and	ie_destino_regra_pc = 'I'
	order by nr_ordem_execucao desc, nr_seq_regra_filtro;

BEGIN
-- verifica se foi passado algum parametro, caso NAO tenha sido passado NAO faz nada

-- esta validacao e para evitar que seja processado toda a tabela por NAO ter uma restricao

if (nr_seq_lote_processo_p IS NOT NULL AND nr_seq_lote_processo_p::text <> '') or (nr_seq_conta_proc_p IS NOT NULL AND nr_seq_conta_proc_p::text <> '') or (nr_seq_lote_conta_p IS NOT NULL AND nr_seq_lote_conta_p::text <> '') or (nr_seq_conta_mat_p IS NOT NULL AND nr_seq_conta_mat_p::text <> '') or (nr_seq_protocolo_p IS NOT NULL AND nr_seq_protocolo_p::text <> '') or (nr_seq_analise_p IS NOT NULL AND nr_seq_analise_p::text <> '') or (nr_seq_conta_p IS NOT NULL AND nr_seq_conta_p::text <> '') then
		
	-- carrega os parametros necessorios para processar os dados

	CALL CALL CALL CALL CALL CALL pls_filtro_regra_preco_cta_pck.carrega_parametros(cd_estabelecimento_p);
	
	-- verifica se tem algo para atualizar nas tabelas

	CALL pls_gerencia_upd_obj_pck.atualizar_objetos('Tasy', 'PLS_FILTRO_REGRA_PRECO_CTA_PCK.GERENCIA_REGRA_FILTRO()', 'PLS_ESTRUTURA_MATERIAL_TM');
	CALL pls_gerencia_upd_obj_pck.atualizar_objetos('Tasy', 'PLS_FILTRO_REGRA_PRECO_CTA_PCK.GERENCIA_REGRA_FILTRO()', 'PLS_GRUPO_SERVICO_TM');
	CALL pls_gerencia_upd_obj_pck.atualizar_objetos('Tasy', 'PLS_FILTRO_REGRA_PRECO_CTA_PCK.GERENCIA_REGRA_FILTRO()', 'PLS_GRUPO_MATERIAL_TM');

	-- alimenta os campos nulos

	CALL pls_filtro_regra_preco_cta_pck.alimenta_campo_nulo(	nr_seq_lote_conta_p, nr_seq_protocolo_p,
				nr_seq_lote_processo_p, nr_seq_conta_p,
				nr_seq_conta_proc_p, nr_seq_conta_mat_p,
				nr_seq_analise_p, cd_estabelecimento_p,
				nm_usuario_p);

	-- limpa o vinculo da regra que existe nos registros que serao processados

	CALL CALL pls_filtro_regra_preco_cta_pck.limpa_vinculo_regra_filtro(	ie_destino_regra_p, nr_seq_lote_conta_p, nr_seq_protocolo_p,
					nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p,
					nr_seq_conta_mat_p, nr_seq_analise_p, cd_estabelecimento_p,
					nm_usuario_p);

	-- insere registros de regras nulas para procedimentos ou materiais que ainda NAO tenham registros

	CALL pls_filtro_regra_preco_cta_pck.cria_registro_regra(	ie_destino_regra_p, nr_seq_lote_conta_p, nr_seq_protocolo_p,
				nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p,
				nr_seq_conta_mat_p, nr_seq_analise_p, cd_estabelecimento_p,
				nm_usuario_p);

	-- limpa as variaveis que serao utilizadas para salvar o tempo de execucoo

	SELECT * FROM pls_filtro_regra_preco_cta_pck.atualiza_log_tempo(	ie_destino_regra_p, nr_seq_lote_conta_p, nr_seq_protocolo_p, nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p, nr_seq_conta_mat_p, nr_seq_analise_p, cd_acao_analise_p, nm_usuario_p, tb_dt_inicio_w, tb_dt_fim_w, tb_regra_w, tb_id_trans_w) INTO STRICT _ora2pg_r;
 tb_dt_inicio_w := _ora2pg_r.tb_dt_inicio_p; tb_dt_fim_w := _ora2pg_r.tb_dt_fim_p; tb_regra_w := _ora2pg_r.tb_nr_seq_regra_p; tb_id_trans_w := _ora2pg_r.tb_nr_id_trans_p;

	-- retorna todas as regras de acordo com a prioridade de execucao, para regras de coparticipacao

	-- so deve retornar caso o parametro do calculo de coparticipacao seja Operadora ou Depende regra.

	nr_contador_w := 0;
	for r_c_regra_w in c_regra(	ie_destino_regra_p, current_setting('pls_filtro_regra_preco_cta_pck.ie_calculo_coparticipacao_w')::pls_parametros.ie_calculo_coparticipacao%type) loop

		tb_regra_w(nr_contador_w) := r_c_regra_w.nr_seq_regra_filtro;
		tb_dt_inicio_w(nr_contador_w) := clock_timestamp();
		
		-- gera uma transacao para cada regra

		select	nextval('pls_id_transacao_cp_cta_seq') nr_id_transacao
		into STRICT	nr_id_transacao_w
		;

		-- processa os filtros da regra e deixa os registros validos na tabela pls_cp_cta_selecao

		CALL CALL CALL CALL CALL pls_filtro_regra_preco_cta_pck.gerencia_aplicacao_filtro(	ie_destino_regra_p, r_c_regra_w.nr_seq_regra_filtro,
						r_c_regra_w.ie_tipo_regra, r_c_regra_w.dt_inicio_vigencia_ref, 
						r_c_regra_w.dt_fim_vigencia_ref, nr_id_transacao_w, 
						nr_seq_lote_conta_p, nr_seq_protocolo_p,
						nr_seq_lote_processo_p,	nr_seq_conta_p,
						nr_seq_conta_proc_p, nr_seq_conta_mat_p,
						nr_seq_analise_p, cd_acao_analise_p,
						cd_estabelecimento_p, nm_usuario_p);

		-- grava na tabela/campo "quente" o codigo da regra que casou com o item

		CALL CALL pls_filtro_regra_preco_cta_pck.grava_regra_combinada_item(	ie_destino_regra_p, r_c_regra_w.nr_seq_regra_filtro,
						r_c_regra_w.ie_tipo_regra, nr_id_transacao_w,
						nm_usuario_p);
			
		tb_id_trans_w(nr_contador_w) := nr_id_transacao_w;
		tb_dt_fim_w(nr_contador_w) := clock_timestamp();
		
		-- se atingiu a quantidade de registros salva o tempo de execucao

		if (nr_contador_w >= pls_util_pck.qt_registro_transacao_w) then

			SELECT * FROM pls_filtro_regra_preco_cta_pck.atualiza_log_tempo(	ie_destino_regra_p, nr_seq_lote_conta_p, nr_seq_protocolo_p, nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p, nr_seq_conta_mat_p, nr_seq_analise_p, cd_acao_analise_p, nm_usuario_p, tb_dt_inicio_w, tb_dt_fim_w, tb_regra_w, tb_id_trans_w) INTO STRICT _ora2pg_r;
 tb_dt_inicio_w := _ora2pg_r.tb_dt_inicio_p; tb_dt_fim_w := _ora2pg_r.tb_dt_fim_p; tb_regra_w := _ora2pg_r.tb_nr_seq_regra_p; tb_id_trans_w := _ora2pg_r.tb_nr_id_trans_p;
			nr_contador_w := 0;
		else
			nr_contador_w := nr_contador_w + 1;
		end if;

		-- limpa a tabela de selecao

		CALL CALL CALL CALL CALL pls_filtro_regra_preco_cta_pck.limpar_transacao(	nr_id_transacao_w);
	end loop;

	-- caso tenha sobrado algo insere no log de tempo

	SELECT * FROM pls_filtro_regra_preco_cta_pck.atualiza_log_tempo(	ie_destino_regra_p, nr_seq_lote_conta_p, nr_seq_protocolo_p, nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p, nr_seq_conta_mat_p, nr_seq_analise_p, cd_acao_analise_p, nm_usuario_p, tb_dt_inicio_w, tb_dt_fim_w, tb_regra_w, tb_id_trans_w) INTO STRICT _ora2pg_r;
 tb_dt_inicio_w := _ora2pg_r.tb_dt_inicio_p; tb_dt_fim_w := _ora2pg_r.tb_dt_fim_p; tb_regra_w := _ora2pg_r.tb_nr_seq_regra_p; tb_id_trans_w := _ora2pg_r.tb_nr_id_trans_p;
end if;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_filtro_regra_preco_cta_pck.gerencia_regra_filtro ( ie_destino_regra_p text, nr_seq_lote_conta_p pls_protocolo_conta.nr_seq_lote%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type, nr_seq_analise_p pls_analise_conta.nr_sequencia%type, cd_acao_analise_p pls_acao_analise.cd_acao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
