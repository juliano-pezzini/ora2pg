-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pfcs_pck_operating_rooms.calc_timeline (cd_establishment_p bigint, nm_user_p text) AS $body$
DECLARE

        cur_procedures CURSOR(nr_seq_location_p bigint) FOR
        SELECT appt.period_start dt_appt_start,
            appt.period_end dt_appt_end,
            proc.period_end dt_proc_end,
            proc.period_start dt_proc_start,
            proc.si_status status_procedure,
            coalesce(proc.ds_coding_disp, appt.ds_reason) ds_tooltip,
            proc.si_status
        FROM pfcs_patient pat, pfcs_appointment appt
LEFT OUTER JOIN pfcs_procedure proc ON (appt.nr_seq_procedure = proc.nr_sequencia)
, pfcs_pck_constants
LEFT OUTER JOIN pfcs_procedure proc ON (PFCS_PCK_CONSTANTS.CD_SURGICAL_PROCEDURE = proc.cd_category)
WHERE ( trunc(coalesce(proc.period_start,appt.period_start)) = trunc(clock_timestamp()) or
                trunc(coalesce(proc.period_end,appt.period_end)) = trunc(clock_timestamp()) or (trunc(appt.period_end) <> trunc(clock_timestamp()) and coalesce(proc.period_end::text, '') = '')
            ) and upper(appt.si_status) in (
                PFCS_PCK_CONSTANTS.SI_STATUS_BOOKED,
                PFCS_PCK_CONSTANTS.SI_STATUS_ARRIVED,
                PFCS_PCK_CONSTANTS.SI_STATUS_FULFILLED)   and appt.nr_seq_patient = pat.nr_sequencia and appt.nr_seq_location  = nr_seq_location_p;

        cur_blocked_slots CURSOR(nr_seq_location_p  bigint) FOR
        SELECT slot.period_start,
            slot.period_end
        from pfcs_slot slot,
             pfcs_schedule sch
        where ( slot.period_start between
                    (trunc(clock_timestamp(),PFCS_PCK_CONSTANTS.CD_MASK_HH24) - (8/24)) and
                    (trunc(clock_timestamp(),PFCS_PCK_CONSTANTS.CD_MASK_HH24) + (9/24))   )
            and (   slot.period_end between
                        (trunc(clock_timestamp(),PFCS_PCK_CONSTANTS.CD_MASK_HH24) - (8/24)) and
                        (trunc(clock_timestamp(),PFCS_PCK_CONSTANTS.CD_MASK_HH24) + (9/24))   )
            and slot.nr_seq_schedule = sch.nr_sequencia
            and sch.nr_seq_location = nr_seq_location_p
            and sch.ie_active = PFCS_PCK_CONSTANTS.IE_TRUE
            and upper(si_status) = PFCS_PCK_CONSTANTS.SI_STATUS_BUSY_UNAVAILABLE
        order by slot.period_start asc;

        cur_or_setups CURSOR(nr_seq_location_p  bigint) FOR
        SELECT tsk.period_start,
            tsk.period_end,
            tsk.si_status,
            tsk.si_intent
        from pfcs_task tsk
        where ( trunc(clock_timestamp()) between trunc(tsk.period_start) and trunc(tsk.period_end) )
            and tsk.cd_task_code = PFCS_PCK_CONSTANTS.CD_TASK_OR_SETUP
            and tsk.si_status in (PFCS_PCK_CONSTANTS.SI_STATUS_ACCEPTED, PFCS_PCK_CONSTANTS.SI_STATUS_IN_PROGRESS)
            and tsk.si_intent in (PFCS_PCK_CONSTANTS.SI_INTENT_ORDER, PFCS_PCK_CONSTANTS.SI_INTENT_PLAN)
            and tsk.nr_seq_location = nr_seq_location_p;

        qt_time_delay_surg_w        pfcs_general_rule.qt_time_delay_surg%type;
        ds_color_w                  pfcs_panel.cd_reference_value%type;

        dt_slot_period_end_w        pfcs_slot.period_end%type;
        dt_slot_period_start_w      pfcs_slot.period_start%type;

        pfcs_panel_seq_w            pfcs_panel.nr_sequencia%type;
        pfcs_panel_detail_seq_w     pfcs_panel_detail.nr_sequencia%type;

        dt_reference_start_w        timestamp;
        dt_reference_end_w          timestamp;

        type blocked_slots_array_w is table of cur_blocked_slots%rowtype index by integer;
        blocked_slots_w blocked_slots_array_w;

BEGIN
        qt_time_delay_surg_w := (pfcs_pck_utils.get_general_rule_value('QT_TIME_DELAY_SURG', cd_establishment_p) / 1440);

        for c01_w in current_setting('pfcs_pck_operating_rooms.cur_rooms')::CURSOR(cd_establishment_p(cd_establishment_p) loop
            ds_color_w := PFCS_PCK_CONSTANTS.CD_COLOR_GRAY;
            dt_reference_start_w := null;
            dt_reference_end_w := null;
            for procedure_w in cur_procedures(c01_w.nr_seq_location) loop
                if ( procedure_w.dt_appt_start <= clock_timestamp() and coalesce(procedure_w.dt_proc_end::text, '') = ''
                     and ( (procedure_w.dt_proc_start > (procedure_w.dt_appt_start + qt_time_delay_surg_w))
                            or (clock_timestamp() > (procedure_w.dt_appt_end + qt_time_delay_surg_w)) )
                ) then
                    ds_color_w := PFCS_PCK_CONSTANTS.CD_COLOR_YELLOW;
                end if;

                dt_reference_start_w := coalesce(procedure_w.dt_proc_start, procedure_w.dt_appt_start);
                dt_reference_end_w := coalesce(
                    procedure_w.dt_proc_end,
                    case when procedure_w.dt_appt_end < clock_timestamp()
                        then (clock_timestamp() + dividir(30,1440))
                    else procedure_w.dt_appt_end end);

                if (dt_reference_start_w < trunc(clock_timestamp() - interval '8 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24)) then
                    dt_reference_start_w := trunc(clock_timestamp() - interval '8 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24);
                end if;
                if (dt_reference_end_w > trunc(clock_timestamp() + interval '9 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24)) then
                    dt_reference_end_w := trunc(clock_timestamp() + interval '9 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24);
                end if;

                 := pfcs_pck.pfcs_generate_results(
                    vl_indicator_p => c01_w.nr_seq_location, ds_color_p => ds_color_w, ds_reference_value_p => c01_w.ds_location, ds_reference_aux_p => procedure_w.ds_tooltip, cd_reference_aux_p => to_char(dt_reference_end_w,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), cd_reference_value_p => to_char(dt_reference_start_w,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), nr_seq_operational_level_p => cd_establishment_p, nr_seq_indicator_p => PFCS_PCK_INDICATORS.NR_OR_TIMELINE_SURGERIES, nm_usuario_p => nm_user_p, nr_seq_panel_p => pfcs_panel_seq_w);
            end loop;

            open cur_blocked_slots(c01_w.nr_seq_location);
            loop
                fetch cur_blocked_slots bulk collect
                    into blocked_slots_w limit 1000;
                EXIT WHEN NOT FOUND; /* apply on cur_blocked_slots */
            end loop;
            close cur_blocked_slots;

            dt_slot_period_start_w := null;
            dt_slot_period_end_w := null;
            for i in 1..blocked_slots_w.count loop
                if (i <> blocked_slots_w.count) then
                    if (blocked_slots_w[i].period_end = blocked_slots_w[i+1].period_start) then
                        coalesce(if (dt_slot_period_start_w)::text, '') = '' then
                            dt_slot_period_start_w := blocked_slots_w[i].period_start;
                        end if;
                        dt_slot_period_end_w := blocked_slots_w[i+1].period_end;
                    else
                         := pfcs_pck.pfcs_generate_results(
                            vl_indicator_p => c01_w.nr_seq_location, ds_color_p => PFCS_PCK_CONSTANTS.CD_COLOR_RED, ds_reference_value_p => c01_w.ds_location, ds_reference_aux_p => PFCS_PCK_CONSTANTS.CD_EXPR_BLOCKED_TIMELINE, cd_reference_aux_p => to_char(
                                coalesce(dt_slot_period_end_w,blocked_slots_w[i].period_end),
                                PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), cd_reference_value_p => to_char(
                                coalesce(dt_slot_period_start_w,blocked_slots_w[i].period_start),
                                PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), nr_seq_operational_level_p => cd_establishment_p, nr_seq_indicator_p => PFCS_PCK_INDICATORS.NR_OR_TIMELINE_SURGERIES, nm_usuario_p => nm_user_p, nr_seq_panel_p => pfcs_panel_seq_w);
                        dt_slot_period_start_w := null;
                        dt_slot_period_end_w := null;
                    end if;
                else
                    if (coalesce(dt_slot_period_start_w::text, '') = '') then
                         := pfcs_pck.pfcs_generate_results(
                            vl_indicator_p => c01_w.nr_seq_location, ds_color_p => PFCS_PCK_CONSTANTS.CD_COLOR_RED, ds_reference_value_p => c01_w.ds_location, ds_reference_aux_p => PFCS_PCK_CONSTANTS.CD_EXPR_BLOCKED_TIMELINE, cd_reference_aux_p => to_char(blocked_slots_w[i].period_end,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), cd_reference_value_p => to_char(blocked_slots_w[i].period_start,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), nr_seq_operational_level_p => cd_establishment_p, nr_seq_indicator_p => PFCS_PCK_INDICATORS.NR_OR_TIMELINE_SURGERIES, nm_usuario_p => nm_user_p, nr_seq_panel_p => pfcs_panel_seq_w);
                    else
                         := pfcs_pck.pfcs_generate_results(
                            vl_indicator_p => c01_w.nr_seq_location, ds_color_p => PFCS_PCK_CONSTANTS.CD_COLOR_RED, ds_reference_value_p => c01_w.ds_location, ds_reference_aux_p => PFCS_PCK_CONSTANTS.CD_EXPR_BLOCKED_TIMELINE, cd_reference_aux_p => to_char(dt_slot_period_end_w,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), cd_reference_value_p => to_char(dt_slot_period_start_w,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), nr_seq_operational_level_p => cd_establishment_p, nr_seq_indicator_p => PFCS_PCK_INDICATORS.NR_OR_TIMELINE_SURGERIES, nm_usuario_p => nm_user_p, nr_seq_panel_p => pfcs_panel_seq_w);
                    end if;
                end if;
            end loop;

            for or_setup_w in cur_or_setups(c01_w.nr_seq_location) loop
                dt_reference_start_w := or_setup_w.period_start;
                dt_reference_end_w := or_setup_w.period_end;
                if (dt_reference_start_w < trunc(clock_timestamp() - interval '8 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24)) then
                    dt_reference_start_w := trunc(clock_timestamp() - interval '8 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24);
                end if;
                if (dt_reference_end_w > trunc(clock_timestamp() + interval '9 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24)) then
                    dt_reference_end_w := trunc(clock_timestamp() + interval '9 days'/24,PFCS_PCK_CONSTANTS.CD_MASK_HH24);
                end if;
                 := pfcs_pck.pfcs_generate_results(
                    vl_indicator_p => c01_w.nr_seq_location, ds_color_p => PFCS_PCK_CONSTANTS.CD_COLOR_DARK_GRAY, ds_reference_value_p => c01_w.ds_location, ds_reference_aux_p => PFCS_PCK_CONSTANTS.CD_EXPR_IN_SETUP_TIMELINE, cd_reference_aux_p => to_char(dt_reference_end_w,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), cd_reference_value_p => to_char(dt_reference_start_w,PFCS_PCK_CONSTANTS.CD_MASK_DATETIME_BR), nr_seq_operational_level_p => cd_establishment_p, nr_seq_indicator_p => PFCS_PCK_INDICATORS.NR_OR_TIMELINE_SURGERIES, nm_usuario_p => nm_user_p, nr_seq_panel_p => pfcs_panel_seq_w);
            end loop;
        end loop;

        CALL pfcs_pck.pfcs_activate_records(
            nr_seq_indicator_p => PFCS_PCK_INDICATORS.NR_OR_TIMELINE_SURGERIES,
            nr_seq_operational_level_p => cd_establishment_p,
            nm_usuario_p => nm_user_p);
    END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pfcs_pck_operating_rooms.calc_timeline (cd_establishment_p bigint, nm_user_p text) FROM PUBLIC;
