-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


CREATE TYPE login_row AS (dt_access timestamp, dt_logoff timestamp, counter bigint);


CREATE OR REPLACE PROCEDURE pkg_login_report.do_login_report (dt_fromDate_p timestamp, dt_toDate_p timestamp, licenses_p integer) AS $body$
DECLARE

      TYPE eligible_logins IS TABLE OF login_row;
      currentDate timestamp;
      counter integer;
      logins eligible_logins;
      startDate timestamp;
      endDate timestamp;
      daysInterval bigint;

BEGIN
      daysInterval := 15;
      currentDate := dt_fromDate_p;
      startDate := currentDate;
      endDate := startDate + daysInterval;
      IF endDate > dt_toDate_p THEN endDate := dt_toDate_p; END IF;
      EXECUTE 'TRUNCATE TABLE CONCURRENT_USERS_T';
      /* Selects only the login records which the logoff date was not set by an automatic logoff (when the users are disconnected by a server shutdown, for example),
         or the count of logoffs at the same time does not exceed a threshold of 20% the license count, to be processed by the first pass. */
      WITH logoff_count AS (SELECT dt_saida, COUNT(nr_sequencia) AS logoff_count FROM TASY_CONTROLE_LOGIN a
                             WHERE TRUNC(a.dt_saida) >= dt_fromDate_p AND a.ds_aplicacao = 'TasySwing' AND (a.dt_saida IS NOT NULL AND a.dt_saida::text <> '') GROUP BY dt_saida),
           acessos AS (SELECT pkg_login_report.normalize_date(b.dt_acesso, 15) + (14/1440) AS dt_acesso, pkg_login_report.normalize_date(b.dt_saida, 15) AS dt_saida FROM TASY_CONTROLE_LOGIN b, logoff_count c
                        WHERE b.dt_saida = c.dt_saida AND c.logoff_count <= (licenses_p * 0.2) AND b.ds_aplicacao = 'TasySwing' AND TRUNC(b.dt_saida) >= startDate AND TRUNC(b.dt_acesso) <= endDate AND (b.dt_saida IS NOT NULL AND b.dt_saida::text <> ''))
        SELECT acessos.dt_acesso, acessos.dt_saida, COUNT(*) BULK COLLECT INTO STRICT logins FROM acessos GROUP BY acessos.dt_acesso, acessos.dt_saida ORDER BY acessos.dt_acesso ASC;
      LOOP
        LOOP
          counter := 0;
          IF logins.COUNT > 0 THEN
            /* For each interval of 15 minutes, all records returned by previous query are iterated and dates compared to check if they fit into the interval  */

            FOR i IN logins.FIRST .. logins.LAST
            LOOP
              IF logins[i].dt_logoff >= currentDate AND logins[i].dt_access <= (currentDate + (15/1440)) THEN
                counter := counter + logins[i].counter;
              END IF;
              /* As the results are ordered by access date, if the access date of a record is after the end of the interval, all the following records won't fall
                into the interval too, so they don't need to be checked. */
              IF logins[i].dt_access > (currentDate + (15/1440)) THEN EXIT; END IF;
            END LOOP;
          END IF;
          INSERT INTO CONCURRENT_USERS_T VALUES (currentDate, counter);
          currentDate := currentDate + (15/1440); /* Adds 15 minutes */
          EXIT WHEN TRUNC(currentDate) > TRUNC(endDate);
        END LOOP;
        startDate := endDate;
        endDate := startDate + daysInterval;
        IF endDate > dt_toDate_p THEN endDate := dt_toDate_p; END IF;
        EXIT WHEN startDate >= dt_toDate_p;
        logins.DELETE;
        /* For performance reasons, the records are retrieved in a maximum interval of 15 days, to reduce the number of iteration
          in the inner loop above. So the query must be executed again, shifting the interval by 15 days until the date specified in the dt_toDate_p parameter. */
        WITH logoff_count AS (SELECT dt_saida, COUNT(nr_sequencia) AS logoff_count FROM TASY_CONTROLE_LOGIN a
                               WHERE TRUNC(a.dt_saida) >= dt_fromDate_p AND a.ds_aplicacao = 'TasySwing' AND (a.dt_saida IS NOT NULL AND a.dt_saida::text <> '') GROUP BY dt_saida),
             acessos AS (SELECT pkg_login_report.normalize_date(b.dt_acesso, 15) + (14/1440) AS dt_acesso, pkg_login_report.normalize_date(b.dt_saida, 15) AS dt_saida FROM TASY_CONTROLE_LOGIN b, logoff_count c
                          WHERE b.dt_saida = c.dt_saida AND c.logoff_count <= (licenses_p * 0.2) AND b.ds_aplicacao = 'TasySwing' AND TRUNC(b.dt_saida) >= startDate AND TRUNC(b.dt_acesso) <= endDate AND (b.dt_saida IS NOT NULL AND b.dt_saida::text <> ''))
            SELECT acessos.dt_acesso, acessos.dt_saida, COUNT(*) BULK COLLECT INTO STRICT logins FROM acessos GROUP BY acessos.dt_acesso, acessos.dt_saida ORDER BY acessos.dt_acesso ASC;
      END LOOP;
  END;

  /* Generates a report containing 15 minutes intervals from 'dt_fromDate_p' to 'dt_toDate_p' and how many users were logged in in the interval.
     In this report all records are counted regardless of the count of logoffs at the same time. */
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pkg_login_report.do_login_report (dt_fromDate_p timestamp, dt_toDate_p timestamp, licenses_p integer) FROM PUBLIC;
