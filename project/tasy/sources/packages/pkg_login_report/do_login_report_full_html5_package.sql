-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


CREATE TYPE login_row AS (dt_access timestamp, dt_logoff timestamp, counter bigint);


CREATE OR REPLACE PROCEDURE pkg_login_report.do_login_report_full_html5 (dt_fromDate_p timestamp, dt_toDate_p timestamp, qt_time_p bigint) AS $body$
DECLARE

    TYPE eligible_logins IS TABLE OF login_row;
    currentDate timestamp;
    counter integer;
    logins eligible_logins;
    startDate timestamp;
    endDate timestamp;
    daysInterval bigint;

BEGIN
    daysInterval := 15;
    currentDate := dt_fromDate_p;
    startDate := currentDate;
    endDate := startDate + daysInterval;
    IF endDate > dt_toDate_p THEN endDate := dt_toDate_p; END IF;
    EXECUTE 'TRUNCATE TABLE CONCURRENT_USERS_T';
    /* Selects the login records to be processed by the first pass. */

     WITH acessos AS (SELECT pkg_login_report.normalize_date(a.dt_acesso, 15) + (14/1440) AS dt_acesso,
							 /*pkg_login_report.normalize_date(a.dt_saida, 15) AS dt_saida*/
 
							 pkg_login_report.normalize_date(coalesce(a.dt_saida, a.dt_acesso + (qt_time_p/1440)), 15) AS dt_saida
					  FROM TASY_LOG_ACESSO a
                      WHERE a.cd_aplicacao_tasy = 'tasy_front-end' 
					  --AND TRUNC(a.dt_saida) >= startDate 
					  AND TRUNC(coalesce(a.dt_saida, a.dt_acesso + (qt_time_p/1440) )) >= startDate
					  AND TRUNC(a.dt_acesso) <= endDate 
					  AND (a.dt_saida IS NOT NULL AND a.dt_saida::text <> ''))
      SELECT acessos.dt_acesso, acessos.dt_saida, COUNT(*) BULK COLLECT INTO STRICT logins FROM acessos GROUP BY acessos.dt_acesso, acessos.dt_saida ORDER BY acessos.dt_acesso ASC;
    LOOP
      LOOP
        counter := 0;
        IF logins.COUNT > 0 THEN
         /* For each interval of 15 minutes, all records returned by previous query are iterated and dates compared to check if they fit into the interval  */

          FOR i IN logins.FIRST .. logins.LAST
          LOOP
            IF logins[i].dt_logoff >= currentDate AND logins[i].dt_access <= (currentDate + (15/1440)) THEN
              counter := counter + logins[i].counter;
            END IF;
            /* As the results are ordered by access date, if the access date of a record is after the end of the interval, all the following records won't fall
                into the interval too, so they don't need to be checked. */
            IF logins[i].dt_access > (currentDate + (15/1440)) THEN EXIT; END IF;
          END LOOP;
        END IF;
        INSERT INTO CONCURRENT_USERS_T VALUES (currentDate, counter);
        currentDate := currentDate + (15/1440); /* Adds 15 minutes */
        EXIT WHEN TRUNC(currentDate) > TRUNC(endDate);
      END LOOP;
	
      startDate := endDate;
      endDate := startDate + daysInterval;

	  IF endDate > dt_toDate_p THEN endDate := dt_toDate_p; END IF;
      EXIT WHEN startDate >= dt_toDate_p;
      logins.DELETE;

	  /* For performance reasons, the records are retrieved in a maximum interval of 15 days, to reduce the number of iteration
          in the inner loop above. So the query must be executed again, shifting the interval by 15 days until the date specified in the dt_toDate_p parameter. */
      WITH acessos AS (SELECT pkg_login_report.normalize_date(a.dt_acesso, 15) + (14/1440) AS dt_acesso, 
							  --pkg_login_report.normalize_date(a.dt_saida, 15) AS dt_saida
							  pkg_login_report.normalize_date(coalesce(a.dt_saida, a.dt_acesso + (qt_time_p/1440)), 15) AS dt_saida
					   FROM TASY_LOG_ACESSO a
                       WHERE a.cd_aplicacao_tasy = 'tasy_front-end' 
					   --AND TRUNC(a.dt_saida) >= startDate 
					   AND TRUNC(coalesce(a.dt_saida, a.dt_acesso + (qt_time_p/1440))) >= startDate
					   AND TRUNC(a.dt_acesso) <= endDate 
					   AND (a.dt_saida IS NOT NULL AND a.dt_saida::text <> ''))
        SELECT acessos.dt_acesso, acessos.dt_saida, COUNT(*) BULK COLLECT INTO STRICT logins FROM acessos GROUP BY acessos.dt_acesso, acessos.dt_saida ORDER BY acessos.dt_acesso ASC;
    END LOOP;
  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pkg_login_report.do_login_report_full_html5 (dt_fromDate_p timestamp, dt_toDate_p timestamp, qt_time_p bigint) FROM PUBLIC;
