-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION pls_tipos_ocor_pck.obter_se_processa_filtro ( dados_consistencia_p pls_tipos_ocor_pck.dados_consistencia, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_forma_geracao_ocor_p pls_tipos_ocor_pck.dados_forma_geracao_ocor, dados_filtro_p pls_tipos_ocor_pck.dados_filtro, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, qt_filtro_processado_p integer, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) RETURNS varchar AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: 	Funcao criada para verificar se a regra do filtro precisa ser processada.
	Ela verifica se a quantidade maxima dos itens que fazem podem ser selecionados
	ja existem na tabela. Os possiveis retornos sao: S -> processa, N -> nao processa e
	Z para de executar todas as regras de filtro
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta:
[X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------

Pontos de atencao:

Alteracoes:
 ------------------------------------------------------------------------------------------------------------------

 usuario OS XXXXXX 01/01/2000 -
 Alteracao:	Descricao da alteracao.
Motivo:	Descricao do motivo.
 ------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */


ie_processa_w		varchar(1);
qt_registro_valido_w	integer;
ds_select_w		varchar(8000);
valor_bind_w		sql_pck.t_dado_bind;
dados_restricao_w	pls_tipos_ocor_pck.dados_select;
dados_restricao_proc_w	pls_tipos_ocor_pck.dados_select;
dados_restricao_mat_w	pls_tipos_ocor_pck.dados_select;
cursor_w		sql_pck.t_cursor;
qt_max_reg_selecao_w	integer;


BEGIN

ie_processa_w := 'S';
-- quantidade de registros que estao validos na tabela de selecao

qt_registro_valido_w := pls_tipos_ocor_pck.obter_qt_registro_valido(nr_id_transacao_p);

-- se estiver na primeira regra ou se estiver processando uma regra de

if (qt_filtro_processado_p = 0) then
	ie_processa_w := 'S';

-- se for para processar algo que somente invalide registros e nao tem mais nada valido na tabela de selecao nem processa

-- a leitura e a seguinte: se for filtro de excecao ou regra de excecao mais nao e regra e filtro de excecao e nao tem registro valido

elsif	((dados_filtro_p.ie_excecao = 'S' or dados_regra_p.ie_excecao = 'S') and (dados_filtro_p.ie_excecao != 'S' or dados_regra_p.ie_excecao != 'S') and (qt_registro_valido_w = 0)) then
	ie_processa_w := 'N';

-- se nao existirem mais registros validos na tabela de selecao e for um filtro de excecao em uma regra boa, simplesmente nao precisa mais executar nada.

-- os filtros de excecao somente tiram registros fora, nunca colocam novos e se nao tem mais nada valido e inutil ficar processando elas.

-- so deixa ativar novos registros se for uma regra de excecao com um filtro de excecao

-- no momento de ler as regras existe um order by que coloca as regras de excecao para serem processadas por ultimo, por isso esse if abaixo resolver a situacao sem causar problemas.

-- isso aumenta a performance em cenarios onde existe uma regra normal e nove regras de excecao (cenario tipico em varios clientes)

elsif (dados_filtro_p.ie_excecao = 'S' and dados_regra_p.ie_excecao = 'N' and qt_registro_valido_w = 0) then
	ie_processa_w := 'Z';

-- so precisa verificar para filtros que nao forem de excecao em regras que nao sao de excecao, pois os de excecao podem tirar registros

elsif (dados_filtro_p.ie_excecao = 'N' and dados_regra_p.ie_excecao = 'N') then

	valor_bind_w := pls_tipos_ocor_pck.obter_select_filtro(	true, nr_id_transacao_p, dados_consistencia_p, dados_regra_p, dados_forma_geracao_ocor_p, dados_filtro_p, dados_restricao_w, dados_restricao_proc_w, dados_restricao_mat_w, cd_estabelecimento_p, valor_bind_w);

	ds_select_w := 'select count(1) from ( ' || ds_select_w || ')';

	-- executa o comando sql com os respectivos binds

	valor_bind_w := sql_pck.executa_sql_cursor(	ds_select_w, valor_bind_w);
	-- retorna a quantidade maxima possivel de registros para a tabela de selecao

	fetch cursor_w into qt_max_reg_selecao_w;
	close cursor_w;

	-- se conseguiu trazer registros

	if ((qt_max_reg_selecao_w IS NOT NULL AND qt_max_reg_selecao_w::text <> '') and qt_max_reg_selecao_w > 0) then
		-- se a quantidade de registros validos for igual a quantidade maxima de registros possiveis na tabela de selecao

		if (qt_max_reg_selecao_w = qt_registro_valido_w) then
			ie_processa_w := 'N';
		end if;
	else
		ie_processa_w := 'S';
	end if;
end if;

return ie_processa_w;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pls_tipos_ocor_pck.obter_se_processa_filtro ( dados_consistencia_p pls_tipos_ocor_pck.dados_consistencia, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_forma_geracao_ocor_p pls_tipos_ocor_pck.dados_forma_geracao_ocor, dados_filtro_p pls_tipos_ocor_pck.dados_filtro, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, qt_filtro_processado_p integer, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
