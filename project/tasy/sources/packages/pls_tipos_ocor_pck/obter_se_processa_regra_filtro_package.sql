-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION pls_tipos_ocor_pck.obter_se_processa_regra_filtro ( dados_consistencia_p pls_tipos_ocor_pck.dados_consistencia, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_forma_geracao_ocor_p pls_tipos_ocor_pck.dados_forma_geracao_ocor, ie_incidencia_regra_p text, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, dados_filtro_p pls_tipos_ocor_pck.dados_filtro, qt_registro_valido_p integer, qt_filtro_processado_p integer, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) RETURNS varchar AS $body$
DECLARE


/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade: Funcao criada para verificar se a regra do filtro precisa ser processada. Ela verifica se a quantidade maxima dos itens que fazem podem ser selecionados ja existem na tabela
de selecao como registros validos
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta:
[X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
 ------------------------------------------------------------------------------------------------------------------

Pontos de atencao:
Cuidar com os ALIAS... Dar nome padronizado, para facilitar identificacao e nao repetir..

Alteracoes:
------------------------------------------------------------------------------------------------------------------


------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */

-- S -> processa, N -> nao processa e Z para de executar todas as regras de filtro

ie_processa_w		varchar(1);
var_cur_w 		integer;
var_exec_w		integer;
var_retorno_w		integer;

qt_reg_selecao_w	integer;
ds_select_w		varchar(3500);
ds_select_final_w	varchar(4000);
dados_restricao_w	pls_tipos_ocor_pck.dados_restricao_select;


BEGIN

ie_processa_w := 'S';

-- se nao existirem mais registros validos na tabela de selecao e for uma regra de excecao, simplesmente nao precisa mais executar nada.

-- as regras de excecao somente tiram registros fora, nunca colocam novos e se nao tem mais nada valido e inutil ficar processando elas.

-- no momento de ler as regras existe um order by que coloca as regras de excecao para serem processadas por ultimo, por isso esse if abaixo resolver a situacao sem causar problemas.

-- isso aumenta a performance em cenarios onde existe uma regra normal e nove regras de excecao (cenario tipico em varios clientes)

if (dados_filtro_p.ie_excecao = 'S' and qt_registro_valido_p = 0) then
	ie_processa_w := 'Z';

-- se estiver na primeira regra processa sempre

elsif (qt_filtro_processado_p = 0) then
	ie_processa_w := 'S';

-- so precisa verificar para regras que nao forem de excecao, pois as de excecao podem tirar registros

elsif (dados_filtro_p.ie_excecao = 'N') then

	-- Obter o select padrao conforme a incidencia da regra.	

	dados_restricao_w := pls_oc_cta_obter_restr_padrao(
					'RESTRICAO', dados_consistencia_p, nr_id_transacao_p, dados_regra_p,
					ie_incidencia_regra_p, null, null, dados_forma_geracao_ocor_p,
					cd_estabelecimento_p, nm_usuario_p, 'N', 'S', 0);

	-- Montar o select padrao juntamente as restricoes.

	ds_select_w := pls_tipos_ocor_pck.montar_select_padrao(	dados_regra_p, null, ie_incidencia_regra_p,
								dados_restricao_w, nm_usuario_p);

	ds_select_final_w := 'select count(1) from ( ' || ds_select_w || ')';

	-- Selecionar todas as contas ou itens, conforme incidencia

	var_cur_w := dbms_sql.open_cursor;
	begin

		dbms_sql.parse(var_cur_w, ds_select_final_w, 1);

		-- Atualizar o valor das binds dos selects padrao.

		dados_restricao_w := pls_oc_cta_obter_restr_padrao(
					'BINDS', dados_consistencia_p, nr_id_transacao_p, dados_regra_p, ie_incidencia_regra_p,
					var_cur_w, null, dados_forma_geracao_ocor_p, cd_estabelecimento_p, nm_usuario_p, 'N', 'S', 0);

		dbms_sql.define_column(var_cur_w, 1, qt_reg_selecao_w);

		-- Executar o select e gravar os dados na tabela de selecao

		var_exec_w := dbms_sql.execute(var_cur_w);
		loop
		var_retorno_w := dbms_sql.fetch_rows(var_cur_w);
		exit when var_retorno_w = 0;

			-- Obter o valor

			dbms_sql.column_value(var_cur_w, 1, qt_reg_selecao_w);
		end loop;
		dbms_sql.close_cursor(var_cur_w);

		-- se conseguiu trazer registros

		if ((qt_reg_selecao_w IS NOT NULL AND qt_reg_selecao_w::text <> '') and qt_reg_selecao_w > 0) then
			-- se a quantidade de registros validos for igual a quantidade maxima de registros possiveis na tabela de selecao

			if (qt_reg_selecao_w = qt_registro_valido_p) then
				ie_processa_w := 'N';
			end if;
		else
			ie_processa_w := 'S';
		end if;


	exception
	when others then
		-- Fechar o cursor que foi aberto.

		if (dbms_sql.is_open(var_cur_w)) then
			dbms_sql.close_cursor(var_cur_w);
		end if;
		-- Exibir a mensagem padrao para as ocorrencias combinadas quando temos algum problema e salvar o log no banco.

		CALL pls_tipos_ocor_pck.trata_erro_sql_dinamico(dados_regra_p, ds_select_final_w, nr_id_transacao_p, nm_usuario_p);
	end;
end if;

return ie_processa_w;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pls_tipos_ocor_pck.obter_se_processa_regra_filtro ( dados_consistencia_p pls_tipos_ocor_pck.dados_consistencia, dados_regra_p pls_tipos_ocor_pck.dados_regra, dados_forma_geracao_ocor_p pls_tipos_ocor_pck.dados_forma_geracao_ocor, ie_incidencia_regra_p text, nr_id_transacao_p pls_selecao_ocor_cta.nr_id_transacao%type, dados_filtro_p pls_tipos_ocor_pck.dados_filtro, qt_registro_valido_p integer, qt_filtro_processado_p integer, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
