-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_conv_xml_cta_pck.gerencia_sel_regra_campo_esp () AS $body$
DECLARE


tb_nr_seq_regra_w	pls_util_cta_pck.t_number_table;
nr_contador_w		integer;
qt_itens_protocolo_w	integer;
qt_regras_w		integer;

C01 CURSOR FOR
	SELECT 	a.nr_sequencia nr_seq_regra,
		a.cd_area_procedimento,
		a.cd_especialidade,
		a.cd_grupo_proc,
		a.cd_procedimento,
		a.ie_tipo_guia,
		a.nr_seq_prestador_exec,
		a.cd_prestador_exec,
		a.nr_seq_prestador_prot,
		a.cd_prestador_prot,
		(SELECT count(1)
		from   	pls_conta_item_imp_tmp b,
			estrutura_procedimento_v c
		where  	c.cd_procedimento = b.cd_procedimento_conv
		and	c.cd_area_procedimento = a.cd_area_procedimento
		and	b.ie_tipo_item_conv = 'P') qt_area_proced,
		(select count(1)
		from   	pls_conta_item_imp_tmp b,
			estrutura_procedimento_v c
		where  	c.cd_procedimento = b.cd_procedimento_conv
		and	c.cd_especialidade = a.cd_especialidade
		and	b.ie_tipo_item_conv = 'P') qt_espec_proced,
		(select count(1)
		from   	pls_conta_item_imp_tmp b,
			estrutura_procedimento_v c
		where  	c.cd_procedimento = b.cd_procedimento_conv
		and	c.cd_grupo_proc = a.cd_grupo_proc
		and	b.ie_tipo_item_conv = 'P') qt_grupo_proced,
		(select count(1)
		from   	pls_conta_item_imp_tmp b
		where  	b.cd_procedimento_conv = a.cd_procedimento
		and	b.ie_tipo_item_conv = 'P') qt_procedimento,
		(select	count(1)
		from	pls_conta_item_imp_tmp b
		where	b.ie_tipo_guia = a.ie_tipo_guia) qt_tipo_guia,
		(select	count(1)
		from	pls_conta_item_imp_tmp b
		where	b.nr_seq_prest_exec_conv = a.nr_seq_prestador_exec) qt_seq_prest_exec,
		(select	count(1)
		from	pls_conta_item_imp_tmp b
		where	b.cd_prest_exec_conv = a.cd_prestador_exec) qt_cd_prest_exec,
		(select	count(1)
		from	pls_conta_item_imp_tmp b
		where	b.nr_seq_prest_prot_conv = a.nr_seq_prestador_prot) qt_seq_prest_prot,
		(select	count(1)
		from	pls_conta_item_imp_tmp b
		where	b.cd_prest_prot_conv = a.cd_prestador_prot) qt_cd_prest_prot
	from   	pls_xml_regra_campo_esp a
	where  	a.ie_situacao = 'A';

C02 CURSOR FOR
	SELECT 	nr_sequencia
	from 	pls_xml_regra_campo_esp
	where 	ie_situacao = 'A';

BEGIN
-- limpa os dados da tabela tempor_ria das regras

EXECUTE 'truncate table pls_regra_campo_espec_tmp';

nr_contador_w := 0;
tb_nr_seq_regra_w.delete;
qt_itens_protocolo_w := 0;
qt_regras_w := 0;

-- verifica quantos itens precisam ser processados

select 	count(1)
into STRICT	qt_itens_protocolo_w
from	pls_conta_item_imp_tmp;

-- verifica quantas regras h_ para processar os itens

select 	count(1)
into STRICT	qt_regras_w
from 	pls_xml_regra_campo_esp
where	ie_situacao = 'A';

-- caso exista mais itens que regras processamos todas as regras

if (qt_itens_protocolo_w > qt_regras_w) then

	open C02;
	loop
		fetch C02 bulk collect into tb_nr_seq_regra_w
		limit pls_util_pck.qt_registro_transacao_w;
		exit when tb_nr_seq_regra_w.count = 0;

		tb_nr_seq_regra_w := pls_conv_xml_cta_pck.alimenta_regra_campo_espec(tb_nr_seq_regra_w);
	end loop;
	close C02;
else
-- se tem menos itens que regras _ feita uma pr_ selecao das regras que ser_o processadas

-- verifica pela quantidade de itens com a informacao que est_ na regra para decidir se

-- _ uma regra v_lida ou n_o, se encontrar 1 item que tenha informado o campo que est_ 

-- na regra ent_o _ uma regra que precisa ser processada

	for r_c01_w in C01 loop
	
		if (r_c01_w.qt_area_proced > 0) or (r_c01_w.qt_espec_proced > 0) or (r_c01_w.qt_grupo_proced > 0) or (r_c01_w.qt_procedimento > 0) or (r_c01_w.qt_tipo_guia > 0) or (r_c01_w.qt_seq_prest_exec > 0) or (r_c01_w.qt_cd_prest_exec > 0) or (r_c01_w.qt_seq_prest_prot > 0) or (r_c01_w.qt_cd_prest_prot > 0) then
			
			tb_nr_seq_regra_w(nr_contador_w) := r_c01_w.nr_seq_regra;
			
			-- se atingiu a quantidade manda para o banco

			if (nr_contador_w >= pls_util_pck.qt_registro_transacao_w) then
			
				tb_nr_seq_regra_w := pls_conv_xml_cta_pck.alimenta_regra_campo_espec(tb_nr_seq_regra_w);
				nr_contador_w := 0;
			else
				nr_contador_w := nr_contador_w + 1;
			end if;
		-- incluido este else caso todos os campos sejam nulos (regra em branco) a regra _ v_lida

		elsif (coalesce(r_c01_w.cd_area_procedimento::text, '') = '') and (coalesce(r_c01_w.cd_especialidade::text, '') = '') and (coalesce(r_c01_w.cd_grupo_proc::text, '') = '') and (coalesce(r_c01_w.cd_procedimento::text, '') = '') and (coalesce(r_c01_w.ie_tipo_guia::text, '') = '') and (coalesce(r_c01_w.nr_seq_prestador_exec::text, '') = '') and (coalesce(r_c01_w.cd_prestador_exec::text, '') = '') and (coalesce(r_c01_w.nr_seq_prestador_prot::text, '') = '') and (coalesce(r_c01_w.cd_prestador_prot::text, '') = '') then						
			
			tb_nr_seq_regra_w(nr_contador_w) := r_c01_w.nr_seq_regra;
			
			-- se atingiu a quantidade manda para o banco

			if (nr_contador_w >= pls_util_pck.qt_registro_transacao_w) then
				
				tb_nr_seq_regra_w := pls_conv_xml_cta_pck.alimenta_regra_campo_espec(tb_nr_seq_regra_w);
				nr_contador_w := 0;
			else
				nr_contador_w := nr_contador_w + 1;
			end if;
		end if;
	end loop;
	-- se possui algum registro manda pra tabela tempor_ria para ser processada

	tb_nr_seq_regra_w := pls_conv_xml_cta_pck.alimenta_regra_campo_espec(tb_nr_seq_regra_w);	
end if;
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_conv_xml_cta_pck.gerencia_sel_regra_campo_esp () FROM PUBLIC;
