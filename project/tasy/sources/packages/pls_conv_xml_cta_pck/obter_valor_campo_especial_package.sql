-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION pls_conv_xml_cta_pck.obter_valor_campo_especial ( qt_caracteres_p pls_xml_regra_esp_compl.qt_caracteres%type, ds_anterior_p pls_xml_regra_esp_compl.ds_anterior%type, ds_posterior_p pls_xml_regra_esp_compl.ds_posterior%type, ds_procedimento_p INOUT pls_conta_item_imp_tmp.ds_procedimento%type) AS $body$
DECLARE


qt_carac_antes_w	integer;
qt_carac_depois_w	integer;
ds_procedimento_w	pls_conta_item_imp_tmp.ds_procedimento%type;
ds_aux_proced_w		varchar(200);


BEGIN

ds_procedimento_w := ds_procedimento_p;

-- pega a posicao que est_ o ds_anterior + 1 para n_o incluir o mesmo

qt_carac_antes_w := position(ds_anterior_p in ds_procedimento_w) + 1;
-- pega a posicao que est_ o ds_posterior come_ando da posicao anterior

qt_carac_depois_w := instr(ds_procedimento_w, ds_posterior_p, qt_carac_antes_w);

qt_carac_depois_w := (qt_carac_depois_w - qt_carac_antes_w);

-- existem quatro formas v_lidas de cadastro da regra do campo

-- 1 - com os campos conte_do anterior, posterior e quantidade de caracteres: ir_ pegar tudo que

-- existir entre os campos e verificar se a quantidade de caracteres bate com a informada na regra

if (ds_anterior_p IS NOT NULL AND ds_anterior_p::text <> '') and (ds_posterior_p IS NOT NULL AND ds_posterior_p::text <> '') and (qt_caracteres_p IS NOT NULL AND qt_caracteres_p::text <> '') then
		
	if (qt_caracteres_p = qt_carac_depois_w) then
	
		-- pega do caracter ap_s o anterior at_ um antes do posterior

		ds_aux_proced_w := substr(ds_procedimento_w, qt_carac_antes_w, qt_carac_depois_w);
		
		-- retira a string que foi identificada da variavel para que na pr_xima regra n_o

		-- corra o risco de entrar novamente (caso as regras tenham sido cadastradas com o mesmo)

		-- ds_anterior para ambas

		ds_procedimento_w := substr(ds_procedimento_w, qt_carac_antes_w + qt_carac_depois_w, length(ds_procedimento_w));
	end if;
	
-- 2 - com os campos conte_do anterior e posterior informados: tudo que estiver antre os campos sem

-- validacao da quantidade de caracteres

elsif (ds_anterior_p IS NOT NULL AND ds_anterior_p::text <> '') and (ds_posterior_p IS NOT NULL AND ds_posterior_p::text <> '') and (coalesce(qt_caracteres_p::text, '') = '') then
	
	-- pega do caracter ap_s o anterior at_ um antes do posterior

	ds_aux_proced_w := substr(ds_procedimento_w, qt_carac_antes_w, qt_carac_depois_w);
	
	-- retira a string que foi identificada da variavel para que na pr_xima regra n_o

	-- corra o risco de entrar novamente (caso as regras tenham sido cadastradas com o mesmo)

	-- ds_anterior para ambas

	ds_procedimento_w := substr(ds_procedimento_w,  qt_carac_antes_w + qt_carac_depois_w, length(ds_procedimento_w));
	
-- 3 - com os campos conte_do anterior e qt caracteres: tudo que estiver ap_s do campo anterior 

-- desde que tenha a quantidade de caracteres informadas na regra

elsif (ds_anterior_p IS NOT NULL AND ds_anterior_p::text <> '') and (coalesce(ds_posterior_p::text, '') = '') and (qt_caracteres_p IS NOT NULL AND qt_caracteres_p::text <> '') then
	
	-- verifica a quantidade de caracteres que h_ no fim da string (-1 para desconsiderar o caracter anterior)

	qt_carac_depois_w := length(ds_procedimento_w) - 1;
	
	-- se a quantidade for igual a da regra ent_o _ v_lida

	if (qt_caracteres_p = qt_carac_depois_w) then
	
		-- pega do caracter anterior (+1) at_ o limite do campo

		ds_aux_proced_w := substr(ds_procedimento_w, qt_carac_antes_w, length(ds_procedimento_w));
		
		-- caso tenha entrado nesta regra significa que _ o fim da string ent_o _ limpa a vari_vel

		-- ds procedimento para evitar que tenha outra regra cadastrada que entre indevidamente

		ds_procedimento_w := null;
	end if;
-- 4 - com apenas o campo conte_do anterior: pega tudo que tiver depois do campo anterior

-- sem v_lidar a quantidade de caracteres

elsif (ds_anterior_p IS NOT NULL AND ds_anterior_p::text <> '') and (coalesce(ds_posterior_p::text, '') = '') and (coalesce(qt_caracteres_p::text, '') = '') then
	
	-- pega do caracter anterior (+1) at_ o limite do campo

	ds_aux_proced_w := substr(ds_procedimento_w, qt_carac_antes_w, length(ds_procedimento_w));
	
	-- caso tenha entrado nesta regra significa que _ o fim da string ent_o _ limpa a vari_vel

	-- ds procedimento para evitar que tenha outra regra cadastrada que entre indevidamente

	ds_procedimento_w := null;
end if;

ds_procedimento_p := ds_procedimento_w;

return;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pls_conv_xml_cta_pck.obter_valor_campo_especial ( qt_caracteres_p pls_xml_regra_esp_compl.qt_caracteres%type, ds_anterior_p pls_xml_regra_esp_compl.ds_anterior%type, ds_posterior_p pls_xml_regra_esp_compl.ds_posterior%type, ds_procedimento_p INOUT pls_conta_item_imp_tmp.ds_procedimento%type) FROM PUBLIC;
