-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


--
-- dblink wrapper to call function security_level_pck.save_invalid() as an autonomous transaction
--
CREATE EXTENSION IF NOT EXISTS dblink;

CREATE OR REPLACE PROCEDURE security_level_pck.save_invalid () AS $body$
DECLARE
	-- Change this to reflect the dblink connection string
	v_conn_str  text := format('port=%s dbname=%s user=%s', current_setting('port'), current_database(), current_user);
	v_query     text;

BEGIN
	v_query := 'CALL security_level_pck.save_invalid_atx ()';
	PERFORM * FROM dblink(v_conn_str, v_query) AS p (ret boolean);

END;
$body$ LANGUAGE plpgsql SECURITY DEFINER;




CREATE OR REPLACE PROCEDURE security_level_pck.save_invalid_atx () AS $body$
BEGIN
            FOR i IN 1..rules_invalid_changed.Count LOOP
                RAISE NOTICE 'Update rule: % with value: %', rules_invalid_changed[i].nr_sequence_col, rules_invalid_changed[i].ie_new_value;
                UPDATE security_level_rule
                    SET     ie_last_value  = rules_invalid_changed[i].ie_new_value,
                            dt_last_update = clock_timestamp()
                    WHERE   nr_sequencia    = rules_invalid_changed[i].nr_sequence_col;
            END LOOP;

        END;

    BEGIN
        listInvalidRules := '';
        -- Verify last date where validation was acepted
        SELECT MAX(dt_last_update) INTO STRICT agree_last_date_user
            FROM user_security_level
            WHERE nm_usuario_reading = nm_usuario_p AND ie_last_action = 'A';
        RAISE NOTICE 'Last date where validation was acepted: %', agree_last_date_user;
        -- Verify last date where validation was closed
        SELECT MAX(dt_last_update) INTO STRICT close_last_date_user
            FROM user_security_level
            WHERE nm_usuario_reading = nm_usuario_p AND ie_last_action = 'C';
        RAISE NOTICE 'Last date where validation was closed: %', close_last_date_user;

        -- Verify days from last option saved as agree after get number of days trunc the value
        SELECT clock_timestamp() - agree_last_date_user INTO STRICT num_days;
        num_days := TRUNC(num_days, 0);
        RAISE NOTICE 'Number of days from last validation acepted: %', num_days;

        -- If last date closed does not exist or it is greater than last agree date calculate the max_num_days if not return 0
        IF coalesce(close_last_date_user::text, '') = '' OR TRUNC(close_last_date_user) <= TRUNC(agree_last_date_user) THEN
            -- Verify number of days to revalidate rules
            select MAX(QT_DAYS_VALIDATION) INTO STRICT max_num_days FROM PRIVACIDADE_PARAMETROS;
            RAISE NOTICE 'Max number of days to revalidate the rules: %', max_num_days;

            -- Verify if value is null or 0, in that case set to 90 days
            IF coalesce(max_num_days::text, '') = '' OR max_num_days = 0 THEN
                max_num_days := 90;
            END IF;
        ELSE
            -- This means that rules must be validated again
            max_num_days := 0;
        END IF;

        -- Look in the cursor with the enabled rules the query to execute and verify if it is valid or not
        FOR security_rules IN security_rules_cur LOOP
            -- Casting original SQL to include variables before execute it
            sql_stmt := security_rules.ds_sql;
            RAISE NOTICE 'Original SQL: %', sql_stmt;
            sql_stmt:=REPLACE(sql_stmt, ':IE_PLATAFORMA', '''' || ie_plataforma_p || '''');
            sql_stmt:=REPLACE(sql_stmt, ':NM_USUARIO', '''' || nm_usuario_p || '''');
            sql_stmt:=REPLACE(sql_stmt, ':CD_ESTABELECIMENTO', cd_establecimiento_p);
            RAISE NOTICE 'SQL to execute: %', sql_stmt;
            -- Executing query stored in the database
            EXECUTE sql_stmt INTO STRICT l_count;
            -- Validate if result is greatter than 0, so the rule is invalid
            IF l_count = 0 THEN
                -- If l_count is 0 the rule is invalid so need to verify if it is shown to user
                IF (LENGTH(listInvalidRules) IS NOT NULL AND (LENGTH(listInvalidRules))::text <> '') THEN
                    listInvalidRules := listInvalidRules || ',';
                END IF;
                listInvalidRules := listInvalidRules || security_rules.nr_sequencia;
                RAISE NOTICE 'Rule is invalid';
            END IF;
            -- Validate if the value changed to update it in the database
            IF coalesce(security_rules.ie_last_value::text, '') = '' OR security_rules.ie_last_value != l_count THEN
                CALL security_level_pck.add_invalid_changed(security_rules.nr_sequencia, l_count);
                RAISE NOTICE 'Rule changed value';
            END IF;
        END LOOP;

        -- Updating invalid rules with new values
        CALL security_level_pck.save_invalid();

        -- Return only if exists invalid rules modified or is a new user or expire the time to revalid the list
        IF rules_invalid_changed.Count > 0 OR coalesce(agree_last_date_user::text, '') = '' OR ((num_days IS NOT NULL AND num_days::text <> '') AND num_days > max_num_days) THEN
            RETURN;
        ELSE
            RETURN;
        END IF;
    END;

    /*
     * Procedure to update the answer of user about the security level screen
     */
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE security_level_pck.save_invalid () FROM PUBLIC; -- REVOKE ALL ON PROCEDURE security_level_pck.save_invalid_atx () FROM PUBLIC;
