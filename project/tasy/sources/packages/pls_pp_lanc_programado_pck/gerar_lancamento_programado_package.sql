-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_pp_lanc_programado_pck.gerar_lancamento_programado ( nr_seq_lote_p pls_pp_lote.nr_sequencia%type, ie_natureza_p pls_evento.ie_natureza%type, ie_tipo_valor_p text, ie_gerar_apos_trib_p pls_pp_lanc_programado.ie_gerar_apos_tributacao%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) AS $body$
DECLARE


_ora2pg_r RECORD;
-- ie_tipo_valor_p -> 	FIXO - Somente serão processadas regras de valores fixos
-- 		REGRA - Somente serão processadas regras que são baseadas em percentual de algum valor
ie_regra_valida_w		varchar(1);
vl_regra_w			pls_pp_lanc_programado.vl_regra%type;

ds_restricao_regra_w 		varchar(6000);
ds_campo_extra_w		varchar(4000);
ds_select_w			varchar(32000);
valor_bind_w			sql_pck.t_dado_bind;
cursor_w			sql_pck.t_cursor;

ds_campo_prestador_w		varchar(100);
nr_seq_prestador_w		pls_pp_prestador_tmp.nr_seq_prestador_pgto%type;
nr_seq_prest_origem_w		pls_pp_prestador_tmp.nr_seq_prestador%type;
ie_pode_lancar_evento_w		varchar(1);
ds_alias_tmp_w			varchar(60);
BEGIN
-- carrega os parâmetros necessários para rodar a função
CALL pls_pp_lote_pagamento_pck.carrega_parametros(nr_seq_lote_p, cd_estabelecimento_p);

ds_alias_tmp_w := pls_pp_lanc_programado_pck.obter_alias_tabela('pretmp');

-- abre o cursor com as regras de lançamento programada
for r_c_regra_w in current_setting('pls_pp_lanc_programado_pck.c_regra')::CURSOR((ie_natureza_p, ie_tipo_valor_p, ie_gerar_apos_trib_p) loop

	ie_regra_valida_w := 'N';
	-- se a data de início estiver entre o período do lote é válida
	if (r_c_regra_w.dt_inicio_vigencia_ref between pls_pp_lote_pagamento_pck.dt_referencia_lote_ini_w
							and pls_pp_lote_pagamento_pck.dt_referencia_lote_fim_w)  then
		ie_regra_valida_w := 'S';

	-- se a data de fim estiver entre o período do lote é válida
	elsif (r_c_regra_w.dt_fim_vigencia_ref between pls_pp_lote_pagamento_pck.dt_referencia_lote_ini_w
						     and pls_pp_lote_pagamento_pck.dt_referencia_lote_fim_w) then
		ie_regra_valida_w := 'S';

	-- se a data inicio for menor que a data inicial do lote e a data fim for maior que a data de fim do lote
	elsif (r_c_regra_w.dt_inicio_vigencia_ref <= pls_pp_lote_pagamento_pck.dt_referencia_lote_ini_w) and (r_c_regra_w.dt_fim_vigencia_ref >= pls_pp_lote_pagamento_pck.dt_referencia_lote_fim_w) then
		ie_regra_valida_w := 'S';
	end if;

	-- se a vigência da regra for válida para o lote
	if (ie_regra_valida_w = 'S') then

		-- inicia a variável com null
		ds_select_w := null;
		ds_campo_extra_w := null;
		ds_restricao_regra_w := null;

		-- se for para lançar a ocorrência para o prestador matriz ou o próprio prestador
		if (r_c_regra_w.ie_prestador_matriz = 'S') then
			ds_campo_prestador_w := 'nr_seq_prestador_matriz';
		else
			ds_campo_prestador_w := 'nr_seq_prestador_pgto';
		end if;

		-- obtém as restrições da regra do prestador e também valida algumas exceções
		SELECT * FROM pls_pp_lanc_programado_pck.obter_restr_lanc_prest(	nr_seq_lote_p, r_c_regra_w.nr_seq_regra, r_c_regra_w.ie_forma_incidencia, r_c_regra_w.nr_seq_evento, r_c_regra_w.nr_seq_prestador, r_c_regra_w.cd_prestador_cod, ds_campo_prestador_w, r_c_regra_w.ie_cooperado, r_c_regra_w.nr_seq_sit_coop, r_c_regra_w.nr_seq_tipo_prestador, r_c_regra_w.ie_situacao_prest, r_c_regra_w.nr_seq_periodo_regra, valor_bind_w, ds_campo_extra_w) INTO STRICT _ora2pg_r;
 valor_bind_w := _ora2pg_r.valor_bind_p; ds_campo_extra_w := _ora2pg_r.ds_campo_extra_p;

		ds_select_w := 	'	select	DISTINCT ' || ds_alias_tmp_w || '.' || ds_campo_prestador_w || ',' || pls_util_pck.enter_w ||
						ds_alias_tmp_w || '.nr_seq_prestador' || pls_util_pck.enter_w ||
						ds_campo_extra_w || pls_util_pck.enter_w ||
				'	from	pls_pp_prestador_tmp ' || ds_alias_tmp_w || pls_util_pck.enter_w ||
				'	where	1 = 1 ' || pls_util_pck.enter_w ||
				ds_restricao_regra_w;

		-- executa o comando sql com os respectivos binds
		valor_bind_w := sql_pck.executa_sql_cursor(ds_select_w, valor_bind_w);

		loop
			fetch cursor_w into nr_seq_prestador_w, nr_seq_prest_origem_w, ie_pode_lancar_evento_w;
			EXIT WHEN NOT FOUND; /* apply on cursor_w */

			-- se pode lançar este evento para o prestador
			if (ie_pode_lancar_evento_w = 'S') then

				-- regra de valor por regra
				if (r_c_regra_w.ie_forma_valor = 'R') then
					-- abre as regras de valor
					for r_c_det_regra_w in current_setting('pls_pp_lanc_programado_pck.c_det_regra')::CURSOR((	r_c_regra_w.nr_seq_regra, nr_seq_lote_p,
										nr_seq_prestador_w, r_c_regra_w.nr_seq_evento) loop

						-- passa os dados para a rotina que gerencia os lançamentos para cada regra
						CALL pls_pp_lanc_programado_pck.gerencia_lanc_valor_regra(	nr_seq_lote_p, nr_seq_prestador_w,
										nr_seq_prest_origem_w, r_c_regra_w,
										r_c_det_regra_w, nm_usuario_p);
					end loop;

				-- regra de valor informado
				elsif (r_c_regra_w.ie_forma_valor = 'I') then

					-- verifica se trata-se de evento de desconto, caso seja é necessário converter o valor para negativo
					if (r_c_regra_w.ie_natureza = 'D') then

						vl_regra_w := pls_util_pck.obter_valor_negativo(r_c_regra_w.vl_regra);
					else
						vl_regra_w := r_c_regra_w.vl_regra;
					end if;

					-- rotina que faz o tratamento para lançar um valor fixo
					CALL pls_pp_lanc_programado_pck.lanca_vl_fixo(	nr_seq_lote_p, nr_seq_prestador_w,
							nr_seq_prest_origem_w, r_c_regra_w.nr_seq_evento,
							pls_pp_lote_pagamento_pck.dt_referencia_lote_ini_w, r_c_regra_w.nr_seq_regra,
							vl_regra_w, nm_usuario_p, r_c_regra_w.cd_centro_custo);
				end if;

			end if;
		end loop;
		close cursor_w;
	end if;
end loop;

-- OS 1381189 - jtonon - 25/05/2017
-- Nesta ocasião o módulo 'OPS - Pagamentos de Produção Médica (Nova)' encontra-se em fase de homologação na Unimed Blmenau. onde os mesmos solicitaram, que o sistema não lance, eventos de lançamentos programados zerados
-- Esta situação ocorre por exemplo, em lançamentos programados, onde é definido um % sobre um determinado evento, ou sobre um tipo de evento, e ocorra de não existir estes eventos, ou tipo de evento no lote
-- Assim, neste ponto da rotina, após gerar os lançamentos, e formar seus valores, deletamos os 'pls_pp_item_lote' e seus registros 'filhos' para que o mesmo não seja lançado no lote
CALL pls_pp_lanc_programado_pck.remover_lancamentos_zerados(nr_seq_lote_p);

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_pp_lanc_programado_pck.gerar_lancamento_programado ( nr_seq_lote_p pls_pp_lote.nr_sequencia%type, ie_natureza_p pls_evento.ie_natureza%type, ie_tipo_valor_p text, ie_gerar_apos_trib_p pls_pp_lanc_programado.ie_gerar_apos_tributacao%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type) FROM PUBLIC;
