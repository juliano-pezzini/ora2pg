-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

	
	/*				*
	*	APPOINTMENT FACTS		*
	*				*/

	
CREATE TYPE appoint_data AS (	nr_seq_app_detail	bigint,
					nr_min_duration		hdm_indic_ft_appoint.nr_min_duration%type,
					qt_absence		hdm_indic_ft_appoint.qt_absence%type,
					dt_reference		timestamp,
					cd_pessoa_fisica	pessoa_fisica.cd_pessoa_fisica%type,
					ie_sexo			pessoa_fisica.ie_sexo%type,
					nr_seq_participante	mprev_participante.nr_sequencia%type,
					dt_nascimento		pessoa_fisica.dt_nascimento%type,
					nr_seq_patient_group	bigint,
					nr_seq_agendamento		bigint);


CREATE OR REPLACE PROCEDURE hdm_indic_pck.populate_ft_appointment () AS $body$
DECLARE

	i			bigint	:= 1;
	j			bigint	:= 1;
	k			bigint	:= 1;
	nr_seq_patient_group_w	bigint	:= null;
	
	vector_person_w			vector_person;
	type vector_appoint_data is table of appoint_data index by integer;
	
	vector_appoint_data_w		vector_appoint_data;
	
	c_persons CURSOR(dt_start_pc timestamp, dt_end_pc timestamp) FOR
				
		SELECT	/*+ USE_CONCAT */
				distinct
				/*+ USE_CONCAT  */

				pf.cd_pessoa_fisica,
				pf.ie_sexo,
				pt.nr_sequencia nr_seq_participante,
				pf.dt_nascimento
		from	mprev_participante pt,
				pessoa_fisica pf,
				mprev_agendamento ap
		where	ap.dt_agenda between dt_start_pc and dt_end_pc
		and		ap.nr_seq_participante = pt.nr_sequencia 
		and		pf.cd_pessoa_fisica = pt.cd_pessoa_fisica
		
union

		SELECT 	/*+ USE_CONCAT */
				distinct
				/*+ USE_CONCAT */

				pf.cd_pessoa_fisica,
				pf.ie_sexo,
				pt.nr_sequencia nr_seq_participante,
				pf.dt_nascimento
		from  	mprev_grupo_turma_partic tur_par,		
				mprev_agendamento ap,	
				mprev_participante pt,
				pessoa_fisica pf		        
		where	ap.dt_agenda between dt_start_pc and dt_end_pc
		and		tur_par.nr_seq_turma = ap.nr_seq_turma
		and    	pt.cd_Pessoa_fisica = pf.cd_pessoa_fisica
		and   	pt.nr_sequencia = tur_par.nr_seq_participante
		
union

		select 	/*+ USE_CONCAT */
				distinct
				/*+ USE_CONCAT */

				pf.cd_pessoa_fisica,
				pf.ie_sexo,
				sel.nr_seq_participante,
				pf.dt_nascimento
		from  	mprev_sel_partic_agenda sel,	
				mprev_agendamento ap,
				mprev_participante pt,
				pessoa_fisica pf		        
		where	ap.dt_agenda between dt_start_pc and dt_end_pc 
		and		sel.nr_seq_agendamento = ap.nr_sequencia
		and 	sel.nr_seq_participante = pt.nr_sequencia
		and 	pt.cd_pessoa_fisica = pf.cd_pessoa_fisica;
		
	c_appoint_data CURSOR(dt_start_pc timestamp, dt_end_pc timestamp, cd_pessoa_fisica_pc text) FOR
		SELECT	ap.dt_agenda dt_reference,
				coalesce(ap.nr_minuto_duracao,0) nr_min_duration,
				coalesce(ap.ie_forma_atendimento,'0') si_form,
				coalesce(ap.ie_tipo_atendimento,'0') si_type,
				coalesce((	SELECT	max(mprev_obter_dados_agenda(z.cd_agenda, 'NM'))
					from	mprev_local_atend_agenda z
					where	exists (select	1
							from	mprev_agendamento a,
									agenda b 
							where	b.cd_agenda = z.cd_agenda
							and	a.nr_Sequencia = ap.nr_sequencia
							and	a.cd_agenda = b.cd_agenda)),wheb_mensagem_pck.get_texto(383299)) nm_place,
				ap.ie_status_agenda si_status,
				coalesce(ap.nr_seq_motivo_canc,0) nr_reason_cancel,
				CASE WHEN coalesce(ap.dt_confirmacao::text, '') = '' THEN  'N'  ELSE 'S' END  si_confirmed,
				CASE WHEN ap.ie_status_agenda='C' THEN  'S'  ELSE 'N' END  si_cancelled,
				0 qt_absence,
				ap.nr_sequencia
		from	mprev_participante pt,
				mprev_agendamento ap
		where	ap.dt_agenda between dt_start_pc and dt_end_pc
		and		ap.nr_seq_participante = pt.nr_sequencia
		and		pt.cd_pessoa_fisica = cd_pessoa_fisica_pc
		
union all

		select	ap.dt_agenda dt_reference,
				coalesce(ap.nr_minuto_duracao,0) nr_min_duration,
				coalesce(ap.ie_forma_atendimento,'0') si_form,
				coalesce(ap.ie_tipo_atendimento,'0') si_type,
				coalesce((	select	max(mprev_obter_dados_agenda(z.cd_agenda, 'NM'))
					from	mprev_local_atend_agenda z
					where	exists (select	1
							from	mprev_agendamento a,
								agenda b 
							where	b.cd_agenda = z.cd_agenda
							and	a.nr_Sequencia = ap.nr_sequencia
							and	a.cd_agenda = b.cd_agenda)),wheb_mensagem_pck.get_texto(383299)) nm_place,
				ap.ie_status_agenda si_status,
				coalesce(ap.nr_seq_motivo_canc,0) nr_reason_cancel,
				CASE WHEN coalesce(ap.dt_confirmacao::text, '') = '' THEN  'N'  ELSE 'S' END  si_confirmed,
				CASE WHEN ap.ie_status_agenda='C' THEN  'S'  ELSE 'N' END  si_cancelled,
				(mprev_obter_dados_agenda_turma(tur_par.nr_sequencia, ap.nr_sequencia, 'F'))::numeric  qt_absence,
				ap.nr_sequencia
		from  	mprev_grupo_turma_partic tur_par,	
				mprev_grupo_col_turma col_tur,
				mprev_agendamento ap,
				mprev_participante pt
		where	ap.dt_agenda between dt_start_pc and dt_end_pc 
		and		tur_par.nr_seq_turma = ap.nr_seq_turma
		and 	col_tur.nr_sequencia = tur_par.nr_seq_turma
		and		tur_par.nr_seq_participante = pt.nr_sequencia
		and		pt.cd_pessoa_fisica = cd_pessoa_fisica_pc
		
union all

		select	ap.dt_agenda dt_reference,
				coalesce(ap.nr_minuto_duracao,0) nr_min_duration,
				coalesce(ap.ie_forma_atendimento,'0') si_form,
				coalesce(ap.ie_tipo_atendimento,'0') si_type,
				coalesce((	select	max(mprev_obter_dados_agenda(z.cd_agenda, 'NM'))
					from	mprev_local_atend_agenda z
					where	exists (select	1
							from	mprev_agendamento a,
								agenda b 
							where	b.cd_agenda = z.cd_agenda
							and	a.nr_Sequencia = ap.nr_sequencia
							and	a.cd_agenda = b.cd_agenda)),wheb_mensagem_pck.get_texto(383299)) nm_place,
				ap.ie_status_agenda si_status,
				coalesce(ap.nr_seq_motivo_canc,0) nr_reason_cancel,
				CASE WHEN coalesce(ap.dt_confirmacao::text, '') = '' THEN  'N'  ELSE 'S' END  si_confirmed,
				CASE WHEN ap.ie_status_agenda='C' THEN  'S'  ELSE 'N' END  si_cancelled,
				(mprev_obter_dados_agenda_turma(ap.nr_seq_turma, ap.nr_sequencia, 'F'))::numeric  qt_absence,
				ap.nr_sequencia
		from  	mprev_sel_partic_agenda sel,	
				mprev_agendamento ap,
				mprev_participante pt
		where	ap.dt_agenda between dt_start_pc and dt_end_pc
		and		ap.nr_sequencia = sel.nr_seq_agendamento
		and		sel.nr_seq_participante = pt.nr_sequencia
		and		pt.cd_pessoa_fisica = cd_pessoa_fisica_pc;
		
	
BEGIN			
		/* Generate person vector */


		i	:= 1;
		for r_c_persons in c_persons(current_setting('hdm_indic_pck.dt_start_w')::timestamp,current_setting('hdm_indic_pck.dt_end_w')::timestamp) loop
			nr_seq_patient_group_w	:= hdm_indic_pck.get_patient_group(	r_c_persons.cd_pessoa_fisica,
									r_c_persons.nr_seq_participante,
									r_c_persons.dt_nascimento,
									r_c_persons.ie_sexo);
									
			vector_person_w[i].cd_pessoa_fisica 		:= r_c_persons.cd_pessoa_fisica;
			vector_person_w[i].nr_seq_participante 		:= r_c_persons.nr_seq_participante;
			vector_person_w[i].dt_nascimento 		:= r_c_persons.dt_nascimento;
			vector_person_w[i].ie_sexo 			:= r_c_persons.ie_sexo;
			vector_person_w[i].nr_seq_patient_group 	:= nr_seq_patient_group_w;
			i	:= i + 1;
		end loop;

		/* Open person vector */


		j	:= 1;
		i := vector_person_w.count;
		for k in 1.. i loop
			for	r_c_appoint_data in c_appoint_data(	current_setting('hdm_indic_pck.dt_start_w')::timestamp,
									current_setting('hdm_indic_pck.dt_end_w')::timestamp,
									vector_person_w[k].cd_pessoa_fisica) loop
				
				vector_appoint_data_w[j].cd_pessoa_fisica 	:= vector_person_w[k].cd_pessoa_fisica;
				vector_appoint_data_w[j].nr_seq_participante 	:= vector_person_w[k].nr_seq_participante;
				vector_appoint_data_w[j].dt_nascimento 		:= vector_person_w[k].dt_nascimento;
				vector_appoint_data_w[j].ie_sexo 		:= vector_person_w[k].ie_sexo;
				vector_appoint_data_w[j].nr_seq_patient_group 	:= vector_person_w[k].nr_seq_patient_group;	

				vector_appoint_data_w[j].dt_reference		:= r_c_appoint_data.dt_reference;
				vector_appoint_data_w[j].nr_min_duration	:= r_c_appoint_data.nr_min_duration;
				vector_appoint_data_w[j].qt_absence		:= r_c_appoint_data.qt_absence;
				vector_appoint_data_w[j].nr_seq_app_detail	:= hdm_indic_pck.get_app_detail(r_c_appoint_data.si_form,
												r_c_appoint_data.si_type, 
												r_c_appoint_data.nm_place, 
												r_c_appoint_data.si_status, 
												r_c_appoint_data.nr_reason_cancel, 
												r_c_appoint_data.si_confirmed, 
												r_c_appoint_data.si_cancelled);
				vector_appoint_data_w[j].nr_seq_agendamento := r_c_appoint_data.nr_sequencia;
						
				j	:= j + 1;
			end loop;
		end loop;

		-- Open appoint data vector 

		PERFORM set_config('hdm_indic_pck.qt_record_w', 0, false);
		i := vector_appoint_data_w.count;
		
		for k in 1.. i loop
			insert into hdm_indic_ft_appoint(	nr_sequencia,
					dt_atualizacao, 
					nm_usuario, 
					dt_atualizacao_nrec, 
					nm_usuario_nrec, 
					nr_seq_app_detail, 
					nr_seq_day, 
					nr_seq_month, 
					nr_seq_patient_group, 
					nr_min_duration, 
					qt_absence, 
					nr_dif_person,
					ds_unique,
					nr_seq_agendamento)
			SELECT	nextval('hdm_indic_ft_appoint_seq'),
				clock_timestamp(),
				current_setting('hdm_indic_pck.nm_usuario_w')::usuario.nm_usuario%type,
				clock_timestamp(),
				current_setting('hdm_indic_pck.nm_usuario_w')::usuario.nm_usuario%type,
				vector_appoint_data_w[k].nr_seq_app_detail,
				(	
					SELECT	max(x.nr_sequencia)
					from	hdm_indic_dm_day x
					where	x.dt_complete_date = pkg_date_utils.start_of(vector_appoint_data_w[k].dt_reference, 'DD', 0)
				) nr_seq_day,
				(	
					select	max(x.nr_sequencia)
					from	hdm_indic_dm_month x
					where	x.dt_complete_date = pkg_date_utils.start_of(vector_appoint_data_w[k].dt_reference, 'MONTH', 0)
				) nr_seq_month,
				vector_appoint_data_w[k].nr_seq_patient_group,
				vector_appoint_data_w[k].nr_min_duration,
				vector_appoint_data_w[k].qt_absence,
				vector_appoint_data_w[k].cd_pessoa_fisica,
				current_setting('hdm_indic_pck.ds_unique_w')::varchar(255),
				vector_appoint_data_w[k].nr_seq_agendamento
			;
				
			if (current_setting('hdm_indic_pck.qt_record_w')::integer >= current_setting('hdm_indic_pck.qt_rec_commit_w')::integer) then
				commit;
				PERFORM set_config('hdm_indic_pck.qt_record_w', 0, false);
			end if;
			PERFORM set_config('hdm_indic_pck.qt_record_w', current_setting('hdm_indic_pck.qt_record_w')::integer + 1, false);
		end loop;
		
		commit;
		
		CALL hdm_indic_pck.link_campaign_with_ap_fact();
		CALL hdm_indic_pck.link_activ_group_with_ap_fact();
		CALL hdm_indic_pck.link_program_with_ap_fact();
		
		CALL hdm_indic_pck.link_professional_whit_ap_fact();
	END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE hdm_indic_pck.populate_ft_appointment () FROM PUBLIC;
