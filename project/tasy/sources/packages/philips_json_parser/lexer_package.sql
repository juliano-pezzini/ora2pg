-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

  
  /* scanner tokens:
    '{', '}', ',', ':', '[', ']', STRING, NUMBER, TRUE, FALSE, NULL
  */
CREATE OR REPLACE FUNCTION philips_json_parser.lexer (jsrc INOUT json_src) AS $body$
DECLARE

    _ora2pg_r RECORD;
tokens lTokens;
    indx integer := 1;
    tok_indx integer := 1;
    buf varchar(4);
    lin_no bigint := 1;
    col_no bigint := 0;

BEGIN
    while(indx <= jsrc.len) loop
      --read into buf
      jsrc := philips_json_parser.next_char(indx, jsrc);
      col_no := col_no + 1;
      --convert to switch case
      case
        when buf = '{' then tokens(tok_indx) := philips_json_parser.mt('{', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = '}' then tokens(tok_indx) := philips_json_parser.mt('}', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = ',' then tokens(tok_indx) := philips_json_parser.mt(',', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = ':' then tokens(tok_indx) := philips_json_parser.mt(':', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = '[' then tokens(tok_indx) := philips_json_parser.mt('[', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = ']' then tokens(tok_indx) := philips_json_parser.mt(']', lin_no, col_no, null); tok_indx := tok_indx + 1;
        when buf = 't' then
          if (jsrc := philips_json_parser.next_char2(indx, jsrc, 4) != 'true') then
            if (current_setting('philips_json_parser.json_strict')::boolean = false and REGEXP_LIKE(buf, '^[[:alpha:]]$', 'i')) then
              tokens(tok_indx) := philips_json_parser.mt('STRING', lin_no, col_no, null);
              SELECT * FROM philips_json_parser.lexname(jsrc, tokens(tok_indx), indx) INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx;
              col_no := col_no + length(tokens[tok_indx].data) + 1;
              tok_indx := tok_indx + 1;
            else
              CALL philips_json_parser.s_error('Expected: ''true''', lin_no, col_no);
            end if;
          else
            tokens(tok_indx) := philips_json_parser.mt('TRUE', lin_no, col_no, null); tok_indx := tok_indx + 1;
            indx := indx + 3;
            col_no := col_no + 3;
          end if;
        when buf = 'n' then
          if (jsrc := philips_json_parser.next_char2(indx, jsrc, 4) != 'null') then
            if (current_setting('philips_json_parser.json_strict')::boolean = false and REGEXP_LIKE(buf, '^[[:alpha:]]$', 'i')) then
              tokens(tok_indx) := philips_json_parser.mt('STRING', lin_no, col_no, null);
              SELECT * FROM philips_json_parser.lexname(jsrc, tokens(tok_indx), indx) INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx;
              col_no := col_no + length(tokens[tok_indx].data) + 1;
              tok_indx := tok_indx + 1;
            else
              CALL philips_json_parser.s_error('Expected: ''null''', lin_no, col_no);
            end if;
          else
            tokens(tok_indx) := philips_json_parser.mt('NULL', lin_no, col_no, null); tok_indx := tok_indx + 1;
            indx := indx + 3;
            col_no := col_no + 3;
          end if;
        when buf = 'f' then
          if (jsrc := philips_json_parser.next_char2(indx, jsrc, 5) != 'false') then
            if (current_setting('philips_json_parser.json_strict')::boolean = false and REGEXP_LIKE(buf, '^[[:alpha:]]$', 'i')) then
              tokens(tok_indx) := philips_json_parser.mt('STRING', lin_no, col_no, null);
              SELECT * FROM philips_json_parser.lexname(jsrc, tokens(tok_indx), indx) INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx;
              col_no := col_no + length(tokens[tok_indx].data) + 1;
              tok_indx := tok_indx + 1;
            else
              CALL philips_json_parser.s_error('Expected: ''false''', lin_no, col_no);
            end if;
          else
            tokens(tok_indx) := philips_json_parser.mt('FALSE', lin_no, col_no, null); tok_indx := tok_indx + 1;
            indx := indx + 4;
            col_no := col_no + 4;
          end if;
        /*   -- 9 = TAB, 10 = \n, 13 = \r (Linux = \n, Windows = \r\n, Mac = \r */

        when(buf = Chr(10)) then --linux newlines
          lin_no := lin_no + 1;
          col_no := 0;

        when(buf = Chr(13)) then --Windows or Mac way
          lin_no := lin_no + 1;
          col_no := 0;
          if (jsrc.len >= indx +1) then -- better safe than sorry
            jsrc := philips_json_parser.next_char(indx+1, jsrc);
            if (buf = Chr(10)) then --\r\n
              indx := indx + 1;
            end if;
          end if;

        when(buf = CHR(9)) then null; --tabbing
        when(buf in ('-', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9')) then --number
          tokens(tok_indx) := philips_json_parser.mt('NUMBER', lin_no, col_no, null);
          SELECT * FROM philips_json_parser.lexnumber(jsrc, tokens(tok_indx), indx) INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx-1;
          col_no := col_no + length(tokens[tok_indx].data);
          tok_indx := tok_indx + 1;
        when buf = '"' then --number
          tokens(tok_indx) := philips_json_parser.mt('STRING', lin_no, col_no, null);
          SELECT * FROM philips_json_parser.lexstring(jsrc, tokens(tok_indx), indx, '"') INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx;
          col_no := col_no + length(tokens[tok_indx].data) + 1;
          tok_indx := tok_indx + 1;
        when buf = '''' and current_setting('philips_json_parser.json_strict')::boolean = false then --number
          tokens(tok_indx) := philips_json_parser.mt('STRING', lin_no, col_no, null);
          SELECT * FROM philips_json_parser.lexstring(jsrc, tokens(tok_indx), indx, '''') INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx;
          col_no := col_no + length(tokens[tok_indx].data) + 1; --hovsa her
          tok_indx := tok_indx + 1;
        when current_setting('philips_json_parser.json_strict')::boolean = false and REGEXP_LIKE(buf, '^[[:alpha:]]$', 'i') then
          tokens(tok_indx) := philips_json_parser.mt('STRING', lin_no, col_no, null);
          SELECT * FROM philips_json_parser.lexname(jsrc, tokens(tok_indx), indx) INTO STRICT _ora2pg_r;
 jsrc := _ora2pg_r.jsrc; tokens(tok_indx) := _ora2pg_r.tok; indx := _ora2pg_r.indx;
          if (tokens[tok_indx](.data_overflow IS NOT NULL AND .data_overflow::text <> '')) then
            col_no := col_no + octet_length(tokens[tok_indx].data_overflow) + 1;
          else
            col_no := col_no + length(tokens[tok_indx].data) + 1;
          end if;
          tok_indx := tok_indx + 1;
        when current_setting('philips_json_parser.json_strict')::boolean = false and buf||jsrc := philips_json_parser.next_char(indx+1, jsrc) = '/*' then --strip comments
          declare
            saveindx bigint := indx;
            un_esc text;
          begin
            indx := indx + 1;
            loop
              indx := indx + 1;
              jsrc := philips_json_parser.next_char(indx, jsrc)||jsrc := philips_json_parser.next_char(indx+1, jsrc);
              exit when buf = '*/';
              exit when coalesce(buf::text, '') = '';
            end loop;

            if (indx = saveindx+2) then
              
              un_esc := '';
              dbms_lob.createtemporary(un_esc, true);
              indx := indx + 1;
              loop
                indx := indx + 1;
                jsrc := philips_json_parser.next_char(indx, jsrc)||jsrc := philips_json_parser.next_char(indx+1, jsrc)||jsrc := philips_json_parser.next_char(indx+2, jsrc)||jsrc := philips_json_parser.next_char(indx+3, jsrc);
                exit when buf = '/**/';
                if coalesce(buf::text, '') = '' then
                  CALL philips_json_parser.s_error('Unexpected sequence /**/ to end unescaped data: '||buf, lin_no, col_no);
                end if;
                jsrc := philips_json_parser.next_char(indx, jsrc);
                dbms_lob.writeappend(un_esc, length(buf), buf);
              end loop;
              tokens(tok_indx) := philips_json_parser.mt('ESTRING', lin_no, col_no, null);
              tokens[tok_indx].data_overflow := un_esc;
              col_no := col_no + octet_length(un_esc) + 1; --note: line count won't work properly
              tok_indx := tok_indx + 1;
              indx := indx + 2;
            end if;

            indx := indx + 1;
          end;
        when buf = ' ' then null; --space
        else
          CALL philips_json_parser.s_error('Unexpected char: '||buf, lin_no, col_no);
      end case;

      indx := indx + 1;
    end loop;

    return;
  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION philips_json_parser.lexer (jsrc INOUT json_src) FROM PUBLIC;
