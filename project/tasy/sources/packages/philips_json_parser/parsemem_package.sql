-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION philips_json_parser.parsemem (tokens lTokens, indx INOUT integer, mem_name text, mem_indx bigint) AS $body$
DECLARE

    mem philips_json_value;
    tok rToken;

BEGIN
    tok := tokens(indx);
    case tok.type_name
      when 'TRUE' then mem := philips_json_value(true);
      when 'FALSE' then mem := philips_json_value(false);
      when 'NULL' then mem := philips_json_value;
      when 'STRING' then mem := case when (tok.data_overflow IS NOT NULL AND tok.data_overflow::text <> '') then philips_json_value(tok.data_overflow) else philips_json_value(tok.data) end;
      when 'ESTRING' then mem := philips_json_value(tok.data_overflow, false);
      when 'NUMBER' then mem := philips_json_value((replace(tok.data, '.', current_setting('philips_json_parser.decimalpoint')::varchar(1)))::numeric );
      when '[' then
        declare
          e_list philips_json_list;
        begin
          indx := indx + 1;
          indx := philips_json_parser.parsearr(tokens, indx);
          mem := e_list.to_json_value;
        end;
      when '{' then
        indx := indx + 1;
        mem := parseObj[tokens, indx].to_json_value;
      else
        philips_json_parser.p_error('Found '||tok.type_name, tok);
    end case;
    mem.mapname := mem_name;
    mem.mapindx := mem_indx;

    indx := indx + 1;
    return;
  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION philips_json_parser.parsemem (tokens lTokens, indx INOUT integer, mem_name text, mem_indx bigint) FROM PUBLIC;
