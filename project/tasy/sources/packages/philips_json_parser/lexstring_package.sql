-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION philips_json_parser.lexstring (jsrc INOUT json_src, tok INOUT rToken, indx INOUT integer, endChar char) AS $body$
DECLARE

    v_extended text := null;v_count bigint := 0;
    varbuf varchar(32767) := '';
    buf varchar(4);
    wrong boolean;

BEGIN
    indx := indx +1;
    jsrc := philips_json_parser.next_char(indx, jsrc);
    while(buf != endChar) loop

      if (v_count > 8191) then 
        if (coalesce(v_extended::text, '') = '') then
          v_extended := '';
          dbms_lob.createtemporary(v_extended, true);
        end if;
        v_extended := philips_json_parser.updateclob(v_extended, unistr(varbuf));
        varbuf := ''; v_count := 0;
      end if;
      if (buf = Chr(13) or buf = CHR(9) or buf = CHR(10)) then
        CALL philips_json_parser.s_error('Control characters not allowed (CHR(9),CHR(10)CHR(13))', tok);
      end if;
      if (buf = '\') then
        --varbuf := varbuf || buf;
        indx := indx + 1;
        jsrc := philips_json_parser.next_char(indx, jsrc);
        case
          when buf in ('\') then
            varbuf := varbuf || buf || buf; v_count := v_count + 2;
            indx := indx + 1;
            jsrc := philips_json_parser.next_char(indx, jsrc);
          when buf in ('"', '/') then
            varbuf := varbuf || buf; v_count := v_count + 1;
            indx := indx + 1;
            jsrc := philips_json_parser.next_char(indx, jsrc);
          when buf = '''' then
            if (current_setting('philips_json_parser.json_strict')::boolean = false) then
              varbuf := varbuf || buf; v_count := v_count + 1;
              indx := indx + 1;
              jsrc := philips_json_parser.next_char(indx, jsrc);
            else
              CALL philips_json_parser.s_error('strictmode - expected: " \ / b f n r t u ', tok);
            end if;
          when buf in ('b', 'f', 'n', 'r', 't') then
            case buf
            when 'b' then varbuf := varbuf || chr(8);
            when 'f' then varbuf := varbuf || chr(12);
            when 'n' then varbuf := varbuf || chr(10);
            when 'r' then varbuf := varbuf || chr(13);
            when 't' then varbuf := varbuf || chr(9);
            end case;
            v_count := v_count + 1;
            indx := indx + 1;
            jsrc := philips_json_parser.next_char(indx, jsrc);
          when buf = 'u' then
            declare
              four varchar(4);
            begin
              jsrc := philips_json_parser.next_char2(indx+1, jsrc, 4);
              wrong := FALSE;
              if (upper(substr(four, 1,1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if (upper(substr(four, 2,1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if (upper(substr(four, 3,1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if (upper(substr(four, 4,1)) not in ('0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','a','b','c','d','e','f')) then wrong := TRUE; end if;
              if (wrong) then
                CALL philips_json_parser.s_error('expected: " \u([0-9][A-F]){4}', tok);
              end if;

              varbuf := varbuf || '\'||four;--chr(to_number(four,'XXXX'));
               v_count := v_count + 5;
              indx := indx + 5;
              jsrc := philips_json_parser.next_char(indx, jsrc);
              end;
          else
            CALL philips_json_parser.s_error('expected: " \ / b f n r t u ', tok);
        end case;
      else
        varbuf := varbuf || buf; v_count := v_count + 1;
        indx := indx + 1;
        jsrc := philips_json_parser.next_char(indx, jsrc);
      end if;
    end loop;

    if (coalesce(buf::text, '') = '') then
      CALL philips_json_parser.s_error('string ending not found', tok);
      --philips_json_parser.debug('Premature string ending');
    end if;

    --philips_json_parser.debug(varbuf);
    --dbms_output.put_line(varbuf);
    if (v_extended IS NOT NULL AND v_extended::text <> '') then
      v_extended := philips_json_parser.updateclob(v_extended, unistr(varbuf));
      tok.data_overflow := v_extended;
      tok.data := substr(v_extended, 1, 32767);
    else
      tok.data := unistr(varbuf);
    end if;
    return;
  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION philips_json_parser.lexstring (jsrc INOUT json_src, tok INOUT rToken, indx INOUT integer, endChar char) FROM PUBLIC;
