-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION doc_export_auto_pkg.get_report_tables (NR_SEQ_REPORT_P RELATORIO.NR_SEQUENCIA%TYPE, DS_PROCEDURE_P RELATORIO.DS_PROCEDURE%TYPE, DS_SQL_REPORT_P RELATORIO.DS_SQL%TYPE, NR_SEQ_BANDA_P BANDA_RELATORIO.NR_SEQUENCIA%TYPE, DS_SQL_BANDA_P BANDA_RELATORIO.DS_SQL%TYPE, NR_SEQ_CAMPO_P BANDA_RELAT_CAMPO.NR_SEQUENCIA%TYPE, DS_SQL_CAMPO_P BANDA_RELAT_CAMPO.DS_SQL%TYPE) RETURNS RELATORIO_DINAMICO.DS_SQL%TYPE AS $body$
DECLARE


    /*===========================================================================================
    Acionada quando o campo IE_EXPORTAR_DOCUMENTO da tabela RELATORIO_AUTO_IMP eh alterado para 'S'
    ou quando eh alterada a definicao de um relatorio referenciado na tabela RELATORIO_AUTO_IMP com
    IE_EXPORTAR_DOCUMENTO = 'S'

    Gatilhos:
    relatorio_auto_imp_atual_after
    relatorio_after_upd_prc_sql
    banda_relat_after_ds_sql
    banda_relat_after_ds_sql_stmt
    banda_relat_campo_after_ds_sql
    banda_relat_cmp_after_sql_stmt

    Fluxo:
    1 - Armazenar o numero do relatorio associado a impressao automatica com IE_EXPORTAR_DOCUMENTO = 'S'
    2 - Armazenar o nome da procedure e o conteudo da query do relatorio
    3 - Se houver procedure no relatorio entao GET_PROCEDURE_TABLES
    3.1 - Verifica se a procedure esta registrada na tabela OBJETO_SISTEMA
    3.2 - Adiciona a variavel DS_TABLES_W as tabelas dependentes das packages dependentes da procedure
    3.3 - Adiciona a variavel DS_TABLES_W as tabelas dependentes da procedure ainda nao listadas
    4 - Se houver query no relatorio entao GET_QUERY_TABLES
    4.1 - Lineraliza a query (transforma tabulacoes e quebras de linha em espaco, acrescenta espaco antes de dois pontos, antes e depois de parenteses e remove espacos consecutivos)
    4.2 - Verifica se eh query (inicia com with ou select)
    4.3 - GET_FROMS pega o texto apos cada " from " da query ate o proximo " select ", " from ", " where ", " group by " ou " order by "
    4.4 - GET_OBJECTS pega de cada from o texto apos cada from, virgula ou join
    4.4.1 - Se o texto eh iniciado por TABLE (, analisa o texto a seguir, despresando abertura de parentese a esquerda ate o proximo espaco
    4.4.1.1 - Se o texto contiver ponto, verifica se o objeto eh package e adiciona a variavel DS_TABLES_W as tabelas dependentes
    4.4.1.2 - Se nao contiver ponto, verifica se o objeto eh function e adiciona a variavel DS_TABLES_W as tabelas dependentes
    4.4.2 - Se o texto nao eh iniciado por TABLE ( ou ( SELECT, entao analisa o texto ate o proximo espaco, despresando abertura de parentese a esquerda
    4.4.2.1 - Se o objeto estiver cadastrado em TABELA_SISTEMA, adiciona a tabela a variavel DS_TABLES_W
    4.4.2.2 - Se o objeto estiver cadastrado em OBJETO_SISTEMA como VIEW, adiciona a variavel DS_TABLES_W as tabelas associadas a view
    5 - GET_QUERY_TABLES das bandas do relatorio e adiciona as tabelas a variavel DS_TABLES_W (Sub-etapas da estapa 4 sao repetidas)
    6 - GET_QUERY_TABLES dos campos das bandas do relatorio e adiciona as tabelas a variavel DS_TABLES_W (Sub-etapas da estapa 4 sao repetidas)
    7 - Retorna a variavel DS_TABLES_W contendo todas tabelas localizadas no relatorio

    OBS) Apenas tabelas que nao iniciam por W_ e possuem o campo DT_ATUALIZACAO sao monitoradas
    ===========================================================================================*/
    DS_TABLES_W RELATORIO_DINAMICO.DS_SQL%TYPE;
    DS_SQL_W    RELATORIO.DS_SQL%TYPE;
    DS_PROCED_W RELATORIO.DS_PROCEDURE%TYPE;

    C_BANDAS CURSOR(NR_REPORT_P RELATORIO.NR_SEQUENCIA%TYPE,
                    NR_BANDA_P  BANDA_RELATORIO.NR_SEQUENCIA%TYPE,
                    DS_SQL_P    BANDA_RELATORIO.DS_SQL%TYPE) FOR

      SELECT DISTINCT B.DS_SQL
        FROM BANDA_RELATORIO B
       WHERE B.NR_SEQ_RELATORIO = NR_REPORT_P
         AND (coalesce(NR_BANDA_P::text, '') = '' OR NR_BANDA_P <> B.NR_SEQUENCIA)
         AND (B.DS_SQL IS NOT NULL AND B.DS_SQL::text <> '')

UNION

      SELECT DS_SQL_P DS_SQL
        
       WHERE (DS_SQL_P IS NOT NULL AND DS_SQL_P::text <> '');

    TYPE T_BANDAS IS TABLE OF C_BANDAS%ROWTYPE;
    R_BANDAS T_BANDAS;

    C_CAMPOS CURSOR(NR_REPORT_P RELATORIO.NR_SEQUENCIA%TYPE,
                    NR_CAMPO_P  BANDA_RELAT_CAMPO.NR_SEQUENCIA%TYPE,
                    DS_SQL_P    BANDA_RELAT_CAMPO.DS_SQL%TYPE) FOR

      SELECT DISTINCT C.DS_SQL
        FROM BANDA_RELATORIO B,
             BANDA_RELAT_CAMPO C
       WHERE B.NR_SEQ_RELATORIO = NR_REPORT_P
         AND B.NR_SEQUENCIA = C.NR_SEQ_BANDA
         AND (coalesce(NR_CAMPO_P::text, '') = '' OR NR_CAMPO_P <> C.NR_SEQUENCIA)
         AND (C.DS_SQL IS NOT NULL AND C.DS_SQL::text <> '')

UNION

      SELECT DS_SQL_P DS_SQL
        
       WHERE (DS_SQL_P IS NOT NULL AND DS_SQL_P::text <> '');

    TYPE T_CAMPOS IS TABLE OF C_CAMPOS%ROWTYPE;
    R_CAMPOS T_CAMPOS;WITH RECURSIVE cte AS (


    C_TABLE_FIELDS_VALIDATOR CURSOR(DS_TABLES_P BANDA_RELAT_CAMPO.DS_SQL%TYPE) FOR
    
      SELECT REGEXP_SUBSTR(str, '[^;]+', 1, 1) value
        FROM (SELECT DS_TABLES_P str )
     LEVEL <= LENGTH(str) - LENGTH(replace(str, ';', '')) + 1  UNION ALL

    
    C_TABLE_FIELDS_VALIDATOR CURSOR(DS_TABLES_P BANDA_RELAT_CAMPO.DS_SQL%TYPE) FOR
    
      SELECT REGEXP_SUBSTR(str, '[^;]+', 1, (c.level+1)) value
        FROM (SELECT DS_TABLES_P str )
     LEVEL <= LENGTH(str) - LENGTH(replace(str, ';', '')) + 1 JOIN cte c ON ()

) SELECT * FROM cte;
;

    TYPE T_TABLE_FIELDS_VALIDATOR IS TABLE OF C_TABLE_FIELDS_VALIDATOR%ROWTYPE;
    R_TABLE_FIELDS_VALIDATOR T_TABLE_FIELDS_VALIDATOR;

    C_SHOWN_SQL_FIELDS CURSOR(NR_SEQ_RELATORIO_P RELATORIO.NR_SEQUENCIA%TYPE) FOR
    
      SELECT brc.nm_atributo
        FROM banda_relat_campo brc
       INNER JOIN banda_relatorio br
          ON br.nr_sequencia = brc.nr_seq_banda
       INNER JOIN relatorio r
          ON br.nr_seq_relatorio = r.nr_sequencia
       WHERE r.nr_sequencia = NR_SEQ_RELATORIO_P;

    TYPE T_SHOWN_SQL_FIELDS IS TABLE OF C_SHOWN_SQL_FIELDS%ROWTYPE;
    R_SHOWN_SQL_FIELDS T_SHOWN_SQL_FIELDS;

    C_SHOWN_TABLES CURSOR(
           NM_TABLE_P ALL_TAB_COLUMNS.TABLE_NAME%TYPE,
           NM_COLUMN_P ALL_TAB_COLUMNS.COLUMN_NAME%TYPE
    ) FOR
    
     SELECT CASE 
                WHEN coalesce(NM_TABLE_P::text, '') = ''
                THEN table_name
                WHEN (NM_TABLE_P IS NOT NULL AND NM_TABLE_P::text <> '') AND NM_TABLE_P <> table_name
                THEN NM_TABLE_P || ';' || table_name 
                ELSE NM_TABLE_P
            END ds_tables
       FROM all_tab_columns 
      WHERE UPPER(table_name)= NM_TABLE_P
        AND UPPER(column_name)= NM_COLUMN_P;

    TYPE T_SHOWN_TABLES IS TABLE OF C_SHOWN_TABLES%ROWTYPE;
    R_SHOWN_TABLES T_SHOWN_TABLES;


BEGIN

    DS_TABLES_W := NULL;

    IF (NR_SEQ_REPORT_P IS NOT NULL AND NR_SEQ_REPORT_P::text <> '') THEN

      IF (DS_PROCEDURE_P IS NOT NULL AND DS_PROCEDURE_P::text <> '') OR (DS_SQL_REPORT_P IS NOT NULL AND DS_SQL_REPORT_P::text <> '') THEN
        DS_PROCED_W := DS_PROCEDURE_P;
        DS_SQL_W    := DS_SQL_REPORT_P;
      ELSE
        SELECT DS_SQL,
               DS_PROCEDURE
          INTO STRICT DS_SQL_W,
               DS_PROCED_W
          FROM RELATORIO
         WHERE NR_SEQUENCIA = NR_SEQ_REPORT_P;
      END IF;

      IF (DS_PROCED_W IS NOT NULL AND DS_PROCED_W::text <> '') THEN
        DS_TABLES_W := doc_export_auto_pkg.get_procedure_tables(DS_PROCED_W);
      END IF;

      IF (DS_SQL_W IS NOT NULL AND DS_SQL_W::text <> '') THEN
        DS_TABLES_W := doc_export_auto_pkg.get_query_tables(DS_SQL_W, DS_TABLES_W);
      END IF;

      OPEN C_BANDAS(NR_SEQ_REPORT_P, NR_SEQ_BANDA_P, DS_SQL_BANDA_P);
      LOOP
        FETCH C_BANDAS BULK COLLECT INTO R_BANDAS LIMIT 100;
        EXIT WHEN R_BANDAS.COUNT = 0;

        FOR i IN R_BANDAS.FIRST..R_BANDAS.LAST LOOP

          DS_TABLES_W := doc_export_auto_pkg.get_query_tables(R_BANDAS[i].DS_SQL,
                                          DS_TABLES_W);

        END LOOP;

      END LOOP;
      CLOSE C_BANDAS;

      OPEN C_CAMPOS(NR_SEQ_REPORT_P, NR_SEQ_CAMPO_P, DS_SQL_CAMPO_P);
      LOOP
        FETCH C_CAMPOS BULK COLLECT INTO R_CAMPOS LIMIT 100;
        EXIT WHEN R_CAMPOS.COUNT = 0;

        FOR i IN R_CAMPOS.FIRST..R_CAMPOS.LAST LOOP

          DS_TABLES_W := doc_export_auto_pkg.get_query_tables(R_CAMPOS[i].DS_SQL,
                                          DS_TABLES_W);

        END LOOP;

      END LOOP;
      CLOSE C_CAMPOS;

    END IF;

    OPEN C_TABLE_FIELDS_VALIDATOR(DS_TABLES_W);
    DS_TABLES_W := NULL;
    LOOP
        FETCH C_TABLE_FIELDS_VALIDATOR BULK COLLECT INTO R_TABLE_FIELDS_VALIDATOR LIMIT 100;
        EXIT WHEN R_TABLE_FIELDS_VALIDATOR.COUNT = 0;

        FOR i IN R_TABLE_FIELDS_VALIDATOR.FIRST..R_TABLE_FIELDS_VALIDATOR.LAST LOOP

          --NR_REPORT_P
          OPEN C_SHOWN_SQL_FIELDS(NR_SEQ_REPORT_P);
          LOOP
              FETCH C_SHOWN_SQL_FIELDS BULK COLLECT INTO R_SHOWN_SQL_FIELDS LIMIT 1000;
              EXIT WHEN R_SHOWN_SQL_FIELDS.COUNT = 0;

              FOR j IN R_SHOWN_SQL_FIELDS.FIRST..R_SHOWN_SQL_FIELDS.LAST LOOP

                OPEN C_SHOWN_TABLES(R_TABLE_FIELDS_VALIDATOR[i].value, R_SHOWN_SQL_FIELDS[j].nm_atributo);
                LOOP
                     FETCH C_SHOWN_TABLES BULK COLLECT INTO R_SHOWN_TABLES LIMIT 1000;
                     EXIT WHEN R_SHOWN_TABLES.COUNT = 0;

                     FOR k IN R_SHOWN_TABLES.FIRST..R_SHOWN_TABLES.LAST LOOP
                     
                         DS_TABLES_W := R_SHOWN_TABLES[k].ds_tables;

                     END LOOP;
                END LOOP;
               CLOSE C_SHOWN_TABLES;

              END LOOP;
             END LOOP;
          CLOSE C_SHOWN_SQL_FIELDS;

        END LOOP;
      END LOOP;
    CLOSE C_TABLE_FIELDS_VALIDATOR;

    RETURN DS_TABLES_W;

  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION doc_export_auto_pkg.get_report_tables (NR_SEQ_REPORT_P RELATORIO.NR_SEQUENCIA%TYPE, DS_PROCEDURE_P RELATORIO.DS_PROCEDURE%TYPE, DS_SQL_REPORT_P RELATORIO.DS_SQL%TYPE, NR_SEQ_BANDA_P BANDA_RELATORIO.NR_SEQUENCIA%TYPE, DS_SQL_BANDA_P BANDA_RELATORIO.DS_SQL%TYPE, NR_SEQ_CAMPO_P BANDA_RELAT_CAMPO.NR_SEQUENCIA%TYPE, DS_SQL_CAMPO_P BANDA_RELAT_CAMPO.DS_SQL%TYPE) FROM PUBLIC;
