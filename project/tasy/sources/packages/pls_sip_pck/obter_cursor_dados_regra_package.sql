-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


-- Monta o comando da regra e abre o cursor passado passando as binds na ordem correta.



CREATE OR REPLACE PROCEDURE pls_sip_pck.obter_cursor_dados_regra ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, dados_regra_p pls_sip_pck.c_regra_item, ie_busca_guia_ref_p boolean, ie_tipo_atend_p sip_nv_dados.ie_tipo_atendimento%type, rc_cursor_p INOUT sql_pck.t_cursor, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

					
dados_sql_regra_w	dados_sql_regra;
sql_w			varchar(32000);
ds_filtro_nao_pode_w	varchar(1000);

BEGIN

dados_sql_regra_w := pls_sip_pck.montar_restricao_regra(dados_regra_p, ie_busca_guia_ref_p, ie_tipo_atend_p);

-- internacoes

if (dados_regra_p.sequ_item between 64 and 108) then
	
	-- busca o filtro que retira os registros que nao podem ser selecionados no segundo acesso da tabela

	dados_sql_regra_w.dados_binds := pls_sip_pck.obter_restr_pode_npode(	dados_regra_p, ie_busca_guia_ref_p, dados_sql_regra_w.dados_binds, 'b');

	sql_w :=	'with dados_temp as ( ' || pls_util_pck.enter_w ||
			'			select 	a.nr_seq_lote_sip,' || pls_util_pck.enter_w || 
			'				a.ie_tipo_protocolo,' || pls_util_pck.enter_w ||
			'				a.nr_seq_segurado,' || pls_util_pck.enter_w ||
			'				a.cd_guia_referencia,' || pls_util_pck.enter_w ||
			'				a.ie_tipo_atendimento,' || pls_util_pck.enter_w ||
			'				a.nr_documento' || pls_util_pck.enter_w;
	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'			from 	sip_nv_dados_v a' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'			from 	sip_nv_dados a' || pls_util_pck.enter_w;
	end if;

	sql_w :=	sql_w||'				' || dados_sql_regra_w.ds_tabela || pls_util_pck.enter_w ||
			'			where	1 = 1' || pls_util_pck.enter_w ||
			'			and 	a.nr_seq_lote_sip = :nr_seq_lote_sip' || pls_util_pck.enter_w ||
			'			and 	a.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'			and 	a.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			'			' || dados_sql_regra_w.regra_sql || pls_util_pck.enter_w ||
			'			group by a.nr_seq_lote_sip,' || pls_util_pck.enter_w ||
			'				a.ie_tipo_protocolo,' || pls_util_pck.enter_w ||
			'				a.nr_seq_segurado,' || pls_util_pck.enter_w ||
			'				a.cd_guia_referencia,' || pls_util_pck.enter_w ||
			'				a.ie_tipo_atendimento,' || pls_util_pck.enter_w ||
			'				a.nr_documento)' || pls_util_pck.enter_w ||
			'select	b.nr_sequencia, ' || pls_util_pck.enter_w ||
			'	''1'' tipo_casamento' || pls_util_pck.enter_w;
	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'from 	dados_temp a, sip_nv_dados_v b' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'from 	dados_temp a, sip_nv_dados b' || pls_util_pck.enter_w;
	end if;

	sql_w :=	sql_w||'where	1 = 1' || pls_util_pck.enter_w ||
			'and	b.nr_seq_lote_sip = a.nr_seq_lote_sip' || pls_util_pck.enter_w || 
			'and	b.ie_tipo_protocolo = a.ie_tipo_protocolo' || pls_util_pck.enter_w || 
			'and 	b.nr_seq_segurado = a.nr_seq_segurado' || pls_util_pck.enter_w || 
			'and 	b.cd_guia_referencia = a.cd_guia_referencia' || pls_util_pck.enter_w || 
			'and 	b.ie_tipo_atendimento = a.ie_tipo_atendimento' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			ds_filtro_nao_pode_w || pls_util_pck.enter_w ||
			'union all' || pls_util_pck.enter_w ||
			'select	b.nr_sequencia, ' || pls_util_pck.enter_w || 
			'	''1'' tipo_casamento' || pls_util_pck.enter_w;
	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'from 	dados_temp a, sip_nv_dados_v b' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'from 	dados_temp a, sip_nv_dados b' || pls_util_pck.enter_w;
	end if;

	sql_w :=	sql_w||'where	1 = 1' || pls_util_pck.enter_w ||
			'and	a.ie_tipo_protocolo = ''R''' || pls_util_pck.enter_w || 
			'and	b.nr_seq_lote_sip = a.nr_seq_lote_sip' || pls_util_pck.enter_w || 
			'and	b.ie_tipo_protocolo = a.ie_tipo_protocolo' || pls_util_pck.enter_w || 
			'and 	b.nr_seq_segurado = a.nr_seq_segurado' || pls_util_pck.enter_w || 
			'and 	b.nr_documento = a.nr_documento' || pls_util_pck.enter_w || 
			'and 	b.ie_tipo_atendimento = a.ie_tipo_atendimento' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			ds_filtro_nao_pode_w;

-- para considerar toda a conta que nao estiver vinculada a algum item assistencial

elsif (dados_regra_p.ie_considerar_conta = 'S') then
	
	-- busca o filtro que retira os registros que nao podem ser selecionados no segundo acesso da tabela

	dados_sql_regra_w.dados_binds := pls_sip_pck.obter_restr_pode_npode(	dados_regra_p, ie_busca_guia_ref_p, dados_sql_regra_w.dados_binds, 'b');

	sql_w :=	'select	distinct b.nr_sequencia, ' || pls_util_pck.enter_w ||
			'	''1'' tipo_casamento' || pls_util_pck.enter_w;
			
	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'from 	sip_nv_dados_v a, sip_nv_dados_v b' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'from 	sip_nv_dados a, sip_nv_dados b' || pls_util_pck.enter_w;
		
	end if;

	sql_w :=	sql_w||'	' || dados_sql_regra_w.ds_tabela || pls_util_pck.enter_w ||
			'where	1 = 1' || pls_util_pck.enter_w ||
			'and	a.nr_seq_lote_sip = :nr_seq_lote_sip' || pls_util_pck.enter_w || 
			'and 	a.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	a.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			'	' || dados_sql_regra_w.regra_sql || pls_util_pck.enter_w ||
			'and	b.nr_seq_lote_sip = a.nr_seq_lote_sip' || pls_util_pck.enter_w ||
			'and	b.nr_seq_conta = a.nr_seq_conta' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			ds_filtro_nao_pode_w || pls_util_pck.enter_w;

-- para considerar toda o atendimento que nao estiver vinculada a algum item assistencial

elsif (coalesce(dados_regra_p.ie_considerar_atend,'N') = 'S') then
	
	-- busca o filtro que retira os registros que nao podem ser selecionados no segundo acesso da tabela

	dados_sql_regra_w.dados_binds := pls_sip_pck.obter_restr_pode_npode(	dados_regra_p, ie_busca_guia_ref_p, dados_sql_regra_w.dados_binds, 'b');

	sql_w :=	'select	distinct b.nr_sequencia, ' || pls_util_pck.enter_w ||
			'	''1'' tipo_casamento' || pls_util_pck.enter_w;
			
	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'from 	sip_nv_dados_v a, sip_nv_dados_v b' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'from 	sip_nv_dados a, sip_nv_dados b' || pls_util_pck.enter_w;
		
	end if;

	sql_w :=	sql_w||'	' || dados_sql_regra_w.ds_tabela || pls_util_pck.enter_w ||
			'where	1 = 1' || pls_util_pck.enter_w ||
			'and	a.nr_seq_lote_sip = :nr_seq_lote_sip' || pls_util_pck.enter_w || 
			'and 	a.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	a.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			'	' || dados_sql_regra_w.regra_sql || pls_util_pck.enter_w ||
			'and	b.nr_seq_lote_sip = a.nr_seq_lote_sip' || pls_util_pck.enter_w ||
			'and	b.ie_tipo_protocolo = a.ie_tipo_protocolo' || pls_util_pck.enter_w || 
			'and 	b.nr_seq_segurado = a.nr_seq_segurado' || pls_util_pck.enter_w || 
			'and 	b.cd_guia_referencia = a.cd_guia_referencia' || pls_util_pck.enter_w || 
			'and 	b.ie_tipo_atendimento = a.ie_tipo_atendimento' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			ds_filtro_nao_pode_w || pls_util_pck.enter_w;
			
-- para considerar todos os materiais da conta

elsif (dados_regra_p.ie_materiais = 'S') then
	
	-- busca o filtro que retira os registros que nao podem ser selecionados no segundo acesso da tabela

	dados_sql_regra_w.dados_binds := pls_sip_pck.obter_restr_pode_npode(	dados_regra_p, ie_busca_guia_ref_p, dados_sql_regra_w.dados_binds, 'b');

	sql_w :=	'select	distinct b.nr_sequencia, ' || pls_util_pck.enter_w ||
			'	''1'' tipo_casamento' || pls_util_pck.enter_w;

	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'from 	sip_nv_dados_v a, sip_nv_dados_v b' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'from 	sip_nv_dados a, sip_nv_dados b' || pls_util_pck.enter_w;
		
	end if;			
		
	sql_w :=	sql_w||'	' || dados_sql_regra_w.ds_tabela || pls_util_pck.enter_w ||
			'where	1 = 1' || pls_util_pck.enter_w ||
			'and	a.nr_seq_lote_sip = :nr_seq_lote_sip' || pls_util_pck.enter_w || 
			'and 	a.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	a.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			'	' || dados_sql_regra_w.regra_sql || pls_util_pck.enter_w ||
			'and	b.nr_seq_lote_sip = a.nr_seq_lote_sip' || pls_util_pck.enter_w ||
			'and	b.nr_seq_conta = a.nr_seq_conta' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	b.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			'and 	b.nr_seq_conta_mat is not null' || pls_util_pck.enter_w ||
			ds_filtro_nao_pode_w || pls_util_pck.enter_w;
else
	-- sql que traz os registros aplicando as regras na sua forma mais basica

	sql_w :=	'select	distinct a.nr_sequencia, ' || pls_util_pck.enter_w ||
			'	''1'' tipo_casamento ' || pls_util_pck.enter_w;
	-- compatibilidade entre o "novo SIP" e o atual

	if	((coalesce(current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento, 'N') = 'N') and (coalesce(current_setting('pls_sip_pck.param_w')::param.ie_novo_sip, 'N') = 'S')) then

		sql_w :=	sql_w||'from 	sip_nv_dados_v a ' || pls_util_pck.enter_w;

	else
		sql_w :=	sql_w||'from 	sip_nv_dados a ' || pls_util_pck.enter_w;
		
	end if;	
			
	sql_w :=	sql_w||'	' || dados_sql_regra_w.ds_tabela || pls_util_pck.enter_w ||
			'where	a.nr_seq_lote_sip = :nr_seq_lote_sip ' || pls_util_pck.enter_w ||
			'and 	a.ie_glosa_conta = ''N''' || pls_util_pck.enter_w ||
			'and 	a.ie_glosa_item = ''N''' || pls_util_pck.enter_w ||
			'	' || dados_sql_regra_w.regra_sql;
end if;

dados_sql_regra_w.dados_binds := sql_pck.bind_variable(':nr_seq_lote_sip', nr_seq_lote_p, dados_sql_regra_w.dados_binds);
		
-- Grava o tempo de execucao de cada regra para o lote.

CALL pls_sip_pck.gravar_tempo_regra(nr_seq_lote_p, dados_regra_p.sequ_regra, 'INICIO', sql_w, nm_usuario_p);

dados_sql_regra_w.dados_binds := sql_pck.executa_sql_cursor(sql_w, dados_sql_regra_w.dados_binds);
			
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_sip_pck.obter_cursor_dados_regra ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, dados_regra_p pls_sip_pck.c_regra_item, ie_busca_guia_ref_p boolean, ie_tipo_atend_p sip_nv_dados.ie_tipo_atendimento%type, rc_cursor_p INOUT sql_pck.t_cursor, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
