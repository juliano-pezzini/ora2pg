-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_sip_pck.consistir_qtde_evento ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


qt_registro_w		integer;
qt_diferenca_w		bigint;
nr_seq_lote_atu_w	sip_lote_item_assistencial.nr_sequencia%type;
nr_seq_item_pai_w	sip_lote_item_assistencial.nr_sequencia%type;
qt_evento_pai_w		sip_lote_item_assistencial.qt_evento%type;

qt_evento_novo_w	sip_lote_item_assistencial.qt_evento%type;

-- retorna todo o mundo que precisa de correcao, ou seja, evento zero e valor de despesa maior que zero

c01 CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT 	nr_seq_item_sip, ie_segmentacao_sip,
		ie_tipo_contratacao, sg_uf,
		dt_ocorrencia, nr_seq_lote,
		nr_sequencia
	from	sip_lote_item_assistencial
	where	nr_seq_lote = nr_seq_lote_pc
	-- tira fora as internacoes, pois este acerto e feito dentro da rotina que faz a contagem e abaixo nesta mesma rotina

	-- pelo motivo que os pais da internacao sao somados e nao tem regra vinculada neles

	and	nr_seq_item_sip not between 64 and 108
	and	qt_evento = 0
	and	vl_despesa > 0;WITH RECURSIVE cte AS (

	
c02 CURSOR(	nr_seq_item_pc	sip_item_assistencial.nr_sequencia%type) FOR
	SELECT	nr_sequencia nr_seq_item_sip
	from	sip_item_assistencial WHERE nr_sequencia = nr_seq_item_pc
  UNION ALL

	
c02 CURSOR(	nr_seq_item_pc	sip_item_assistencial.nr_sequencia%type) FOR
	SELECT	nr_sequencia nr_seq_item_sip
	from	sip_item_assistencial JOIN cte c ON (c.prior nr_seq_superior = nr_sequencia)

) SELECT * FROM cte
	group by nr_sequencia ORDER BY  nr_sequencia desc;
;

-- compara todos os registros do regime de internacao (EY) e compara com o seu pai (INTERNACOES)

-- onde existir diferenca na quantidade de EVENTOS busca a quantidade das INTERNACOES e coloca no regime de internacao

-- esse tratamento foi feito para tratar os casos onde existe valor de despesa e nao existe evento (colocamos 1 neste caso)	

c03 CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_item_lote,
		a.qt_evento qt_evento_antigo,
		a.ie_tipo_contratacao,
		a.ie_segmentacao_sip,
		a.sg_uf,
		a.dt_ocorrencia,
		a.nr_seq_lote,
		b.nr_seq_superior,
		(SELECT	sum(xy.qt_evento)
		 from 	sip_lote_item_assistencial xy
		 where 	xy.nr_seq_lote = a.nr_seq_lote
		 and	xy.nr_seq_item_sip = b.nr_seq_superior
		 and	xy.ie_tipo_contratacao = a.ie_tipo_contratacao
		 and	xy.ie_segmentacao_sip = a.ie_segmentacao_sip
		 and 	xy.sg_uf = a.sg_uf
		 and	xy.dt_ocorrencia = a.dt_ocorrencia) qt_evento_novo
	from	sip_lote_item_assistencial a,
		sip_item_assistencial b
	where	a.nr_seq_lote = nr_seq_lote_pc
	and	b.nr_sequencia = a.nr_seq_item_sip
	and	b.cd_classificacao = 'EY'
	and	b.ie_evento = 'S'
	and	(b.nr_seq_superior IS NOT NULL AND b.nr_seq_superior::text <> '')
	and 	exists (	select	1
				from	sip_item_assistencial x,
					sip_lote_item_assistencial y
				where	x.nr_sequencia = b.nr_seq_superior
				and	x.ie_evento = 'S'
				and 	y.nr_seq_lote = a.nr_seq_lote
				and	y.nr_seq_item_sip = x.nr_sequencia
				and 	y.ie_segmentacao_sip = a.ie_segmentacao_sip
				and 	y.ie_tipo_contratacao = a.ie_tipo_contratacao
				and 	y.sg_uf = a.sg_uf
				and 	y.dt_ocorrencia = a.dt_ocorrencia
				and	y.qt_evento <> a.qt_evento)
	order by b.nr_seq_superior desc;

-- compara todos os registros de causas selecionadas de internacao (F) e compara com o seu "pai" (INTERNACOES)

-- onde existir diferenca na quantidade de EVENTOS busca a quantidade das causas selecionadas e coloca nas internacoes

-- esse tratamento foi feito para tratar os casos de recurso de glosas

c04 CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT 	a.nr_sequencia nr_seq_item_lote,
		a.qt_evento qt_evento_antigo,
		a.ie_tipo_contratacao,
		a.ie_segmentacao_sip,
		a.sg_uf,
		a.dt_ocorrencia,
		-- causas selecionadas de internacao

		(SELECT	sum(xy.qt_evento)
		 from 	sip_lote_item_assistencial xy
		 where	xy.nr_seq_lote = a.nr_seq_lote
		 and	xy.nr_seq_item_sip = 88
		 and	xy.ie_tipo_contratacao = a.ie_tipo_contratacao
		 and	xy.ie_segmentacao_sip = a.ie_segmentacao_sip
		 and	xy.sg_uf = a.sg_uf
		 and	xy.dt_ocorrencia = a.dt_ocorrencia) qt_evento_novo
	from 	sip_lote_item_assistencial a, sip_item_assistencial b
	where	a.nr_seq_lote = nr_seq_lote_pc
	and 	b.nr_sequencia = a.nr_seq_item_sip
	and 	b.cd_classificacao = 'E'
	and 	exists (select 1
			 from 	sip_item_assistencial x,
				sip_lote_item_assistencial y
			 where 	x.nr_sequencia = 88
			 and 	y.nr_seq_lote = a.nr_seq_lote
			 and 	y.nr_seq_item_sip = x.nr_sequencia
			 and 	y.ie_segmentacao_sip = a.ie_segmentacao_sip
			 and 	y.ie_tipo_contratacao = a.ie_tipo_contratacao
			 and 	y.sg_uf = a.sg_uf
			 and 	y.dt_ocorrencia = a.dt_ocorrencia
			 -- quantidade de eventos das causas maior que das internacoes

			 and 	y.qt_evento > a.qt_evento);
			
-- Faz a comparacao entre EX e EY, ajustando com base no EX, e atribuindo a diferenca no EY

c05 CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_item_lote,
		a.qt_evento qt_evento_antigo,
		a.ie_tipo_contratacao,
		a.ie_segmentacao_sip,
		a.sg_uf,
		a.dt_ocorrencia,
		a.nr_seq_lote,
		b.nr_seq_superior,
		(	SELECT	sum(y.qt_evento)
			from 	sip_item_assistencial		x,
				sip_lote_item_assistencial	y
			where	x.ie_evento			= 'S'
			and	y.nr_seq_lote			= a.nr_seq_lote
			and	y.nr_seq_item_sip		= x.nr_sequencia
			and	y.ie_segmentacao_sip		= a.ie_segmentacao_sip
			and	y.ie_tipo_contratacao		= a.ie_tipo_contratacao
			and	y.sg_uf				= a.sg_uf
			and	y.dt_ocorrencia			= a.dt_ocorrencia
			and	x.cd_classificacao		= 'EX')  qt_evento_novo
	from	sip_lote_item_assistencial	a,
		sip_item_assistencial		b
	where	a.nr_seq_lote			= nr_seq_lote_pc
	and	b.nr_sequencia			= a.nr_seq_item_sip
	and	b.cd_classificacao		= 'EY'
	and	b.ie_evento			= 'S'
	and	(b.nr_seq_superior IS NOT NULL AND b.nr_seq_superior::text <> '')
	and   	exists (	select	1
				from	sip_item_assistencial		x,
					sip_lote_item_assistencial	y
				where	x.ie_evento			= 'S'
				and	y.nr_seq_lote			= a.nr_seq_lote
				and	y.nr_seq_item_sip		= x.nr_sequencia
				and	y.ie_segmentacao_sip		= a.ie_segmentacao_sip
				and	y.ie_tipo_contratacao		= a.ie_tipo_contratacao
				and	y.sg_uf				= a.sg_uf
				and	y.dt_ocorrencia			= a.dt_ocorrencia
				and	x.cd_classificacao		= 'EX'
				and	y.qt_evento			<> a.qt_evento)
	order by b.nr_seq_superior desc;
	
-- comparacao entre EX e E, com base no E

current_setting('pls_sip_pck.c06')::CURSOR( CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_item_lote,
		a.qt_evento qt_evento_antigo,
		a.ie_tipo_contratacao,
		a.ie_segmentacao_sip,
		a.sg_uf,
		a.dt_ocorrencia,
		a.nr_seq_lote,
		b.nr_seq_superior,
		(	SELECT	sum(y.qt_evento)
			from 	sip_item_assistencial		x,
				sip_lote_item_assistencial	y
			where	x.ie_evento			= 'S'
			and	y.nr_seq_lote			= a.nr_seq_lote
			and	y.nr_seq_item_sip		= x.nr_sequencia
			and	y.ie_segmentacao_sip		= a.ie_segmentacao_sip
			and	y.ie_tipo_contratacao		= a.ie_tipo_contratacao
			and	y.sg_uf				= a.sg_uf
			and	y.dt_ocorrencia			= a.dt_ocorrencia
			and	x.cd_classificacao		= 'EX')  qt_evento_novo
	from	sip_lote_item_assistencial	a,
		sip_item_assistencial		b
	where	a.nr_seq_lote			= nr_seq_lote_pc
	and	b.nr_sequencia			= a.nr_seq_item_sip
	and	a.nr_seq_item_sip		= 64
	and   	exists (	select	1
				from	sip_item_assistencial		x,
					sip_lote_item_assistencial	y
				where	x.ie_evento			= 'S'
				and	y.nr_seq_lote			= a.nr_seq_lote
				and	y.nr_seq_item_sip		= x.nr_sequencia
				and	y.ie_segmentacao_sip		= a.ie_segmentacao_sip
				and	y.ie_tipo_contratacao		= a.ie_tipo_contratacao
				and	y.sg_uf				= a.sg_uf
				and	y.dt_ocorrencia			= a.dt_ocorrencia
				and	x.cd_classificacao		= 'EX'
				and	y.qt_evento			<> a.qt_evento)
	order by b.nr_seq_superior desc;

-- Carrega os F que a somatoria dos seus filhos diretos (F1 ao F5) seja SUPERIOR ao proprio F.

-- Por regra da ANS, o numero de F nao precisa ser a soma dos Filhos diretos, no entanto, quando for ajustado

-- os Filhos diretos por conta do recurso de glosa e contestacao, pode acontecer de um filho direto ter a quantidade 

-- de eventos aumentada, logo deixando os filhos com mais eventos que o pai F, e isto pode gerar erro

current_setting('pls_sip_pck.c07')::CURSOR( CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT 	a.nr_sequencia nr_seq_item_lote,
		a.qt_evento qt_evento_antigo,
		a.ie_tipo_contratacao,
		a.ie_segmentacao_sip,
		a.sg_uf,
		a.dt_ocorrencia,
		a.qt_evento,
		-- quantidade dos filhos, servira para filtrar aqueles que devem ser alterados

		(SELECT	sum(xy.qt_evento)
		 from 	sip_lote_item_assistencial	xy
		 where	xy.nr_seq_lote			= a.nr_seq_lote
		 and	xy.nr_seq_item_sip		in (89, 98, 99, 105, 107)
		 and	xy.ie_tipo_contratacao		= a.ie_tipo_contratacao
		 and	xy.ie_segmentacao_sip		= a.ie_segmentacao_sip
		 and	xy.sg_uf			= a.sg_uf
		 and	xy.dt_ocorrencia		= a.dt_ocorrencia) qt_evento_filhos
	from 	sip_lote_item_assistencial a, sip_item_assistencial b
	where	a.nr_seq_lote		= nr_seq_lote_pc
	and 	b.nr_sequencia		= a.nr_seq_item_sip
	and 	a.nr_seq_item_sip	= 88;
	
-- Ajuste para a inconsistencia 20, somente pode ser executada quando todas as contas de EX estiverem em EY, e vice versa


current_setting('pls_sip_pck.c08')::CURSOR( CURSOR(	nr_seq_lote_pc	pls_lote_sip.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_item,
		(	SELECT	sum(y.qt_evento) qt_evento_pai
			from	sip_item_assistencial		x,
				sip_lote_item_assistencial	y
			where	x.nr_sequencia		= b.nr_seq_superior
			and	x.ie_evento		= 'S'
			and	y.nr_seq_item_sip 	= x.nr_sequencia
			and	y.nr_seq_lote		= a.nr_seq_lote
			and	y.sg_uf			= a.sg_uf
			and	y.ie_segmentacao_sip	= a.ie_segmentacao_sip
			and	y.ie_tipo_contratacao	= a.ie_tipo_contratacao
			and	y.dt_ocorrencia		= a.dt_ocorrencia
			and	y.qt_evento		<> a.qt_evento) qt_evento_pai
	from	sip_inconsistencia		t,
		sip_lote_item_assistencial	a,
		sip_item_assistencial		b
	where	t.cd_inconsistencia	= 20
	and	t.ie_situacao		= 'A'
	and	a.nr_seq_lote		= nr_seq_lote_pc
	and	b.nr_sequencia		= a.nr_seq_item_sip
	and	b.cd_classificacao	in ('EX', 'EY')
	and	b.ie_evento		= 'S'
	and	(b.nr_seq_superior IS NOT NULL AND b.nr_seq_superior::text <> '')
	-- quando o item for diferente do pai

	and	exists (	select	1
				from	sip_item_assistencial		x,
					sip_lote_item_assistencial	y
				where	x.nr_sequencia		= b.nr_seq_superior
				and	x.ie_evento		= 'S'
				and	y.nr_seq_item_sip 	= x.nr_sequencia
				and	y.nr_seq_lote		= a.nr_seq_lote
				and	y.sg_uf			= a.sg_uf
				and	y.ie_segmentacao_sip	= a.ie_segmentacao_sip
				and	y.ie_tipo_contratacao	= a.ie_tipo_contratacao
				and	y.dt_ocorrencia		= a.dt_ocorrencia
				and	y.qt_evento		<> a.qt_evento);
BEGIN
-- Decidido que quando ocorrer de um item assistencial nao tiver nenhum evento, porem ter valor de despesa(Isso ocorre quando uma ou poucas contas sao vinculadas

-- ao periodo especifico de um item assistencial e nao for internacao e so tiver materiais e taxas na conta, nesse caso nao conta evento).

-- Decisao tomada em conversa entre Decio, Leonardo e LRPossamai.


-- acha os itens que tem a situacao

for r_c01_w in c01(nr_seq_lote_p) loop
	
	-- verifica novamente se o evento esta de fato zerado e com despesa.

	-- necessario porque o c01 mantem um snapshot dos dados na sua abertura, mas

	-- o c02 atualiza todos da hierarquia da arvore, inclusive os que serao (ainda nao foram)

	-- navegados pelo c01, fazendo em algumas situacoes onde a arvore possui diversos casos de 

	-- evento zerado, ficar superior ao que deveria.

	
	select 	count(1)
	into STRICT	qt_registro_w
	from	sip_lote_item_assistencial
	where	nr_sequencia = r_c01_w.nr_sequencia
	-- tira fora as internacoes, pois este acerto e feito dentro da rotina que faz a contagem e abaixo nesta mesma rotina

	-- pelo motivo que os pais da internacao sao somados e nao tem regra vinculada neles

	and	qt_evento = 0
	and	vl_despesa > 0;
	
	-- se encontrou um registro valido para a operacao, atualiza

	if (qt_registro_w > 0) then
		-- cursor que retorna o proprio item assistencial (r_c01_w.nr_seq_item_sip) e os seus itens superiores

		for r_c02_w in c02(r_c01_w.nr_seq_item_sip) loop
			
			-- faz o update respeitando toda a classificacao do item que apresentou o problema

			update	sip_lote_item_assistencial set
				qt_evento = qt_evento + 1
			where	nr_seq_lote = r_c01_w.nr_seq_lote
			and	nr_seq_item_sip = r_c02_w.nr_seq_item_sip
			and	ie_segmentacao_sip = r_c01_w.ie_segmentacao_sip
			and	ie_tipo_contratacao = r_c01_w.ie_tipo_contratacao
			and	sg_uf = r_c01_w.sg_uf
			and	dt_ocorrencia = r_c01_w.dt_ocorrencia;
			commit;
			
		end loop;
	end if;
end loop;

-- atualiza o somatorio dos dados selecionados de CAUSAS SELECIONADAS DE INTERNACAO

CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,88,'S');


-- atualiza as quantidades de eventos das INTERNACOES para corrigir os casos onde as CAUSAS SELECIONADAS DE INTERNACAO

-- sao maiores que as INTERNACOES pelo motivo do recurso de glosa (recurso de glosa nao contamos eventos, apenas quando o item possuir so ele fica com 1)

for r_c04_w in c04(nr_seq_lote_p) loop

	-- obtem a diferenca da quantidade de eventos em relacao ao que esta informado na base

	qt_diferenca_w := (r_c04_w.qt_evento_novo - r_c04_w.qt_evento_antigo);
	

	update	sip_lote_item_assistencial set
		qt_evento = r_c04_w.qt_evento_novo
	where	nr_sequencia = r_c04_w.nr_seq_item_lote;
	commit;
	

	-- busca qualquer filho que tenha registro para atualizar a quantidade de eventos

	select	min(xy.nr_sequencia)
	into STRICT	nr_seq_lote_atu_w
	from 	sip_lote_item_assistencial xy
	where 	xy.nr_seq_lote = nr_seq_lote_p
	-- procura o item no tipo de internacao

	and	xy.nr_seq_item_sip = 65
	and	xy.ie_tipo_contratacao = r_c04_w.ie_tipo_contratacao
	and	xy.ie_segmentacao_sip = r_c04_w.ie_segmentacao_sip
	and 	xy.sg_uf = r_c04_w.sg_uf
	and	xy.dt_ocorrencia = r_c04_w.dt_ocorrencia
	-- acha um que pode ser alterado

	and (xy.qt_evento + qt_diferenca_w) > 0;
	

	-- altera a quantidade para nao dar inconsistencia 12 - Numero de eventos nao pode ser diferente do informado nos subitens.

	update	sip_lote_item_assistencial set
		qt_evento = (qt_evento + qt_diferenca_w)
	where	nr_sequencia = nr_seq_lote_atu_w;
	commit;
	

	-- busca todos os filhos do 65 para acertar o valor da diferenca

	CALL pls_sip_pck.acerto_internacao(nr_seq_lote_p, 65, qt_diferenca_w, r_c04_w.ie_tipo_contratacao, r_c04_w.ie_segmentacao_sip, r_c04_w.sg_uf, r_c04_w.dt_ocorrencia);
end loop;



-- verifica se existe algum item da TIPO DE INTERNACAO que nao foi vinculado a um REGIME DE INTERNACAO

select	count(1)
into STRICT	qt_registro_w
from (
		SELECT 	a.nr_sequencia
		from 	sip_nv_dados a,
			sip_nv_regra_vinc_it b
		where 	a.nr_seq_lote_sip = nr_seq_lote_p
		and	b.nr_seq_sip_nv_dados = a.nr_sequencia
		and	b.nr_seq_item_assist in (WITH RECURSIVE cte AS (
	SELECT	x.nr_sequencia
							from	sip_item_assistencial x WHERE x.cd_classificacao = 'EX'
  UNION ALL
	SELECT	x.nr_sequencia
							from	sip_item_assistencial x JOIN cte c ON (c.prior nr_sequencia = x.x.nr_seq_superior)

) SELECT * FROM cte;
)
		EXCEPT
		select	a.nr_sequencia
		from	sip_nv_dados a, 
			sip_nv_regra_vinc_it b
		where	a.nr_seq_lote_sip = nr_seq_lote_p
		and	b.nr_seq_sip_nv_dados = a.nr_sequencia
		and	b.nr_seq_item_assist in (WITH RECURSIVE cte AS (
(	select	x.nr_sequencia
							from	sip_item_assistencial x WHERE x.cd_classificacao = 'EY')
  UNION ALL
(	select	x.nr_sequencia
							from	sip_item_assistencial x JOIN cte c ON (c.prior nr_sequencia = x.x.nr_seq_superior)

) SELECT * FROM cte;
)) alias3;
							
-- se nao tem pendencia de EY no EX, verifica o inverso

if (qt_registro_w = 0) then

	select	count(1)
	into STRICT	qt_registro_w
	from (
			SELECT 	a.nr_sequencia
			from 	sip_nv_dados a,
				sip_nv_regra_vinc_it b
			where 	a.nr_seq_lote_sip = nr_seq_lote_p
			and	b.nr_seq_sip_nv_dados = a.nr_sequencia
			and	b.nr_seq_item_assist in (WITH RECURSIVE cte AS (
	SELECT	x.nr_sequencia
								from	sip_item_assistencial x WHERE x.cd_classificacao = 'EY'
  UNION ALL
	SELECT	x.nr_sequencia
								from	sip_item_assistencial x JOIN cte c ON (c.prior nr_sequencia = x.x.nr_seq_superior)

) SELECT * FROM cte;
)
			EXCEPT
			select	a.nr_sequencia
			from	sip_nv_dados a, 
				sip_nv_regra_vinc_it b
			where	a.nr_seq_lote_sip = nr_seq_lote_p
			and	b.nr_seq_sip_nv_dados = a.nr_sequencia
			and	b.nr_seq_item_assist in (WITH RECURSIVE cte AS (
(	select	x.nr_sequencia
								from	sip_item_assistencial x WHERE x.cd_classificacao = 'EX')
  UNION ALL
(	select	x.nr_sequencia
								from	sip_item_assistencial x JOIN cte c ON (c.prior nr_sequencia = x.x.nr_seq_superior)

) SELECT * FROM cte;
)) alias4;
end if;

-- atualiza o somatorio dos dados selecionados de REGIME DE INTERNACAO

-- se tudo foi vinculado faz o tratamento.

if (qt_registro_w = 0) then

	
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,65,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,82,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,78,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,75,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,67,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,66,'S');
	
	-- atualiza as quantidades de eventos

	for r_c03_w in c03(nr_seq_lote_p) loop
		
		qt_evento_novo_w := coalesce(r_c03_w.qt_evento_novo, 0);
		
		-- obtem a diferenca da quantidade de eventos em relacao ao que esta informado na base

		qt_diferenca_w := (qt_evento_novo_w - r_c03_w.qt_evento_antigo);
		
		update	sip_lote_item_assistencial set
			qt_evento = qt_evento_novo_w
		where	nr_sequencia = r_c03_w.nr_seq_item_lote;
		commit;
		
		-- busca qualquer filho que tenha registro para atualizar a quantidade de eventos

		select	min(xy.nr_sequencia)
		into STRICT	nr_seq_lote_atu_w
		from 	sip_lote_item_assistencial xy
		where 	xy.nr_seq_lote = nr_seq_lote_p
		-- filhos do regime de internacao

		and	xy.nr_seq_item_sip between 84 and 87
		and	xy.ie_tipo_contratacao = r_c03_w.ie_tipo_contratacao
		and	xy.ie_segmentacao_sip = r_c03_w.ie_segmentacao_sip
		and 	xy.sg_uf = r_c03_w.sg_uf
		and	xy.dt_ocorrencia = r_c03_w.dt_ocorrencia
		-- acha um que pode ser alterado

		and (xy.qt_evento + qt_diferenca_w) > 0;
		
		-- altera a quantidade para nao dar inconsistencia 12 - Numero de eventos nao pode ser diferente do informado nos subitens.

		update	sip_lote_item_assistencial set
			qt_evento = (qt_evento + qt_diferenca_w)
		where	nr_sequencia = nr_seq_lote_atu_w;
		commit;
	
	end loop;
	
	-- compara os EX e EY

	for r_c05_w in c05(nr_seq_lote_p) loop
	
		qt_evento_novo_w := coalesce(r_c05_w.qt_evento_novo, 0);
		
		-- obtem a diferenca da quantidade de eventos em relacao ao que esta informado na base

		qt_diferenca_w := (qt_evento_novo_w - r_c05_w.qt_evento_antigo);
		
		update	sip_lote_item_assistencial set
			qt_evento	= qt_evento_novo_w
		where	nr_sequencia	= r_c05_w.nr_seq_item_lote;
		commit;
		
		-- busca qualquer filho que tenha registro para atualizar a quantidade de eventos

		select	min(xy.nr_sequencia)
		into STRICT	nr_seq_lote_atu_w
		from 	sip_lote_item_assistencial xy
		where 	xy.nr_seq_lote = nr_seq_lote_p
		-- filhos do regime de internacao

		and	xy.nr_seq_item_sip between 84 and 87
		and	xy.ie_tipo_contratacao = r_c05_w.ie_tipo_contratacao
		and	xy.ie_segmentacao_sip = r_c05_w.ie_segmentacao_sip
		and 	xy.sg_uf = r_c05_w.sg_uf
		and	xy.dt_ocorrencia = r_c05_w.dt_ocorrencia
		-- acha um que pode ser alterado

		and (xy.qt_evento + qt_diferenca_w) > 0;
		
		-- altera a quantidade para nao dar inconsistencia 12 - Numero de eventos nao pode ser diferente do informado nos subitens.

		update	sip_lote_item_assistencial set
			qt_evento	= (qt_evento + qt_diferenca_w)
		where	nr_sequencia	= nr_seq_lote_atu_w;
		commit;
		
	end loop;
	
	-- compara os E e EX

	for r_c06_w in current_setting('pls_sip_pck.c06')::CURSOR((nr_seq_lote_p) loop
	
		qt_evento_novo_w := coalesce(r_c06_w.qt_evento_novo, 0);
		
		update	sip_lote_item_assistencial set
			qt_evento	= qt_evento_novo_w
		where	nr_sequencia	= r_c06_w.nr_seq_item_lote;
		commit;
	end loop;
	
	-- Valida os F com filhos

	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,89,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,99,'S');
	CALL pls_sip_pck.atualiza_soma_evento_inter(nr_seq_lote_p,105,'S');
	
	-- Compara o F com os filhos, nao necessariamente precisam bater(regra ANS), mas caso o total dos filhos for superior,

	-- entao tem que equiparar

	for r_c07_w in current_setting('pls_sip_pck.c07')::CURSOR((nr_seq_lote_p) loop
	
		-- feito a comparacao aqui, por motivos de performance

		if (r_c07_w.qt_evento < r_c07_w.qt_evento_filhos) then
		
			
			update	sip_lote_item_assistencial set
				qt_evento	= r_c07_w.qt_evento_filhos
			where	nr_sequencia	= r_c07_w.nr_seq_item_lote;
			commit;
		end if;
		
		
	end loop;
	
	-- ao final, quando tudo estiver pareado, verifica ainda se pode ocorrer a inconsistencia 20, caso positivo, ajusta.

	for r_c08_w in current_setting('pls_sip_pck.c08')::CURSOR((nr_seq_lote_p) loop
	
		update	sip_lote_item_assistencial set
			qt_evento	= r_c08_w.qt_evento_pai
		where	nr_sequencia	= r_c08_w.nr_seq_item;
		
	end loop;
	commit;

end if;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_sip_pck.consistir_qtde_evento ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
