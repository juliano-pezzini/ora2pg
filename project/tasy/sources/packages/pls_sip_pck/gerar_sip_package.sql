-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


-- Gera o lote do SIP especificado.



CREATE OR REPLACE PROCEDURE pls_sip_pck.gerar_sip ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p pls_outorgante.cd_estabelecimento%type, ie_recarrega_contas_p text default 'S') AS $body$
DECLARE


dt_periodo_inicial_w 		pls_lote_sip.dt_periodo_inicial%type;
dt_periodo_final_w 		pls_lote_sip.dt_periodo_final%type;
ie_validar_zerados_w		pls_lote_sip.ie_gerar_itens_zerados%type;
ie_tipo_geracao_lote_w		varchar(30);
ds_obs_log_w			pls_sip_nv_tempo_geracao.ds_observacao%type;
ds_cabecalho_bp_w		varchar(100);
ds_descricao_bp_w		varchar(500);

nr_seq_tempo_ger_w		pls_sip_nv_tempo_geracao.nr_sequencia%type;
nr_processo_total_w		integer;
ie_recarrega_conta_w		varchar(1);


BEGIN
ie_recarrega_conta_w := coalesce(ie_recarrega_contas_p, 'S');

-- se recarregar as contas tem 11 etapas, senao so 10

if (ie_recarrega_conta_w = 'S') then
	nr_processo_total_w	:= 11;
else
	nr_processo_total_w	:= 10;
end if;

nr_seq_tempo_ger_w	:= null;

-- valida se o SIP pode ser alterado

CALL pls_sip_pck.valida_pode_alterar_sip(nr_seq_lote_p, cd_estabelecimento_p, 'tudo');

-- limpa a tabela que armazena os tempos da geracao para comecar a gravar os novos.

delete	from pls_sip_nv_tempo_geracao
where	nr_seq_lote	= nr_seq_lote_p;
commit;

-- aumenta o tamanho da leitura de blocos para melhorar a performance

CALL pls_util_pck.gerencia_tamanho_bloco('AUMENTAR');

ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(1, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'Carregamento inicial dos dados', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w, 1);
-- Carregar os valores dos parametros usados pela geracao do SIP

SELECT * FROM pls_sip_pck.carregar_parametros(	nr_seq_lote_p, cd_estabelecimento_p, dt_periodo_inicial_w, dt_periodo_final_w, ie_validar_zerados_w, ie_tipo_geracao_lote_w) INTO STRICT dt_periodo_inicial_w, dt_periodo_final_w, ie_validar_zerados_w, ie_tipo_geracao_lote_w;
-- Atualiza os dados necessarios para a correta geracao do lote. 

CALL pls_sip_pck.sip_atualiza_valores_default(nr_seq_lote_p);
-- atualiza a tabela PLS_GRUPO_SERVICO_TM se necessario

-- nesta tabela existe o grupo de servico e seus respectivos procedimentos

CALL pls_gerencia_upd_obj_pck.atualizar_objetos(nm_usuario_p, 'PLS_SIP_PCK.GERAR_SIP()', 'PLS_GRUPO_SERVICO_TM');
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'Carregamento inicial dos dados', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(2, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_limpa_tabela', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w, 2);
-- se acaso ja tiver sido gerado alguma vez, limpa todas as regras e os dados finais

-- adotamos a filosofia que sempre que o SIP e regerado, todo o casamento de regras precisa ser refeito

CALL pls_sip_pck.sip_nv_limpa_tabela(nr_seq_lote_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_limpa_tabela', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(3, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_alimenta_qt_vidas', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,3);
-- alimenta a quantidade de vidas na pls_lote_sip

-- posteriormente sera utilizada para extratificar os dados (acima de 50.000 gera por uf)

CALL pls_sip_pck.sip_nv_alimenta_qt_vidas(nr_seq_lote_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_alimenta_qt_vidas', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


-- se e para refazer a alimentacao dos dados

if (coalesce(ie_recarrega_contas_p, 'S') = 'S') then
	ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(4, nr_processo_total_w, ie_recarrega_conta_w);
	ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
	ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
	nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_alimenta_dados', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
	CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,4);
	-- alimenta os dados na tabela sip_nv_dados

	CALL pls_sip_pck.sip_nv_alimenta_dados(	nr_seq_lote_p, dt_periodo_inicial_w, dt_periodo_final_w, nm_usuario_p, cd_estabelecimento_p);
	CALL pls_sip_pck.remove_contas_analise_pendente( nr_seq_lote_p, nm_usuario_p, cd_estabelecimento_p);
	nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_alimenta_dados', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);
end if;


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(5, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_gerencia_regra_vinc', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,5);
-- faz a ligacao dos dados com os itens assistenciais

CALL pls_sip_pck.sip_nv_gerencia_regra_vinc(nr_seq_lote_p, nm_usuario_p, cd_estabelecimento_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_gerencia_regra_vinc', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(6, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_consistencia_sistema', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,6);
-- faz uma analise das inconsistencias que precisam ser corrigidas pelo cliente

sip_nv_consistencia_sistema(	nr_seq_lote_p, ie_tipo_geracao_lote_w, dt_periodo_final_w, nm_usuario_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_consistencia_sistema', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(7, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_alimenta_dados_finais', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,7);
-- gera estrutura final do sip para posteriormente gerar o XML

CALL pls_sip_pck.sip_nv_alimenta_dados_finais(nr_seq_lote_p, nm_usuario_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'sip_nv_alimenta_dados_finais', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(8, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'gerar_itens_expostos', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,8);
-- gera os itens que nao tiveram eventos porem deve ser realizado o calculo dos expostos.

CALL pls_sip_pck.gerar_itens_expostos(nr_seq_lote_p, nm_usuario_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'gerar_itens_expostos', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(9, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'pls_atualizar_exposto_sip', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w, 9);
-- gera o numero dos expostos

CALL pls_sip_pck.pls_atualizar_exposto_sip(nr_seq_lote_p, current_setting('pls_sip_pck.ie_sip_w')::pls_controle_estab.ie_sip%type, nm_usuario_p, cd_estabelecimento_p, dt_periodo_inicial_w, dt_periodo_final_w);
-- gera os itens assistenciais com valores zerados caso seja marcado o campos ie_validar_zerados no lote

if (ie_validar_zerados_w = 'S') then
	CALL pls_sip_pck.gera_itens_zerados(nr_seq_lote_p, null, ie_tipo_geracao_lote_w, dt_periodo_inicial_w, nm_usuario_p);
end if;
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'pls_atualizar_exposto_sip', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(10, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'consistir_qtde_evento', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w, 10);
-- consiste os eventos para que nao fique evento zero com valor de despesa maior que zero

CALL pls_sip_pck.consistir_qtde_evento(nr_seq_lote_p, nm_usuario_p);
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'consistir_qtde_evento', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);


ds_obs_log_w	:= pls_sip_pck.obter_descricao_processo_pb(11, nr_processo_total_w, ie_recarrega_conta_w);
ds_cabecalho_bp_w := substr(ds_obs_log_w, 0, (position('-' in ds_obs_log_w) - 2));
ds_descricao_bp_w := substr(ds_obs_log_w, (position('-' in ds_obs_log_w) + 2));
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'pls_util_pck.gerencia_tamanho_bloco', ds_obs_log_w, 'I', nm_usuario_p, nr_seq_tempo_ger_w);
CALL gravar_processo_longo(ds_descricao_bp_w, ds_cabecalho_bp_w,11);


-- aumenta o tamanho da leitura de blocos para melhorar a performance

CALL pls_util_pck.gerencia_tamanho_bloco('DIMINUIR');
nr_seq_tempo_ger_w := pls_sip_pck.gravar_tempo_execucao(nr_seq_lote_p, 'pls_util_pck.gerencia_tamanho_bloco', ds_obs_log_w, 'F', nm_usuario_p, nr_seq_tempo_ger_w);

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_sip_pck.gerar_sip ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type, cd_estabelecimento_p pls_outorgante.cd_estabelecimento%type, ie_recarrega_contas_p text default 'S') FROM PUBLIC;
