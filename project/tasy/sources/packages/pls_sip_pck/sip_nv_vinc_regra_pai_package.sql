-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_sip_pck.sip_nv_vinc_regra_pai ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nr_seq_item_p sip_item_assistencial.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

		
sql_regra_w 			varchar(4000);
filtro_regra_sql_w 		varchar(2000);

nr_sequencia_w			dbms_sql.number_table;
nr_seq_apres_w			dbms_sql.number_table;
ie_permite_regra_w		dbms_sql.varchar2_table;
qt_registro_filho_w		dbms_sql.number_table;

tb_dados_w			pls_util_cta_pck.t_number_table;
tb_casamento_w			pls_util_cta_pck.t_varchar2_table_2;WITH RECURSIVE cte AS (


-- este cursor vai sempre pegar o primeiro nivel da hierarquia para nao incluir um item mais de uma vez

-- por isso que e utilizado o level 2

C01 CURSOR(nr_seq_item_p		sip_item_assistencial.nr_sequencia%type) FOR
	SELECT	1 as level,nr_sequencia,nr_seq_apres
	from	sip_item_assistencial WHERE nr_sequencia 	=  nr_seq_item_p
	order	by ie_ordem_aplicacao_regra,
		   nr_seq_apres
  UNION ALL




C01 CURSOR(nr_seq_item_p		sip_item_assistencial.nr_sequencia%type) FOR
	SELECT	(c.level+1),nr_sequencia,nr_seq_apres
	from	sip_item_assistencial JOIN cte c ON (c.prior nr_sequencia = nr_seq_superior)

) SELECT * FROM cte WHERE level = 2
	and (ie_permite_regra = 'S' or coalesce(ie_permite_regra::text, '') = '');
;

C02 CURSOR(	nr_seq_lote_p			pls_lote_sip.nr_sequencia%type,
		nr_seq_item_busca_p		sip_item_assistencial.nr_sequencia%type,
		nr_seq_item_pai_p		sip_item_assistencial.nr_sequencia%type) FOR
	-- Foi removido o minus pois o not exists ja havia sido colocado devido ao tratamento de performance.

	-- O problema de duplicacao que havia sido resolvido com o minus na verdade tinha origem na procedure 

	-- sip_nv_vincula_regra onde foi alterado o valor da bind_variable do item assistencial para qual o registro nao pode ser duplicado.

	SELECT	a.nr_sequencia sequencia,
		'3' ie_tipo_casamento
	from	sip_nv_dados a,
		sip_nv_regra_vinc_it b
	where	a.nr_seq_lote_sip	= nr_seq_lote_p
	and   	b.nr_seq_item_assist	= nr_seq_item_busca_p
	and	b.nr_seq_sip_nv_dados	= a.nr_sequencia
	and   	not exists (	SELECT	0
				from	sip_nv_regra_vinc_it d
				where	d.nr_seq_sip_nv_dados	= a.nr_sequencia
				and   	d.nr_seq_item_assist	= nr_seq_item_pai_p);
BEGIN

if (nr_seq_item_p IS NOT NULL AND nr_seq_item_p::text <> '') then

	filtro_regra_sql_w := ' and a.nr_seq_superior = :nr_seq_superior';
else
	filtro_regra_sql_w := ' and a.nr_seq_superior is null';
end if;

sql_regra_w :=	'select a.nr_sequencia, ' ||
		'	a.ie_permite_regra, ' ||
		'	a.nr_seq_apres, ' ||
		'	(select	count(1) ' ||
		'	from	sip_item_assistencial x ' ||
		'	where	x.nr_seq_superior = a.nr_sequencia) qt_registro_filho ' ||
		'from	sip_item_assistencial a ' ||
		' where 1 = 1 ' || 
		filtro_regra_sql_w ||
		' order by a.nr_seq_apres';
		
if (nr_seq_item_p IS NOT NULL AND nr_seq_item_p::text <> '') then
	
	EXECUTE sql_regra_w
	bulk collect into STRICT nr_sequencia_w, ie_permite_regra_w, nr_seq_apres_w, qt_registro_filho_w
	using nr_seq_item_p;
else
	EXECUTE sql_regra_w
	bulk collect into STRICT nr_sequencia_w, ie_permite_regra_w, nr_seq_apres_w, qt_registro_filho_w;
end if;

if (nr_sequencia_w.count > 0) then

	for i in nr_sequencia_w.first .. nr_sequencia_w.last loop
				
		-- se tem filhos, vali atras dos filhos primeiro

		if (qt_registro_filho_w(i) > 0) then
			
			-- vai atras os itens filhos para resolver eles primeiro

			CALL pls_sip_pck.sip_nv_vinc_regra_pai(nr_seq_lote_p, nr_sequencia_w(i), nm_usuario_p);
		end if;
		
		-- se for permitido regra faz o vinculo dos valores filhos no pai

		if (coalesce(ie_permite_regra_w(i)::text, '') = '' or ie_permite_regra_w(i) = 'S') then
		
			-- busca todos os filhos de primeiro nivel do item em questao

			for r_C01 in C01(nr_sequencia_w(i)) loop
			
				-- busca todos os registros vinculados aos itens assistenciais filhos menos os que ja estao gravados no pai

				open C02(nr_seq_lote_p, r_C01.nr_sequencia, nr_sequencia_w(i));
				loop
					fetch C02
					bulk collect into tb_dados_w, tb_casamento_w
					limit current_setting('pls_sip_pck.qt_registro_transacao_w')::integer;
								
					exit when tb_dados_w.count = 0;
						
					CALL pls_sip_pck.p_grava_vinculo_regra(nr_sequencia_w(i), null, tb_dados_w, tb_casamento_w, nm_usuario_p);
										
					commit;
				end loop;
				close C02;
				
			end loop;
		end if;
	end loop;
end if;
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_sip_pck.sip_nv_vinc_regra_pai ( nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nr_seq_item_p sip_item_assistencial.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
