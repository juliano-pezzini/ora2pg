-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


CREATE TYPE l_row AS (
	nr_seq_regra_w			sip_nv_regra_vinc_it.nr_sequencia%type,
	ie_tipo_atendimento_w		sip_nv_dados.ie_tipo_atendimento%type,
	cd_guia_w			varchar(150),
	qt_proc_mat_w			sip_nv_dados.qt_proc_mat%type,
	vl_liberado_w			sip_nv_dados.vl_liberado%type,
	nr_seq_conta_proc_w		sip_nv_dados.nr_seq_conta_proc%type,
	qt_nasc_vivos_conta_w		integer,
	nr_seq_conta_w			sip_nv_dados.nr_seq_conta%type,
	ie_tipo_despesa_w		sip_nv_dados.ie_tipo_despesa%type,
	ie_origem_info_w		sip_nv_dados.ie_origem_info%type,
	ie_glosa_conta_w		sip_nv_dados.ie_glosa_conta%type
);


CREATE OR REPLACE PROCEDURE pls_sip_pck.sip_nv_totaliza_regra ( nr_seq_item_assist_p sip_item_assistencial.nr_sequencia%type, ie_tipo_geracao_p text, nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nm_usuario_p text) AS $body$
DECLARE


ds_sql_regra_w		varchar(5000);
ds_filtro_sql_w		varchar(500);
ds_sql_w		varchar(6000);
bind_sql_w		sql_pck.t_dado_bind;
rc_cursor_w		sql_pck.t_cursor;

type l_data is table of l_row;

l_data_cursor l_data;

nr_seq_regra_w		sip_nv_regra_vinc_it.nr_sequencia%type;
ie_tipo_atendimento_w	sip_nv_dados.ie_tipo_atendimento%type;
cd_guia_w		varchar(150);
qt_proc_mat_w		sip_nv_dados.qt_proc_mat%type;
vl_liberado_w		sip_nv_dados.vl_liberado%type;
nr_seq_conta_proc_w	sip_nv_dados.nr_seq_conta_proc%type;
qt_nasc_vivos_conta_w	bigint;
nr_seq_conta_w		sip_nv_dados.nr_seq_conta%type;
ie_tipo_despesa_w	sip_nv_dados.ie_tipo_despesa%type;
ie_origem_info_w	sip_nv_dados.ie_origem_info%type;
ie_glosa_conta_w	sip_nv_dados.ie_glosa_conta%type;
ie_glosa_atendimento_w	sip_nv_dados.ie_glosa_conta%type;

type tp_guia_aux is table of varchar(150) index by varchar(150);
type tp_nasc_vivos_aux is table of bigint index by varchar(150);
sip_nv_guia_aux_w		tp_guia_aux;
sip_nv_nasc_vivo_aux_w		tp_nasc_vivos_aux;

idx_nasc_vivos_w	varchar(50);
nr_sequencia_lote	sip_item_assistencial.nr_sequencia%type;
qt_evento_w		sip_lote_item_assistencial.qt_evento%type;
qt_evento_guia_w	sip_lote_item_assistencial.qt_evento%type;
qt_nasc_vivos_w		sip_lote_item_assistencial.qt_evento%type;
vl_despesa_w		sip_lote_item_assistencial.vl_despesa%type;

qt_registro_regra_w	integer;
tb_regra_w		pls_util_cta_pck.t_number_table;
idx_regra_w		integer;
ie_conta_evento_w	varchar(1);
	
c_dados CURSOR(nr_seq_item_assist_pc	sip_item_assistencial.nr_sequencia%type) FOR
	SELECT	ie_tipo_contratacao,
		ie_segmentacao_sip,
		sg_uf,
		dt_atendimento
	from	w_sip_dt_atendimento
	where	nr_seq_item_assist = nr_seq_item_assist_pc;
		
BEGIN	
	-- define o comando select que ira buscar os dados para contagem

	-- Na quantidade de itens e usado o round para que nao apareca casa decimais 

	-- na quantidade de eventos do item assistencial, pois a quantidade de alguns procedimentos ou materiais pode 

	-- nao ser um numero inteiro.

	ds_sql_regra_w :=	'select	b.nr_sequencia nr_seq_regra,' || pls_util_pck.enter_w ||
				'	a.ie_tipo_atendimento,' || pls_util_pck.enter_w || 
				-- Para reembolsos nao tem guia, concatena com o campo NR_DOCUMENTO por que este 

				-- e o que identifica cada um dos atendimentos.

				'	decode(a.ie_tipo_protocolo,' || pls_util_pck.enter_w || 
				'		 ''R'', to_char(a.nr_documento),' || pls_util_pck.enter_w || 
				'		 nvl(a.cd_guia_referencia, a.cd_guia)) || ''||'' || to_char(a.nr_seq_segurado) cd_guia,' || pls_util_pck.enter_w || 
				' 	round(a.qt_proc_mat),' || pls_util_pck.enter_w || 
				'	a.vl_liberado,' || pls_util_pck.enter_w || 
				'	a.nr_seq_conta_proc,' || pls_util_pck.enter_w || 
				-- jjung OS 635866 - Conforme visto com Gustavo - HSJ e observando as rotinas de importacao das contas medicas no portal,

				-- o campo QT_NASC_VIVO nao e mais utilizado e nao deve ser considerado, pois os valores do campo estao sendo gravados

				-- no campo QT_NADC_VIVO_TERMO, existiam no HSJ algumas contas onde havia informado o campo QT_NASC_VIVO e o campo

				-- QT_NASC_VIVO_TERMO e por este motivo o numero de Nascidos vivos estava sendo gerado muito alto. O campo foi removido do

				-- somatorio mas foi mantido na estrutra do SIP_NV_DADOS por motivos de seguranca. Caso seja alterado o processo novamente sera facil

				-- reimplementar o tratamento do campo.

				'	nvl(a.qt_nasc_vivos_total, 0) qt_nasc_vivos_total,' || pls_util_pck.enter_w || 				
				'	a.nr_seq_conta nr_seq_conta,' || pls_util_pck.enter_w || 
				' 	a.ie_tipo_despesa,' || pls_util_pck.enter_w || 
				' 	a.ie_origem_info, ' || pls_util_pck.enter_w || 	
				' 	a.ie_glosa_conta ' || pls_util_pck.enter_w || 
				'from	sip_nv_dados a,' || pls_util_pck.enter_w || 
				'	sip_nv_regra_vinc_it b ' || pls_util_pck.enter_w || 
				'where a.nr_seq_lote_sip	= :nr_seq_lote_sip' || pls_util_pck.enter_w || 
				'and	a.ie_tipo_contratacao	= :ie_tipo_contratacao' || pls_util_pck.enter_w || 
				'and	a.ie_segmentacao_sip	= :ie_segmentacao_sip' || pls_util_pck.enter_w ||
				'and	a.dt_atendimento	= :dt_ocorrencia' || pls_util_pck.enter_w ||
				'and	b.nr_seq_item_assist 	= :nr_seq_item_assist' || pls_util_pck.enter_w || 
				'and	b.nr_seq_sip_nv_dados 	= a.nr_sequencia ' || pls_util_pck.enter_w;
	
	-- busca todos os dados que existem para o item assistencial

	for r_c_dados_w in c_dados(nr_seq_item_assist_p) loop
				
		bind_sql_w.delete;
		
		bind_sql_w := sql_pck.bind_variable(':nr_seq_lote_sip', nr_seq_lote_p, bind_sql_w);
		bind_sql_w := sql_pck.bind_variable(':ie_tipo_contratacao', r_c_dados_w.ie_tipo_contratacao, bind_sql_w);
		bind_sql_w := sql_pck.bind_variable(':ie_segmentacao_sip', r_c_dados_w.ie_segmentacao_sip, bind_sql_w);
		bind_sql_w := sql_pck.bind_variable(':dt_ocorrencia', r_c_dados_w.dt_atendimento, bind_sql_w);
		bind_sql_w := sql_pck.bind_variable(':nr_seq_item_assist', nr_seq_item_assist_p, bind_sql_w);
	
		-- se tiver UF filtra pela mesma

		ds_filtro_sql_w := null;
		
		if (r_c_dados_w.sg_uf != 'NC') then
			ds_filtro_sql_w := 'and a.sg_uf = :sg_uf';
			bind_sql_w := sql_pck.bind_variable(':sg_uf', r_c_dados_w.sg_uf, bind_sql_w);
		end if;
		
		ds_sql_w := ds_sql_regra_w || ds_filtro_sql_w || pls_util_pck.enter_w || ' order by a.qt_nasc_vivos_total ' || pls_util_pck.enter_w;
		
		bind_sql_w := sql_pck.executa_sql_cursor(ds_sql_w, bind_sql_w);
		
		qt_evento_w := 0;
		vl_despesa_w := 0;
		qt_nasc_vivos_w := 0;
		-- apaga todos os dados das tabelas temporarias que e utilizada para contar o numero de guias e nascidos vivos

		sip_nv_guia_aux_w.delete;
		sip_nv_nasc_vivo_aux_w.delete;
		idx_regra_w := 0;
		qt_registro_regra_w := 0;
		-- percorre os dados e faz os somatorios

		loop
			-- busca os registros com um fetch bulk

			fetch rc_cursor_w bulk collect into l_data_cursor limit current_setting('pls_sip_pck.qt_registro_transacao_w')::integer;
						
			exit when l_data_cursor.count = 0;
			
			for i in l_data_cursor.first..l_data_cursor.last loop
			
				-- alimenta as variaveis que serao utilizadas abaixo

				nr_seq_regra_w		:= l_data_cursor[i].nr_seq_regra_w;
				ie_tipo_atendimento_w	:= l_data_cursor[i].ie_tipo_atendimento_w;
				cd_guia_w		:= l_data_cursor[i].cd_guia_w;
				qt_proc_mat_w		:= l_data_cursor[i].qt_proc_mat_w;
				vl_liberado_w		:= l_data_cursor[i].vl_liberado_w;
				nr_seq_conta_proc_w	:= l_data_cursor[i].nr_seq_conta_proc_w;
				qt_nasc_vivos_conta_w	:= l_data_cursor[i].qt_nasc_vivos_conta_w;
				nr_seq_conta_w		:= l_data_cursor[i].nr_seq_conta_w;
				ie_tipo_despesa_w	:= l_data_cursor[i].ie_tipo_despesa_w;
				ie_origem_info_w	:= l_data_cursor[i].ie_origem_info_w;
				ie_glosa_conta_w	:= l_data_cursor[i].ie_glosa_conta_w;
				
				-- insere o registro do item do lote para ter como alimentar a tabela SIP_NV_VINC_DADOS

				-- sem problemas de integridade

				-- insere o item so na primeira vez, pois dentro deste loop e feita a contagem dos numeros

				-- que no final desta rotina sao atualizados de acordo com a contagem

				if (qt_registro_regra_w = 0) then
					-- faz um insert na tabela do lote e retorna a sequencia no ultimo parametro

					nr_sequencia_lote := pls_sip_pck.sip_nv_insere_lote(	nr_seq_item_assist_p, nr_seq_lote_p, r_c_dados_w.sg_uf, r_c_dados_w.ie_tipo_contratacao, r_c_dados_w.ie_segmentacao_sip, r_c_dados_w.dt_atendimento, 0, 0, nm_usuario_p, nr_sequencia_lote);
				end if;
				
				tb_regra_w(idx_regra_w) := nr_seq_regra_w;

				-- se tem registros o suficiente para atualizar faz o vinculo entre as regras e os dados com o item do lote do sip

				if (idx_regra_w >= current_setting('pls_sip_pck.qt_registro_transacao_w')::integer) then
				
					sip_nv_insere_vinc_dados( nr_sequencia_lote, tb_regra_w, nm_usuario_p);
					tb_regra_w.delete;
					idx_regra_w := 0;
					
				-- se nao bota na fila e fica na espera.

				else
					idx_regra_w := idx_regra_w + 1;
				end if;
				
				ie_conta_evento_w := 'S';
		
				-- Esse aqui e temporario, apenas para nao considerar no somatorio de eventos, os "recursos de glosa" 

				-- que a Rio Preto

				-- cadastrou como conta (Identificados pelo inicio 70 no codigo da guia).

				-- sumir com isso daqui em 23/02/2016 - dlehmkuhl

				if (current_setting('pls_sip_pck.ie_rio_preto_w')::varchar(1) = 'S') then
					if (substr(cd_guia_w, 1, 2)  = '70') then
						ie_conta_evento_w := 'N';
					end if;
				end if;
				
				-- Recurso de Glosa econtas de intercambio passa a contar nos eventos, baseado em algumas regras para nao duplicar a quantidade de eventos para o mesmo procedimento.

				-- feito um parametro para alterar entre o calculo antigo e novo 

				if	((ie_conta_evento_w = 'S') and (current_setting('pls_sip_pck.param_w')::param.ie_novo_sip = 'S')) or
					((ie_origem_info_w not in ('RG', 'CI') and ie_conta_evento_w = 'S') and (current_setting('pls_sip_pck.param_w')::param.ie_novo_sip = 'N')) then
				
					
					-- jjung OS 592978 - Para o item G - Nascidos Vivos deve ser contado nos eventos a quantidade de nascidos vivos na PLS_CONTA.

					if (nr_seq_item_assist_p = 108) then
						-- E inserido na tabela auxiliar W_SIP_NV_NASC_VIVO_AUX para que seja contado a quantidade de nascidos vivos para cada  conta apenas uma vez, devido a estrutura 

						-- do SIP gravar na SIP_NV_DADOS as quantidades para cada um dos itens da conta.

						
						-- Somente quando for recurso de glosa e item G, e necessario levantar se a conta original esta completamente glosada.

						-- Isso nao e feito na carga de dados da SIP_NV_DADOS, porque essa informacao e usada para vincular a conta a uma regra,

						-- Para o recurso de glosa, caso esteja marcado la na carga de dados essa informacao, o recurso pode deixar de ser vinculado corretamente, 

						-- uma vez que via de regra uma conta glosada nao pode ser vinculada a nenhuma regra.

						if (ie_origem_info_w in ('RG', 'CI')) then
						
							ie_glosa_conta_w := pls_obter_se_conta_glosada(nr_seq_conta_w);
						end if;
						
						-- Quando for recurso de glosa, so deve contar os nascidos vivos caso a conta origem tenha sido totalmente glosada, senao deve

						-- ser zero, para evitar duplicar o valor.

						
						if	(((ie_origem_info_w in ('RG', 'CI')) and (ie_glosa_conta_w = 'S')) or (not ie_origem_info_w in ('RG', 'CI'))) then
						
							sip_nv_nasc_vivo_aux_w(cd_guia_w) := qt_nasc_vivos_conta_w;
						
						end if;
						
					--se for internacao ou estiver em Outros Atendimentos Ambulatoriais armazena na tabela para contar posteriormente

					elsif (ie_tipo_atendimento_w = 'I') then		
					
						-- a excecao apenas ignora os itens que nao deram certo no insert porque ja existem na tabela

						
						-- Somente quando for recurso de glosa e internacao, e necessario levantar se o atendimento original esta completamente glosada.

						-- Isso nao e feito na carga de dados da SIP_NV_DADOS, porque essa informacao e usada para vincular a conta a uma regra,

						-- Para o recurso de glosa, caso esteja marcado la na carga de dados essa informacao, o recurso pode deixar de ser vinculado corretamente, 

						-- uma vez que via de regra uma conta glosada nao pode ser vinculada a nenhuma regra.

						if (ie_origem_info_w in ('RG', 'CI')) then
						
							ie_glosa_atendimento_w := pls_sip_pck.obter_se_atendimento_glosado(nr_seq_conta_w);
						end if;
						
						
						-- Quando for recurso de glosa, so deve considerar a guia caso o atendimento origem tenha sido totalmente glosada, senao deve ser zero, para evitar duplicar o valor.

						if	(((ie_origem_info_w in ('RG', 'CI')) and (ie_glosa_atendimento_w = 'S')) or (not ie_origem_info_w in ('RG', 'CI'))) then
							
							sip_nv_guia_aux_w(cd_guia_w) := cd_guia_w;
						end if;
					else
						-- so conta se for procedimento para o mundo ambulatorial

						if (nr_seq_conta_proc_w IS NOT NULL AND nr_seq_conta_proc_w::text <> '') then
							-- Se nao for para considerar taxas, diarias, materiais, medicamentos, OPM, pacotes e gases medicinais

							-- Vai verificar o tipo de despesa.

							if (current_setting('pls_sip_pck.param_w')::param.ie_sip_contagem_evento = 'S') then
								-- se nao for procedimentos zera a quantidade para nao contar na soma.

								if (ie_tipo_despesa_w not in ('1', '4')) then
								
									qt_proc_mat_w	:= 0;
								end if;
							end if;
							
							qt_evento_w := qt_evento_w + coalesce(qt_proc_mat_w, 0);
						end if;
					end if;
				end if;
				
				vl_despesa_w := vl_despesa_w + coalesce(vl_liberado_w, 0);
				
				qt_registro_regra_w := qt_registro_regra_w + 1;
			end loop;
		end loop;
		close rc_cursor_w;
		
		-- se o cursor acima retornou registros contabiliza os totais a atualiza no item do lote

		if (qt_registro_regra_w > 0) then
			-- Processar os dados que sobraram.

			sip_nv_insere_vinc_dados( nr_sequencia_lote, tb_regra_w, nm_usuario_p);
			tb_regra_w.delete;
			
			-- contar os eventos das internacoes.

			qt_evento_guia_w	:= sip_nv_guia_aux_w.count;
			
			-- contar os eventos de nascidos vivos.

			if (sip_nv_nasc_vivo_aux_w.count > 0) then
				
				idx_nasc_vivos_w := sip_nv_nasc_vivo_aux_w.first;
				
				while(idx_nasc_vivos_w IS NOT NULL AND idx_nasc_vivos_w::text <> '') loop
				
					qt_nasc_vivos_w := qt_nasc_vivos_w + sip_nv_nasc_vivo_aux_w(idx_nasc_vivos_w);
					
					idx_nasc_vivos_w := sip_nv_nasc_vivo_aux_w.next(idx_nasc_vivos_w);
				end loop;
			end if;
			
			-- inclui os eventos das guias

			qt_evento_w := qt_evento_w + qt_evento_guia_w + qt_nasc_vivos_w;
			
			-- se for internacao e tiver evento zerado coloca um fixo

			-- para internacao e tudo feito aqui, para o mundo ambulatorial isto e feito na consistir_qtde_evento

			-- o motivo de fazer para internacao aqui e que os itens pais da internacao sao somados e nao vinculados a regras como acontecer

			-- nos itens do mundo ambulatorial

			if (nr_seq_item_assist_p between 64 and 108) then
				if (qt_evento_w = 0 and vl_despesa_w > 0) then
					qt_evento_w := 1;			
				end if;
			end if;
			
			-- atualiza os dados do lote do sip

			update	sip_lote_item_assistencial
			set	qt_evento	= qt_evento_w,
				vl_despesa	= vl_despesa_w
			where	nr_sequencia	= nr_sequencia_lote;
			
			commit;
		end if;
	end loop;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_sip_pck.sip_nv_totaliza_regra ( nr_seq_item_assist_p sip_item_assistencial.nr_sequencia%type, ie_tipo_geracao_p text, nr_seq_lote_p pls_lote_sip.nr_sequencia%type, nm_usuario_p text) FROM PUBLIC;
