-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION pls_pp_tributacao_pck.obter_regra_trib_tit_pagar_pf ( cd_pessoa_fisica_p pessoa_fisica.cd_pessoa_fisica%type, cd_tributo_p tributo.cd_tributo%type, vl_base_calc_p pls_pp_valor_trib_pessoa.vl_base_total%type, ie_tipo_contratacao_p pls_pp_valor_trib_pessoa.ie_tipo_contratacao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, dt_referencia_p timestamp, nr_seq_tipo_prest_p pls_tipo_prestador.nr_sequencia%type, nr_seq_class_prestador_p pls_prestador.nr_seq_classificacao%type, pr_aliquota_p out tributo_conta_pagar.pr_aliquota%type, cd_cond_pagto_p out tributo_conta_pagar.cd_cond_pagto%type, ie_acumulativo_p out tributo_conta_pagar.ie_acumulativo%type, vl_teto_base_calc_p out tributo_conta_pagar.vl_teto_base_calculo%type, vl_desc_dependente_p out tributo_conta_pagar.vl_desc_dependente%type, vl_minimo_p out tributo_conta_pagar.vl_minimo%type, vl_minimo_tributo_p out tributo_conta_pagar.vl_minimo_tributo%type, nr_seq_trans_reg_p out tributo_conta_pagar.nr_seq_trans_reg%type, nr_seq_trans_baixa_p out tributo_conta_pagar.nr_seq_trans_baixa%type, cd_beneficiario_p out tributo_conta_pagar.cd_beneficiario%type, ie_periodicidade_p out tributo_dctf.ie_periodicidade%type, cd_variacao_p out tributo_dctf.cd_variacao%type, cd_darf_p out tributo_conta_pagar.cd_darf%type, nr_seq_classe_p out tributo_conta_pagar.nr_seq_classe%type, cd_tipo_baixa_neg_p out tributo_conta_pagar.cd_tipo_baixa_neg%type, cd_conta_financ_p out tributo_conta_pagar.cd_conta_financ%type) AS $body$
DECLARE


cd_municipio_ibge_w	compl_pessoa_fisica.cd_municipio_ibge%type;
cd_empresa_w		estabelecimento.cd_empresa%type;
ie_regra_valida_w	boolean;
nr_seq_regra_w		tributo_conta_pagar.nr_sequencia%type;

c01 CURSOR(	cd_tributo_pc		tributo.cd_tributo%type,
		cd_empresa_pc		estabelecimento.cd_empresa%type,
		dt_referencia_pc	timestamp) FOR
	SELECT	cp.nr_sequencia,
		cp.pr_aliquota,
		cp.cd_cond_pagto,
		cp.vl_minimo,
		cp.vl_minimo_tributo,
		cp.ie_acumulativo,
		cp.vl_teto_base_calculo,
		cp.vl_desc_dependente,
		cp.cd_municipio_ibge,
		cp.ie_tipo_contratacao,
		cp.cd_estabelecimento,
		cp.ie_origem_titulo,
		cp.vl_base_inicial,
		cp.vl_base_final,
		cp.cd_pessoa_fisica,
		cp.nr_seq_tipo_prestador,
		cp.nr_seq_trans_reg,
		cp.nr_seq_trans_baixa,
		cp.cd_beneficiario,
		coalesce(cp.cd_darf,t.cd_retencao) cd_darf,
		cp.nr_seq_classe,
		cp.cd_tipo_baixa_neg,
		cp.cd_conta_financ,
		cp.nr_seq_class_prestador
	from	tributo_conta_pagar cp,
		tributo t
	where	cp.cd_tributo = t.cd_tributo
	and	cp.cd_tributo = cd_tributo_pc
	and	cp.cd_empresa = cd_empresa_pc
	and	dt_referencia_pc between cp.dt_inicio_vigencia_ref and cp.dt_fim_vigencia_ref
	and	cp.ie_tipo_pessoa in ('A', 'F')
	and	coalesce(cp.cd_pessoa_juridica::text, '') = ''
	order by
		coalesce(cp.cd_pessoa_fisica,' ') desc,
		coalesce(cp.ie_tipo_contratacao,' ') desc,
		coalesce(cp.cd_municipio_ibge,'0') desc,
		coalesce(cp.ie_origem_titulo,0) desc;

c02 CURSOR(	cd_tributo_pc		tributo.cd_tributo%type,
		dt_referencia_pc	timestamp) FOR
	SELECT	a.ie_periodicidade,
		a.cd_variacao
	from	tributo_dctf a
	where	a.cd_tributo = cd_tributo_pc
	and	dt_referencia_pc >= a.dt_inicio_vigencia
	and	coalesce(a.dt_fim_vigencia::text, '') = ''
	
union all

	SELECT	a.ie_periodicidade,
		a.cd_variacao
	from	tributo_dctf a
	where	a.cd_tributo = cd_tributo_pc
	and	dt_referencia_pc between a.dt_inicio_vigencia and a.dt_fim_vigencia;

BEGIN

if (cd_tributo_p IS NOT NULL AND cd_tributo_p::text <> '') and (cd_pessoa_fisica_p IS NOT NULL AND cd_pessoa_fisica_p::text <> '') then

	select	max(cd_empresa)
	into STRICT	cd_empresa_w
	from	estabelecimento
	where	cd_estabelecimento = cd_estabelecimento_p;

	-- busca o codigo do municipio do tipo de complemento 1 - residencial

	select	max(cd_municipio_ibge)
	into STRICT	cd_municipio_ibge_w
	from	compl_pessoa_fisica a
	where	a.cd_pessoa_fisica = cd_pessoa_fisica_p
	and	a.ie_tipo_complemento = 1;

	for r_c01_w in c01(cd_tributo_p, cd_empresa_w, dt_referencia_p) loop

		-- a regra comeca sendo valida

		ie_regra_valida_w := true;

		-- se tiver o estabelecimento informado na regra deve ser igual ao estabelecimento atual

		if (r_c01_w.cd_estabelecimento IS NOT NULL AND r_c01_w.cd_estabelecimento::text <> '') and (r_c01_w.cd_estabelecimento != cd_estabelecimento_p) then
			ie_regra_valida_w := false;
		end if;

		-- se tem origem do titulo informada a mesma deve ser 25 - OPS - Pagamentos de Producao Medica (nova)

		if (r_c01_w.ie_origem_titulo IS NOT NULL AND r_c01_w.ie_origem_titulo::text <> '') and (r_c01_w.ie_origem_titulo != '25') then
			ie_regra_valida_w := false;
		end if;

		-- se esta informada a base de calculo inicial entao verifica se a base que esta sendo calculada e maior que a inicial

		if (r_c01_w.vl_base_inicial IS NOT NULL AND r_c01_w.vl_base_inicial::text <> '') and (r_c01_w.vl_base_inicial >= vl_base_calc_p) then
			ie_regra_valida_w := false;
		end if;

		-- se esta informada a base de calculo final entao verifica se a base que esta sendo calculada e menor que a final

		if (r_c01_w.vl_base_final IS NOT NULL AND r_c01_w.vl_base_final::text <> '') and (r_c01_w.vl_base_final <= vl_base_calc_p) then
			ie_regra_valida_w := false;
		end if;

		-- se a regra for por tipo de contratacao entao deve ser o mesmo tipo de contratacao que estamos calculando

		if (r_c01_w.ie_tipo_contratacao IS NOT NULL AND r_c01_w.ie_tipo_contratacao::text <> '') and (r_c01_w.ie_tipo_contratacao != ie_tipo_contratacao_p) then
			ie_regra_valida_w := false;
		end if;
		
		-- se tiver o campo de codigo do municipio informado, entao verificamos

		if (r_c01_w.cd_municipio_ibge IS NOT NULL AND r_c01_w.cd_municipio_ibge::text <> '') and (r_c01_w.cd_municipio_ibge != cd_municipio_ibge_w) then
			ie_regra_valida_w := false;
		end if;

		-- se for regra por PF

		if (r_c01_w.cd_pessoa_fisica IS NOT NULL AND r_c01_w.cd_pessoa_fisica::text <> '') and (r_c01_w.cd_pessoa_fisica != cd_pessoa_fisica_p) then
			ie_regra_valida_w := false;
		end if;

		-- se a regra possui filtro por tipo de prestador, entao deve ser igual

		if (r_c01_w.nr_seq_tipo_prestador IS NOT NULL AND r_c01_w.nr_seq_tipo_prestador::text <> '') and (r_c01_w.nr_seq_tipo_prestador != nr_seq_tipo_prest_p) then
			ie_regra_valida_w := false;
		end if;
		
		-- se a regra possui filtro por classificacao de prestador, entao deve ser igual

		if (r_c01_w.nr_seq_class_prestador IS NOT NULL AND r_c01_w.nr_seq_class_prestador::text <> '') and (r_c01_w.nr_seq_class_prestador != nr_seq_class_prestador_p) then
			ie_regra_valida_w := false;
		end if;
		
		-- se apos todas verificacoes ainda for valida entao e a regra correta, alimenta as 

		-- variaveis e sai do loop

		if (ie_regra_valida_w) then

			-- alimenta os parametros OUT

			pr_aliquota_p		:= r_c01_w.pr_aliquota;
			cd_cond_pagto_p		:= r_c01_w.cd_cond_pagto;
			ie_acumulativo_p	:= r_c01_w.ie_acumulativo;
			vl_teto_base_calc_p	:= r_c01_w.vl_teto_base_calculo;
			vl_desc_dependente_p	:= r_c01_w.vl_desc_dependente;
			vl_minimo_p		:= r_c01_w.vl_minimo;
			vl_minimo_tributo_p	:= r_c01_w.vl_minimo_tributo;
			nr_seq_trans_reg_p	:= r_c01_w.nr_seq_trans_reg;
			nr_seq_trans_baixa_p	:= r_c01_w.nr_seq_trans_baixa;
			cd_beneficiario_p	:= r_c01_w.cd_beneficiario;
			cd_darf_p		:= r_c01_w.cd_darf;
			nr_seq_classe_p		:= r_c01_w.nr_seq_classe;
			cd_tipo_baixa_neg_p 	:= r_c01_w.cd_tipo_baixa_neg;
			cd_conta_financ_p 	:= r_c01_w.cd_conta_financ;
			nr_seq_regra_w 		:= r_c01_w.nr_sequencia;

			-- sai do loop e fecha o cursor

			exit;
		end if;
	end loop;
end if;

-- esses campos serao utilizados na geracao dos titulos dos tributos

for r_c02_w in c02(cd_tributo_p, dt_referencia_p) loop

	ie_periodicidade_p := r_c02_w.ie_periodicidade;
	cd_variacao_p := r_c02_w.cd_variacao;

	-- o primeiro registro que encontrar ja e valido na rotina original nao possui ordenacao

	exit;
end loop;

return;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pls_pp_tributacao_pck.obter_regra_trib_tit_pagar_pf ( cd_pessoa_fisica_p pessoa_fisica.cd_pessoa_fisica%type, cd_tributo_p tributo.cd_tributo%type, vl_base_calc_p pls_pp_valor_trib_pessoa.vl_base_total%type, ie_tipo_contratacao_p pls_pp_valor_trib_pessoa.ie_tipo_contratacao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, dt_referencia_p timestamp, nr_seq_tipo_prest_p pls_tipo_prestador.nr_sequencia%type, nr_seq_class_prestador_p pls_prestador.nr_seq_classificacao%type, pr_aliquota_p out tributo_conta_pagar.pr_aliquota%type, cd_cond_pagto_p out tributo_conta_pagar.cd_cond_pagto%type, ie_acumulativo_p out tributo_conta_pagar.ie_acumulativo%type, vl_teto_base_calc_p out tributo_conta_pagar.vl_teto_base_calculo%type, vl_desc_dependente_p out tributo_conta_pagar.vl_desc_dependente%type, vl_minimo_p out tributo_conta_pagar.vl_minimo%type, vl_minimo_tributo_p out tributo_conta_pagar.vl_minimo_tributo%type, nr_seq_trans_reg_p out tributo_conta_pagar.nr_seq_trans_reg%type, nr_seq_trans_baixa_p out tributo_conta_pagar.nr_seq_trans_baixa%type, cd_beneficiario_p out tributo_conta_pagar.cd_beneficiario%type, ie_periodicidade_p out tributo_dctf.ie_periodicidade%type, cd_variacao_p out tributo_dctf.cd_variacao%type, cd_darf_p out tributo_conta_pagar.cd_darf%type, nr_seq_classe_p out tributo_conta_pagar.nr_seq_classe%type, cd_tipo_baixa_neg_p out tributo_conta_pagar.cd_tipo_baixa_neg%type, cd_conta_financ_p out tributo_conta_pagar.cd_conta_financ%type) FROM PUBLIC;
