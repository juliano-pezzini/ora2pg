-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_pp_apropriacao_pck.gerencia_valores_apropriacao ( nr_seq_lote_p pls_pp_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


-- verifica nos registros que precisam ser tomadas ações para pagamento negativo, os registro que são
-- para gerar apropriação e insere estes na tabela de apropriação, gerando assim uma nova 'divida' para o prestador
-- também são atualizados registros que já são de apropriação e não foram quitados neste lote, para isso só atualizamos
-- o valor da divida na tabela
tb_nr_seq_item_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_evento_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_evt_orig_w	pls_util_cta_pck.t_number_table;
tb_vl_negativo_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_prestador_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_lote_w	pls_util_cta_pck.t_number_table;

-- o case when é para tratar a situação onde existe uma regra que diz que o evento a ser utilizado
-- na apropriação pode ser o evento original ou um evento que é informado nos parâmetros da operadora
c01 CURSOR(	nr_seq_lote_pc			pls_pp_lote.nr_sequencia%type,
		ie_regra_usa_event_orig_pc	pls_parametro_pagamento.ie_evento_orig_prox_pagto%type,
		nr_seq_evento_param_op_pc	pls_parametro_pagamento.nr_seq_evento_prox_pgto%type) FOR
	SELECT	a.nr_sequencia,
		a.nr_seq_evento nr_seq_evento_orig,
		a.vl_acao_negativo,
		a.nr_seq_prestador,
		case ie_regra_usa_event_orig_pc
			when 'S' then
				a.nr_seq_evento
			else
				nr_seq_evento_param_op_pc
		end nr_seq_evento,
		a.nr_seq_lote
	from	pls_pp_item_lote a
	where	a.nr_seq_lote = nr_seq_lote_pc
	and	a.ie_acao_negativo = 'S'
	and	a.ie_acao_pgto_negativo = 'PP'
	and	coalesce(a.nr_seq_pp_it_aprop::text, '') = ''
	
union all

	SELECT	a.nr_sequencia,
		a.nr_seq_evento nr_seq_evento_orig,
		a.vl_acao_negativo,
		a.nr_seq_prestador,
		case ie_regra_usa_event_orig_pc
			when 'S' then
				a.nr_seq_evento
			else
				nr_seq_evento_param_op_pc
		end nr_seq_evento,
		a.nr_seq_lote
	from	pls_pp_item_lote a,
		pls_pp_prestador b
	where	a.nr_seq_lote = nr_seq_lote_pc
	and	a.ie_acao_negativo = 'S'
	and	a.ie_acao_pgto_negativo = 'CP'
	and	b.nr_seq_prestador = a.nr_seq_prestador
	and	b.ie_acao_pgto_negativo = 'PP'
	and	coalesce(a.nr_seq_pp_it_aprop::text, '') = '';

c02 CURSOR(	nr_seq_lote_pc	pls_pp_lote.nr_sequencia%type) FOR
	SELECT	a.nr_seq_pp_it_aprop,
		a.vl_acao_negativo
	from	pls_pp_item_lote a,
		pls_pp_item_apropriacao b
	where	a.nr_seq_lote = nr_seq_lote_pc
	and	a.ie_acao_negativo = 'S'
	and	b.nr_sequencia = a.nr_seq_pp_it_aprop
	and	b.ie_baixado = 'N';


BEGIN

-- insere os novos registros de apropriação
open c01(nr_seq_lote_p, pls_pp_lote_pagamento_pck.ie_evento_orig_prox_pagto_w, pls_pp_lote_pagamento_pck.nr_seq_evento_prox_pgto_w);
loop
	fetch c01 bulk collect into 	tb_nr_seq_item_w ,tb_nr_seq_evt_orig_w, tb_vl_negativo_w,
					tb_nr_seq_prestador_w, tb_nr_seq_evento_w, tb_nr_seq_lote_w
	limit pls_util_pck.qt_registro_transacao_w;
	exit when tb_nr_seq_item_w.count = 0;

	forall i in tb_nr_seq_item_w.first..tb_nr_seq_item_w.last
		insert into pls_pp_item_apropriacao(
			nr_sequencia, ie_baixado, nr_seq_evento,
			nr_seq_evento_orig, nr_seq_it_lote_orig, nr_seq_prestador,
			vl_divida, dt_atualizacao, dt_atualizacao_nrec,
			nm_usuario, nm_usuario_nrec, nr_seq_lote_orig
		) values (
			nextval('pls_pp_item_apropriacao_seq'), 'N', tb_nr_seq_evento_w(i),
			tb_nr_seq_evt_orig_w(i), tb_nr_seq_item_w(i), tb_nr_seq_prestador_w(i),
			tb_vl_negativo_w(i), clock_timestamp(), clock_timestamp(),
			nm_usuario_p, nm_usuario_p, tb_nr_seq_lote_w(i)
		);
	commit;
end loop;
close c01;

tb_nr_seq_item_w.delete;
tb_vl_negativo_w.delete;

-- atualiza os registros que entraram no lote mas não foram totalmente quitados
open c02(nr_seq_lote_p);
loop
	fetch c02 bulk collect into	tb_nr_seq_item_w, tb_vl_negativo_w
	limit pls_util_pck.qt_registro_transacao_w;
	exit when tb_nr_seq_item_w.count = 0;

	forall i in tb_nr_seq_item_w.first..tb_nr_seq_item_w.last
		update 	pls_pp_item_apropriacao
		set	vl_divida = tb_vl_negativo_w(i),
			nm_usuario = nm_usuario_p,
			dt_atualizacao = clock_timestamp()
		where	nr_sequencia = tb_nr_seq_item_w(i);
	commit;
end loop;
close c02;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_pp_apropriacao_pck.gerencia_valores_apropriacao ( nr_seq_lote_p pls_pp_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
