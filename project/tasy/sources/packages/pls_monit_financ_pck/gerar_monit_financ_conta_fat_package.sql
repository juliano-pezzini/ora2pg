-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


-- 1 - Rotina para gerar o monitoramento financeiro das contas fora de faturamento e deviam ser faturadas
CREATE OR REPLACE PROCEDURE pls_monit_financ_pck.gerar_monit_financ_conta_fat ( nm_usuario_p usuario.nm_usuario%type ) AS $body$
DECLARE


dt_ref_inicial_w	timestamp := trunc(clock_timestamp() - interval '300 days');
dt_ref_final_w		timestamp := fim_dia(clock_timestamp() - interval '30 days');
dt_atual_w		timestamp := clock_timestamp();
nr_dias_w		w_pls_monit_fin_cta_fat.nr_dias%type;
qt_commit_w		integer := 1;
ie_novo_pos_estab_w	pls_visible_false.ie_novo_pos_estab%type;
qt_registro_w		integer;
ie_origem_valor_pos_w	w_pls_monit_fin_cta_fat.ie_origem_valor_pos%type;

C01 CURSOR(dt_ref_inicial_pc	timestamp,
		dt_ref_final_pc		timestamp,
		ie_novo_pos_estab_pc	pls_visible_false.ie_novo_pos_estab%type ) FOR
	SELECT	c.dt_atendimento_referencia dt_atendimento_ref,
		c.nr_sequencia nr_seq_conta,
		x.nr_seq_conta_proc,
		x.nr_seq_conta_mat,
		x.vl_beneficiario vl_pos_estab,
		x.vl_administracao vl_pos_estab_taxa,
		x.nr_sequencia nr_seq_conta_pos,
		c.cd_estabelecimento,
		x.nr_seq_mensalidade_seg,
		x.nr_seq_mat_rec,
		x.nr_seq_proc_rec,
		x.nr_seq_disc_mat,
		x.nr_seq_disc_proc,
		x.nr_seq_lote_disc,
		y.nr_seq_ajuste_fat,
		z.ie_tipo_protocolo,
                x.ie_status_faturamento,
                c.ie_status_fat
	from	pls_conta_pos_cab_v		c,
		pls_conta_pos_estabelecido	x,
		pls_conta			y,
		pls_protocolo_conta		z
	where	x.nr_seq_conta		= c.nr_sequencia
	and	y.nr_sequencia		= x.nr_seq_conta
	and	z.nr_sequencia		= y.nr_seq_protocolo
	and	x.ie_status_faturamento	in ('L','P') -- Liberado para faturamento / Permitido faturamento
	and	x.ie_situacao 		= 'A' -- Status Ativo
	and	x.ie_status_faturamento	= 'L' -- Liberado para faturamento
	and	c.ie_status_fat		in ('L','P') -- Liberado para faturamento
	and	ie_novo_pos_estab_pc	= 'N'
	and	c.dt_atendimento_referencia between dt_ref_inicial_pc and dt_ref_final_pc
	
union

	SELECT	c.dt_atendimento_referencia dt_atendimento_ref,
		c.nr_sequencia nr_seq_conta,
		x.nr_seq_conta_proc,
		null nr_seq_conta_mat,
		coalesce(x.vl_medico, 0) + coalesce(x.vl_materiais, 0) + coalesce(x.vl_custo_operacional, 0) vl_pos_estab,
		coalesce(x.vl_lib_taxa_co, 0) + coalesce(x.vl_lib_taxa_material, 0) + coalesce(x.vl_lib_taxa_servico, 0) vl_pos_estab_taxa,
		x.nr_sequencia nr_seq_conta_pos,
		c.cd_estabelecimento,
		null nr_seq_mensalidade_seg,
		null nr_seq_mat_rec,
		x.nr_seq_proc_rec,
		null nr_seq_disc_mat,
		x.nr_seq_disc_proc,
		x.nr_seq_lote_disc,
		y.nr_seq_ajuste_fat,
		z.ie_tipo_protocolo,
                x.ie_status_faturamento,
                c.ie_status_fat
	from	pls_conta_pos_cab_v		c,
		pls_conta_pos_proc		x,
		pls_conta			y,
		pls_protocolo_conta		z
	where	x.nr_seq_conta		= c.nr_sequencia
	and	y.nr_sequencia		= x.nr_seq_conta
	and	z.nr_sequencia		= y.nr_seq_protocolo
	and	x.ie_status_faturamento	= 'L' -- Liberado para faturamento
	and	c.ie_status_fat		in ('L','P') -- Liberado para faturamento
	and	c.ie_status		= 'F' -- Fechado
	and	ie_novo_pos_estab_pc	= 'S'
	and	c.dt_atendimento_referencia between dt_ref_inicial_pc and dt_ref_final_pc
	
union

	select	c.dt_atendimento_referencia dt_atendimento_ref,
		c.nr_sequencia nr_seq_conta,
		null nr_seq_conta_proc,
		x.nr_seq_conta_mat,
		x.vl_materiais vl_pos_estab,
		x.vl_lib_taxa_material vl_pos_estab_taxa,
		x.nr_sequencia nr_seq_conta_pos,
		c.cd_estabelecimento,
		null nr_seq_mensalidade_seg,
		x.nr_seq_mat_rec,
		null nr_seq_proc_rec,
		x.nr_seq_disc_mat,
		null nr_seq_disc_proc,
		x.nr_seq_lote_disc,
		y.nr_seq_ajuste_fat,
		z.ie_tipo_protocolo,
                x.ie_status_faturamento,
                c.ie_status_fat
	from	pls_conta_pos_cab_v		c,
		pls_conta_pos_mat		x,
		pls_conta			y,
		pls_protocolo_conta		z
	where	x.nr_seq_conta		= c.nr_sequencia
	and	y.nr_sequencia		= x.nr_seq_conta
	and	z.nr_sequencia		= y.nr_seq_protocolo
	and	x.ie_status_faturamento	= 'L' -- Liberado para faturamento
	and	c.ie_status_fat		in ('L','P') -- Liberado para faturamento
	and	c.ie_status		= 'F' -- Fechado
	and	ie_novo_pos_estab_pc	= 'S'
	and	c.dt_atendimento_referencia between dt_ref_inicial_pc and dt_ref_final_pc;

BEGIN
delete FROM w_pls_monit_fin_cta_fat;

select	coalesce(max(ie_novo_pos_estab),'N')
into STRICT	ie_novo_pos_estab_w
from	pls_visible_false;

for r_c01_w in c01( dt_ref_inicial_w, dt_ref_final_w, ie_novo_pos_estab_w ) loop
	qt_registro_w	:= 0;
	qt_commit_w	:= qt_commit_w + 1;

	nr_dias_w	:= 180; -- Periodo de 180 dias
	if (r_c01_w.dt_atendimento_ref between(trunc(dt_atual_w,'dd')-60) and (fim_dia(dt_atual_w)-30)) then -- Periodo de 30 dias
		nr_dias_w := 30;

	elsif (r_c01_w.dt_atendimento_ref between(trunc(dt_atual_w, 'dd')-90) and (fim_dia(dt_atual_w)-60)) then -- Periodo de 60 dias
		nr_dias_w := 60;

	elsif (r_c01_w.dt_atendimento_ref between(trunc(dt_atual_w, 'dd')-120) and (fim_dia(dt_atual_w)-90)) then -- Periodo de 90 dias
		nr_dias_w := 90;

	elsif (r_c01_w.dt_atendimento_ref between(trunc(dt_atual_w,'dd')-180) and (fim_dia(dt_atual_w)-120)) then -- Periodo de 120 dias
		nr_dias_w := 120;

	end if;

	if (r_c01_w.nr_seq_conta_proc IS NOT NULL AND r_c01_w.nr_seq_conta_proc::text <> '') and (ie_novo_pos_estab_w = 'N') then -- Procedimento
		select	count(1)
		into STRICT	qt_registro_w
		from    pls_fatura 		f,
			pls_fatura_evento 	fe,
			pls_fatura_conta 	fc,
			pls_fatura_proc 	fp
		where   f.nr_sequencia   		= fe.nr_seq_fatura
		and     fe.nr_sequencia  		= fc.nr_seq_fatura_evento
		and     fc.nr_sequencia  		= fp.nr_seq_fatura_conta
		and     fp.nr_seq_conta_pos_estab	= r_c01_w.nr_seq_conta_pos
		and	fp.ie_tipo_cobranca in ('1','2')
		and     coalesce(f.ie_cancelamento::text, '') = '';

		-- Verifica a mensalidade.
		-- Por questões de performance, só tenta validar a mensalidade se não encontrou nenhum faturamento, se encontrou, não precisa consultar a mensalidade.
		-- Com o "pós antigo", é necessário duas verificações, uma olhando se o pls_conta_pos_estabelecido.nr_seq_mensalidade_seg está preenchido, e caso não esteja,
		-- então deve olhar se a pls_conta_pos_estabelecido.nr_sequencia não está contida na pls_mensalidade_item_conta.nr_seq_conta_pos_estab
		if (qt_registro_w = 0) then

			-- Se encontrou uma mensalidade, então marca como 1 o qt_registro_w
			if (r_c01_w.nr_seq_mensalidade_seg IS NOT NULL AND r_c01_w.nr_seq_mensalidade_seg::text <> '') then

				qt_registro_w := 1;
			else
				-- Se não tem mensalidade direto no pós, ainda tenta achar na pls_mensalidade_item_conta
				select	count(1)
				into STRICT	qt_registro_w
				from	pls_mensalidade_item_conta	a,
					pls_mensalidade_seg_item	b,
					pls_mensalidade			c,
					pls_lote_mensalidade		d
				where	b.nr_sequencia			= a.nr_seq_item
				and	c.nr_sequencia			= b.nr_seq_mensalidade
				and	d.nr_sequencia			= c.nr_seq_lote
				and	a.nr_seq_conta_pos_estab	= r_c01_w.nr_seq_conta_pos
				and	d.ie_status			= 2 -- somente lotes "definitivos"
				and	coalesce(c.ie_cancelamento::text, '') = ''; -- não deve estar cancelada
			end if;
		end if;

	elsif (r_c01_w.nr_seq_conta_mat IS NOT NULL AND r_c01_w.nr_seq_conta_mat::text <> '') and (ie_novo_pos_estab_w = 'N') then -- Material
		select	count(1)
		into STRICT	qt_registro_w
		from    pls_fatura 		f,
			pls_fatura_evento 	fe,
			pls_fatura_conta 	fc,
			pls_fatura_mat 		fp
		where   f.nr_sequencia   		= fe.nr_seq_fatura
		and     fe.nr_sequencia  		= fc.nr_seq_fatura_evento
		and     fc.nr_sequencia  		= fp.nr_seq_fatura_conta
		and     fp.nr_seq_conta_pos_estab	= r_c01_w.nr_seq_conta_pos
		and	fp.ie_tipo_cobranca in ('1','2')
		and     coalesce(f.ie_cancelamento::text, '') = '';


		-- Verifica a mensalidade.
		-- Por questões de performance, só tenta validar a mensalidade se não encontrou nenhum faturamento, se encontrou, não precisa consultar a mensalidade.
		-- Com o "pós antigo", é necessário duas verificações, uma olhando se o pls_conta_pos_estabelecido.nr_seq_mensalidade_seg está preenchido, e caso não esteja,
		-- então deve olhar se a pls_conta_pos_estabelecido.nr_sequencia não está contida na pls_mensalidade_item_conta.nr_seq_conta_pos_estab
		if (qt_registro_w = 0) then

			-- Se encontrou uma mensalidade, então marca como 1 o qt_registro_w
			if (r_c01_w.nr_seq_mensalidade_seg IS NOT NULL AND r_c01_w.nr_seq_mensalidade_seg::text <> '') then

				qt_registro_w := 1;
			else
				-- Se não tem mensalidade direto no pós, ainda tenta achar na pls_mensalidade_item_conta
				select	count(1)
				into STRICT	qt_registro_w
				from	pls_mensalidade_item_conta	a,
					pls_mensalidade_seg_item	b,
					pls_mensalidade			c,
					pls_lote_mensalidade		d
				where	b.nr_sequencia			= a.nr_seq_item
				and	c.nr_sequencia			= b.nr_seq_mensalidade
				and	d.nr_sequencia			= c.nr_seq_lote
				and	a.nr_seq_conta_pos_estab	= r_c01_w.nr_seq_conta_pos
				and	d.ie_status			= 2 -- somente lotes "definitivos"
				and	coalesce(c.ie_cancelamento::text, '') = ''; -- não deve estar cancelada
			end if;
		end if;

	elsif (r_c01_w.nr_seq_conta_proc IS NOT NULL AND r_c01_w.nr_seq_conta_proc::text <> '') and (ie_novo_pos_estab_w = 'S') then -- Procedimento
		select	count(1)
		into STRICT	qt_registro_w
		from    pls_fatura 		f,
			pls_fatura_evento 	fe,
			pls_fatura_conta 	fc,
			pls_fatura_proc 	fp
		where   f.nr_sequencia   	= fe.nr_seq_fatura
		and     fe.nr_sequencia  	= fc.nr_seq_fatura_evento
		and     fc.nr_sequencia  	= fp.nr_seq_fatura_conta
		and     fp.nr_seq_pos_proc	= r_c01_w.nr_seq_conta_pos
		and	fp.ie_tipo_cobranca in ('1','2')
		and     coalesce(f.ie_cancelamento::text, '') = '';


		-- Verifica a mensalidade.
		-- Por questões de performance, só tenta validar a mensalidade se não encontrou nenhum faturamento, se encontrou, não precisa consultar a mensalidade.
		-- Com o "pós novo", é necessário verificar a existencia do proc/mat na pls_mensalidade_item_conta
		if (qt_registro_w = 0) then

			select	count(1)
			into STRICT	qt_registro_w
			from	pls_mensalidade_item_conta	a,
				pls_mensalidade_seg_item	b,
				pls_mensalidade			c,
				pls_lote_mensalidade		d
			where	b.nr_sequencia		= a.nr_seq_item
			and	c.nr_sequencia		= b.nr_seq_mensalidade
			and	d.nr_sequencia		= c.nr_seq_lote
			and	a.nr_seq_pos_proc	= r_c01_w.nr_seq_conta_proc
			and	d.ie_status		= 2 -- somente lotes "definitivos"
			and	coalesce(c.ie_cancelamento::text, '') = ''; -- não deve estar cancelada
		end if;

	elsif (r_c01_w.nr_seq_conta_mat IS NOT NULL AND r_c01_w.nr_seq_conta_mat::text <> '') and (ie_novo_pos_estab_w = 'S') then -- Material
		select	count(1)
		into STRICT	qt_registro_w
		from    pls_fatura 		f,
			pls_fatura_evento 	fe,
			pls_fatura_conta 	fc,
			pls_fatura_mat 		fp
		where   f.nr_sequencia   	= fe.nr_seq_fatura
		and     fe.nr_sequencia  	= fc.nr_seq_fatura_evento
		and     fc.nr_sequencia  	= fp.nr_seq_fatura_conta
		and     fp.nr_seq_pos_mat	= r_c01_w.nr_seq_conta_pos
		and	fp.ie_tipo_cobranca in ('1','2')
		and     coalesce(f.ie_cancelamento::text, '') = '';


		-- Verifica a mensalidade.
		-- Por questões de performance, só tenta validar a mensalidade se não encontrou nenhum faturamento, se encontrou, não precisa consultar a mensalidade.
		-- Com o "pós novo", é necessário verificar a existencia do proc/mat na pls_mensalidade_item_conta
		if (qt_registro_w = 0) then

			select	count(1)
			into STRICT	qt_registro_w
			from	pls_mensalidade_item_conta	a,
				pls_mensalidade_seg_item	b,
				pls_mensalidade			c,
				pls_lote_mensalidade		d
			where	b.nr_sequencia		= a.nr_seq_item
			and	c.nr_sequencia		= b.nr_seq_mensalidade
			and	d.nr_sequencia		= c.nr_seq_lote
			and	a.nr_seq_pos_mat	= r_c01_w.nr_seq_conta_mat
			and	d.ie_status		= 2 -- somente lotes "definitivos"
			and	coalesce(c.ie_cancelamento::text, '') = ''; -- não deve estar cancelada
		end if;

	end if;

        if (r_c01_w.ie_status_faturamento = 'L' and r_c01_w.ie_status_fat = 'P' and qt_registro_w > 0) then
                qt_registro_w := 0;
        end if;

	-- Verifica a origem do valor pós
	ie_origem_valor_pos_w := null;

	--  2 - Recurso de glosa
	if	((r_c01_w.nr_seq_mat_rec IS NOT NULL AND r_c01_w.nr_seq_mat_rec::text <> '') or (r_c01_w.nr_seq_proc_rec IS NOT NULL AND r_c01_w.nr_seq_proc_rec::text <> '')) then
		ie_origem_valor_pos_w := '2';

	-- 3 - Contestação
	elsif	((r_c01_w.nr_seq_disc_mat IS NOT NULL AND r_c01_w.nr_seq_disc_mat::text <> '') or (r_c01_w.nr_seq_disc_proc IS NOT NULL AND r_c01_w.nr_seq_disc_proc::text <> '') or (r_c01_w.nr_seq_lote_disc IS NOT NULL AND r_c01_w.nr_seq_lote_disc::text <> '')) then
		ie_origem_valor_pos_w := '3';

	-- 4 - Refaturamento
	elsif (r_c01_w.nr_seq_ajuste_fat IS NOT NULL AND r_c01_w.nr_seq_ajuste_fat::text <> '') then
		ie_origem_valor_pos_w := '4';

	-- 5 - Reembolso
	elsif (r_c01_w.ie_tipo_protocolo = 'R') then
		ie_origem_valor_pos_w := '5';

	-- se não se encaixou em nenhuma alternativa, deve ser considerado como 1 - produção médica. Importante esta ser a ultima opção, conforme regra atual
	elsif (coalesce(ie_origem_valor_pos_w::text, '') = '') then
		ie_origem_valor_pos_w := '1';
	end if;

	-- Inserir
	if (qt_registro_w = 0) then
		insert into w_pls_monit_fin_cta_fat(nr_sequencia,				nm_usuario,			dt_atualizacao,
			nm_usuario_nrec,			dt_atualizacao_nrec,		nr_seq_conta,
			dt_atendimento_ref,			nr_dias,			nr_seq_conta_proc,
			nr_seq_conta_mat,			vl_pos_estab,			vl_pos_estab_taxa,
			cd_estabelecimento,			ie_origem_valor_pos)
		values (nextval('w_pls_monit_fin_cta_fat_seq'),	nm_usuario_p,			clock_timestamp(),
			nm_usuario_p,				clock_timestamp(),			r_c01_w.nr_seq_conta,
			r_c01_w.dt_atendimento_ref,		nr_dias_w,			r_c01_w.nr_seq_conta_proc,
			r_c01_w.nr_seq_conta_mat,		coalesce(r_c01_w.vl_pos_estab,0),	coalesce(r_c01_w.vl_pos_estab_taxa,0),
			r_c01_w.cd_estabelecimento,		ie_origem_valor_pos_w);
	end if;

	if (qt_commit_w > 500) then
		commit;
		qt_commit_w := 0;
	end if;
end loop;

commit;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_monit_financ_pck.gerar_monit_financ_conta_fat ( nm_usuario_p usuario.nm_usuario%type ) FROM PUBLIC;
