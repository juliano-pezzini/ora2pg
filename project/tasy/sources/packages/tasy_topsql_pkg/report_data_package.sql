-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';



/*  
    Computes the TOP SQLs between the last two snapshots 
    Reads from table TASY_TOPSQL_SQLAREA and writes to table TASY_TOPSQL_SQLAREA_REPORT
    Uses ELAPSED TIME as the column to order the results and classify the TOP-N queries
*/
CREATE OR REPLACE PROCEDURE tasy_topsql_pkg.report_data () AS $body$
DECLARE

    l_report_sql_minimal_exec       bigint;
    l_report_sql_minimal_elapsed    bigint;
    l_number_of_sqls_per_report     bigint;
    l_last_snap_id_reported         bigint;
    l_end_snap_id                   bigint;
    l_begin_snap_id                 bigint;
    l_transfer_to_remote_db         bigint;
    l_end_date                      timestamp;
    l_begin_date                    timestamp;
    l_number_rows_merged            bigint;


    
    

BEGIN
    -- Get configuration values
    SELECT
        number_of_sqls_per_report,
        report_sql_minimal_executions,
        report_sql_minimal_elapsed,
        last_snap_id_reported,
        transfer_to_remote_db
    INTO STRICT
        l_number_of_sqls_per_report,
        l_report_sql_minimal_exec,
        l_report_sql_minimal_elapsed,
        l_last_snap_id_reported,
        l_transfer_to_remote_db
    FROM
        tasy_topsql_control_tab LIMIT 1;

    -- Select the last snapshot id available
    SELECT coalesce(MAX(snap_id),0)
    INTO STRICT l_end_snap_id
    FROM tasy_topsql_sqlarea;

    -- If the last snapshot were already analyzed, stop processing
    IF l_end_snap_id <= l_last_snap_id_reported THEN
        RAISE EXCEPTION '%', 'Last snapshot id have already being reported. Last snapshot id reported: ' 
            || l_last_snap_id_reported || '. Last snapshot available: ' || l_end_snap_id USING ERRCODE = '45018';
    ELSE
        -- Select the penultimate snapshot id (to compose the window to report)
        SELECT MAX(snap_id) AS snap_id
        INTO STRICT l_begin_snap_id
        FROM tasy_topsql_sqlarea
        WHERE snap_id != l_end_snap_id;
    END IF;

    -- Select the snapshot date from both snapshot ids
    SELECT MAX(sample_date)
    INTO STRICT l_begin_date
    FROM tasy_topsql_sqlarea
    WHERE snap_id = l_begin_snap_id;

    SELECT MAX(sample_date)
    INTO STRICT l_end_date
    FROM tasy_topsql_sqlarea
    WHERE snap_id = l_end_snap_id;

    /* 
        Only compute snapshots within the same day
        The objective is to exclude overnight processing jobs that run on less critical hours
    */
    IF (trunc(l_end_date) = trunc(l_begin_date) AND (l_end_date IS NOT NULL AND l_end_date::text <> '') AND (l_begin_date IS NOT NULL AND l_begin_date::text <> '')) THEN
        /* 
            Merge query computes the top SQLs comparing the last two snapshots from table TASY_TOPSQL_SQLAREA
            SQL metrics should exists in both snapshots or at the final snapshot (table B)
        */
        BEGIN
            MERGE INTO tasy_topsql_sqlarea_report S
            USING(
                SELECT
                    sql_id,
                    command_type,
                    object_name,
                    module,
                    action,
                    begin_sample_date,
                    end_sample_date,
                    executions,
                    elapsed_time,
                    cpu_time,
                    disk_reads,
                    buffer_gets,
                    user_io_wait_time,
                    rows_processed,
                    sql_text
                FROM (
                    SELECT
                        b.sql_id AS sql_id,
                        b.command_type AS command_type,
                        b.object_name AS object_name,
                        b.module AS module,
                        b.action AS action,
                        coalesce(a.sample_date,b.sample_date) AS begin_sample_date,
                        b.sample_date AS end_sample_date,
                        b.executions - coalesce(a.executions,0) AS executions,
                        b.elapsed_time - coalesce(a.elapsed_time,0) AS elapsed_time, 
                        b.cpu_time - coalesce(a.cpu_time,0) AS cpu_time,
                        b.disk_reads - coalesce(a.disk_reads,0) AS disk_reads,
                        b.buffer_gets - coalesce(a.buffer_gets,0) AS buffer_gets,
                        b.user_io_wait_time - coalesce(a.user_io_wait_time,0) AS user_io_wait_time,
                        b.rows_processed - coalesce(a.rows_processed,0) AS rows_processed,
                        b.sql_text AS sql_text
                    FROM tasy_topsql_sqlarea a
                    RIGHT OUTER JOIN tasy_topsql_sqlarea b ON (a.sql_id = b.sql_id)
                    WHERE a.snap_id = l_begin_snap_id
                    AND b.snap_id = l_end_snap_id
                    -- Config checks
                    AND b.executions - coalesce(a.executions,0) >= l_report_sql_minimal_exec
                    AND b.elapsed_time - coalesce(a.elapsed_time,0) >= l_report_sql_minimal_elapsed
                    -- Sanity checks
                    AND b.cpu_time - coalesce(a.cpu_time,0) >= 0
                    AND b.disk_reads - coalesce(a.disk_reads,0) >= 0
                    AND b.buffer_gets - coalesce(a.buffer_gets,0) >= 0
                    AND b.user_io_wait_time - coalesce(a.user_io_wait_time,0) >= 0
                    AND b.rows_processed - coalesce(a.rows_processed,0) >= 0
                    -- TOP SQLs classified by Elapsed Time
                    ORDER BY b.elapsed_time DESC, b.sql_id ASC
                ) alias21 LIMIT (l_number_of_sqls_per_report)) Q
            ON (S.sql_id = Q.sql_id)
            -- When sql id exists, update the last% columns and add the value in total% columns
            WHEN MATCHED THEN UPDATE SET S.last_sample = Q.end_sample_date, 
                S.last_executions = Q.executions,
                S.last_elapsed_time = Q.elapsed_time,
                S.last_cpu_time = Q.cpu_time,
                S.last_disk_reads = Q.disk_reads,
                S.last_buffer_gets = Q.buffer_gets,
                S.last_user_io_wait_time = Q.user_io_wait_time,
                S.last_rows_processed = Q.rows_processed,
                S.total_executions = S.total_executions + Q.executions,
                S.total_elapsed_time = S.total_elapsed_time + Q.elapsed_time,
                S.total_cpu_time = S.total_cpu_time + Q.cpu_time,
                S.total_disk_reads = S.total_disk_reads + Q.disk_reads,
                S.total_buffer_gets = S.total_buffer_gets + Q.buffer_gets,
                S.total_user_io_wait_time = S.total_user_io_wait_time + Q.user_io_wait_time,
                S.total_rows_processed = S.total_rows_processed + Q.rows_processed,
                S.occurences_top_n = S.occurences_top_n + 1
            WHERE (Q.end_sample_date > S.last_sample)
            WHEN NOT MATCHED THEN INSERT(
                S.sql_id,
                S.command_type,
                S.object_name,
                S.module,
                S.action,
                S.first_sample,
                S.last_sample,
                S.last_executions,
                S.last_elapsed_time,
                S.last_cpu_time,
                S.last_disk_reads,
                S.last_buffer_gets,
                S.last_user_io_wait_time,
                S.last_rows_processed,
                S.total_executions,
                S.total_elapsed_time,
                S.total_cpu_time,
                S.total_disk_reads,
                S.total_buffer_gets,
                S.total_user_io_wait_time,
                S.total_rows_processed,
                S.sql_text,
                S.sql_fulltext,
                S.last_sql_plans,
                S.occurences_top_n
            ) 
            VALUES (
                Q.sql_id,
                Q.command_type,
                Q.object_name,
                Q.module,
                Q.action,
                Q.begin_sample_date,
                Q.end_sample_date,
                Q.executions,
                Q.elapsed_time,
                Q.cpu_time,
                Q.disk_reads,
                Q.buffer_gets,
                Q.user_io_wait_time,
                Q.rows_processed,
                Q.executions,
                Q.elapsed_time,
                Q.cpu_time,
                Q.disk_reads,
                Q.buffer_gets,
                Q.user_io_wait_time,
                Q.rows_processed,
                Q.sql_text,
                null,
                null,
                1
            );

            GET DIAGNOSTICS l_number_rows_merged = ROW_COUNT;
        EXCEPTION
            -- If the update/insert fails because the numbers are too big for columns, reset report table
            WHEN SQLSTATE '50014' THEN
                EXECUTE 'TRUNCATE TABLE tasy_topsql_sqlarea';
                EXECUTE 'TRUNCATE TABLE tasy_topsql_sqlarea_report';
                l_number_rows_merged := 0;
        END;
        -- If rows were merged        
        IF l_number_rows_merged > 0 THEN
            -- Get SQL full text and plans
            CALL tasy_topsql_pkg.populate_fulltext_and_plans();
            -- Keep only fresh data, remove old report data
            CALL tasy_topsql_pkg.remove_report_data();
        END IF;
    END IF;

    -- Update control table last analyzed snapshot id
    UPDATE tasy_topsql_control_tab
    SET last_snap_id_reported = l_end_snap_id;
    -- Commit here to avoid losing the work if the destination database link is not working 
    COMMIT;

    -- If enabled, copy result to remote destination database via database link
    IF l_transfer_to_remote_db = 1 AND l_number_rows_merged > 0 THEN
        -- It may have an autocommit (if the database link needs to be created = DDL)
        CALL tasy_topsql_pkg.transfer_to_remote_db_proc();
        COMMIT;
    END IF;

EXCEPTION
    WHEN others THEN
        RAISE EXCEPTION '%', 'Error trying to report last two snapshots: ' || sqlerrm USING ERRCODE = '45019';
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE tasy_topsql_pkg.report_data () FROM PUBLIC;
