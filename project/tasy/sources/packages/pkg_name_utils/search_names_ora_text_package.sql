-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

CREATE OR REPLACE FUNCTION pkg_name_utils.search_names_ora_text (name text, name_type text default null, exact_match text default null) RETURNS SETOF PERSON_NAME_TABLE AS $body$
DECLARE
	person_name_r	person_name_row_score := person_name_row_score(null,null,null,null,null,null,null, null);
	name_w			varchar(512);
	decode_w		varchar(512);
	name_query		varchar(2000);
	name_types		text[];

	v01				person_name%rowtype;
	c01 REFCURSOR;
BEGIN
	if (dbms_db_version.version < '12') then
		CALL wheb_mensagem_pck.exibir_mensagem_abort('This function may not be called in Oracle versions prior to 12.'
);
	end if;

	/*Using EXECUTE IMMEDIATE, so that this function will compile in Oracle versions prior to 12*/


    if (coalesce(exact_match::text, '') = '') then
		EXECUTE	' select listagg(token, '' and '') within group (order by rownum) name ' ||
			  ' from (select case when length(regexp_substr(:name, ''[^[:space:]]+'', 1, level)) > 3 then ' ||
              ' ''fuzzy('' || regexp_replace(regexp_substr(:name, ''[^[:space:]]+'', 1, level), ''(.)'', ''\\\1'') || ''%, 60, 100, weight)'' ' ||
              ' else regexp_replace(regexp_substr(:name, ''[^[:space:]]+'', 1, level), ''(.)'', ''\\\1'') || ''%'' ' ||
              ' end	token from	dual ' ||
			  '	connect by regexp_substr(:name, ''[^[:space:]]+'', 1, level) is not null)'
              into STRICT	name_w
			  using	name, name, name, name;
	else
		EXECUTE	' select	listagg(token, '' and '') within group (order by rownum) name ' ||
							' from		(select  regexp_replace(regexp_substr(:name, ''[^[:space:]]+'', 1, level), ''(.)'', ''\\\1'') || ''%'' token ' ||
							'					from	dual ' ||
							'					connect by regexp_substr(:name, ''[^[:space:]]+'', 1, level) is not null)'
							into STRICT	name_w
							using	name, name;
	end if;
						
	name_query :=	' select	nr_sequencia,' ||
					'		ds_given_name,' ||
					'		ds_component_name_1,' ||
					'		ds_component_name_2,' ||
					'		ds_component_name_3,' ||
					'		ds_family_name,' ||
					'		ds_type ';

	if (name_type IS NOT NULL AND name_type::text <> '') then
		name_types := pkg_name_utils.split(name_type,',');

		for i in 1..name_types.last loop
			decode_w := decode_w || ',''' || name_types(i) || ''',' || i;
		end loop;

		name_query := name_query || ', nr_score from	(select	a.*, score(1) nr_score, ' ||
									'				row_number() over(partition by nr_sequencia order by decode(ds_type' || decode_w || ')) as ind ' ||
									'	    from	person_name a ' ||
									' 		where	contains(ds_given_name, :name, 1) > 0 ' ||
									' 		order	by score(1) desc) ' ||
									' where	ind = 1 ';
	else
		name_query := name_query || ', score(1) nr_score from	person_name ' ||
									' where	contains(ds_given_name, :name, 1) > 0 ' ||
									' order	by score(1) desc ';
	end if;

	open c01 for EXECUTE name_query using name_w;

	loop
	fetch c01 into
		person_name_r.nr_sequencia,
		person_name_r.ds_given_name,
		person_name_r.ds_component_name_1,
		person_name_r.ds_component_name_2,
		person_name_r.ds_component_name_3,
		person_name_r.ds_family_name,
		person_name_r.ds_type,
		person_name_r.nr_score;
	EXIT WHEN NOT FOUND; /* apply on c01 */
		begin
		RETURN NEXT person_name_r;
		end;
	end loop;
	close c01;
end;


$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pkg_name_utils.search_names_ora_text (name text, name_type text default null, exact_match text default null) FROM PUBLIC;
