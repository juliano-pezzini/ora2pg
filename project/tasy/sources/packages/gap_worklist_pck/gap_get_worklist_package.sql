-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE FUNCTION gap_worklist_pck.gap_get_worklist (cd_estabelecimento_p bigint,cd_perfil_p bigint,nm_usuario_p text) RETURNS SETOF WORKLIST_DATA AS $body$
DECLARE

	
	is_c01_data_exists_w boolean := false;
	is_c02_data_exists_w boolean := false;
	is_c03_data_exists_w boolean := false;
	is_c04_data_exists_w boolean := false;

	c01 CURSOR(cd_perfil_p	bigint,nm_usuario_p	text) FOR
		SELECT	distinct a.nr_sequencia,
			a.dt_validade,
			a.nr_seq_tipo,
			a.nr_seq_categoria,
			a.cd_pessoa_fisica,
			b.ie_tipo_pendencia
		from	gap_processo a,
			gap_regra_pendencia b,
			gap_regra_pend_resp c
		where	((b.ie_agrupar = 'D' and ((a.dt_validade - clock_timestamp()) < b.qt_dias_anteced)) or (b.ie_agrupar = 'W' and (a.dt_validade between clock_timestamp() and obter_inicio_fim_semana(adicionar_semanas(clock_timestamp(), b.qt_dias_anteced),'F'))) or (b.ie_agrupar = 'M' and (a.dt_validade between clock_timestamp() and pkg_date_utils.end_of(pkg_date_utils.add_month(clock_timestamp(),b.qt_dias_anteced,0),'MONTH')))) and
			(b.nr_sequencia = c.nr_seq_regra and
			((coalesce(nm_usuario_p::text, '') = '' and  c.cd_perfil = cd_perfil_p)
			or (coalesce(cd_perfil_p::text, '') = '' and c.nm_usuario_dest = nm_usuario_p))) and
			a.ie_resultado <> 'C' and
			b.ie_tipo_pendencia = 'VP' and
			a.cd_estabelecimento = b.cd_estabelecimento and
			a.dt_validade > (SELECT	max(dt_inicio)
					from 	gap_processo c,
						gap_regra_pendencia d
					where	c.ie_resultado <> 'C' and
						d.ie_tipo_pendencia = 'VP' and
						a.cd_pessoa_fisica = c.cd_pessoa_fisica and
						c.cd_estabelecimento = d.cd_estabelecimento);

	c02 CURSOR(cd_perfil_p	bigint,nm_usuario_p	text) FOR
		SELECT distinct a.nr_sequencia,
			c.dt_validade,
			a.nr_seq_tipo,
			a.nr_seq_categoria,
			a.cd_pessoa_fisica,
			b.ie_tipo_pendencia
		from	gap_processo a,
			gap_regra_pendencia b,
			pessoa_documentacao c,
			gap_regra_pend_resp d
		where 	a.cd_pessoa_fisica = c.cd_pessoa_fisica and
			((b.ie_agrupar = 'D' and ((c.dt_validade - clock_timestamp()) < b.qt_dias_anteced)) or (b.ie_agrupar = 'W' and (c.dt_validade between clock_timestamp() and obter_inicio_fim_semana(adicionar_semanas(clock_timestamp(), b.qt_dias_anteced),'F'))) or (b.ie_agrupar = 'M' and (c.dt_validade between clock_timestamp() and pkg_date_utils.end_of(pkg_date_utils.add_month(clock_timestamp(),b.qt_dias_anteced,0),'MONTH')))) and
			(b.nr_sequencia = d.nr_seq_regra and
			((coalesce(nm_usuario_p::text, '') = '' and  d.cd_perfil = cd_perfil_p)
			or (coalesce(cd_perfil_p::text, '') = '' and d.nm_usuario_dest = nm_usuario_p))) and
			a.ie_resultado <> 'C' and
			b.ie_tipo_pendencia = 'VD' and
			a.cd_estabelecimento = b.cd_estabelecimento;
			
	c03 CURSOR(cd_perfil_p	bigint,nm_usuario_p	text) FOR
		SELECT	distinct a.nr_sequencia,
			c.dt_validade_conselho,
			a.nr_seq_tipo,
			a.nr_seq_categoria,
			a.cd_pessoa_fisica,
			b.ie_tipo_pendencia
		from	gap_processo a,
			gap_regra_pendencia b,
			pessoa_fisica c,
			gap_regra_pend_resp d
		where	a.cd_pessoa_fisica = c.cd_pessoa_fisica and
			((b.ie_agrupar = 'D' and ((c.dt_validade_conselho - clock_timestamp()) < b.qt_dias_anteced)) or (b.ie_agrupar = 'W' and (c.dt_validade_conselho between clock_timestamp() and obter_inicio_fim_semana(adicionar_semanas(clock_timestamp(), b.qt_dias_anteced),'F'))) or (b.ie_agrupar = 'M' and (c.dt_validade_conselho between clock_timestamp() and pkg_date_utils.end_of(pkg_date_utils.add_month(clock_timestamp(),b.qt_dias_anteced,0),'MONTH')))) and
			(b.nr_sequencia = d.nr_seq_regra and
			((coalesce(nm_usuario_p::text, '') = '' and  d.cd_perfil = cd_perfil_p)
			or (coalesce(cd_perfil_p::text, '') = '' and d.nm_usuario_dest = nm_usuario_p))) and
			a.ie_resultado <> 'C' and
			b.ie_tipo_pendencia = 'VC' and
			a.cd_estabelecimento = b.cd_estabelecimento;
	
	c04 CURSOR(cd_perfil_p	bigint,nm_usuario_p	text) FOR
		SELECT	distinct a.nr_sequencia,
			c.dt_prevista,
			a.nr_seq_tipo,
			a.nr_seq_categoria,
			a.cd_pessoa_fisica,
			b.ie_tipo_pendencia
		from 	gap_processo a,
			gap_regra_pendencia b,
			gap_processo_etapa c,
			gap_regra_pend_resp d
		where 	((b.ie_agrupar = 'D' and ((c.dt_prevista - clock_timestamp()) < b.qt_dias_anteced)) or (b.ie_agrupar = 'W' and (c.dt_prevista between clock_timestamp() and obter_inicio_fim_semana(adicionar_semanas(clock_timestamp(), b.qt_dias_anteced),'F')))	or (b.ie_agrupar = 'M' and (c.dt_prevista between clock_timestamp() and pkg_date_utils.end_of(pkg_date_utils.add_month(clock_timestamp(),b.qt_dias_anteced,0),'MONTH'))))
		and 	(b.nr_sequencia = d.nr_seq_regra and
			((coalesce(nm_usuario_p::text, '') = '' and  d.cd_perfil = cd_perfil_p)
			or (coalesce(cd_perfil_p::text, '') = '' and d.nm_usuario_dest = nm_usuario_p)))
		and	 a.ie_resultado <> 'C'
		and	 c.ie_resultado <> 'A'
		and	 b.ie_tipo_pendencia = 'VE'
		and	 c.nr_seq_processo = a.nr_sequencia;
			
	c05 CURSOR FOR
		SELECT	distinct a.nr_sequencia,
			c.dt_prevista,
			a.nr_seq_tipo,
			a.nr_seq_categoria,
			a.cd_pessoa_fisica,
			b.ie_tipo_pendencia
		from 	gap_processo a,
			gap_regra_pendencia b,
			gap_processo_etapa c,
			gap_tipo d,
			gap_ritual e,
			gap_regra_pend_resp f
		where 	((b.ie_agrupar = 'D' and ((c.dt_prevista - clock_timestamp()) < b.qt_dias_anteced)) or (b.ie_agrupar = 'W' and (c.dt_prevista between clock_timestamp() and obter_inicio_fim_semana(adicionar_semanas(clock_timestamp(), b.qt_dias_anteced),'F')))	or (b.ie_agrupar = 'M' and (c.dt_prevista between clock_timestamp() and pkg_date_utils.end_of(pkg_date_utils.add_month(clock_timestamp(),b.qt_dias_anteced,0),'MONTH'))))
		and 	f.ie_responsavel = 'E'
		and 	a.nr_seq_tipo = d.nr_sequencia
		and 	e.nr_seq_tipo = d.nr_sequencia
		and 	e.cd_pessoa_fisica = obter_pf_usuario(wheb_usuario_pck.get_nm_usuario,'C')
		and 	a.ie_resultado <> 'C'
		and 	c.ie_resultado <> 'A'
		and 	b.ie_tipo_pendencia = 'VE'
		and 	c.nr_seq_processo = a.nr_sequencia;
					
	
BEGIN
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= null;
	
	for row_c01 in c01(null, nm_usuario_p) loop
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_validade;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
		is_c01_data_exists_w 		:= 	true;
		RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
	end loop;

	if is_c01_data_exists_w = false then
		for row_c01 in c01(cd_perfil_p, null) loop
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_validade;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
			is_c01_data_exists_w 		:= 	true;
			RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
		end loop;
	end if;
	
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= null;
	
	for row_c01 in c02(null, nm_usuario_p) loop
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_validade;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
		is_c02_data_exists_w 		:= 	true;
		RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
	end loop;

	if is_c02_data_exists_w = false then
		for row_c01 in c02(cd_perfil_p, null) loop
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_validade;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
			is_c02_data_exists_w 		:= 	true;
			RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
		end loop;
	end if;

	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= null;
	
	for row_c01 in c03(null, nm_usuario_p) loop
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_validade_conselho;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
		is_c03_data_exists_w 		:= 	true;
		RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
	end loop;

	if is_c03_data_exists_w = false then
		for row_c01 in c03(cd_perfil_p, null) loop
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_validade_conselho;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
			is_c03_data_exists_w 		:= 	true;
			RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
		end loop;
	end if;

	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:= null;
	current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= null;
	
	for row_c01 in c04(null, nm_usuario_p) loop
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_prevista;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
		is_c04_data_exists_w 		:= 	true;
		RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
	end loop;

	if is_c04_data_exists_w = false then
		for row_c01 in c04(cd_perfil_p, null) loop
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_prevista;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
			current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
			is_c04_data_exists_w 		:= 	true;
			RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
		end loop;
	end if;
	
	for row_c01 in c05 loop
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_sequencia	:=	row_c01.nr_sequencia;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.dt_validade	:=	row_c01.dt_prevista;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_tipo	:=	row_c01.nr_seq_tipo;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.nr_seq_categoria	:=	row_c01.nr_seq_categoria;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_pessoa_fisica	:=	row_c01.cd_pessoa_fisica;
		current_setting('gap_worklist_pck.t_worklist_row')::worklist_row.cd_reason    	:= 	row_c01.ie_tipo_pendencia;
		RETURN NEXT current_setting('gap_worklist_pck.t_worklist_row'::worklist_row);
	end loop;
	
	return;
  END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION gap_worklist_pck.gap_get_worklist (cd_estabelecimento_p bigint,cd_perfil_p bigint,nm_usuario_p text) FROM PUBLIC;
