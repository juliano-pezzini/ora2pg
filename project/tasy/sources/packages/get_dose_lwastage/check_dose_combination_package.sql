-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE get_dose_lwastage.check_dose_combination ( pres_dose_p bigint, wastage_w INOUT bigint, wastage_w1 INOUT bigint, wastage_w2 INOUT bigint, counter_w INOUT bigint, counter_w1 INOUT bigint, counter_w2 INOUT bigint, finalarr INOUT dosage_array ) AS $body$
DECLARE

        dose_quantity_w    dosage_array;
        dose_quantity_w1   dosage_array;
        dosage_qty_test    dosage_array;
        dose_qty           dosage_array;
        final_qty          dosage_array;
        pres_dose_w        bigint;
        remainder_w        bigint;
        quotient_w         bigint;
        pend_dose_w        bigint;
        n                  bigint;
        a                  bigint;
        inter_w            bigint;
        inter_c            bigint;
        temp_var           bigint := 0;
        adjust_factor      bigint := 0;
        inner_cnt          bigint := 0;
        p1                 bigint := 0;
        q1                 bigint := 0;
        r1                 bigint := 0;
        dose_tmp_w         bigint;

BEGIN
      --Loop 1 Logic
        pres_dose_w := pres_dose_p;
        counter_w := 0;
        wastage_w := pres_dose_w;
        FOR i in 1 .. current_setting('get_dose_lwastage.dose_available')::ty_list_array.count Loop
            IF current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose = pres_dose_w Then
              finalarr(current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].cd_material) := current_setting('get_dose_lwastage.dose_available')::ty_list_array(i);
              finalarr(current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].cd_material).qt_dose_quantity := 1;
              return;
            End If;
        End Loop;
        /*IF dose_available.EXISTS(pres_dose_w) THEN
		    finalarr(pres_dose_w) := 1;
		    return;
                 END IF;*/
        FOR i IN REVERSE dose_available.count..1 LOOP
         if (current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose <= pres_dose_w) then
        
            remainder_w := MOD(pres_dose_w, current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose);
            quotient_w := trunc(pres_dose_w / current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose);
            IF ( current_setting('get_dose_lwastage.dose_available')::coalesce(ty_list_array.prior(i)::text, '') = '' AND remainder_w != 0 ) THEN
                quotient_w := quotient_w + 1;
            ELSE
                pres_dose_w := remainder_w;
            END IF;

            dose_quantity_w(i) := current_setting('get_dose_lwastage.dose_available')::ty_list_array(i);
            dose_quantity_w[i].qt_dose_quantity := quotient_w;
            counter_w := counter_w + quotient_w;
            wastage_w := abs(wastage_w - current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose * 	    	        dose_quantity_w[i].qt_dose_quantity);
            finalarr(current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].cd_material) := dose_quantity_w(i);

            IF ( remainder_w = 0 ) THEN
				return;
            END IF;
            --finalarr(dose_available(i).cd_material) := dose_quantity_w(i);
		 end if;
        END LOOP;
        --index adjustment
        FOR i IN REVERSE dose_available.count..1 LOOP
            IF NOT dose_quantity_w.exists(i) Then
                dose_quantity_w(i) := current_setting('get_dose_lwastage.dose_available')::ty_list_array(i);
                dose_quantity_w[i].qt_dose_quantity := 0;
            End If;
        End Loop;

        dosage_qty_test := dose_quantity_w;
        dose_qty := dose_quantity_w;
        dose_quantity_w1 := dose_quantity_w;
        final_qty := dose_quantity_w;

        n := finalarr.last;
        WHILE (n IS NOT NULL AND n::text <> '') LOOP
            n := finalarr.PRIOR(n);
        END LOOP;
   /*LOOP 2 Logic calculating P+1,Q1,R1 ; P1,Q+1,R1; P1,Q1,R+1*/

        wastage_w1 := wastage_w;
        counter_w1 := counter_w;
        FOR i IN REVERSE dose_available.count..1 LOOP
            pres_dose_w := pres_dose_p;
            pend_dose_w := 0;
            remainder_w := 0;
            quotient_w := 0;
            dose_tmp_w := 0;
            inter_c := 0;
            inter_w := pres_dose_w;
            dosage_qty_test := dose_qty;
            dosage_qty_test[i].qt_dose_quantity := dose_quantity_w[i].qt_dose_quantity + 1;
            dose_tmp_w := current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose * dosage_qty_test[i].qt_dose_quantity;
            inter_c := dosage_qty_test[i].qt_dose_quantity;

            FOR x IN i + 1..dose_available.count LOOP
                dose_tmp_w := dose_tmp_w + current_setting('get_dose_lwastage.dose_available')::ty_list_array[x].qt_spec_group_dose * dose_quantity_w[x].qt_dose_quantity;
                inter_c := inter_c + dose_quantity_w[x].qt_dose_quantity;
            END LOOP;

            pend_dose_w := pres_dose_w - dose_tmp_w;
            inter_w := abs(pend_dose_w);

            IF ( pend_dose_w <= 0 ) THEN
                FOR k IN REVERSE i..1 - 1 LOOP
                    dosage_qty_test[k].qt_dose_quantity := 0;
                END LOOP;
            ELSE
                IF ( current_setting('get_dose_lwastage.dose_available')::coalesce(ty_list_array.prior(i)::text, '') = '' ) THEN
                    dosage_qty_test[i].qt_dose_quantity := dosage_qty_test[i].qt_dose_quantity + 1;
                    inter_c := inter_c + dosage_qty_test[i].qt_dose_quantity;
                END IF;
                FOR j IN REVERSE i..1 - 1 LOOP
                    remainder_w := MOD(pend_dose_w, current_setting('get_dose_lwastage.dose_available')::ty_list_array[j].qt_spec_group_dose);
                    quotient_w := trunc(pend_dose_w / current_setting('get_dose_lwastage.dose_available')::ty_list_array[j].qt_spec_group_dose);
                    IF ( current_setting('get_dose_lwastage.dose_available')::coalesce(ty_list_array.prior(i)::text, '') = '' AND remainder_w != 0 ) THEN
                        quotient_w := quotient_w + 1;
                    ELSE
                        pend_dose_w := remainder_w;
                    END IF;
                    dosage_qty_test[i].qt_dose_quantity := quotient_w;
                    inter_c := inter_c + quotient_w;
                    inter_w := inter_w + abs(inter_w - current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose * dosage_qty_test[i].qt_dose_quantity);
                    IF ( remainder_w = 0 ) THEN
                    	return;
                    END IF;
                END LOOP;
            END IF;
                -- IF conditions to compare W,C and W1,C1
            IF ( wastage_w1 > inter_w OR ( wastage_w1 = inter_w AND counter_w1 > inter_c ) ) THEN
                wastage_w1 := inter_w;
                counter_w1 := inter_c;
                final_qty := dosage_qty_test;
            END IF;
        END LOOP;

        n := current_setting('get_dose_lwastage.dose_available')::ty_list_array.last;
        WHILE (n IS NOT NULL AND n::text <> '') LOOP
            n := current_setting('get_dose_lwastage.dose_available')::ty_list_array.PRIOR(n);
        END LOOP;
        /*LOOP 2 Logic calculating P-1,Q1,R1 ; P1,Q-1,R1; P1,Q1,R-1*/

        counter_w2 := counter_w1;
        wastage_w2 := wastage_w1;
        dosage_qty_test := dose_qty;

        FOR i IN REVERSE dose_available.count..1 LOOP
            pres_dose_w := pres_dose_p;
            dose_tmp_w := 0;
            inter_c := 0;
            inter_w := pres_dose_w;
            pend_dose_w := 0;
            remainder_w := 0;
            quotient_w := 0;
            dosage_qty_test := dose_qty;

            IF ( dose_qty[i].qt_dose_quantity > 0 ) THEN
      
                dosage_qty_test[i].qt_dose_quantity := dose_qty[i].qt_dose_quantity - 1;
                dose_tmp_w := current_setting('get_dose_lwastage.dose_available')::ty_list_array[i].qt_spec_group_dose * dosage_qty_test[i].qt_dose_quantity;
                inter_c := dosage_qty_test[i].qt_dose_quantity;

                FOR x IN i + 1..dose_available.count LOOP
                    dose_tmp_w := dose_tmp_w + current_setting('get_dose_lwastage.dose_available')::ty_list_array[x].qt_spec_group_dose * dose_qty[x].qt_dose_quantity;
                    inter_c := inter_c + dose_qty[x].qt_dose_quantity;
                END LOOP;
                pend_dose_w := pres_dose_w - dose_tmp_w;
                inter_w := abs(pend_dose_w);

                IF ( pend_dose_w <= 0 ) THEN
                    FOR k IN 1..i - 1 LOOP 
                    dosage_qty_test[k].qt_dose_quantity := 0;
                    END LOOP;
                    EXIT;
                ELSE
                    IF ( current_setting('get_dose_lwastage.dose_available')::coalesce(ty_list_array.prior(i)::text, '') = '' ) THEN
                        dosage_qty_test[i].qt_dose_quantity := dosage_qty_test[i].qt_dose_quantity + 1;
                        inter_c := inter_c + dosage_qty_test[i].qt_dose_quantity;
                    END IF;
                    FOR j IN REVERSE i..1 - 1 LOOP
                        remainder_w := MOD(pend_dose_w, current_setting('get_dose_lwastage.dose_available')::ty_list_array[j].qt_spec_group_dose);
                        quotient_w := trunc(pend_dose_w / current_setting('get_dose_lwastage.dose_available')::ty_list_array[j].qt_spec_group_dose);

                        IF ( remainder_w != 0 AND current_setting('get_dose_lwastage.dose_available')::coalesce(ty_list_array.prior(j)::text, '') = '' ) THEN
                            quotient_w := quotient_w + 1;
                        ELSE
                            pend_dose_w := remainder_w;
                        END IF;
                        dosage_qty_test[j].qt_dose_quantity := quotient_w;
                        inter_c := inter_c + quotient_w;
                        inter_w := abs(inter_w - current_setting('get_dose_lwastage.dose_available')::ty_list_array[j].qt_spec_group_dose * dosage_qty_test[j].qt_dose_quantity);

                        IF ( remainder_w = 0 ) THEN
							return;
                        END IF;
                    END LOOP;
                END IF;
            END IF;

            IF ( wastage_w2 > inter_w OR ( wastage_w2 = inter_w AND counter_w2 > inter_c ) ) THEN
                wastage_w2 := inter_w;
                counter_w2 := inter_c;
                final_qty := dosage_qty_test;
            END IF;

        END LOOP;
        n := current_setting('get_dose_lwastage.dose_available')::ty_list_array.last;
        WHILE (n IS NOT NULL AND n::text <> '') LOOP
            n := current_setting('get_dose_lwastage.dose_available')::ty_list_array.PRIOR(n);
            ---- IF conditions to compare W,C and W2,C2
        END LOOP;
         /* calculate wastage and count and compare */

        finalarr.DELETE;
        a := current_setting('get_dose_lwastage.dose_available')::ty_list_array.last;
        WHILE (a IS NOT NULL AND a::text <> '') LOOP
            finalarr(current_setting('get_dose_lwastage.dose_available')::ty_list_array[a].cd_material) := final_qty(a);
            a := current_setting('get_dose_lwastage.dose_available')::ty_list_array.PRIOR(a);
        END LOOP;
        n := finalarr.last;
        WHILE (n IS NOT NULL AND n::text <> '') LOOP
            n := finalarr.PRIOR(n);
        END LOOP;
    END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE get_dose_lwastage.check_dose_combination ( pres_dose_p bigint, wastage_w INOUT bigint, wastage_w1 INOUT bigint, wastage_w2 INOUT bigint, counter_w INOUT bigint, counter_w1 INOUT bigint, counter_w2 INOUT bigint, finalarr INOUT dosage_array ) FROM PUBLIC;
