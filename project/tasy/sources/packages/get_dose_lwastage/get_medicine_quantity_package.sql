-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE get_dose_lwastage.get_medicine_quantity (finalarr INOUT dosage_array, pres_dose_p bigint, spec_grp_p bigint, dosage_array_p ty_list_array ) AS $body$
DECLARE

        _ora2pg_r RECORD;
available_dose   dosage_array;
        cd_material_w    dosage_array;
        ds_material_w    dosage_array;
        presc_qty        bigint;
        drug_list        ty_alloc;
        arr_indx         integer;
        dose             bigint;
        wastage_w1       bigint;
        wastage_w2       bigint;
        wastage_w        bigint;
        counter_w1       bigint;
        counter_w2       bigint;
        counter_w        bigint;

BEGIN
         current_setting('get_dose_lwastage.dose_available')::ty_list_array.delete;
         PERFORM set_config('get_dose_lwastage.dose_available', dosage_array_p, false);
        presc_qty := pres_dose_p;
        SELECT * FROM get_dose_lwastage.check_dose_combination(presc_qty, wastage_w, wastage_w1, wastage_w2, counter_w, counter_w1, counter_w2, finalarr) INTO STRICT _ora2pg_r;
 wastage_w := _ora2pg_r.wastage_w; wastage_w1 := _ora2pg_r.wastage_w1; wastage_w2 := _ora2pg_r.wastage_w2; counter_w := _ora2pg_r.counter_w; counter_w1 := _ora2pg_r.counter_w1; counter_w2 := _ora2pg_r.counter_w2; finalarr := _ora2pg_r.finalarr;

        IF ( wastage_w1 > 0 AND wastage_w > 0 AND wastage_w2 > 0 ) THEN
        
            finalarr.DELETE();
             /* recursion function call */

            current_setting('get_dose_lwastage.l_cache')::ty_alloc_array.delete; --delete cache before first call
            drug_list := get_dose_lwastage.get_drug_list(presc_qty);
            arr_indx := drug_list.array.last;
            WHILE (arr_indx IS NOT NULL AND arr_indx::text <> '') LOOP arr_indx := drug_list.array.PRIOR(arr_indx);
            END LOOP;
            arr_indx := drug_list.array.last;
            WHILE (arr_indx IS NOT NULL AND arr_indx::text <> '') LOOP
                IF finalarr.EXISTS(drug_list.array[arr_indx].cd_material) THEN
                    finalarr(drug_list.array[arr_indx].cd_material).qt_dose_quantity := finalarr(drug_list.array[arr_indx].cd_material).qt_dose_quantity + 1;
                ELSE
                    finalarr(drug_list.array[arr_indx].cd_material) := drug_list.array(arr_indx);
                    finalarr(drug_list.array[arr_indx].cd_material).qt_dose_quantity := 1;
                END IF;
                arr_indx := drug_list.array.PRIOR(arr_indx);
            END LOOP;
        END IF;
        dose := finalarr.last;
        WHILE (dose IS NOT NULL AND dose::text <> '') LOOP
            dose := finalarr.PRIOR(dose);
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
            NULL;
    END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE get_dose_lwastage.get_medicine_quantity (finalarr INOUT dosage_array, pres_dose_p bigint, spec_grp_p bigint, dosage_array_p ty_list_array ) FROM PUBLIC;
