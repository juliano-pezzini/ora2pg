-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


--Procedure utilizada para atualizar os valores de materiais do recurso de glosa



CREATE OR REPLACE PROCEDURE pls_gerencia_envio_ans_pck.atualiza_valor_mat_rec ( nr_seq_lote_p pls_monitor_tiss_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


qt_pago_w		pls_monitor_tiss_mat_val.qt_liberado%type;
vl_recursado_w		pls_rec_glosa_mat.vl_recursado%type;
vl_pago_w		pls_rec_glosa_mat.vl_acatado%type;
vl_glosa_w		pls_rec_glosa_mat.vl_recursado%type;
nr_index_w		integer;
dados_mat_update_w	pls_gerencia_envio_ans_pck.dados_monitor_mat_update;

C01 CURSOR(nr_seq_lote_pc	pls_monitor_tiss_lote.nr_sequencia%type) FOR
	SELECT	a.nr_sequencia nr_seq_mat_val,
		b.dt_pagamento_recurso,
		a.nr_seq_conta_mat,
		a.nr_seq_mat_rec,
		b.nr_seq_conta
	from	pls_monitor_tiss_mat_val a,
		pls_monitor_tiss_cta_val b
	where	b.nr_sequencia 		= a.nr_seq_cta_val
	and	(a.nr_seq_mat_rec IS NOT NULL AND a.nr_seq_mat_rec::text <> '')
	and	b.nr_seq_lote_monitor 	= nr_seq_lote_pc;

BEGIN
--Inicia o contador

nr_index_w := 0;

--Abre o cursor de itens que so de recurso de glosa

for r_C01_w in C01(nr_seq_lote_p) loop
	--Caso seja pagamento do recurso ento busca o valor liberado e o valor de glosa

	if (r_C01_w.dt_pagamento_recurso IS NOT NULL AND r_C01_w.dt_pagamento_recurso::text <> '') then
		select	sum(coalesce(a.vl_liberado,0)),
			sum(coalesce(a.vl_glosa,0))
		into STRICT	vl_pago_w,
			vl_glosa_w
		from	pls_conta_rec_resumo_item	a
		where	a.nr_seq_mat_rec = r_C01_w.nr_seq_mat_rec;

	else
		-- Caso no seja pagamento de recurso os valores e quantidade paga ficam zerados

		qt_pago_w := 0;
		vl_pago_w := 0;
		vl_glosa_w := 0;
	end if;

	--Caso o valor pago for maior que zero o valor liberado ser fixo 1

	if (vl_pago_w > 0) then
		qt_pago_w := 1;
	else
		qt_pago_w := 0;
	end if;

	--Pega o valor recursodo pois este ser sempre o valor apresentado

	select	sum(vl_recursado)
	into STRICT	vl_recursado_w
	from	pls_rec_glosa_mat
	where	nr_sequencia = r_c01_w.nr_seq_mat_rec;

	--Insere os dados no record para depois fazer o update

	dados_mat_update_w.qt_liberado(nr_index_w)	:= qt_pago_w;
	dados_mat_update_w.vl_material(nr_index_w)	:= coalesce(vl_recursado_w,0);
	dados_mat_update_w.qt_material(nr_index_w)	:= 1;
	dados_mat_update_w.vl_liberado(nr_index_w)	:= vl_pago_w;
	dados_mat_update_w.vl_glosa(nr_index_w)		:= vl_glosa_w;
	dados_mat_update_w.nr_sequencia(nr_index_w)	:= r_C01_w.nr_seq_mat_val;

	--Caso tenha alcanado a quantidade de registros, chama a procedure para realizar o forall e limpa as variveis

	--Caso no, incrementa o contador

	if (nr_index_w >= pls_util_pck.qt_registro_transacao_w) then
		CALL pls_gerencia_envio_ans_pck.atualizar_monit_tiss_mat_rec(dados_mat_update_w, nm_usuario_p);

		dados_mat_update_w := pls_gerencia_envio_ans_pck.limpar_type_dados_mat_update(dados_mat_update_w);

		nr_index_w := 0;
	else
		nr_index_w := nr_index_w + 1;
	end if;
end loop;
--Chama a procedure que realiza o forall pois caso enha restado algum registro ir fazer o update

CALL pls_gerencia_envio_ans_pck.atualizar_monit_tiss_mat_rec(dados_mat_update_w, nm_usuario_p);
--Limpa o record de update

dados_mat_update_w := pls_gerencia_envio_ans_pck.limpar_type_dados_mat_update(dados_mat_update_w);

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_gerencia_envio_ans_pck.atualiza_valor_mat_rec ( nr_seq_lote_p pls_monitor_tiss_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
