-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE ctb_online_pck.ctb_atualizar_saldo ( nr_lote_contabil_p bigint, ie_acumular_p text, nm_usuario_p text, ie_virada_p text, ds_erro_p INOUT text, ie_consistir_p text default 'S') AS $body$
DECLARE


nr_sequencia_w          ctb_saldo.nr_sequencia%type;
nr_seq_movimento_w      ctb_movimento.nr_sequencia%type;
current_setting('ctb_online_pck.cd_conta_contabil_w')::ctb_regra_estab_dif.cd_conta_contabil%type     conta_contabil.cd_conta_contabil%type;
cd_centro_custo_w       ctb_movto_centro_custo.cd_centro_custo%type;
vl_movimento_w          ctb_movto_centro_custo.vl_movimento%type;
vl_encerramento_w       ctb_movto_centro_custo.vl_movimento%type;
vl_enc_debito_w         ctb_movto_centro_custo.vl_movimento%type;
vl_enc_credito_w        ctb_movto_centro_custo.vl_movimento%type;
vl_debito_w             ctb_movto_centro_custo.vl_movimento%type;
vl_credito_w            ctb_movto_centro_custo.vl_movimento%type;
vl_saldo_w              ctb_saldo.vl_saldo%type;
nr_seq_mes_ref_w        lote_contabil.nr_seq_mes_ref%type;
nr_seq_mes_ant_w        ctb_mes_ref.nr_sequencia%type;
cd_estab_lote_w         lote_contabil.cd_estabelecimento%type;
cd_estabelecimento_w    ctb_movimento.cd_estabelecimento%type;
cd_empresa_w            ctb_mes_ref.cd_empresa%type;
ie_deb_cred_w           varchar(01);
ie_centro_custo_w       varchar(01);
ie_debito_credito_w     ctb_grupo_conta.ie_debito_credito%type;
ie_encerramento_w       lote_contabil.ie_encerramento%type;
ds_exception_w          varchar(4000);
ds_erro_w               varchar(2000);
ds_erro_ww              varchar(2000);
dt_referencia_w         ctb_mes_ref.dt_referencia%type;
dt_referencia_ww        ctb_mes_ref.dt_referencia%type;
dt_atualizacao_w        lote_contabil.dt_atualizacao_saldo%type;
dt_consistencia_w       lote_contabil.dt_consistencia%type;
dt_abertura_w           ctb_mes_ref.dt_abertura%type;
dt_processo_w           lote_contabil.dt_processo%type;
dt_fechamento_w         ctb_mes_ref.dt_fechamento%type;
qt_movto_cc_w           bigint;
cd_classificacao_w      ctb_movimento.cd_classif_debito%type;
cd_classif_sup_w        conta_contabil.cd_classif_superior%type;
nr_nivel_conta_w        integer(10);
ie_eliminacao_lancto_w  ctb_movimento.ie_eliminacao_lancto%type;
nr_seq_proj_rec_w       ctb_movimento.nr_seq_proj_rec%type;
ie_agrupar_projeto_w    varchar(01);
cd_perfil_w             integer(5);
ie_debito_const         constant      varchar(01) := 'D';
ie_credito_const        constant      varchar(01) := 'C';
ie_not_const            constant      varchar(01) := 'N';
ie_yes_const            constant      varchar(01) := 'S';
ie_x_const              constant      varchar(01) := 'X';
tam_subst_const         constant      integer(04)       := 4000;
msg_269630              constant      integer(6)        := 269630; --('O Mes esta fechado ou nao aberto' || '#@#@');
msg_269638              constant      integer(6)        := 269638; --('Erro ao Inserir Saldo: (1)' || chr(13) ||ds_erro_w || '#@#@');
msg_269639              constant      integer(6)        := 269639; --('Erro ao Inserir Saldo: (2)' || chr(13) ||ds_erro_w || '#@#@');

type t_estab is table of boolean index by integer;
estab_w         t_estab;

C01 CURSOR FOR
SELECT  a.nr_sequencia,
        a.vl_movimento,
        a.cd_conta_debito,
        ie_debito_const,
        ie_centro_custo,
        c.ie_debito_credito,
        CASE WHEN ie_encerramento_w=ie_not_const THEN  0  ELSE a.vl_movimento END  vl_encerramento,
        coalesce(a.cd_estabelecimento, cd_estab_lote_w) cd_estabelecimento,
        a.cd_classif_debito cd_classificacao,
        a.ie_eliminacao_lancto
from    ctb_grupo_conta c,
        Conta_contabil b,
        ctb_movimento a
where   a.nr_lote_contabil = nr_lote_contabil_p
and     a.cd_conta_debito  = b.cd_conta_contabil
and     b.cd_grupo         = c.cd_grupo
and     coalesce(a.ds_consistencia::text, '') = ''

union all

SELECT  a.nr_sequencia,
        a.vl_movimento,
        a.cd_conta_credito,
        ie_credito_const,
        ie_centro_custo,
        c.ie_debito_credito,
        CASE WHEN ie_encerramento_w=ie_not_const THEN  0  ELSE a.vl_movimento END  vl_encerramento,
        coalesce(a.cd_estabelecimento, cd_estab_lote_w) cd_estabelecimento,
        a.cd_classif_credito cd_classificacao,
        a.ie_eliminacao_lancto
from    ctb_grupo_conta c,
        Conta_contabil b,
        ctb_movimento a
where   a.nr_lote_contabil  = nr_lote_contabil_p
and     a.cd_conta_credito  = b.cd_conta_contabil
and     b.cd_grupo          = c.cd_grupo
and     coalesce(a.dt_atualizacao_saldo::text, '') = '';

C02 CURSOR FOR
SELECT  cd_centro_custo,
        vl_movimento,
        CASE WHEN ie_encerramento_w=ie_not_const THEN  0  ELSE vl_movimento END  vl_encerramento
from    ctb_movto_centro_custo
where   nr_seq_movimento    = nr_seq_movimento_w
and     ie_centro_custo_w   in (ie_yes_const,'O')

union all

SELECT  0,
        vl_movimento_w,
        vl_encerramento_w

where   ((ie_centro_custo_w = ie_not_const) or (qt_movto_cc_w = 0));

C03 CURSOR FOR
SELECT distinct nr_seq_proj_rec from ( SELECT  a.nr_seq_proj_rec
                                       from    ctb_grupo_conta c,
                                               Conta_contabil b,
                                               ctb_movimento a
                                       where   a.nr_lote_contabil = nr_lote_contabil_p
                                       and     a.cd_conta_debito  = b.cd_conta_contabil
                                       and     b.cd_grupo         = c.cd_grupo
                                       and     (a.nr_seq_proj_rec IS NOT NULL AND a.nr_seq_proj_rec::text <> '')

union all

                                       select  a.nr_seq_proj_rec
                                       from    ctb_grupo_conta c,
                                               Conta_contabil b,
                                               ctb_movimento a
                                       where   a.nr_lote_contabil  = nr_lote_contabil_p
                                       and     a.cd_conta_credito  = b.cd_conta_contabil
                                       and     b.cd_grupo          = c.cd_grupo
                                       and     (a.nr_seq_proj_rec IS NOT NULL AND a.nr_seq_proj_rec::text <> '') ) alias2;


  vet RECORD;

BEGIN

    cd_perfil_w             := wheb_usuario_pck.get_cd_perfil;

    if (ie_consistir_p = ie_yes_const) then

        ds_erro_p             =>    ds_erro_w := ctb_online_pck.ctb_consistir_lote( nr_lote_contabil_p    =>    nr_lote_contabil_p, ds_erro_p             =>    ds_erro_w, nm_usuario_p          =>    nm_usuario_p);

    end if;

    begin
        select nr_seq_mes_ref,
               cd_estabelecimento,
               dt_atualizacao_saldo,
               dt_consistencia,
               dt_processo,
               coalesce(ie_encerramento,ie_not_const)
        into STRICT   nr_seq_mes_ref_w,
               cd_estab_lote_w,
               dt_atualizacao_w,
               dt_consistencia_w,
               dt_processo_w,
               ie_encerramento_w
        from   lote_contabil
        where  nr_lote_contabil    = nr_lote_contabil_p;
    exception
        when no_data_found then
             ds_exception_w  := SUBSTR(SQLERRM, 1, tam_subst_const);
             CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => ds_exception_w );
        when too_many_rows then
             ds_exception_w  := SUBSTR(SQLERRM, 1, tam_subst_const);
             CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => ds_exception_w );
        when others then
             ds_exception_w  := SUBSTR(SQLERRM, 1, tam_subst_const);
             CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => ds_exception_w );
    end;

    if (ie_acumular_p = ie_yes_const) then

        ctb_consistir_classif_saldo( nr_seq_mes_ref_p  => nr_seq_mes_ref_w,
                                     cd_estab_p        => cd_estab_lote_w,
                                     nm_usuario_p      => nm_usuario_p,
                                     ds_erro_p         => ds_erro_w );

    end if;

    begin
        select cd_empresa,
               dt_referencia,
               dt_abertura,
               dt_fechamento
        into STRICT   cd_empresa_w,
               dt_referencia_w,
               dt_abertura_w,
               dt_fechamento_w
        from   ctb_mes_ref
        where  nr_sequencia   = nr_seq_mes_ref_w;
    exception
        when no_data_found then
             ds_exception_w  := SUBSTR(SQLERRM, 1, tam_subst_const);
             CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => ds_exception_w );
        when too_many_rows then
             ds_exception_w  := SUBSTR(SQLERRM, 1, tam_subst_const);
             CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => ds_exception_w );
         when others then
             ds_exception_w  := SUBSTR(SQLERRM, 1, tam_subst_const);
             CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => ds_exception_w );
    end;

    dt_referencia_ww     := PKG_DATE_UTILS.start_of( PKG_DATE_UTILS.ADD_MONTH(dt_referencia_w, 1, 0), 'month', 0 );

    select coalesce(max(nr_sequencia),0)
    into STRICT   nr_seq_mes_ant_w
    from   ctb_mes_ref
    where  cd_empresa     = cd_empresa_w
    and    dt_referencia  = dt_referencia_ww;

    if (coalesce(dt_abertura_w::text, '') = '') or (dt_fechamento_w IS NOT NULL AND dt_fechamento_w::text <> '') then

        --(-20011, 'O Mes esta fechado ou nao aberto' || '#@#@');

        CALL wheb_mensagem_pck.exibir_mensagem_abort( ds_mensagem_erro_p => msg_269630 );

    end if;

    CALL ctb_atualizar_dt_processo( cd_estabelecimento_p => cd_estab_lote_w,
                               nr_seq_mes_ref_p     => nr_seq_mes_ref_w,
                               nr_lote_contabil_p   => nr_lote_contabil_p,
                               nm_usuario_p         => nm_usuario_p,
                               dt_processo_p        => clock_timestamp() );

    CALL ctb_gravar_log_lote( nr_lote_contabil_p, 5, null, nm_usuario_p);

    for vet in ( SELECT  a.nr_sequencia
                 from    ctb_movimento a
                 where   a.nr_lote_contabil     = nr_lote_contabil_p
                 and     (a.dt_atualizacao_saldo IS NOT NULL AND a.dt_atualizacao_saldo::text <> '')
                 and     a.ie_status_origem     = 'SO') loop

        CALL ctb_online_pck.ctb_desatualizar_saldo_movto( nr_seq_movto_p => vet.nr_sequencia,
                                                     ie_acumular_p  => ie_not_const,
                                                     nm_usuario_p   => nm_usuario_p,
                                                     ie_commit_p    => ie_yes_const );
    end loop;

    open    C01;
    loop
    fetch   C01 into
        nr_seq_movimento_w,
        vl_movimento_w,
        current_setting('ctb_online_pck.cd_conta_contabil_w')::ctb_regra_estab_dif.cd_conta_contabil%type,
        ie_deb_cred_w,
        ie_centro_custo_w,
        ie_debito_credito_w,
        vl_encerramento_w,
        cd_estabelecimento_w,
        cd_classificacao_w,
        ie_eliminacao_lancto_w;
    EXIT WHEN NOT FOUND; /* apply on C01 */

        if (not estab_w.exists(cd_estabelecimento_w)) then

            estab_w(cd_estabelecimento_w) := true;

        end if;

        cd_classif_sup_w    := substr(ctb_obter_classif_conta_sup( cd_classif_conta_p => cd_classificacao_w,
                                                                   dt_vigencia_p      => dt_referencia_w,
                                                                   cd_empresa_p       => cd_empresa_w ), 1, 40 );

        nr_nivel_conta_w    := CTB_Obter_Nivel_Classif_Conta(cd_classif_conta_p => cd_classificacao_w);

        vl_enc_debito_w     := 0;
        vl_enc_credito_w    := 0;

        select  count(nr_sequencia)
        into STRICT    qt_movto_cc_w
        from    ctb_movto_centro_custo
        where   nr_seq_movimento = nr_seq_movimento_w;

        if (ie_encerramento_w = ie_not_const) and (ie_centro_custo_w = 'O') and (qt_movto_cc_w = 0) then

            ie_centro_custo_w   := ie_not_const;

        end if;

        open    C02;
        loop
        fetch   C02 into
            cd_centro_custo_w,
            vl_movimento_w,
            vl_encerramento_w;
        EXIT WHEN NOT FOUND; /* apply on C02 */

            if (cd_centro_custo_w = 0) then

                cd_centro_custo_w  := null;

            end if;

            select  coalesce(max(nr_sequencia),0)
            into STRICT    nr_sequencia_w
            from    ctb_saldo
            where   nr_seq_mes_ref          = nr_seq_mes_ref_w
            and     cd_estabelecimento      = cd_estabelecimento_w
            and     cd_conta_contabil       = current_setting('ctb_online_pck.cd_conta_contabil_w')::ctb_regra_estab_dif.cd_conta_contabil%type
            and     coalesce(cd_centro_custo,0)  = coalesce(cd_centro_custo_w,0);

            if (nr_sequencia_w = 0) then

                vl_saldo_w      := 0;

                if (nr_seq_mes_ant_w > 0) then

                    select  coalesce(max(vl_saldo),0)
                    into STRICT    vl_saldo_w
                    from    ctb_saldo
                    where   nr_seq_mes_ref          = nr_seq_mes_ant_w
                    and     cd_estabelecimento      = cd_estabelecimento_w
                    and     cd_conta_contabil       = current_setting('ctb_online_pck.cd_conta_contabil_w')::ctb_regra_estab_dif.cd_conta_contabil%type
                    and     coalesce(cd_centro_custo,0)  = coalesce(cd_centro_custo_w,0);

                end if;

                begin
                insert into ctb_saldo(
                    nr_sequencia,           nr_seq_mes_ref,
                    dt_atualizacao,         nm_usuario,
                    cd_estabelecimento,     cd_conta_contabil,
                    cd_centro_custo,        vl_debito,
                    vl_encerramento,        vl_credito,
                    vl_movimento,           vl_saldo,
                    vl_enc_debito,          vl_enc_credito,
                    vl_eliminacao,          cd_classificacao,
                    cd_classif_sup,         nr_nivel_conta)
                values (
                    nextval('ctb_saldo_seq'),  nr_seq_mes_ref_w,
                    clock_timestamp(),                nm_usuario_p,
                    cd_estabelecimento_w,   current_setting('ctb_online_pck.cd_conta_contabil_w')::ctb_regra_estab_dif.cd_conta_contabil%type,
                    cd_centro_custo_w,      0,
                    0,                      0,
                    0,                      vl_saldo_w,
                    0,                      0,
                    0,                      cd_classificacao_w,
                    cd_classif_sup_w,       nr_nivel_conta_w);
                exception
                    when unique_violation then
                        ds_erro_w   := sqlerrm(SQLSTATE);
                        --(-20011,'Erro ao Inserir Saldo: (1)' || chr(13) ||ds_erro_w || '#@#@');

                        CALL wheb_mensagem_pck.exibir_mensagem_abort( nr_seq_mensagem_p => msg_269638,
                                                                 vl_macros_p       => 'DS_ERRO='||ds_erro_w );
                    when others then
                        ds_erro_w   := sqlerrm(SQLSTATE);
                        --(-20011,'Erro ao Inserir Saldo: (1)' || chr(13) ||ds_erro_w || '#@#@');

                        CALL wheb_mensagem_pck.exibir_mensagem_abort( nr_seq_mensagem_p => msg_269638,
                                                                 vl_macros_p       => 'DS_ERRO='||ds_erro_w );
                end;

            end if;

            vl_debito_w         := 0;
            vl_credito_w        := 0;
            vl_enc_debito_w     := 0;
            vl_enc_credito_w    := 0;

            if (ie_deb_cred_w   = ie_debito_const) then
                vl_debito_w     := vl_movimento_w;
                vl_enc_debito_w := coalesce(vl_encerramento_w,0);
            else
                vl_credito_w        := vl_movimento_w;
                vl_enc_credito_w    := coalesce(vl_encerramento_w,0);
            end if;
            if (ie_debito_credito_w <> ie_deb_cred_w) then
                vl_movimento_w      := vl_movimento_w * -1;
                vl_encerramento_w   := vl_encerramento_w * -1;
            end if;

            begin
                update  ctb_saldo
                set     dt_atualizacao      = clock_timestamp(),
                        nm_usuario          = nm_usuario_p,
                        vl_debito           = vl_debito + vl_debito_w,
                        vl_credito          = vl_credito + vl_credito_w,
                        vl_saldo            = vl_saldo + vl_movimento_w,
                        vl_movimento        = vl_movimento + vl_movimento_w,
                        vl_encerramento     = vl_encerramento + vl_encerramento_w,
                        vl_enc_debito       = coalesce(vl_enc_debito,0) + vl_enc_debito_w,
                        vl_enc_credito      = coalesce(vl_enc_credito,0) + vl_enc_credito_w,
                        vl_eliminacao       = coalesce(vl_eliminacao,0) + CASE WHEN ie_eliminacao_lancto_w=ie_yes_const THEN  vl_movimento_w  ELSE 0 END ,
                        cd_classificacao    = cd_classificacao_w,
                        cd_classif_sup      = cd_classif_sup_w,
                        nr_nivel_conta      = nr_nivel_conta_w
                where   nr_sequencia        = nr_sequencia_w;
            exception
                when no_data_found then
                    ds_erro_w   := sqlerrm(SQLSTATE);
                    --(-20011,'Erro ao Inserir Saldo: (2)' || chr(13) ||ds_erro_w || '#@#@');

                    CALL wheb_mensagem_pck.exibir_mensagem_abort( nr_seq_mensagem_p => msg_269639,
                                                             vl_macros_p       => 'DS_ERRO='||ds_erro_w);
                when too_many_rows then
                    ds_erro_w   := sqlerrm(SQLSTATE);
                    --(-20011,'Erro ao Inserir Saldo: (2)' || chr(13) ||ds_erro_w || '#@#@');

                    CALL wheb_mensagem_pck.exibir_mensagem_abort( nr_seq_mensagem_p => msg_269639,
                                                             vl_macros_p       => 'DS_ERRO='||ds_erro_w);
            end;

        end loop;
        close C02;

    end loop;
    close C01;

    update  ctb_movimento a
    set     a.dt_atualizacao_saldo = clock_timestamp()
    where   a.nr_lote_contabil     = nr_lote_contabil_p
    and     coalesce(a.ds_consistencia::text, '') = '';

    update  lote_contabil a
    set     a.dt_atualizacao_saldo = clock_timestamp()
    where   a.nr_lote_contabil     = nr_lote_contabil_p
    and     not exists ( SELECT 1
                         from ctb_movimento b
                         where a.nr_lote_contabil     = b.nr_lote_contabil
                         and   coalesce(b.dt_atualizacao_saldo::text, '') = '' );
    commit;

    CALL ctb_atualizar_dt_processo( cd_estabelecimento_p => cd_estab_lote_w,
                               nr_seq_mes_ref_p     => nr_seq_mes_ref_w,
                               nr_lote_contabil_p   => nr_lote_contabil_p,
                               nm_usuario_p         => nm_usuario_p,
                               dt_processo_p        => null );

    cd_estabelecimento_w := estab_w.first;
    while (cd_estabelecimento_w IS NOT NULL AND cd_estabelecimento_w::text <> '') loop

        if (ie_acumular_p = ie_yes_const) then

            CALL ctb_online_pck.CTB_Acumular_Saldo( nr_seq_mes_ref_w,
                                               cd_estabelecimento_w,
                                               nm_usuario_p );

        end if;

        if (ie_virada_p = ie_yes_const) then

            CALL ctb_virada_saldo( nr_seq_mes_ref_p     => nr_seq_mes_ref_w,
                              cd_estabelecimento_p => cd_estabelecimento_w,
                              nm_usuario_p         => nm_usuario_p );

        end if;

        cd_estabelecimento_w := estab_w.next(cd_estabelecimento_w);

    end loop;

    ds_erro_p := ds_erro_w;

    obter_param_usuario(923, 125, cd_perfil_w, nm_usuario_p, cd_estabelecimento_w, ie_agrupar_projeto_w);

    if ie_agrupar_projeto_w = ie_yes_const then

        open    C03;
        loop
        fetch   C03 into
            nr_seq_proj_rec_w;
        EXIT WHEN NOT FOUND; /* apply on C03 */

        CTB_ATUALIZAR_SALDO_PROJETO( nr_lote_contabil_p   => nr_lote_contabil_p,
                                     ie_acumular_p        => ie_acumular_p,
                                     nm_usuario_p         => nm_usuario_p,
                                     ie_virada_p          => ie_virada_p,
                                     ds_erro_p            => ds_erro_ww,
                                     ie_consistir_p       => ie_consistir_p,
                                     nr_seq_proj_rec_p    => nr_seq_proj_rec_w );

        end loop;
        close C03;

        if  coalesce(ds_erro_p::text, '') = '' then

            ds_erro_p := ds_erro_ww;

        end if;

    end if;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE ctb_online_pck.ctb_atualizar_saldo ( nr_lote_contabil_p bigint, ie_acumular_p text, nm_usuario_p text, ie_virada_p text, ds_erro_p INOUT text, ie_consistir_p text default 'S') FROM PUBLIC;
