-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';

-- ? feito union no comando abaixo para tratar tanto se for selecionado v?rios itens, quanto se for clicado somente com o bot?o direito do mouse
-- fun??o respons?vel por calcular o valor liberado e taxas para interc?mbio (procedimento) quando for decidido aceitar o valor
-- calculado do item
CREATE OR REPLACE FUNCTION pls_cta_alt_valor_pck.pls_calc_vl_lib_vl_calc ( vl_apre_hi_p pls_conta_proc_v.vl_procedimento_ptu_imp%type, vl_apre_mat_p pls_conta_proc_v.vl_material_ptu_imp%type, vl_apre_co_p pls_conta_proc_v.vl_co_ptu_imp%type, vl_apre_taxa_hi_p pls_conta_proc_v.vl_taxa_servico_imp%type, vl_apre_taxa_mat_p pls_conta_proc_v.vl_taxa_material_imp%type, vl_apre_taxa_co_p pls_conta_proc_v.vl_taxa_co_imp%type, vl_calc_hi_p pls_conta_proc_v.vl_calc_hi_util%type, vl_calc_mat_p pls_conta_proc_v.vl_calc_mat_util%type, vl_calc_co_p pls_conta_proc_v.vl_calc_co_util%type, vl_calc_taxa_hi_p pls_conta_proc_v.vl_taxa_servico%type, vl_calc_taxa_mat_p pls_conta_proc_v.vl_taxa_material%type, vl_calc_taxa_co_p pls_conta_proc_v.vl_taxa_co%type, tx_intercambio_imp_p pls_conta_proc_v.tx_intercambio_imp%type, tx_intercambio_p pls_conta_proc_v.tx_intercambio%type) RETURNS DADOS_VL_TX_LIBE AS $body$
DECLARE


dados_retorno_w   dados_vl_tx_libe;
pr_liberacao_w     bigint;
vl_dif_liberado_w  pls_conta_proc.vl_liberado%type;
ie_resolveu_dif_w  boolean;
vl_total_calc_w    pls_conta_proc.vl_liberado%type;
vl_total_apres_w  pls_conta_proc.vl_liberado%type;


BEGIN

--Quando estivermos falando de interc?mbio, o valor calculado n?o poder? superar o valor apresentado, ent?o primeiramente comparamos e
--caso for maior, todos os valores e taxas que comp?em o vl_calculado, passar?o a receber os valores apresentados.
vl_total_calc_w := coalesce(vl_calc_hi_p,0) + coalesce(vl_calc_co_p,0) + coalesce(vl_calc_mat_p,0) +
       coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0);

vl_total_apres_w:= coalesce(vl_apre_hi_p,0) + coalesce(vl_apre_co_p,0) + coalesce(vl_apre_mat_p,0) +
       coalesce(vl_apre_taxa_hi_p,0) + coalesce(vl_apre_taxa_co_p,0) + coalesce(vl_apre_taxa_mat_p,0);

if (vl_total_calc_w > vl_total_apres_w) then

  dados_retorno_w.vl_liberado_hi  := vl_apre_hi_p;
  dados_retorno_w.vl_liberado_co  := vl_apre_co_p;
  dados_retorno_w.vl_liberado_mat := vl_apre_mat_p;
  dados_retorno_w.vl_lib_taxa_hi  := vl_apre_taxa_hi_p;
  dados_retorno_w.vl_lib_taxa_mat  := vl_apre_taxa_mat_p;
  dados_retorno_w.vl_lib_taxa_co  := vl_apre_taxa_co_p;

elsif (vl_calc_hi_p <= vl_apre_hi_p) and (vl_calc_co_p <= vl_apre_co_p) and (vl_calc_mat_p <= vl_apre_mat_p) and (vl_calc_taxa_hi_p <= vl_apre_taxa_hi_p ) and (vl_calc_taxa_co_p <= vl_apre_taxa_co_p) and (vl_calc_taxa_mat_p <= vl_apre_taxa_mat_p) then
  dados_retorno_w.vl_liberado_hi  := vl_calc_hi_p;
  dados_retorno_w.vl_liberado_co  := vl_calc_co_p;
  dados_retorno_w.vl_liberado_mat := vl_calc_mat_p;
  dados_retorno_w.vl_lib_taxa_hi  := vl_calc_taxa_hi_p;
  dados_retorno_w.vl_lib_taxa_mat  := vl_calc_taxa_mat_p;
  dados_retorno_w.vl_lib_taxa_co  := vl_calc_taxa_co_p;
else

	-- Caso os valores calculados de taxas sejam 0 e a soma dos valores
	-- individuais calculados seja maior que os valores individuais 
	-- ? liberado o valor apresentado, mantendo assim o teto do valor apresentado
  if (coalesce(vl_calc_taxa_hi_p, 0) = 0) and (coalesce(vl_calc_taxa_mat_p, 0) = 0) and (coalesce(vl_calc_taxa_co_p, 0) = 0) and
    ((coalesce(vl_calc_hi_p,0) + coalesce(vl_calc_co_p,0) + coalesce(vl_calc_mat_p,0)) >
    (coalesce(vl_apre_hi_p,0) + coalesce(vl_apre_co_p,0) + coalesce(vl_apre_mat_p,0))) then

    dados_retorno_w.vl_liberado_hi := coalesce(vl_apre_hi_p,0);
    dados_retorno_w.vl_liberado_co := coalesce(vl_apre_co_p,0);
    dados_retorno_w.vl_liberado_mat := coalesce(vl_apre_mat_p,0);
  else
    -- Obter primeiro a propor??o de libera??o do valor total  e das taxas
    -- divide o somat?rio do calculado pelo apresentado
    --tratamento realizado para caso n?o exista valor de taxa calculado para que n?o exista diverg?ncia no valor liberado
    --Necess?rio realizar o round por quatro para n?o liberar um valor a maior que o apresentado
    if (coalesce(vl_calc_taxa_hi_p, 0) = 0) and (coalesce(vl_calc_taxa_mat_p, 0) = 0) and (coalesce(vl_calc_taxa_co_p, 0) = 0) then
      pr_liberacao_w  := round((dividir_sem_round(coalesce(vl_calc_hi_p,0) + coalesce(vl_calc_co_p,0) + coalesce(vl_calc_mat_p,0)
            ,coalesce(vl_apre_hi_p,0) + coalesce(vl_apre_co_p,0) + coalesce(vl_apre_mat_p,0)))::numeric,4);
    --necess?rio o tratamento abaixo para quando houver discrep?ncia entre o valor da taxa apresentado e o valor calculado
    elsif  ((coalesce(tx_intercambio_imp_p,0) > (coalesce(tx_intercambio_p,0)+1)) and (coalesce(tx_intercambio_p,0) > 0) and
      (((coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0)) < (coalesce(vl_apre_taxa_hi_p,0) + coalesce(vl_apre_taxa_co_p,0) + coalesce(vl_apre_taxa_mat_p,0))) and
      ((coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0)) > 0))) then
      pr_liberacao_w  := round((dividir_sem_round(coalesce(vl_calc_hi_p,0) + coalesce(vl_calc_co_p,0) + coalesce(vl_calc_mat_p,0)
            ,coalesce(vl_apre_hi_p,0) + coalesce(vl_apre_co_p,0) + coalesce(vl_apre_mat_p,0)))::numeric,4);
    else
      pr_liberacao_w  := round((dividir_sem_round(coalesce(vl_calc_hi_p,0) + coalesce(vl_calc_co_p,0) + coalesce(vl_calc_mat_p,0) +
                   coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0)
            ,coalesce(vl_apre_hi_p,0) + coalesce(vl_apre_co_p,0) + coalesce(vl_apre_mat_p,0) +
            coalesce(vl_apre_taxa_hi_p,0) + coalesce(vl_apre_taxa_co_p,0) + coalesce(vl_apre_taxa_mat_p,0)))::numeric,4);
    end if;

    -- Valores liberados individuais
	
	if (pr_liberacao_w > 1) then
		dados_retorno_w.vl_liberado_hi := vl_apre_hi_p;
		dados_retorno_w.vl_liberado_co  := vl_apre_co_p;
		dados_retorno_w.vl_liberado_mat  := vl_apre_mat_p;
	else
		dados_retorno_w.vl_liberado_hi := round((coalesce(vl_apre_hi_p, 0) * pr_liberacao_w)::numeric, 2);
		dados_retorno_w.vl_liberado_co  := round((coalesce(vl_apre_co_p, 0) * pr_liberacao_w)::numeric,2);
		dados_retorno_w.vl_liberado_mat  := round((coalesce(vl_apre_mat_p, 0) * pr_liberacao_w)::numeric,2);
	end if;
  end if;

  -- Liberado taxas
  -- ? feito este if pelo motivo que a conta pode ter sido enviada depois do per?odo que calcula a taxa de interc?mbio.
  -- na verdade, se n?o calculou taxa de interc?mbio, n?o deve gerar valores para liberar, por isso ? atribu?do zero para as taxas
  --Alterado o tratamento para somente n?o atualizar caso todas as taxas sejam 0, pois pode ser que tenha sido calculado taxa de co e apresentada taxa de Hi neste caso  deve ser ajustada a taxa liberada
  if (coalesce(vl_calc_taxa_hi_p, 0) = 0) and (coalesce(vl_calc_taxa_mat_p, 0) = 0) and (coalesce(vl_calc_taxa_co_p, 0) = 0) then
    dados_retorno_w.vl_lib_taxa_hi  := 0;
    dados_retorno_w.vl_lib_taxa_mat  := 0;
    dados_retorno_w.vl_lib_taxa_co  := 0;
  elsif  ((coalesce(tx_intercambio_imp_p,0) > (coalesce(tx_intercambio_p,0)+1)) and (coalesce(tx_intercambio_p,0) > 0) and
    (((coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0)) < (coalesce(vl_apre_taxa_hi_p,0) + coalesce(vl_apre_taxa_co_p,0) + coalesce(vl_apre_taxa_mat_p,0))) and
    ((coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0)) > 0))) then
    if (coalesce(vl_apre_hi_p,0)  > 0) then
      dados_retorno_w.vl_lib_taxa_hi  := round((coalesce(vl_calc_taxa_hi_p,0))::numeric, 2);
    else
      dados_retorno_w.vl_lib_taxa_hi  := 0;
    end if;

    if (coalesce(vl_apre_mat_p,0) > 0) then
      dados_retorno_w.vl_lib_taxa_mat  := round((coalesce(vl_calc_taxa_mat_p,0))::numeric, 2);
    else
      dados_retorno_w.vl_lib_taxa_mat  := 0;
    end if;

    if (coalesce(vl_apre_co_p,0) > 0) then
      dados_retorno_w.vl_lib_taxa_co  := round((coalesce(vl_calc_taxa_co_p,0))::numeric,2);
    else
      dados_retorno_w.vl_lib_taxa_co  := 0;
    end if;

  else
    dados_retorno_w.vl_lib_taxa_hi  := round((coalesce(vl_apre_taxa_hi_p, 0) * pr_liberacao_w)::numeric, 2);
    dados_retorno_w.vl_lib_taxa_mat  := round((coalesce(vl_apre_taxa_mat_p, 0)  * pr_liberacao_w)::numeric, 2);
    dados_retorno_w.vl_lib_taxa_co  := round((coalesce(vl_apre_taxa_co_p,0)  * pr_liberacao_w)::numeric,2);
  end if;

  --Verifica se o valor liberado n?o ? superior ao calculado neste caso deve ser executado um aredondamento
  vl_dif_liberado_w  := ((dados_retorno_w.vl_liberado_hi) + (dados_retorno_w.vl_liberado_co) + (dados_retorno_w.vl_liberado_mat) +
           (dados_retorno_w.vl_lib_taxa_hi) + (dados_retorno_w.vl_lib_taxa_co) + (dados_retorno_w.vl_lib_taxa_mat)) -
           (coalesce(vl_calc_hi_p,0) + coalesce(vl_calc_co_p,0) + coalesce(vl_calc_mat_p,0) +
           coalesce(vl_calc_taxa_hi_p,0) + coalesce(vl_calc_taxa_co_p,0) + coalesce(vl_calc_taxa_mat_p,0));

  --Caso o valor for maior ser? verificado e qual valor esta a diferen?a e descontado o mesmo
  if (vl_dif_liberado_w > 0) then
    ie_resolveu_dif_w := false;
    --verifica??o para valor de hi
    if (dados_retorno_w.vl_liberado_hi > vl_calc_hi_p)  then
      dados_retorno_w.vl_liberado_hi  := dados_retorno_w.vl_liberado_hi - vl_dif_liberado_w;
      vl_dif_liberado_w := 0;
      ie_resolveu_dif_w := true;
    end if;
    --verifica??o para valor de co
    if (ie_resolveu_dif_w = false) then

      if (dados_retorno_w.vl_liberado_co > vl_calc_co_p) then
        dados_retorno_w.vl_liberado_co  := dados_retorno_w.vl_liberado_co - vl_dif_liberado_w;
        vl_dif_liberado_w := 0;
        ie_resolveu_dif_w := true;
      end if;
    end if;
    --verifica??o para valor de mat
    if (ie_resolveu_dif_w = false) then

      if (dados_retorno_w.vl_liberado_mat > vl_calc_mat_p) then
        dados_retorno_w.vl_liberado_mat  := dados_retorno_w.vl_liberado_mat - vl_dif_liberado_w;
        vl_dif_liberado_w := 0;
        ie_resolveu_dif_w := true;
      end if;
    end if;
    --verifica??o para valor taxa hi
    if (ie_resolveu_dif_w = false) then

      if (dados_retorno_w.vl_lib_taxa_hi > vl_calc_taxa_hi_p) then
        dados_retorno_w.vl_lib_taxa_hi  := dados_retorno_w.vl_lib_taxa_hi - vl_dif_liberado_w;
        vl_dif_liberado_w := 0;
        ie_resolveu_dif_w := true;
      end if;
    end if;
    --verifica??o para valor de co
    if (ie_resolveu_dif_w = false) then

      if (dados_retorno_w.vl_lib_taxa_co > vl_calc_taxa_co_p) then
        dados_retorno_w.vl_lib_taxa_co  := dados_retorno_w.vl_lib_taxa_co - vl_dif_liberado_w;
        vl_dif_liberado_w := 0;
        ie_resolveu_dif_w := true;
      end if;
    end if;
    --verifica??o para valor de mat
    if (ie_resolveu_dif_w = false) then

      if (dados_retorno_w.vl_lib_taxa_mat > vl_calc_taxa_mat_p) then
        dados_retorno_w.vl_lib_taxa_mat  := dados_retorno_w.vl_lib_taxa_mat - vl_dif_liberado_w;
        vl_dif_liberado_w := 0;
        ie_resolveu_dif_w := true;
      end if;
    end if;
  end if;
end if;

return dados_retorno_w;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION pls_cta_alt_valor_pck.pls_calc_vl_lib_vl_calc ( vl_apre_hi_p pls_conta_proc_v.vl_procedimento_ptu_imp%type, vl_apre_mat_p pls_conta_proc_v.vl_material_ptu_imp%type, vl_apre_co_p pls_conta_proc_v.vl_co_ptu_imp%type, vl_apre_taxa_hi_p pls_conta_proc_v.vl_taxa_servico_imp%type, vl_apre_taxa_mat_p pls_conta_proc_v.vl_taxa_material_imp%type, vl_apre_taxa_co_p pls_conta_proc_v.vl_taxa_co_imp%type, vl_calc_hi_p pls_conta_proc_v.vl_calc_hi_util%type, vl_calc_mat_p pls_conta_proc_v.vl_calc_mat_util%type, vl_calc_co_p pls_conta_proc_v.vl_calc_co_util%type, vl_calc_taxa_hi_p pls_conta_proc_v.vl_taxa_servico%type, vl_calc_taxa_mat_p pls_conta_proc_v.vl_taxa_material%type, vl_calc_taxa_co_p pls_conta_proc_v.vl_taxa_co%type, tx_intercambio_imp_p pls_conta_proc_v.tx_intercambio_imp%type, tx_intercambio_p pls_conta_proc_v.tx_intercambio%type) FROM PUBLIC;
