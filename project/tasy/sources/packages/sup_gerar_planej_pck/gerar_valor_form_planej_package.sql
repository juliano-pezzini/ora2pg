-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


	/* Procedure para gerar o valor das fórmulas de planejamento */

CREATE OR REPLACE PROCEDURE sup_gerar_planej_pck.gerar_valor_form_planej ( nr_sequencia_p bigint, cd_material_p bigint, ie_simular_p text, vl_retorno_p INOUT bigint, cd_estabelecimento_p bigint, nm_usuario_p text) AS $body$
DECLARE


	c001				integer;

	ds_formula_orig_w			varchar(4000);
	ds_formula_w			varchar(4000);
	ds_informacao_w			varchar(2000);
	vl_informacao_w			double precision;
	vl_atributo_w			double precision;
	tam_formula_w			bigint;
	ie_pos_separador_w		bigint;
	vl_coluna_w			varchar(17);
	ds_sql_w				varchar(4000);
	vl_retorno_atrib_w			double precision	:= 0;
	vl_formula_w			double precision;
	nm_formula_w			varchar(255);
	ie_cond_verdadeira_w		varchar(1);

	
BEGIN

	if (current_setting('sup_gerar_planej_pck.qt_dias_fim_mes_w')::bigint < 0) then
		begin

		select	round(last_day(clock_timestamp()) - clock_timestamp())
		into STRICT	current_setting('sup_gerar_planej_pck.qt_dias_fim_mes_w')::bigint
		;

		end;
	end if;

	/* Obter o nome e a fórmula a ser executada */

	select	upper(ds_formula),
		ds_macro
	into STRICT	ds_formula_orig_w,
		nm_formula_w
	from	sup_formula_planej_compra
	where	nr_sequencia = nr_sequencia_p;

	if (ds_formula_orig_w IS NOT NULL AND ds_formula_orig_w::text <> '') then
		begin

		/* Substitui as palavras chaves e quebras de linha */

		ds_formula_orig_w	:= replace(ds_formula_orig_w,'RAIZ','SQRT');
		ds_formula_orig_w := replace(ds_formula_orig_w,'TRUNCAR','TRUNC');
		ds_formula_orig_w := replace(ds_formula_orig_w,'ARREDONDAR','ROUND');
		ds_formula_orig_w	:= replace(ds_formula_orig_w,'POTENCIA','POWER');
		ds_formula_orig_w	:= replace(ds_formula_orig_w,'LOTE (','SUP_OBTER_QTDE_LOTE_MULTIPLO(' || to_char(cd_material_p) || ', ');
		ds_formula_orig_w	:= replace(ds_formula_orig_w,'DIAS',to_char(current_setting('sup_gerar_planej_pck.qt_dias_fim_mes_w')::bigint));
		ds_formula_orig_w	:= replace(replace(ds_formula_orig_w,chr(13),' '),chr(10),' ');

		/* Caso identifique a palavra "SE", compreende que é uma fórmula com condição lógica */

		/* e executa a rotina para validar se a condição é verdadeira */

		if (substr(ds_formula_orig_w,1,2) = 'SE') then
			begin

			ie_cond_verdadeira_w	:= 'N';

			/* Enquanto a condição não for verdadeira, continua testando */

			while(ie_cond_verdadeira_w <> 'S') loop
				begin

				/* Desmonta a condição para executar a rotina de validação */

				ds_formula_orig_w		:= substr(ds_formula_orig_w,4,length(ds_formula_orig_w));
				tam_formula_w		:= length(ds_formula_orig_w);
				ie_pos_separador_w	:= position('ENTAO' in ds_formula_orig_w);

				/* Joga a condição para a variavel ds_informacao_w e o restante da fórmula para a ds_formula_orig_w */

				ds_informacao_w		:= substr(ds_formula_orig_w,1,(ie_pos_separador_w - 1));
				ds_formula_orig_w		:= substr(ds_formula_orig_w,(ie_pos_separador_w + 5),tam_formula_w);

				ie_cond_verdadeira_w := sup_gerar_planej_pck.obter_se_condicao_verdadeira(ds_informacao_w, cd_material_p, ie_simular_p, ie_cond_verdadeira_w, cd_estabelecimento_p, nm_usuario_p);

				/* Caso a condição não seja verdadeira, verifica se existem outras opções */

				/* Se existir, apaga a parte da fórmula (na variavel) que estava dentro da condição falsa, e continua adiante */

				/* Caso não houver novas condições, retorna 0 */

				if (ie_cond_verdadeira_w = 'N') then
					begin

					tam_formula_w			:= length(ds_formula_orig_w);
					ie_pos_separador_w		:= position('SE' in ds_formula_orig_w);

					/* Para retornar zero na fórmula, pois nenhuma condição foi válida (ao acabar as opções)*/

					if (ie_pos_separador_w = 0) then
						ds_formula_orig_w		:= '';
						ds_formula_w		:= '0';
						ie_cond_verdadeira_w	:= 'S';
					else
						ds_formula_orig_w		:= substr(ds_formula_orig_w,ie_pos_separador_w,tam_formula_w);
					end if;

					end;
				/* Se a condição for verdadeira, busca a parte da fórmula referente a esta condição, apagando todo o resto (da variavel) */

				else
					begin

					ie_pos_separador_w	:= position('SE' in ds_formula_orig_w);

					if (ie_pos_separador_w > 0) then
						ds_formula_orig_w	:= substr(ds_formula_orig_w,1,(ie_pos_separador_w - 1));
					end if;

					ds_formula_orig_w		:= trim(both ds_formula_orig_w);
					end;
				end if;

				end;
			end loop;

			end;
		end if;

		/* Ao obter a fórmula, seja a partir da condição verdadeira ou de uma fórmula sem condição lógica, */

		/* prossegue com o cálculo da mesma */

		while(ds_formula_orig_w IS NOT NULL AND ds_formula_orig_w::text <> '') loop
			begin

			/* Desmonta a fórmula para pegar palavra por palavra e substituir por seus valores */

			tam_formula_w			:= length(ds_formula_orig_w);
			ie_pos_separador_w		:= position(' ' in ds_formula_orig_w);

			if (ie_pos_separador_w <> 0) then
				ds_informacao_w		:= substr(ds_formula_orig_w,1,(ie_pos_separador_w - 1));
				ds_formula_orig_w		:= substr(ds_formula_orig_w,(ie_pos_separador_w + 1),tam_formula_w);
			else
				ds_informacao_w		:= ds_formula_orig_w;
				ds_formula_orig_w		:= '';
			end if;

			if (substr(ds_informacao_w,1,3) = '#A_') then
				begin

				/* Identifica se é uma simulação para buscar ou os valores informados pelo usuario para teste (caso seja simulação) */

				/* ou os valores reais gerados (caso não seja simulação) */

				if (ie_simular_p = 'S') then
					begin

					select	coalesce(max(vl_macro),0)
					into STRICT	vl_informacao_w
					from	w_sup_simula_form_planej
					where	ds_macro = ds_informacao_w
					and	nm_usuario = nm_usuario_p;

					end;
				else
					begin

					select	coalesce(max(vl_atributo),0)
					into STRICT	vl_informacao_w
					from	w_valor_atributo
					where	nm_atributo = substr(ds_informacao_w,4,length(ds_informacao_w))
					and	cd_estabelecimento = cd_estabelecimento_p
					and	cd_material = cd_material_p
					and	nm_usuario = nm_usuario_p;

					end;
				end if;

				ds_informacao_w	:= replace(to_char(vl_informacao_w),',','.');

				end;
			elsif (substr(ds_informacao_w,1,3) = '#F_') then
				begin

				/* Identifica se é uma simulação para buscar ou os valores informados pelo usuario para teste (caso seja simulação) */

				/* ou os valores reais gerados (caso não seja simulação) */

				if (ie_simular_p = 'S') then
					begin

					select	coalesce(max(vl_macro),0)
					into STRICT	vl_informacao_w
					from	w_sup_simula_form_planej
					where	ds_macro = ds_informacao_w
					and	nm_usuario = nm_usuario_p;

					end;
				else
					begin

					select	coalesce(max(vl_formula),0)
					into STRICT	vl_informacao_w
					from	w_valor_formula
					where	nm_formula = substr(ds_informacao_w,4,length(ds_informacao_w))
					and	cd_estabelecimento = cd_estabelecimento_p
					and	cd_material = cd_material_p
					and	nm_usuario = nm_usuario_p;

					end;
				end if;

				ds_informacao_w	:= replace(to_char(vl_informacao_w),',','.');

				end;
			end if;

			ds_formula_w	:= ds_formula_w || ds_informacao_w;

			end;
		end loop; /*END WHILE*/
		/* Após obter a fórmula totalmente alterada, executa a query para obter o valor e gravar */

		if (ds_formula_w IS NOT NULL AND ds_formula_w::text <> '') then
			begin

			ds_sql_w	:= 'select	 ' || ds_formula_w || ' from dual';

			c001	:= dbms_sql.open_cursor;
			dbms_sql.parse(c001,ds_sql_w,dbms_sql.native);
			dbms_sql.define_column(c001, 1, vl_coluna_w, 17);
			vl_retorno_atrib_w	:= dbms_sql.execute(c001);
			vl_retorno_atrib_w	:= dbms_sql.fetch_rows(c001);
			dbms_sql.column_value(c001, 1, vl_coluna_w);
			dbms_sql.close_cursor(c001);

			vl_retorno_atrib_w	:= (vl_coluna_w)::numeric;

			if (ie_simular_p = 'N') then
				begin

				CALL CALL sup_gerar_planej_pck.gravar_valor_formula_planej(
					nr_sequencia_p,
					nm_formula_w,
					vl_retorno_atrib_w,
					cd_material_p,
					cd_estabelecimento_p,
					nm_usuario_p);

				end;
			end if;

			end;
		end if;

		end;
	end if;

	vl_retorno_p	:= vl_retorno_atrib_w;

	END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE sup_gerar_planej_pck.gerar_valor_form_planej ( nr_sequencia_p bigint, cd_material_p bigint, ie_simular_p text, vl_retorno_p INOUT bigint, cd_estabelecimento_p bigint, nm_usuario_p text) FROM PUBLIC;
