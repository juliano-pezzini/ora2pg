-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_rec_glosa_emp_pck.gera_erg_lote_lvl_prot ( nr_seq_grg_lote_p pls_grg_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE

/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Gera o lote de envio de recurso de glosa a nivel de protocolo
	
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[X  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------

Pontos de atencao:
Alteracoes:
-------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */


nr_sequencia_w		pls_erg_recurso.nr_sequencia%type;

nr_seq_erg_cabecalho_w	pls_erg_cabecalho.nr_sequencia%type;

-- Carrega os lotes a serem gerados a nivel de protocolo

c01 CURSOR(	nr_seq_grg_lote_pc	pls_grg_lote.nr_sequencia%type) FOR
	SELECT	x.cd_estabelecimento,
		x.nr_sequencia nr_seq_grg_lote,
		clock_timestamp() dt_geracao_lote,
		y.nr_protocolo,
		(	SELECT	sum(t.contador)
			from (	select	count(1) contador
				from	pls_grg_protocolo	a,
					pls_grg_guia		b,
					pls_grg_guia_proc	c
				where	b.nr_seq_grg_protocolo	= a.nr_sequencia
				and	c.nr_seq_grg_guia	= b.nr_sequencia
				and	c.ie_origem_acao	in ('G', 'I')
				and	a.nr_seq_grg_lote	= nr_seq_grg_lote_pc
				
union all

				select	count(1) contador
				from	pls_grg_protocolo	a,
					pls_grg_guia		b,
					pls_grg_guia_mat	c
				where	b.nr_seq_grg_protocolo	= a.nr_sequencia
				and	c.nr_seq_grg_guia	= b.nr_sequencia
				and	c.ie_origem_acao	in ('G', 'I')
				and	a.nr_seq_grg_lote	= nr_seq_grg_lote_pc) t ) qt_itens_rec_inval,
		(	select	sum(c.vl_recursado) vl_recursado
			from	pls_grg_protocolo	a,
				pls_grg_guia		b,
				pls_grg_guia_proc	c
			where	b.nr_seq_grg_protocolo	= a.nr_sequencia
			and	c.nr_seq_grg_guia	= b.nr_sequencia
			and	a.nr_seq_grg_lote	= nr_seq_grg_lote_pc
			and	a.nr_protocolo		= y.nr_protocolo ) vl_recursado_estim_proc,
			
		(	select	sum(c.vl_recursado) vl_recursado
			from	pls_grg_protocolo	a,
				pls_grg_guia		b,
				pls_grg_guia_mat	c
			where	b.nr_seq_grg_protocolo	= a.nr_sequencia
			and	c.nr_seq_grg_guia	= b.nr_sequencia
			and	a.nr_seq_grg_lote	= nr_seq_grg_lote_pc
			and	a.nr_protocolo		= y.nr_protocolo ) vl_recursado_estim_mat
			
	from	pls_grg_lote		x,
		pls_grg_protocolo	y
	where	y.nr_seq_grg_lote	= x.nr_sequencia
	and	x.nr_sequencia		= nr_seq_grg_lote_pc
	group by y.nr_protocolo, x.cd_estabelecimento, x.nr_sequencia;

BEGIN


-- Abre os lotes conforme protocolos

for r_c01_w in c01(nr_seq_grg_lote_p) loop

	-- So gera o novo lote e protocolo, se nao tiver nenhum recurso a nivel de guia ou item dentro do protocolo, e o valor recursado "estimado" for maior que zero

	if	((coalesce(r_c01_w.qt_itens_rec_inval, 0) = 0) and
		 ((coalesce(r_c01_w.vl_recursado_estim_proc, 0) + coalesce(r_c01_w.vl_recursado_estim_mat, 0)) > 0)) then
			
		-- levanta a PK (nao foi incluso no cursor c01, pois e mais rapido fazer o if com os valores, do que colocar tudo no where)

		select	nextval('pls_erg_recurso_seq')
		into STRICT	nr_sequencia_w
		;
		
		-- Manda o lote novo para o banco

		CALL pls_rec_glosa_emp_pck.grava_erg_lote(	nr_sequencia_w,
				r_c01_w.cd_estabelecimento,
				r_c01_w.nr_seq_grg_lote,
				r_c01_w.dt_geracao_lote,
				nm_usuario_p,
				'N');
		
		-- gera o cabecalho

		CALL pls_rec_glosa_emp_pck.gera_erg_cabecalho(	nr_sequencia_w,
					'P',
					r_c01_w.nr_protocolo,
					nm_usuario_p,
					'N');

		-- gera os prestadores

		CALL pls_rec_glosa_emp_pck.gera_erg_prestador(	nr_sequencia_w,
					nm_usuario_p,
					'N');
					
					
		-- Gera os protocolo para este lote, bem como as respectivas glosas

		CALL pls_rec_glosa_emp_pck.gera_erg_protocolo(	nr_sequencia_w,
					r_c01_w.nr_protocolo,
					nm_usuario_p,
					'N');
		
		-- Atualiza o valor recursado do cabecalho

		CALL pls_rec_glosa_emp_pck.atual_erg_vl_recur_cab(nr_sequencia_w,
					nm_usuario_p,
					'N');
	end if; -- Fim se protocolo tiver valor recursado
	
end loop;

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_rec_glosa_emp_pck.gera_erg_lote_lvl_prot ( nr_seq_grg_lote_p pls_grg_lote.nr_sequencia%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
