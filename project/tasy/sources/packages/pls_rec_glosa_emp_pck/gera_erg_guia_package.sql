-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_rec_glosa_emp_pck.gera_erg_guia ( nr_seq_erg_lote_p pls_erg_recurso.nr_sequencia%type, ie_objeto_recurso_p pls_erg_cabecalho.ie_objeto_recurso%type, nm_usuario_p usuario.nm_usuario%type, ie_commit_p text) AS $body$
DECLARE

_ora2pg_r RECORD;
/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Finalidade:	Gera as guias de envio de recurso de glosa
	
-------------------------------------------------------------------------------------------------------------------

Locais de chamada direta: 
[X]  Objetos do dicionario [ ] Tasy (Delphi/Java) [  ] Portal [  ]  Relatorios [ ] Outros:
-------------------------------------------------------------------------------------------------------------------

Pontos de atencao:
Alteracoes:
-------------------------------------------------------------------------------------------------------------------

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */


-- Tabelas virtuais auxiliares

aux_nr_seq_erg_cabecalho_w	dbms_sql.number_table;
aux_nr_seq_grg_guia_w		dbms_sql.number_table;
aux_cd_senha_w			dbms_sql.varchar2_table;
aux_nr_guia_operadora_w		dbms_sql.varchar2_table;
aux_nr_guia_origem_w		dbms_sql.varchar2_table;
aux_vl_recursado_proc_w		dbms_sql.number_table;
aux_vl_recursado_mat_w		dbms_sql.number_table;
aux_qt_item_inval_proc_w	dbms_sql.number_table;
aux_qt_item_inval_mat_w		dbms_sql.number_table;

-- Tabelas Virtuais

tb_nr_seq_erg_cabecalho_w	dbms_sql.number_table;
tb_nr_seq_grg_guia_w		dbms_sql.number_table;
tb_cd_senha_w			dbms_sql.varchar2_table;
tb_nr_guia_operadora_w		dbms_sql.varchar2_table;
tb_nr_guia_origem_w		dbms_sql.varchar2_table;

-- indices

i	integer;
j	integer;


-- Carrega as guias, neste momento ainda nao e separado as guias com valores a serem recursados

c01 CURSOR(	nr_seq_erg_lote_pc	pls_erg_recurso.nr_sequencia%type,
		ie_objeto_recurso_pc	pls_erg_cabecalho.ie_objeto_recurso%type) FOR
	-- nivel a item

	SELECT	b.nr_sequencia nr_seq_erg_cabecalho,
		e.cd_senha,
		d.cd_guia nr_guia_operadora,
		d.cd_guia_prestador nr_guia_origem,
		d.nr_sequencia nr_seq_grg_guia,
		(	SELECT	sum(x.vl_recursado) vl_recursado
			from	pls_grg_guia_proc	x
			where	x.nr_seq_grg_guia	= d.nr_sequencia
			and	x.ie_origem_acao	= 'I') vl_recursado_proc,
		(	select	sum(x.vl_recursado) vl_recursado
			from	pls_grg_guia_mat	x
			where	x.nr_seq_grg_guia	= d.nr_sequencia
			and	x.ie_origem_acao	= 'I') vl_recursado_mat,
		(	select	count(1)
			from	pls_grg_guia_proc	x
			where	x.nr_seq_grg_guia	= d.nr_sequencia
			and	x.ie_origem_acao	in ('P', 'G')) qt_item_inval_proc,
		(	select	count(1)
			from	pls_grg_guia_mat	x
			where	x.nr_seq_grg_guia	= d.nr_sequencia
			and	x.ie_origem_acao	in ('P', 'G')) qt_item_inval_mat
	from	pls_erg_recurso		a,
		pls_erg_cabecalho	b,
		pls_grg_protocolo	c,
		pls_grg_guia		d,
		pls_dma_guia_imp	e
	where	b.nr_seq_erg_recurso	= a.nr_sequencia
	and	c.nr_seq_grg_lote	= a.nr_seq_grg_lote
	and	c.nr_protocolo		= b.nr_protocolo
	and	d.nr_seq_grg_protocolo	= c.nr_sequencia
	and	e.nr_sequencia		= d.nr_seq_dma_guia
	and	a.nr_sequencia		= nr_seq_erg_lote_pc
	and	ie_objeto_recurso_pc	= 'I'
	
union all

	-- Nivel de guia

	select	b.nr_sequencia nr_seq_erg_cabecalho,
		e.cd_senha,
		d.cd_guia nr_guia_operadora,
		d.cd_guia_prestador nr_guia_origem,
		d.nr_sequencia nr_seq_grg_guia,
		d.vl_recursado vl_recursado_proc,
		d.vl_recursado vl_recursado_mat,
		(	select	count(1)
			from	pls_grg_guia_proc	x
			where	x.nr_seq_grg_guia	= d.nr_sequencia
			and	x.ie_origem_acao	in ('P', 'I')) qt_item_inval_proc,
		(	select	count(1)
			from	pls_grg_guia_mat	x
			where	x.nr_seq_grg_guia	= d.nr_sequencia
			and	x.ie_origem_acao	in ('P', 'I')) qt_item_inval_mat
	from	pls_erg_recurso		a,
		pls_erg_cabecalho	b,
		pls_grg_protocolo	c,
		pls_grg_guia		d,
		pls_dma_guia_imp	e
	where	b.nr_seq_erg_recurso	= a.nr_sequencia
	and	c.nr_seq_grg_lote	= a.nr_seq_grg_lote
	and	c.nr_protocolo		= b.nr_protocolo
	and	d.nr_seq_grg_protocolo	= c.nr_sequencia
	and	e.nr_sequencia		= d.nr_seq_dma_guia
	and	a.nr_sequencia		= nr_seq_erg_lote_pc
	and	ie_objeto_recurso_pc	= 'G';
	

BEGIN

begin

	j := 0;

	-- Carrega todas as guias

	open c01(nr_seq_erg_lote_p, ie_objeto_recurso_p);
	loop
		fetch c01 bulk collect into	aux_nr_seq_erg_cabecalho_w,
						aux_cd_senha_w,
						aux_nr_guia_operadora_w,
						aux_nr_guia_origem_w,
						aux_nr_seq_grg_guia_w,
						aux_vl_recursado_proc_w,
						aux_vl_recursado_mat_w,
						aux_qt_item_inval_proc_w,
						aux_qt_item_inval_mat_w limit pls_util_pck.qt_registro_transacao_w;
		exit when aux_nr_seq_erg_cabecalho_w.count = 0;
		
		-- navega por todas as guias

		for i in aux_nr_seq_erg_cabecalho_w.first..aux_nr_seq_erg_cabecalho_w.last loop
		
			-- se a guia tiver algum valor recursado, e tiver nao possuir acoes em niveis diferentes do passado por parametro, ela sera incluida na lista para ser gravada no banco

			if	((coalesce(aux_vl_recursado_proc_w(i), 0) + coalesce(aux_vl_recursado_mat_w(i), 0)) > 0) and
				((coalesce(aux_qt_item_inval_proc_w(i),0) + coalesce(aux_qt_item_inval_mat_w(i), 0)) = 0)then
		
				tb_nr_seq_erg_cabecalho_w(j)	:= aux_nr_seq_erg_cabecalho_w(i);
				tb_cd_senha_w(j)		:= aux_cd_senha_w(i);
				tb_nr_guia_operadora_w(j)	:= aux_nr_guia_operadora_w(i);
				tb_nr_guia_origem_w(j)		:= aux_nr_guia_origem_w(i);
				tb_nr_seq_grg_guia_w(j)		:= aux_nr_seq_grg_guia_w(i);
				
				-- se chegou no limite, manda para o banco

				if (j >= pls_util_pck.qt_registro_transacao_w) then
				
					SELECT * FROM pls_rec_glosa_emp_pck.grava_erg_guia(tb_nr_seq_erg_cabecalho_w, tb_nr_seq_grg_guia_w, tb_cd_senha_w, tb_nr_guia_operadora_w, tb_nr_guia_origem_w, nm_usuario_p, 'N', 'S') INTO STRICT _ora2pg_r;
 tb_nr_seq_erg_cabecalho_w := _ora2pg_r.tb_nr_seq_erg_cabecalho_p; tb_nr_seq_grg_guia_w := _ora2pg_r.tb_nr_seq_grg_guia_p; tb_cd_senha_w := _ora2pg_r.tb_cd_senha_p; tb_nr_guia_operadora_w := _ora2pg_r.tb_nr_guia_operadora_p; tb_nr_guia_origem_w := _ora2pg_r.tb_nr_guia_origem_p;							
					j := 0;
				else
					j := j +1;
				end if;
			end if;
		end loop; -- Navegou pelo vetor carregado pelo cursor.
		
		-- Apos o processo, limpa as tabelas virtuais auxiliares

		aux_nr_seq_erg_cabecalho_w.delete;
		aux_cd_senha_w.delete;
		aux_nr_guia_operadora_w.delete;
		aux_nr_guia_origem_w.delete;
		aux_nr_seq_grg_guia_w.delete;
		aux_qt_item_inval_proc_w.delete;
		aux_qt_item_inval_proc_w.delete;

	end loop;
	
	-- Ainda verifica se "sobrou" guias a serem inseridas

	
	if (tb_nr_seq_erg_cabecalho_w.count > 0) then
		
		SELECT * FROM pls_rec_glosa_emp_pck.grava_erg_guia(tb_nr_seq_erg_cabecalho_w, tb_nr_seq_grg_guia_w, tb_cd_senha_w, tb_nr_guia_operadora_w, tb_nr_guia_origem_w, nm_usuario_p, 'N', 'S') INTO STRICT _ora2pg_r;
 tb_nr_seq_erg_cabecalho_w := _ora2pg_r.tb_nr_seq_erg_cabecalho_p; tb_nr_seq_grg_guia_w := _ora2pg_r.tb_nr_seq_grg_guia_p; tb_cd_senha_w := _ora2pg_r.tb_cd_senha_p; tb_nr_guia_operadora_w := _ora2pg_r.tb_nr_guia_operadora_p; tb_nr_guia_origem_w := _ora2pg_r.tb_nr_guia_origem_p;
	end if;
				

	if (coalesce(ie_commit_p, 'S') = 'S') then

		commit;
	end if;


	-- Decide qual das formas de recurso sera gerada, por guia ou itens

	if (coalesce(ie_objeto_recurso_p, 'I') = 'G') then
	
		-- Quando e nivel de "Guia", apenas as glosas das guias deverao ser geradas

		CALL pls_rec_glosa_emp_pck.gera_erg_guia_glosa(	nr_seq_erg_lote_p,
					nm_usuario_p,
					'N');	
	elsif (coalesce(ie_objeto_recurso_p, 'I') = 'I') then
	
		--Gera o recurso com base nos itens (itens das guias)

		CALL pls_rec_glosa_emp_pck.gera_erg_itens_guia(	nr_seq_erg_lote_p,
					nm_usuario_p,
					'N');
	end if;

exception

	when others then
		
		if (c01%isopen) then
		
			close c01;
		end if;
		
		CALL pls_rec_glosa_emp_pck.exibe_msg_erro_gerar_erg();
		
end;



END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_rec_glosa_emp_pck.gera_erg_guia ( nr_seq_erg_lote_p pls_erg_recurso.nr_sequencia%type, ie_objeto_recurso_p pls_erg_cabecalho.ie_objeto_recurso%type, nm_usuario_p usuario.nm_usuario%type, ie_commit_p text) FROM PUBLIC;
