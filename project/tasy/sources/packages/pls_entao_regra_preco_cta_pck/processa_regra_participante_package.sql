-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';




CREATE OR REPLACE PROCEDURE pls_entao_regra_preco_cta_pck.processa_regra_participante ( ie_destino_regra_p text, nr_seq_lote_conta_p pls_protocolo_conta.nr_seq_lote%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type, nr_seq_analise_p pls_analise_conta.nr_sequencia%type, cd_acao_analise_p pls_acao_analise.cd_acao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) AS $body$
DECLARE


_ora2pg_r RECORD;
nr_contador_w		integer;
	
tb_nr_seq_partic_w	pls_util_cta_pck.t_number_table;
tb_nr_seq_regra_entao_w	pls_util_cta_pck.t_number_table;
tb_vl_negociado_w	pls_util_cta_pck.t_number_table;
tb_vl_medico_w		pls_util_cta_pck.t_number_table;
tb_vl_anestesista_w	pls_util_cta_pck.t_number_table;
tb_vl_auxiliares_w	pls_util_cta_pck.t_number_table;
	
C01 CURSOR FOR
	SELECT	entao.cd_edicao_amb,
		entao.cd_moeda_anestesista,
		entao.cd_moeda_ch_medico,
		entao.ie_autogerado,
		entao.ie_ch_padrao_anestesista,
		entao.ie_nao_gera_tx_inter,
		entao.ie_preco_informado,
		entao.nr_seq_cbhpm_edicao,
		entao.nr_seq_edicao_tuss,
		entao.tx_ajuste_ch_honor,
		entao.tx_ajuste_geral,
		entao.tx_ajuste_partic,
		entao.vl_anestesista,
		entao.vl_auxiliares,
		entao.vl_ch_honorarios,
		entao.vl_medico,
		entao.vl_proc_negociado,
		temp.nr_seq_proc_partic,
		temp.dt_procedimento_referencia,
		temp.ie_origem_proced,
		temp.cd_procedimento,
		temp.nr_seq_prestador_exec,
		temp.ie_tipo_guia,
		temp.cd_convenio,
		temp.cd_categoria,
		temp.cd_especialidade,
		temp.nr_seq_congenere_seg,
		temp.nr_seq_congenere_prot,
		temp.nr_seq_cp_comb_proc_entao,
		temp.cd_grupo_proc,
		temp.cd_area_proced,
		temp.ie_autogerado_proc,
		temp.dt_mes_competencia,
		temp.cd_prestador_exec
	from	pls_cp_cta_partic_tmp temp,
		pls_cp_cta_epartic entao
	where	entao.nr_sequencia = temp.nr_seq_cp_comb_proc_entao;
BEGIN

-- alimenta a tabela temporária com os dados necessários para identificar a regra então e fazer a valorização do item
CALL pls_entao_regra_preco_cta_pck.alimenta_tab_temp_partic(	ie_destino_regra_p, nr_seq_lote_conta_p, nr_seq_protocolo_p,
				nr_seq_lote_processo_p, nr_seq_conta_p, nr_seq_conta_proc_p,
				nr_seq_conta_mat_p, nr_seq_analise_p, cd_acao_analise_p, 
				cd_estabelecimento_p, nm_usuario_p);

-- pega todos os registros que foram inseridos na tabela temporária e 'encontra' o então respectivo
-- após salva o mesmo na tabela temporária
CALL pls_entao_regra_preco_cta_pck.define_regra_entao_partic();

-- faz a limpeza das tabelas de log, deletando todos os logs que existam com as sequencias dos 
-- materiais que foram incluidos na tabela temporária
nr_contador_w := 0;
for r_C01_w in C01 loop

	tb_nr_seq_partic_w(nr_contador_w) := r_c01_w.nr_seq_proc_partic;
	
	-- se atingiu a quantidade faz o delete
	if (nr_contador_w >= pls_util_pck.qt_registro_transacao_w) then
	
		SELECT * FROM pls_entao_regra_preco_cta_pck.delete_tabela_log_partic(	tb_nr_seq_partic_w, nr_contador_w) INTO STRICT _ora2pg_r;
 	tb_nr_seq_partic_w := _ora2pg_r.tb_nr_seq_proc_partic_p; nr_contador_w := _ora2pg_r.nr_contador_p;
	else
		nr_contador_w := nr_contador_w + 1;
	end if;
end loop;

-- se sobrou algo manda pro banco e limpa as variáveis
SELECT * FROM pls_entao_regra_preco_cta_pck.delete_tabela_log_partic(	tb_nr_seq_partic_w, nr_contador_w) INTO STRICT _ora2pg_r;
 	tb_nr_seq_partic_w := _ora2pg_r.tb_nr_seq_proc_partic_p; nr_contador_w := _ora2pg_r.nr_contador_p;

-- inicia as variáveis
SELECT * FROM pls_entao_regra_preco_cta_pck.atualiza_participantes(	ie_destino_regra_p, nr_contador_w, tb_nr_seq_partic_w, tb_nr_seq_regra_entao_w, tb_vl_negociado_w, tb_vl_medico_w, tb_vl_anestesista_w, tb_vl_auxiliares_w) INTO STRICT _ora2pg_r;
 nr_contador_w := _ora2pg_r.nr_contador_p; tb_nr_seq_partic_w := _ora2pg_r.tb_nr_seq_proc_partic_p; tb_nr_seq_regra_entao_w := _ora2pg_r.tb_nr_seq_regra_entao_p; tb_vl_negociado_w := _ora2pg_r.tb_vl_negociado_p; tb_vl_medico_w := _ora2pg_r.tb_vl_medico_p; tb_vl_anestesista_w := _ora2pg_r.tb_vl_anestesista_p; tb_vl_auxiliares_w := _ora2pg_r.tb_vl_auxiliares_p;

-- percorre todos os itens com os itens das regras então
for r_C01_w in C01 loop

	tb_nr_seq_partic_w(nr_contador_w) := r_C01_w.nr_seq_proc_partic;
	tb_nr_seq_regra_entao_w(nr_contador_w) := r_C01_w.nr_seq_cp_comb_proc_entao;

	CALL pls_entao_regra_preco_cta_pck.gerencia_log_partic(	'Início da valorização, vinculado ao então de sequencia ' || r_C01_w.nr_seq_cp_comb_proc_entao || '.',
				r_C01_w.nr_seq_proc_partic,
				null,
				null,
				null,
				null,
				ie_destino_regra_p,
				nm_usuario_p);
				
	-- obtem os valores dos procedimentos e aplica as taxas de acordo com a origem do procedimento
	SELECT * FROM pls_entao_regra_preco_cta_pck.obter_valores_entao_partic(	ie_destino_regra_p, r_C01_w.cd_edicao_amb, r_C01_w.nr_seq_cbhpm_edicao, r_C01_w.nr_seq_edicao_tuss, r_C01_w.vl_ch_honorarios, r_C01_w.tx_ajuste_partic, r_C01_w.cd_moeda_ch_medico, r_C01_w.cd_moeda_anestesista, r_C01_w.ie_ch_padrao_anestesista, r_C01_w.tx_ajuste_ch_honor, r_C01_w.tx_ajuste_geral, r_C01_w.ie_preco_informado, r_C01_w.vl_proc_negociado, r_C01_w.vl_medico, r_C01_w.vl_auxiliares, r_C01_w.vl_anestesista, r_C01_w.ie_autogerado, r_C01_w.nr_seq_proc_partic, r_C01_w.dt_procedimento_referencia, r_C01_w.ie_origem_proced, r_C01_w.cd_procedimento, r_C01_w.nr_seq_prestador_exec, r_C01_w.ie_tipo_guia, r_C01_w.cd_convenio, r_C01_w.cd_categoria, r_C01_w.cd_especialidade, r_C01_w.nr_seq_congenere_seg, r_C01_w.nr_seq_congenere_prot, r_C01_w.cd_grupo_proc, r_C01_w.cd_area_proced, r_C01_w.ie_autogerado_proc, r_C01_w.dt_mes_competencia, r_C01_w.cd_prestador_exec, cd_estabelecimento_p, nm_usuario_p, tb_vl_negociado_w(nr_contador_w), tb_vl_medico_w(nr_contador_w), tb_vl_anestesista_w(nr_contador_w), tb_vl_auxiliares_w(nr_contador_w)) INTO STRICT tb_vl_negociado_w(nr_contador_w), tb_vl_medico_w(nr_contador_w), tb_vl_anestesista_w(nr_contador_w), tb_vl_auxiliares_w(nr_contador_w);
	
	CALL pls_entao_regra_preco_cta_pck.gerencia_log_partic(	'Término da valorização.',
				r_C01_w.nr_seq_proc_partic,
				tb_vl_anestesista_w(nr_contador_w),
				tb_vl_auxiliares_w(nr_contador_w),
				tb_vl_medico_w(nr_contador_w),
				tb_vl_negociado_w(nr_contador_w),
				ie_destino_regra_p,
				nm_usuario_p);
	
	-- se atingiu a quantidade manda pro banco
	if (nr_contador_w >= pls_util_pck.qt_registro_transacao_w) then

		SELECT * FROM pls_entao_regra_preco_cta_pck.atualiza_participantes(	ie_destino_regra_p, nr_contador_w, tb_nr_seq_partic_w, tb_nr_seq_regra_entao_w, tb_vl_negociado_w, tb_vl_medico_w, tb_vl_anestesista_w, tb_vl_auxiliares_w) INTO STRICT _ora2pg_r;
 nr_contador_w := _ora2pg_r.nr_contador_p; tb_nr_seq_partic_w := _ora2pg_r.tb_nr_seq_proc_partic_p; tb_nr_seq_regra_entao_w := _ora2pg_r.tb_nr_seq_regra_entao_p; tb_vl_negociado_w := _ora2pg_r.tb_vl_negociado_p; tb_vl_medico_w := _ora2pg_r.tb_vl_medico_p; tb_vl_anestesista_w := _ora2pg_r.tb_vl_anestesista_p; tb_vl_auxiliares_w := _ora2pg_r.tb_vl_auxiliares_p;
	else
		nr_contador_w := nr_contador_w + 1;
	end if;
end loop;

-- se sobrou algo manda pro banco
SELECT * FROM pls_entao_regra_preco_cta_pck.atualiza_participantes(	ie_destino_regra_p, nr_contador_w, tb_nr_seq_partic_w, tb_nr_seq_regra_entao_w, tb_vl_negociado_w, tb_vl_medico_w, tb_vl_anestesista_w, tb_vl_auxiliares_w) INTO STRICT _ora2pg_r;
 nr_contador_w := _ora2pg_r.nr_contador_p; tb_nr_seq_partic_w := _ora2pg_r.tb_nr_seq_proc_partic_p; tb_nr_seq_regra_entao_w := _ora2pg_r.tb_nr_seq_regra_entao_p; tb_vl_negociado_w := _ora2pg_r.tb_vl_negociado_p; tb_vl_medico_w := _ora2pg_r.tb_vl_medico_p; tb_vl_anestesista_w := _ora2pg_r.tb_vl_anestesista_p; tb_vl_auxiliares_w := _ora2pg_r.tb_vl_auxiliares_p;

-- atualiza os logs de procedimento caso tenha ficado algo sem atualizar
CALL pls_entao_regra_preco_cta_pck.atualizar_log_partic(nm_usuario_p, ie_destino_regra_p);

END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE pls_entao_regra_preco_cta_pck.processa_regra_participante ( ie_destino_regra_p text, nr_seq_lote_conta_p pls_protocolo_conta.nr_seq_lote%type, nr_seq_protocolo_p pls_protocolo_conta.nr_sequencia%type, nr_seq_lote_processo_p pls_cta_lote_processo.nr_sequencia%type, nr_seq_conta_p pls_conta.nr_sequencia%type, nr_seq_conta_proc_p pls_conta_proc.nr_sequencia%type, nr_seq_conta_mat_p pls_conta_mat.nr_sequencia%type, nr_seq_analise_p pls_analise_conta.nr_sequencia%type, cd_acao_analise_p pls_acao_analise.cd_acao%type, cd_estabelecimento_p estabelecimento.cd_estabelecimento%type, nm_usuario_p usuario.nm_usuario%type) FROM PUBLIC;
