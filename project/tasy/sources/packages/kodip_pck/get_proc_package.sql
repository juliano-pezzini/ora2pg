-- Generated by Ora2Pg, the Oracle database Schema converter, version 23.1
-- Copyright 2000-2022 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=srv-dbora-03.whebdc.com.br;service_name=DEV_1815;port=1521

SET client_encoding TO 'UTF8';


/*-----------------------------------------------------------------------------------------------------------------------------------------------------------------
'Proc'
*/
CREATE OR REPLACE FUNCTION kodip_pck.get_proc ( nr_seq_documento_p text, nr_atendimento_p bigint) RETURNS SETOF T_PROC AS $body$
DECLARE


_ora2pg_r RECORD;
nr_seq_episodio_w		episodio_paciente.nr_sequencia%type;
nr_atendimento_w		atendimento_paciente.nr_atendimento%type;
reg_integracao_w		gerar_int_padrao.reg_integracao_conv;

procedimento_w		procedimento%rowtype;
r_proc_w			r_proc;

c01 CURSOR FOR
SELECT	pp.nr_sequencia,
	pp.cd_procedimento,
	pp.ie_origem_proced,
	obter_ie_tipo_proc_3m(pp.ie_proc_princ_atend) proctype,
	pp.dt_inicio_procedimento,
	pp.dt_procedimento,
	pp.ie_lado,
	pp.dt_final_procedimento,
	pp.nr_seq_atepacu,
	ap.nr_seq_episodio,
	ap.nr_atendimento,
	CASE WHEN pcm.ie_relevante_drg='N' THEN 'true' END  ie_not_for_drg
FROM atendimento_paciente ap, procedimento_paciente pp
LEFT OUTER JOIN procedimento_pac_medico pcm ON (pp.nr_sequencia = pcm.nr_seq_propaci)
WHERE pp.nr_atendimento = ap.nr_atendimento  and (pp.nr_interno_conta IS NOT NULL AND pp.nr_interno_conta::text <> '') and coalesce(pp.cd_motivo_exc_conta::text, '') = '' and ap.nr_seq_episodio = nr_seq_episodio_w and pp.ie_origem_proced = 11;

c01_w	c01%rowtype;

c02 CURSOR FOR
SELECT	b.nr_sequencia,
	substr(b.ds_procedimento, 4000) ds_procedimento,
	ds_titulo
from	procedimento_pac_medico a,
	proc_pac_medico_inf_adic b
where	a.nr_seq_propaci = c01_w.nr_sequencia
and	a.nr_sequencia = b.nr_seq_proc_pac_med
order by b.nr_sequencia;

c02_w	c02%rowtype;



BEGIN
nr_seq_episodio_w	:=	somente_numero(nr_seq_documento_p);
nr_atendimento_w	:=	nr_atendimento_p;
SELECT * FROM kodip_pck.inicializacao(nr_seq_episodio_w, nr_atendimento_w, reg_integracao_w) INTO STRICT _ora2pg_r;
 nr_seq_episodio_w := _ora2pg_r.nr_seq_episodio_p; nr_atendimento_w := _ora2pg_r.nr_atendimento_p; reg_integracao_w := _ora2pg_r.reg_integracao_p;

reg_integracao_w.nm_elemento	:= 'Proc';

open c01;
loop
fetch c01 into
	c01_w;
EXIT WHEN NOT FOUND; /* apply on c01 */
	begin
	r_proc_w	:=	null;
	
	begin
	select	*
	into STRICT	procedimento_w
	from	procedimento
	where	cd_procedimento = c01_w.cd_procedimento
	and	ie_origem_proced = c01_w.ie_origem_proced;
	exception
	when others then
		procedimento_w	:=	null;
	end;
	
	reg_integracao_w.nm_tabela	:=	'PROCEDIMENTO_PACIENTE';
	intpd_processar_atrib_envio(reg_integracao_w, 'CD_PROCEDIMENTO_LOC', 'Code', 'N', procedimento_w.cd_procedimento_loc, 'N', r_proc_w.code);
	intpd_processar_atrib_envio(reg_integracao_w, 'DS_PROCEDIMENTO', 'CodeText', 'N', procedimento_w.ds_procedimento, 'N', r_proc_w.codetext);
	
	
	intpd_processar_atrib_envio(reg_integracao_w, 'NR_SEQ_ATEPACU', 'DeptNum', 'N', kodip_pck.get_deptnum(c01_w.nr_atendimento, c01_w.nr_seq_atepacu, c01_w.dt_procedimento), 'N', r_proc_w.deptnum);
	intpd_processar_atrib_envio(reg_integracao_w, 'IE_LADO', 'Loc', 'N', c01_w.ie_lado, 'S', r_proc_w.loc);
	
	if (c01_w.dt_inicio_procedimento IS NOT NULL AND c01_w.dt_inicio_procedimento::text <> '') then
		intpd_processar_atrib_envio(reg_integracao_w, 'DT_INICIO_PROCEDIMENTO', 'OpDate', 'N', to_char(c01_w.dt_inicio_procedimento, 'YYYYMMDDHH24MISS'), 'N', r_proc_w.opdate);
	else
		intpd_processar_atrib_envio(reg_integracao_w, 'DT_PROCEDIMENTO', 'OpDate', 'N', to_char(c01_w.dt_procedimento, 'YYYYMMDDHH24MISS'), 'N', r_proc_w.opdate);
	end if;
	
	intpd_processar_atrib_envio(reg_integracao_w, 'DT_FINAL_PROCEDIMENTO', 'OpDateEnd', 'N', to_char(c01_w.dt_final_procedimento, 'YYYYMMDDHH24MISS'), 'N', r_proc_w.opdateend);
	intpd_processar_atrib_envio(reg_integracao_w, 'IE_PROC_PRINC_ATEND', 'ProcType', 'N', c01_w.proctype, 'N', r_proc_w.proctype);
	intpd_processar_atrib_envio(reg_integracao_w, 'IE_PROC_PRINC_ATEND', 'ProcTypeFlags', 'N', c01_w.proctype, 'N', r_proc_w.proctypeflags);
	intpd_processar_atrib_envio(reg_integracao_w, 'IE_RELEVANTE_DRG', 'NotForGr', 'N', c01_w.ie_not_for_drg, 'N', r_proc_w.notforgr);

	open c02;
	loop
	fetch c02 into	
		c02_w;
	EXIT WHEN NOT FOUND; /* apply on c02 */
		begin
		reg_integracao_w.nm_tabela	:= 'PROC_PAC_MEDICO_INF_ADIC';
		intpd_processar_atrib_envio(reg_integracao_w, 'DS_PROCEDIMENTO', 'Note', 'N', coalesce(c02_w.ds_procedimento, c02_w.ds_titulo), 'N', r_proc_w.note);
		exit;
		end;
	end loop;
	close c02;
	
	reg_integracao_w.nm_tabela	:=	'PROCEDIMENTO_PACIENTE';
	intpd_processar_atrib_envio(reg_integracao_w, 'NR_SEQUENCIA', 'ProcId', 'N', c01_w.nr_sequencia || '|' || c02_w.nr_sequencia, 'N', r_proc_w.procid);
	
	/*'
	Pending of Definition:
	--CatVer
	--Note	
	'*/
	RETURN NEXT r_proc_w;
	end;
end loop;
close c01;

reg_integracao_w := kodip_pck.record_log(nr_seq_episodio_w, reg_integracao_w);
END;

$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON FUNCTION kodip_pck.get_proc ( nr_seq_documento_p text, nr_atendimento_p bigint) FROM PUBLIC;
